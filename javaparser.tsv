name	startLine	endLine	classPath	readabilityScore	label	original_method	abstract_method	model_prediction	is_diff	partially_detokenized_method	detokenized_method
addMethod	97	113	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/Generator.java	0.0228452757000923	LOW	"		private void addMethod(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable, Runnable onNoExistingMethod){
		    List<CallableDeclaration<?>> existingCallables = containingClassOrInterface.getCallablesWithSignature(callable.getSignature());
		    if (existingCallables.isEmpty()) {
		        onNoExistingMethod.run();
		        return;
		    }
		    if (existingCallables.size() > 1) {
		        throw new AssertionError(f(""Wanted to regenerate a method with signature %s in %s, but found more than one."", callable.getSignature(), containingClassOrInterface.getNameAsString()));
		    }
		    final CallableDeclaration<?> existingCallable = existingCallables.get(0);
		    callable.setJavadocComment(callable.getJavadocComment().orElseGet(() -> existingCallable.getJavadocComment().orElse(null)));
		    annotateGenerated(callable);
		    containingClassOrInterface.getMembers().replace(existingCallable, callable);
		}"	$indentation$ private $whitespace$ void $whitespace$ addmethod ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable , $whitespace$ runnable $whitespace$ onnoexistingmethod ) { $newline$ $indentation$ list < callabledeclaration < ? >> $whitespace$ existingcallables $whitespace$ = $whitespace$ containingclassorinterface . getcallableswithsignature ( callable . getsignature ( ) ) ; $newline$ $indentation$ if $whitespace$ ( existingcallables . isempty ( ) ) $whitespace$ { $newline$ $indentation$ onnoexistingmethod . run ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( existingcallables . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$ , $whitespace$ callable . getsignature ( ) , $whitespace$ containingclassorinterface . getnameasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ callabledeclaration < ? > $whitespace$ existingcallable $whitespace$ = $whitespace$ existingcallables . get ( $number$ ) ; $newline$ $indentation$ callable . setjavadoccomment ( callable . getjavadoccomment ( ) . orelseget ( ( ) $whitespace$ - > $whitespace$ existingcallable . getjavadoccomment ( ) . orelse ( null ) ) ) ; $newline$ $indentation$ annotategenerated ( callable ) ; $newline$ $indentation$ containingclassorinterface . getmembers ( ) . replace ( existingcallable , $whitespace$ callable ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ addmethod ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable, $whitespace$ runnable $whitespace$ onnoexistingmethod ) { $newline$ $indentation$ list < callabledeclaration <? >> $whitespace$ existingcallables $whitespace$ = $whitespace$ containingclassorinterface. getcallableswithsignature ( callable. getsignature ( ) ) ; $newline$ $indentation$ if $whitespace$ ( existingcallables. isempty ( ) ) $whitespace$ { $newline$ $indentation$ onnoexistingmethod. run ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( existingcallables. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$, $whitespace$ callable. getsignature ( ), $whitespace$ containingclassorinterface. getnameasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ callabledeclaration <? > $whitespace$ existingcallable $whitespace$ = $whitespace$ existingcallables. get ( $number$ ) ; $newline$ $indentation$ callable. setjavadoccomment ( callable. getjavadoccomment ( ). orelseget ( ( ) $whitespace$ - > $whitespace$ existingcallable. getjavadoccomment ( ). orelse ( null ) ) ) ; $newline$ $indentation$ annotategenerated ( callable ) ; $newline$ $indentation$ containingclassorinterface. getmembers ( ). replace ( existingcallable, $whitespace$ callable ) ; $newline$ $indentation$ }			
annotate	63	75	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/Generator.java	0.0844877436757087	LOW	"		private void annotate(T node, Class<?> annotation, Expression content){
		    node.setAnnotations(node.getAnnotations().stream().filter(a -> !a.getNameAsString().equals(annotation.getSimpleName())).collect(toNodeList()));
		    if (content != null) {
		        node.addSingleMemberAnnotation(annotation.getSimpleName(), content);
		    } else {
		        node.addMarkerAnnotation(annotation.getSimpleName());
		    }
		    node.tryAddImportToParentCompilationUnit(annotation);
		}"	$indentation$ private $whitespace$ void $whitespace$ annotate ( t $whitespace$ node , $whitespace$ class < ? > $whitespace$ annotation , $whitespace$ expression $whitespace$ content ) { $newline$ $indentation$ node . setannotations ( node . getannotations ( ) . stream ( ) . filter ( a $whitespace$ - > $whitespace$ ! a . getnameasstring ( ) . equals ( annotation . getsimplename ( ) ) ) . collect ( tonodelist ( ) ) ) ; $newline$ $indentation$ if $whitespace$ ( content $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ node . addsinglememberannotation ( annotation . getsimplename ( ) , $whitespace$ content ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ node . addmarkerannotation ( annotation . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ node . tryaddimporttoparentcompilationunit ( annotation ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ annotate ( t $whitespace$ node, $whitespace$ class <? > $whitespace$ annotation, $whitespace$ expression $whitespace$ content ) { $newline$ $indentation$ node. setannotations ( node. getannotations ( ). stream ( ). filter ( a $whitespace$ - > $whitespace$! a. getnameasstring ( ). equals ( annotation. getsimplename ( ) ) ). collect ( tonodelist ( ) ) ) ; $newline$ $indentation$ node. addsinglememberannotation ( annotation. getsimplename ( ), $whitespace$ a. getmessage ( ) ) ; $newline$ $indentation$ node. tryaddimporttoparentcompilationunit ( annotation ) ; $newline$ $indentation$ }			
replaceWhenSameSignature	90	95	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/Generator.java	0.1035005748271942	LOW	"		protected void replaceWhenSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable){
		    addMethod(containingClassOrInterface, callable, () -> {
		        throw new AssertionError(f(""Wanted to regenerate a method with signature %s in %s, but it wasn't there."", callable.getSignature(), containingClassOrInterface.getNameAsString()));
		    });
		}"	$indentation$ protected $whitespace$ void $whitespace$ replacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable ) { $newline$ $indentation$ addmethod ( containingclassorinterface , $whitespace$ callable , $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$ , $whitespace$ callable . getsignature ( ) , $whitespace$ containingclassorinterface . getnameasstring ( ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ replacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable ) { $newline$ $indentation$ addmethod ( containingclassorinterface, $whitespace$ callable, $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$, $whitespace$ callable. getsignature ( ), $whitespace$ containingclassorinterface. getnameasstring ( ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }			
removeMethodWithSameSignature	119	123	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/Generator.java	0.1646838039159774	LOW	"		protected void removeMethodWithSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable){
		    for (CallableDeclaration<?> existingCallable : containingClassOrInterface.getCallablesWithSignature(callable.getSignature())) {
		        containingClassOrInterface.remove(existingCallable);
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ removemethodwithsamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable ) { $newline$ $indentation$ for $whitespace$ ( callabledeclaration < ? > $whitespace$ existingcallable $whitespace$ : $whitespace$ containingclassorinterface . getcallableswithsignature ( callable . getsignature ( ) ) ) $whitespace$ { $newline$ $indentation$ containingclassorinterface . remove ( existingcallable ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ removemethodwithsamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable ) { $newline$ $indentation$ for $whitespace$ ( callabledeclaration <? > $whitespace$ existingcallable $whitespace$ : $whitespace$ containingclassorinterface. getcallableswithsignature ( callable. getsignature ( ) ) ) $whitespace$ { $newline$ $indentation$ containingclassorinterface. remove ( existingcallable ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
annotateWhenOverridden	66	76	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/NodeGenerator.java	0.0242549907416105	LOW	"		protected void annotateWhenOverridden(BaseNodeMetaModel nodeMetaModel, MethodDeclaration methodDeclaration){
		    Class<? extends Node> type = nodeMetaModel.getType();
		    Class<?> superClass = type.getSuperclass();
		    boolean isOverriding = Arrays.stream(superClass.getMethods()).filter(m -> m.getName().equals(methodDeclaration.getNameAsString())).anyMatch(m -> m.getParameters().length == methodDeclaration.getParameters().size());
		    if (isOverriding) {
		        annotateOverridden(methodDeclaration);
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ annotatewhenoverridden ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ methoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ class < ? $whitespace$ extends $whitespace$ node > $whitespace$ type $whitespace$ = $whitespace$ nodemetamodel . gettype ( ) ; $newline$ $indentation$ class < ? > $whitespace$ superclass $whitespace$ = $whitespace$ type . getsuperclass ( ) ; $newline$ $indentation$ boolean $whitespace$ isoverriding $whitespace$ = $whitespace$ arrays . stream ( superclass . getmethods ( ) ) . filter ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( methoddeclaration . getnameasstring ( ) ) ) . anymatch ( m $whitespace$ - > $whitespace$ m . getparameters ( ) . length $whitespace$ == $whitespace$ methoddeclaration . getparameters ( ) . size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( isoverriding ) $whitespace$ { $newline$ $indentation$ annotateoverridden ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ annotatewhenoverridden ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ methoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ class <? $whitespace$ extends $whitespace$ node > $whitespace$ type $whitespace$ = $whitespace$ nodemetamodel. gettype ( ) ; $newline$ $indentation$ class <? > $whitespace$ superclass $whitespace$ = $whitespace$ type. getsuperclass ( ) ; $newline$ $indentation$ boolean $whitespace$ isoverriding $whitespace$ = $whitespace$ arrays. stream ( superclass. getmethods ( ) ). filter ( m $whitespace$ - > $whitespace$ m. getname ( ). equals ( methoddeclaration. getnameasstring ( ) ) ). anymatch ( j $whitespace$ - > $whitespace$ m. getparameters ( ). length $whitespace$ == $whitespace$ methoddeclaration. getparameters ( ). size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( isoverriding ) $whitespace$ { $newline$ $indentation$ annotateoverridden ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
parseNode	54	58	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/NodeGenerator.java	0.0802527442574501	LOW	"		protected Pair<CompilationUnit, ClassOrInterfaceDeclaration> parseNode(BaseNodeMetaModel nodeMetaModel){
		    CompilationUnit nodeCu = sourceRoot.parse(nodeMetaModel.getPackageName(), nodeMetaModel.getTypeName() + "".java"");
		    ClassOrInterfaceDeclaration nodeCoid = nodeCu.getClassByName(nodeMetaModel.getTypeName()).orElseThrow(() -> new AssertionError(""Can't find class""));
		    return new Pair<>(nodeCu, nodeCoid);
		}"	$indentation$ protected $whitespace$ pair < compilationunit , $whitespace$ classorinterfacedeclaration > $whitespace$ parsenode ( basenodemetamodel $whitespace$ nodemetamodel ) { $newline$ $indentation$ compilationunit $whitespace$ nodecu $whitespace$ = $whitespace$ sourceroot . parse ( nodemetamodel . getpackagename ( ) , $whitespace$ nodemetamodel . gettypename ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ classorinterfacedeclaration $whitespace$ nodecoid $whitespace$ = $whitespace$ nodecu . getclassbyname ( nodemetamodel . gettypename ( ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( nodecu , $whitespace$ nodecoid ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ pair < compilationunit, $whitespace$ classorinterfacedeclaration > $whitespace$ parsenode ( basenodemetamodel $whitespace$ nodemetamodel ) { $newline$ $indentation$ compilationunit $whitespace$ nodecu $whitespace$ = $whitespace$ sourceroot. parse ( nodemetamodel. getpackagename ( ), $whitespace$ nodemetamodel. gettypename ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ classorinterfacedeclaration $whitespace$ nodecoid $whitespace$ = $whitespace$ nodecu. getclassbyname ( nodemetamodel. gettypename ( ) ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( nodecu, $whitespace$ nodecoid ) ; $newline$ $indentation$ }			
generateVisitMethodForNode	80	100	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/VisitorGenerator.java	0.0058479346334934	LOW	"		private void generateVisitMethodForNode(BaseNodeMetaModel node, ClassOrInterfaceDeclaration visitorClass, CompilationUnit compilationUnit){
		    final Optional<MethodDeclaration> existingVisitMethod = visitorClass.getMethods().stream().filter(m -> ""visit"".equals(m.getNameAsString())).filter(m -> m.getParameter(0).getType().toString().equals(node.getTypeName())).findFirst();
		    if (existingVisitMethod.isPresent()) {
		        generateVisitMethodBody(node, existingVisitMethod.get(), compilationUnit);
		    } else if (createMissingVisitMethods) {
		        MethodDeclaration newVisitMethod = visitorClass.addMethod(""visit"").addParameter(node.getTypeNameGenerified(), ""n"").addParameter(argumentType, ""arg"").setType(returnType);
		        if (!visitorClass.isInterface()) {
		            newVisitMethod.addAnnotation(new MarkerAnnotationExpr(new Name(""Override""))).addModifier(PUBLIC);
		        }
		        generateVisitMethodBody(node, newVisitMethod, compilationUnit);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ generatevisitmethodfornode ( basenodemetamodel $whitespace$ node , $whitespace$ classorinterfacedeclaration $whitespace$ visitorclass , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ final $whitespace$ optional < methoddeclaration > $whitespace$ existingvisitmethod $whitespace$ = $whitespace$ visitorclass . getmethods ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ $string$ . equals ( m . getnameasstring ( ) ) ) . filter ( m $whitespace$ - > $whitespace$ m . getparameter ( $number$ ) . gettype ( ) . tostring ( ) . equals ( node . gettypename ( ) ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( existingvisitmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ generatevisitmethodbody ( node , $whitespace$ existingvisitmethod . get ( ) , $whitespace$ compilationunit ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( createmissingvisitmethods ) $whitespace$ { $newline$ $indentation$ methoddeclaration $whitespace$ newvisitmethod $whitespace$ = $whitespace$ visitorclass . addmethod ( $string$ ) . addparameter ( node . gettypenamegenerified ( ) , $whitespace$ $string$ ) . addparameter ( argumenttype , $whitespace$ $string$ ) . settype ( returntype ) ; $newline$ $indentation$ if $whitespace$ ( ! visitorclass . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ newvisitmethod . addannotation ( new $whitespace$ markerannotationexpr ( new $whitespace$ name ( $string$ ) ) ) . addmodifier ( public ) ; $newline$ $indentation$ } $newline$ $indentation$ generatevisitmethodbody ( node , $whitespace$ newvisitmethod , $whitespace$ compilationunit ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generatevisitmethodfornode ( basenodemetamodel $whitespace$ node, $whitespace$ classorinterfacedeclaration $whitespace$ visitorclass, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ final $whitespace$ optional < methoddeclaration > $whitespace$ existingvisitmethod $whitespace$ = $whitespace$ visitorclass. getmethods ( ). stream ( ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$ $string$. equals ( m. getnameasstring ( ) ) ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$ m. getparameter ( $number$ ). gettype ( ). tostring ( ). equals ( node. gettypename ( ) ) ) $newline$ $indentation$. findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( existingvisitmethod. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ onvisitmethodbody ( node, $whitespace$ existingvisitmethod. get ( ), $whitespace$ compilationunit ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( createmissingvisitmethods ) $whitespace$ { $newline$ $indentation$ onvisitmethodbody ( node, $whitespace$ newvisitmethod, $whitespace$ compilationunit ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
generate	59	74	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/VisitorGenerator.java	0.0236523877829313	LOW	"		public final void generate() throws Exception{
		    Log.info(""Running %s"", () -> getClass().getSimpleName());
		    final CompilationUnit compilationUnit = sourceRoot.tryToParse(pkg, visitorClassName + "".java"").getResult().get();
		    Optional<ClassOrInterfaceDeclaration> visitorClassOptional = compilationUnit.getClassByName(visitorClassName);
		    if (!visitorClassOptional.isPresent()) {
		        visitorClassOptional = compilationUnit.getInterfaceByName(visitorClassName);
		    }
		    final ClassOrInterfaceDeclaration visitorClass = visitorClassOptional.get();
		    JavaParserMetaModel.getNodeMetaModels().stream().filter((baseNodeMetaModel) -> !baseNodeMetaModel.isAbstract()).forEach(node -> generateVisitMethodForNode(node, visitorClass, compilationUnit));
		    after();
		}"	$indentation$ public $whitespace$ final $whitespace$ void $whitespace$ generate ( ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ compilationunit $whitespace$ = $whitespace$ sourceroot . trytoparse ( pkg , $whitespace$ visitorclassname $whitespace$ + $whitespace$ $string$ ) . getresult ( ) . get ( ) ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ visitorclassoptional $whitespace$ = $whitespace$ compilationunit . getclassbyname ( visitorclassname ) ; $newline$ $indentation$ if $whitespace$ ( ! visitorclassoptional . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ visitorclassoptional $whitespace$ = $whitespace$ compilationunit . getinterfacebyname ( visitorclassname ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ visitorclass $whitespace$ = $whitespace$ visitorclassoptional . get ( ) ; $newline$ $indentation$ javaparsermetamodel . getnodemetamodels ( ) . stream ( ) . filter ( ( basenodemetamodel ) $whitespace$ - > $whitespace$ ! basenodemetamodel . isabstract ( ) ) . foreach ( node $whitespace$ - > $whitespace$ generatevisitmethodfornode ( node , $whitespace$ visitorclass , $whitespace$ compilationunit ) ) ; $newline$ $indentation$ after ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ final $whitespace$ void $whitespace$ generate ( ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ log. info ( $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ compilationunit $whitespace$ = $whitespace$ sourceroot. trytoparse ( pkg, $whitespace$ visitorclassname $whitespace$ + $whitespace$ $string$ ) $newline$ $indentation$. getresult ( ). get ( ) ; $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ visitorclass $whitespace$ = $whitespace$ visitorclassoptional. get ( ) ; $newline$ $indentation$ javaparsermetamodel. getnodemetamodels ( ). stream ( ). filter ( ( basenodemetamodel ) $whitespace$ - > $whitespace$! basenodemetamodel. isabstract ( ) ) $newline$ $indentation$. foreach ( node $whitespace$ - > $whitespace$ generatevisitmethodfornode ( node, $whitespace$ visitorclass, $whitespace$ compilationunit ) ) ; $newline$ $indentation$ after ( ) ; $newline$ $indentation$ }			
run	73	103	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/CoreGenerator.java	0.0183553639799356	LOW	"		private void run(SourceRoot sourceRoot, SourceRoot generatedJavaCcSourceRoot) throws Exception{
		    new TypeCastingGenerator(sourceRoot).generate();
		    new GenericListVisitorAdapterGenerator(sourceRoot).generate();
		    new GenericVisitorAdapterGenerator(sourceRoot).generate();
		    new GenericVisitorWithDefaultsGenerator(sourceRoot).generate();
		    new EqualsVisitorGenerator(sourceRoot).generate();
		    new ObjectIdentityEqualsVisitorGenerator(sourceRoot).generate();
		    new NoCommentEqualsVisitorGenerator(sourceRoot).generate();
		    new VoidVisitorAdapterGenerator(sourceRoot).generate();
		    new VoidVisitorGenerator(sourceRoot).generate();
		    new VoidVisitorWithDefaultsGenerator(sourceRoot).generate();
		    new GenericVisitorGenerator(sourceRoot).generate();
		    new HashCodeVisitorGenerator(sourceRoot).generate();
		    new ObjectIdentityHashCodeVisitorGenerator(sourceRoot).generate();
		    new NoCommentHashCodeVisitorGenerator(sourceRoot).generate();
		    new CloneVisitorGenerator(sourceRoot).generate();
		    new ModifierVisitorGenerator(sourceRoot).generate();
		    new PropertyGenerator(sourceRoot).generate();
		    new RemoveMethodGenerator(sourceRoot).generate();
		    new ReplaceMethodGenerator(sourceRoot).generate();
		    new CloneGenerator(sourceRoot).generate();
		    new GetMetaModelGenerator(sourceRoot).generate();
		    new MainConstructorGenerator(sourceRoot).generate();
		    new NodeModifierGenerator(sourceRoot).generate();
		    new AcceptGenerator(sourceRoot).generate();
		    new TokenKindGenerator(sourceRoot, generatedJavaCcSourceRoot).generate();
		    new BndGenerator(sourceRoot).generate();
		    new NotNullGenerator(sourceRoot).generate();
		}"	$indentation$ private $whitespace$ void $whitespace$ run ( sourceroot $whitespace$ sourceroot , $whitespace$ sourceroot $whitespace$ generatedjavaccsourceroot ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ new $whitespace$ typecastinggenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ genericlistvisitoradaptergenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ genericvisitoradaptergenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ genericvisitorwithdefaultsgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ equalsvisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ objectidentityequalsvisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ nocommentequalsvisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ voidvisitoradaptergenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ voidvisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ voidvisitorwithdefaultsgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ genericvisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ hashcodevisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ objectidentityhashcodevisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ nocommenthashcodevisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ clonevisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ propertygenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ removemethodgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ replacemethodgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ clonegenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ getmetamodelgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ mainconstructorgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ nodemodifiergenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ acceptgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ tokenkindgenerator ( sourceroot , $whitespace$ generatedjavaccsourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ bndgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ new $whitespace$ notnullgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ run ( sourceroot $whitespace$ sourceroot, $whitespace$ sourceroot $whitespace$ generatedjavaccsourceroot ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ new $whitespace$ typecastinggenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ genericlistvisitoradaptergenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ genericvisitoradaptergenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ genericvisitorwithdefaultsgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ equalsvisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ objectidentityequalsvisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ nocommentequalsvisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ voidvisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ voidvisitorwithdefaultsgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ nocommenthashcodevisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ clonevisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ new $whitespace$ modifiervisitorgenerator ( sourceroot ). generate ( ) ; $			
main	52	71	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/CoreGenerator.java	0.2342520803213119	LOW	"		public static void main(String[] args) throws Exception{
		    if (args.length != 1) {
		        throw new RuntimeException(""Need 1 parameter: the JavaParser source checkout root directory."");
		    }
		    Log.setAdapter(new Log.StandardOutStandardErrorAdapter());
		    final Path root = Paths.get(args[0], "".."", ""javaparser-core"", ""src"", ""main"", ""java"");
		    final SourceRoot sourceRoot = new SourceRoot(root, parserConfiguration);
		    StaticJavaParser.setConfiguration(parserConfiguration);
		    final Path generatedJavaCcRoot = Paths.get(args[0], "".."", ""javaparser-core"", ""target"", ""generated-sources"", ""javacc"");
		    final SourceRoot generatedJavaCcSourceRoot = new SourceRoot(generatedJavaCcRoot, parserConfiguration);
		    new CoreGenerator().run(sourceRoot, generatedJavaCcSourceRoot);
		    sourceRoot.saveAll();
		}"	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ main ( string [ ] $whitespace$ args ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ if $whitespace$ ( args . length $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log . setadapter ( new $whitespace$ log . standardoutstandarderroradapter ( ) ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ root $whitespace$ = $whitespace$ paths . get ( args [ $number$ ] , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ sourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( root , $whitespace$ parserconfiguration ) ; $newline$ $indentation$ staticjavaparser . setconfiguration ( parserconfiguration ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ generatedjavaccroot $whitespace$ = $whitespace$ paths . get ( args [ $number$ ] , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ generatedjavaccsourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( generatedjavaccroot , $whitespace$ parserconfiguration ) ; $newline$ $indentation$ new $whitespace$ coregenerator ( ) . run ( sourceroot , $whitespace$ generatedjavaccsourceroot ) ; $newline$ $indentation$ sourceroot . saveall ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ main ( string [ ] $whitespace$ args ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ if $whitespace$ ( args. length $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log. setadapter ( new $whitespace$ log. standardoutstandarderroradapter ( ) ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ root $whitespace$ = $whitespace$ paths. get ( args [ $number$ ], $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ sourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( root, $whitespace$ parserconfiguration ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ generatedjavaccroot $whitespace$ = $whitespace$ paths. get ( args [ $number$ ], $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ generatedjavaccsourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( generatedjavaccroot, $whitespace$ parserconfiguration ) ; $newline$ $indentation$ new $whitespace$ coregenerator ( ). run ( sourceroot, $whitespace$ generatedjavaccsourceroot ) ; $newline$ $indentation$ sourceroot. saveall ( ) ; $newline$ $indentation$ }			
generateNode	40	49	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/CloneGenerator.java	0.0840679109096527	LOW	"		@Override
		protected void generateNode(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, ClassOrInterfaceDeclaration nodeCoid){
		    nodeCu.addImport(CloneVisitor.class);
		    MethodDeclaration cloneMethod = (MethodDeclaration) parseBodyDeclaration(f(""@Override public %s clone() { return (%s) accept(new CloneVisitor(), null); }"", nodeMetaModel.getTypeNameGenerified(), nodeMetaModel.getTypeNameGenerified()));
		    addOrReplaceWhenSameSignature(nodeCoid, cloneMethod);
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ nodecu . addimport ( clonevisitor . class ) ; $newline$ $indentation$ methoddeclaration $whitespace$ clonemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ nodemetamodel . gettypenamegenerified ( ) , $whitespace$ nodemetamodel . gettypenamegenerified ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ clonemethod ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ nodecu. addimport ( clonevisitor. class ) ; $newline$ $indentation$ methoddeclaration $whitespace$ clonemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ nodemetamodel. gettypenamegenerified ( ), $whitespace$ nodemetamodel. gettypenamegenerified ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ clonemethod ) ; $newline$ $indentation$ }			
generateNode	40	50	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/GetMetaModelGenerator.java	0.0429111197590827	LOW	"		@Override
		protected void generateNode(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, ClassOrInterfaceDeclaration nodeCoid){
		    final MethodDeclaration getMetaModelMethod = (MethodDeclaration) parseBodyDeclaration(f(""%s public %s getMetaModel() { return JavaParserMetaModel.%s; }"", nodeMetaModel.isRootNode() ? """" : ""@Override"", nodeMetaModel.getClass().getSimpleName(), nodeMetaModel.getMetaModelFieldName()));
		    addOrReplaceWhenSameSignature(nodeCoid, getMetaModelMethod);
		    nodeCu.addImport(nodeMetaModel.getClass().getName());
		    nodeCu.addImport(JavaParserMetaModel.class);
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getmetamodelmethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ nodemetamodel . isrootnode ( ) $whitespace$ ? $whitespace$ $string$ $whitespace$ : $whitespace$ $string$ , $whitespace$ nodemetamodel . getclass ( ) . getsimplename ( ) , $whitespace$ nodemetamodel . getmetamodelfieldname ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ getmetamodelmethod ) ; $newline$ $indentation$ nodecu . addimport ( nodemetamodel . getclass ( ) . getname ( ) ) ; $newline$ $indentation$ nodecu . addimport ( javaparsermetamodel . class ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getmetamodelmethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ nodemetamodel. isrootnode ( ) $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ $string$, $whitespace$ nodemetamodel. getclass ( ). getsimplename ( ), $whitespace$ nodemetamodel. getmetamodelfieldname ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ getmetamodelmethod ) ; $newline$ $indentation$ nodecu. addimport ( nodemetamodel. getclass ( ). getname ( ) ) ; $newline$ $indentation$ nodecu. addimport ( javaparsermetamodel. class ) ; $newline$ $indentation$ }			
generateNode	44	74	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/MainConstructorGenerator.java	0.011862083338201	LOW	"		@Override
		protected void generateNode(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, ClassOrInterfaceDeclaration nodeCoid){
		    if (nodeMetaModel.is(Node.class)) {
		        return;
		    }
		    ConstructorDeclaration constructor = new ConstructorDeclaration().setPublic(true).setName(nodeCoid.getNameAsString()).addParameter(TokenRange.class, ""tokenRange"").setJavadocComment(""\n     * This constructor is used by the parser and is considered private.\n     "");
		    BlockStmt body = constructor.getBody();
		    SeparatedItemStringBuilder superCall = new SeparatedItemStringBuilder(""super("", "", "", "");"");
		    superCall.append(""tokenRange"");
		    for (PropertyMetaModel parameter : nodeMetaModel.getConstructorParameters()) {
		        constructor.addParameter(parameter.getTypeNameForSetter(), parameter.getName());
		        if (nodeMetaModel.getDeclaredPropertyMetaModels().contains(parameter)) {
		            body.addStatement(f(""%s(%s);"", parameter.getSetterMethodName(), parameter.getName()));
		        } else {
		            superCall.append(parameter.getName());
		        }
		    }
		    body.getStatements().addFirst(parseExplicitConstructorInvocationStmt(superCall.toString()));
		    body.addStatement(""customInitialization();"");
		    addOrReplaceWhenSameSignature(nodeCoid, constructor);
		    nodeCu.addImport(TokenRange.class);
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ if $whitespace$ ( nodemetamodel . is ( node . class ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ constructordeclaration $whitespace$ constructor $whitespace$ = $whitespace$ new $whitespace$ constructordeclaration ( ) . setpublic ( true ) . setname ( nodecoid . getnameasstring ( ) ) . addparameter ( tokenrange . class , $whitespace$ $string$ ) . setjavadoccomment ( $string$ ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ constructor . getbody ( ) ; $newline$ $indentation$ separateditemstringbuilder $whitespace$ supercall $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ supercall . append ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ parameter $whitespace$ : $whitespace$ nodemetamodel . getconstructorparameters ( ) ) $whitespace$ { $newline$ $indentation$ constructor . addparameter ( parameter . gettypenameforsetter ( ) , $whitespace$ parameter . getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( nodemetamodel . getdeclaredpropertymetamodels ( ) . contains ( parameter ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ parameter . getsettermethodname ( ) , $whitespace$ parameter . getname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ supercall . append ( parameter . getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . getstatements ( ) . addfirst ( parseexplicitconstructorinvocationstmt ( supercall . tostring ( ) ) ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ constructor ) ; $newline$ $indentation$ nodecu . addimport ( tokenrange . class ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ if $whitespace$ ( nodemetamodel. is ( node. class ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ constructordeclaration $whitespace$ constructor $whitespace$ = $whitespace$ new $whitespace$ constructordeclaration ( ). setpublic ( true ). setname ( nodecoid. getnameasstring ( ) ). addparameter ( tokenrange. class, $whitespace$ $string$ ). setjavadoccomment ( $string$ ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ constructor. getbody ( ) ; $newline$ $indentation$ separateditemstringbuilder $whitespace$ supercall $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ if $whitespace$ ( nodemetamodel. getdeclaredpropertymetamodels ( ). contains ( parameter ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ parameter. getsettermethodname ( ), $whitespace$ parameter. getname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ supercall			
generateSetter	66	123	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/PropertyGenerator.java	0.0033274111337959	LOW	"		private void generateSetter(BaseNodeMetaModel nodeMetaModel, ClassOrInterfaceDeclaration nodeCoid, PropertyMetaModel property){
		    // Ensure the relevant imports have been added for the methods/annotations used
		    nodeCoid.findCompilationUnit().get().addImport(ObservableProperty.class);
		    final String name = property.getName();
		    // Fill body
		    final String observableName = camelCaseToScreaming(name.startsWith(""is"") ? name.substring(2) : name);
		    declaredProperties.put(observableName, property);
		    if (property == JavaParserMetaModel.nodeMetaModel.commentPropertyMetaModel) {
		        // Node.comment has a very specific setter that we shouldn't overwrite.
		        return;
		    }
		    final MethodDeclaration setter = new MethodDeclaration(createModifierList(PUBLIC), parseType(property.getContainingNodeMetaModel().getTypeNameGenerified()), property.getSetterMethodName());
		    annotateWhenOverridden(nodeMetaModel, setter);
		    if (property.getContainingNodeMetaModel().hasWildcard()) {
		        setter.setType(parseType(""T""));
		    }
		    setter.addAndGetParameter(property.getTypeNameForSetter(), property.getName()).addModifier(FINAL);
		    final BlockStmt body = setter.getBody().get();
		    body.getStatements().clear();
		    if (property.isRequired()) {
		        Class<?> type = property.getType();
		        if (property.isNonEmpty() && property.isSingular()) {
		            nodeCoid.findCompilationUnit().get().addImport(""com.github.javaparser.utils.Utils.assertNonEmpty"", true, false);
		            body.addStatement(f(""assertNonEmpty(%s);"", name));
		        } else if (type != boolean.class && type != int.class) {
		            nodeCoid.findCompilationUnit().get().addImport(""com.github.javaparser.utils.Utils.assertNotNull"", true, false);
		            body.addStatement(f(""assertNotNull(%s);"", name));
		        }
		    }
		    // Check if the new value is the same as the old value
		    String returnValue = CodeUtils.castValue(""this"", setter.getType(), nodeMetaModel.getTypeName());
		    body.addStatement(f(""if (%s == this.%s) { return %s; }"", name, name, returnValue));
		    body.addStatement(f(""notifyPropertyChange(ObservableProperty.%s, this.%s, %s);"", observableName, name, name));
		    if (property.isNode()) {
		        body.addStatement(f(""if (this.%s != null) this.%s.setParentNode(null);"", name, name));
		    }
		    body.addStatement(f(""this.%s = %s;"", name, name));
		    if (property.isNode()) {
		        body.addStatement(f(""setAsParentNodeOf(%s);"", name));
		    }
		    if (property.getContainingNodeMetaModel().hasWildcard()) {
		        body.addStatement(f(""return (T) this;""));
		    } else {
		        body.addStatement(f(""return this;""));
		    }
		    addOrReplaceWhenSameSignature(nodeCoid, setter);
		    if (property.getContainingNodeMetaModel().hasWildcard()) {
		        annotateSuppressWarnings(setter);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ generatesetter ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ $//·ensure·the·relevant·imports·have·been·added·for·the·methods/annotations·used$ $newline$ $indentation$ nodecoid . findcompilationunit ( ) . get ( ) . addimport ( observableproperty . class ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ name $whitespace$ = $whitespace$ property . getname ( ) ; $newline$ $indentation$ $//·fill·body$ $newline$ $indentation$ final $whitespace$ string $whitespace$ observablename $whitespace$ = $whitespace$ camelcasetoscreaming ( name . startswith ( $string$ ) $whitespace$ ? $whitespace$ name . substring ( $number$ ) $whitespace$ : $whitespace$ name ) ; $newline$ $indentation$ declaredproperties . put ( observablename , $whitespace$ property ) ; $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ javaparsermetamodel . nodemetamodel . commentpropertymetamodel ) $whitespace$ { $newline$ $indentation$ $//·node.comment·has·a·very·specific·setter·that·we·shouldn't·overwrite.$ $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ setter $whitespace$ = $whitespace$ new $whitespace$ methoddeclaration ( createmodifierlist ( public ) , $whitespace$ parsetype ( property . getcontainingnodemetamodel ( ) . gettypenamegenerified ( ) ) , $whitespace$ property . getsettermethodname ( ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ setter ) ; $newline$ $indentation$ if $whitespace$ ( property . getcontainingnodemetamodel ( ) . haswildcard ( ) ) $whitespace$ { $newline$ $indentation$ setter . settype ( parsetype ( $string$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ setter . addandgetparameter ( property . gettypenameforsetter ( ) , $whitespace$ property . getname ( ) ) . addmodifier ( final ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ setter . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ if $whitespace$ ( property . isrequired ( ) ) $whitespace$ { $newline$ $indentation$ class < ? > $whitespace$ type $whitespace$ = $whitespace$ property . gettype ( ) ; $newline$ $indentation$ if $whitespace$ ( property . isnonempty ( ) $whitespace$ && $whitespace$ property . issingular ( ) ) $whitespace$ { $newline$ $indentation$ nodecoid . findcompilationunit ( ) . get ( ) . addimport ( $string$ , $whitespace$ true , $whitespace$ false ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( type $whitespace$ != $whitespace$ boolean . class $whitespace$ && $whitespace$ type $whitespace$ != $whitespace$ int . class ) $whitespace$ { $newline$ $indentation$ nodecoid . findcompilationunit ( ) . get ( ) . addimport ( $string$ , $whitespace$ true , $whitespace$ false ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·check·if·the·new·value·is·the·same·as·the·old·value$ $newline$ $indentation$ string $whitespace$ returnvalue $whitespace$ = $whitespace$ codeutils . castvalue ( $string$ , $whitespace$ setter . gettype ( ) , $whitespace$ nodemetamodel . gettypename ( ) ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name , $whitespace$ name , $whitespace$ returnvalue ) ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ observablename , $whitespace$ name , $whitespace$ name ) ) ; $newline$ $indentation$ if $whitespace$ ( property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name , $whitespace$ name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name , $whitespace$ name ) ) ; $newline$ $indentation$ if $whitespace$ ( property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property . getcontainingnodemetamodel ( ) . haswildcard ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ setter ) ; $newline$ $indentation$ if $whitespace$ ( property . getcontainingnodemetamodel ( ) . haswildcard ( ) ) $whitespace$ { $newline$ $indentation$ annotatesuppresswarnings ( setter ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generatesetter ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ $//space$ = $whitespace$ nodecoid. findcompilationunit ( ). get ( ). addimport ( observableproperty. class ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ name $whitespace$ = $whitespace$ property. getname ( ) ; $newline$ $indentation$ $////llreaming ( name. startswith ( $string$ ) $whitespace$? $whitespace$ name. substring ( $number$ ) $whitespace$ : $whitespace$ name ) ; $newline$ $indentation$ declaredproperties. put ( observablename, $whitespace$ property ) ; $newline$ $indentation$ // $whitespace$ do $whitespace$ nothing $whitespace$ to $whitespace$ do $whitespace$ here $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ setter $whitespace$ = $whitespace$ new $whitespace$ methoddeclaration ( createmodifierlist ( public ), $whitespace$ parsetype ( property. getcontainingnodemetamodel ( ). gettypenamegenerified ( ) ), $whitespace$ property. getsettermethodname ( ) ) ; $newline$ $indentation$ annotate			
after	159	176	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/PropertyGenerator.java	0.0793864279985427	LOW	"		@Override
		protected void after() throws Exception{
		    CompilationUnit observablePropertyCu = sourceRoot.tryToParse(""com.github.javaparser.ast.observer"", ""ObservableProperty.java"").getResult().get();
		    EnumDeclaration observablePropertyEnum = observablePropertyCu.getEnumByName(""ObservableProperty"").get();
		    observablePropertyEnum.getEntries().clear();
		    List<String> observablePropertyNames = new LinkedList<>(declaredProperties.keySet());
		    observablePropertyNames.sort(String::compareTo);
		    for (String propName : observablePropertyNames) {
		        generateObservableProperty(observablePropertyEnum, declaredProperties.get(propName), false);
		    }
		    List<String> derivedPropertyNames = new LinkedList<>(derivedProperties.keySet());
		    derivedPropertyNames.sort(String::compareTo);
		    for (String propName : derivedPropertyNames) {
		        generateObservableProperty(observablePropertyEnum, derivedProperties.get(propName), true);
		    }
		    observablePropertyEnum.addEnumConstant(""RANGE"");
		    observablePropertyEnum.addEnumConstant(""COMMENTED_NODE"");
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ after ( ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ compilationunit $whitespace$ observablepropertycu $whitespace$ = $whitespace$ sourceroot . trytoparse ( $string$ , $whitespace$ $string$ ) . getresult ( ) . get ( ) ; $newline$ $indentation$ enumdeclaration $whitespace$ observablepropertyenum $whitespace$ = $whitespace$ observablepropertycu . getenumbyname ( $string$ ) . get ( ) ; $newline$ $indentation$ observablepropertyenum . getentries ( ) . clear ( ) ; $newline$ $indentation$ list < string > $whitespace$ observablepropertynames $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( declaredproperties . keyset ( ) ) ; $newline$ $indentation$ observablepropertynames . sort ( string : : compareto ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ propname $whitespace$ : $whitespace$ observablepropertynames ) $whitespace$ { $newline$ $indentation$ generateobservableproperty ( observablepropertyenum , $whitespace$ declaredproperties . get ( propname ) , $whitespace$ false ) ; $newline$ $indentation$ } $newline$ $indentation$ list < string > $whitespace$ derivedpropertynames $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( derivedproperties . keyset ( ) ) ; $newline$ $indentation$ derivedpropertynames . sort ( string : : compareto ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ propname $whitespace$ : $whitespace$ derivedpropertynames ) $whitespace$ { $newline$ $indentation$ generateobservableproperty ( observablepropertyenum , $whitespace$ derivedproperties . get ( propname ) , $whitespace$ true ) ; $newline$ $indentation$ } $newline$ $indentation$ observablepropertyenum . addenumconstant ( $string$ ) ; $newline$ $indentation$ observablepropertyenum . addenumconstant ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ after ( ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ collection < string > $whitespace$ actionspropertynames $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( declaredproperties. keyset ( ) ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ propname $whitespace$ : $whitespace$ observablepropertynames ) $whitespace$ { $newline$ $indentation$ generateobservableproperty ( observablepropertyenum, $whitespace$ declaredproperties. get ( propname ), $whitespace$ false ) ; $newline$ $indentation$ } $newline$ $indentation$ list < string > $whitespace$ derivedpropertynames $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( derivedproperties. keyset ( ) ) ; $newline$ $indentation$ derivedpropertynames. sort ( string : : compareto ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ propname $whitespace$ : $whitespace$ derivedpropertynames ) $whitespace$ { $newline$ $indentation$ generateobservableproperty ( observablepropertyenum, $whitespace$ derivedproperties. get ( propname ), $whitespace$ true ) ; $newline$ $indentation$ } $newline$ $indentation$ observablepropertyenum. addenumconstant ( $string$ ) ; $newline$ $indentation$ observablepropertyenum. addenum			
generateGetter	125	138	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/PropertyGenerator.java	0.169618159532547	LOW	"		private void generateGetter(BaseNodeMetaModel nodeMetaModel, ClassOrInterfaceDeclaration nodeCoid, PropertyMetaModel property){
		    final MethodDeclaration getter = new MethodDeclaration(createModifierList(PUBLIC), parseType(property.getTypeNameForGetter()), property.getGetterMethodName());
		    annotateWhenOverridden(nodeMetaModel, getter);
		    final BlockStmt body = getter.getBody().get();
		    body.getStatements().clear();
		    if (property.isOptional()) {
		        // Ensure imports have been included.
		        nodeCoid.findCompilationUnit().get().addImport(Optional.class);
		        body.addStatement(f(""return Optional.ofNullable(%s);"", property.getName()));
		    } else {
		        body.addStatement(f(""return %s;"", property.getName()));
		    }
		    addOrReplaceWhenSameSignature(nodeCoid, getter);
		}"	$indentation$ private $whitespace$ void $whitespace$ generategetter ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getter $whitespace$ = $whitespace$ new $whitespace$ methoddeclaration ( createmodifierlist ( public ) , $whitespace$ parsetype ( property . gettypenameforgetter ( ) ) , $whitespace$ property . getgettermethodname ( ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ getter ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ getter . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ if $whitespace$ ( property . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ $//·ensure·imports·have·been·included.$ $newline$ $indentation$ nodecoid . findcompilationunit ( ) . get ( ) . addimport ( optional . class ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . getname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ getter ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generategetter ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getter $whitespace$ = $whitespace$ new $whitespace$ methoddeclaration ( createmodifierlist ( public ), $whitespace$ parsetype ( property. gettypenameforgetter ( ) ), $whitespace$ property. getgettermethodname ( ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel, $whitespace$ getter ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ getter. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ if $whitespace$ ( property. isoptional ( ) ) $whitespace$ { $newline$ $indentation$ $//// $newline$ $indentation$ nodecoid. findcompilationunit ( ). get ( ). addimport ( optional. class ) ; $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ property. getname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ property. getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ getter ) ; $newline$ $indentation$ }			
generateObservableProperty	140	157	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/PropertyGenerator.java	0.1998934000730514	LOW	"		private void generateObservableProperty(EnumDeclaration observablePropertyEnum, PropertyMetaModel property, boolean derived){
		    boolean isAttribute = !Node.class.isAssignableFrom(property.getType());
		    String name = property.getName();
		    String constantName = camelCaseToScreaming(name.startsWith(""is"") ? name.substring(2) : name);
		    EnumConstantDeclaration enumConstantDeclaration = observablePropertyEnum.addEnumConstant(constantName);
		    if (isAttribute) {
		        enumConstantDeclaration.addArgument(""Type.SINGLE_ATTRIBUTE"");
		    } else {
		        if (property.isNodeList()) {
		            enumConstantDeclaration.addArgument(""Type.MULTIPLE_REFERENCE"");
		        } else {
		            enumConstantDeclaration.addArgument(""Type.SINGLE_REFERENCE"");
		        }
		    }
		    if (derived) {
		        enumConstantDeclaration.addArgument(""true"");
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ generateobservableproperty ( enumdeclaration $whitespace$ observablepropertyenum , $whitespace$ propertymetamodel $whitespace$ property , $whitespace$ boolean $whitespace$ derived ) { $newline$ $indentation$ boolean $whitespace$ isattribute $whitespace$ = $whitespace$ ! node . class . isassignablefrom ( property . gettype ( ) ) ; $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ property . getname ( ) ; $newline$ $indentation$ string $whitespace$ constantname $whitespace$ = $whitespace$ camelcasetoscreaming ( name . startswith ( $string$ ) $whitespace$ ? $whitespace$ name . substring ( $number$ ) $whitespace$ : $whitespace$ name ) ; $newline$ $indentation$ enumconstantdeclaration $whitespace$ enumconstantdeclaration $whitespace$ = $whitespace$ observablepropertyenum . addenumconstant ( constantname ) ; $newline$ $indentation$ if $whitespace$ ( isattribute ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration . addargument ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration . addargument ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ enumconstantdeclaration . addargument ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( derived ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration . addargument ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generateobservableproperty ( enumdeclaration $whitespace$ observablepropertyenum, $whitespace$ propertymetamodel $whitespace$ property, $whitespace$ boolean $whitespace$ derived ) { $newline$ $indentation$ boolean $whitespace$ isattribute $whitespace$ = $whitespace$! node. class. isassignablefrom ( property. gettype ( ) ) ; $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ property. getname ( ) ; $newline$ $indentation$ string $whitespace$ constantname $whitespace$ = $whitespace$ camelcasetoscreaming ( name. startswith ( $string$ ) $whitespace$? $whitespace$ name. substring ( $number$ ) $whitespace$ : $whitespace$ name ) ; $newline$ $indentation$ enumconstantdeclaration $whitespace$ enumconstantdeclaration $whitespace$ = $whitespace$ observablepropertyenum. addenumconstant ( constantname ) ; $newline$ $indentation$ if $whitespace$ ( isattribute ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration. addargument ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration. addargument ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ enumconstantdeclaration. addargument ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( derived ) $whitespace$ { $newline$ $indentation$ enumconstantdeclaration. addargument ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
generateNode	44	85	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/RemoveMethodGenerator.java	0.079445406794548	LOW	"		@Override
		protected void generateNode(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, ClassOrInterfaceDeclaration nodeCoid){
		    MethodDeclaration removeNodeMethod = (MethodDeclaration) parseBodyDeclaration(""public boolean remove(Node node) {}"");
		    nodeCu.addImport(Node.class);
		    annotateWhenOverridden(nodeMetaModel, removeNodeMethod);
		    final BlockStmt body = removeNodeMethod.getBody().get();
		    body.addStatement(""if (node == null) { return false; }"");
		    int numberPropertiesDeclared = 0;
		    for (PropertyMetaModel property : nodeMetaModel.getDeclaredPropertyMetaModels()) {
		        if (!property.isNode()) {
		            continue;
		        }
		        String check;
		        if (property.isNodeList()) {
		            check = nodeListCheck(property);
		        } else {
		            if (property.isRequired()) {
		                continue;
		            }
		            String removeAttributeMethodName = generateRemoveMethodForAttribute(nodeCoid, nodeMetaModel, property);
		            check = attributeCheck(property, removeAttributeMethodName);
		        }
		        if (property.isOptional()) {
		            check = f(""if (%s != null) { %s }"", property.getName(), check);
		        }
		        body.addStatement(check);
		        numberPropertiesDeclared++;
		    }
		    if (nodeMetaModel.getSuperNodeMetaModel().isPresent()) {
		        body.addStatement(""return super.remove(node);"");
		    } else {
		        body.addStatement(""return false;"");
		    }
		    if (!nodeMetaModel.isRootNode() && numberPropertiesDeclared == 0) {
		        removeMethodWithSameSignature(nodeCoid, removeNodeMethod);
		    } else {
		        addOrReplaceWhenSameSignature(nodeCoid, removeNodeMethod);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ methoddeclaration $whitespace$ removenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( $string$ ) ; $newline$ $indentation$ nodecu . addimport ( node . class ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ removenodemethod ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ removenodemethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ int $whitespace$ numberpropertiesdeclared $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ property $whitespace$ : $whitespace$ nodemetamodel . getdeclaredpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ check ; $newline$ $indentation$ if $whitespace$ ( property . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ nodelistcheck ( property ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isrequired ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ removeattributemethodname $whitespace$ = $whitespace$ generateremovemethodforattribute ( nodecoid , $whitespace$ nodemetamodel , $whitespace$ property ) ; $newline$ $indentation$ check $whitespace$ = $whitespace$ attributecheck ( property , $whitespace$ removeattributemethodname ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ property . getname ( ) , $whitespace$ check ) ; $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( check ) ; $newline$ $indentation$ numberpropertiesdeclared ++ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodemetamodel . getsupernodemetamodel ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! nodemetamodel . isrootnode ( ) $whitespace$ && $whitespace$ numberpropertiesdeclared $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ removemethodwithsamesignature ( nodecoid , $whitespace$ removenodemethod ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ removenodemethod ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ objectdeclaration $whitespace$ removenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( $string$ ) ; $newline$ $indentation$ nodecu. addimport ( node. class ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel, $whitespace$ removenodemethod ) ; $newline$ $indentation$ // $whitespace$ if $whitespace$ the $whitespace$ property $whitespace$ is $whitespace$ not $whitespace$ a $whitespace$ valid $whitespace$ cors $whitespace$ request $newline$ $indentation$ boolean $whitespace$ validcourses $whitespace$ = $whitespace$ false ; $newline$ $indentation$ string $whitespace$ check ; $newline$ $indentation$ if $whitespace$ ( property. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ nodelistcheck ( property ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property. isrequired ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ removeattributemethodname $whitespace$ = $whitespace$			
nodeListCheck	94	101	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/RemoveMethodGenerator.java	0.1275603175163269	LOW	"		private String nodeListCheck(PropertyMetaModel property){
		    return f(""for (int i = 0; i < %s.size(); i++) {"" + ""  if (%s.get(i) == node) {"" + ""    %s.remove(i);"" + ""    return true;"" + ""  }"" + ""}"", property.getName(), property.getName(), property.getName());
		}"	$indentation$ private $whitespace$ string $whitespace$ nodelistcheck ( propertymetamodel $whitespace$ property ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ property . getname ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . getname ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ nodelistcheck ( propertymetamodel $whitespace$ property ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$, $whitespace$ property. getname ( ), $whitespace$ property. getname ( ), $whitespace$ property. getname ( ) ) ; $newline$ $indentation$ }			
generateRemoveMethodForAttribute	103	112	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/RemoveMethodGenerator.java	0.1810580492019653	LOW	"		private String generateRemoveMethodForAttribute(ClassOrInterfaceDeclaration nodeCoid, BaseNodeMetaModel nodeMetaModel, PropertyMetaModel property){
		    final String methodName = ""remove"" + capitalize(property.getName());
		    final MethodDeclaration removeMethod = (MethodDeclaration) parseBodyDeclaration(f(""public %s %s() {}"", nodeMetaModel.getTypeName(), methodName));
		    final BlockStmt block = removeMethod.getBody().get();
		    block.addStatement(f(""return %s((%s) null);"", property.getSetterMethodName(), property.getTypeNameForSetter()));
		    addOrReplaceWhenSameSignature(nodeCoid, removeMethod);
		    return methodName;
		}"	$indentation$ private $whitespace$ string $whitespace$ generateremovemethodforattribute ( classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ final $whitespace$ string $whitespace$ methodname $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ capitalize ( property . getname ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ removemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ nodemetamodel . gettypename ( ) , $whitespace$ methodname ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ block $whitespace$ = $whitespace$ removemethod . getbody ( ) . get ( ) ; $newline$ $indentation$ block . addstatement ( f ( $string$ , $whitespace$ property . getsettermethodname ( ) , $whitespace$ property . gettypenameforsetter ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ removemethod ) ; $newline$ $indentation$ return $whitespace$ methodname ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ generateremovemethodforattribute ( classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ final $whitespace$ string $whitespace$ methodname $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ capitalize ( property. getname ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ removemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ nodemetamodel. gettypename ( ), $whitespace$ methodname ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ block $whitespace$ = $whitespace$ removemethod. getbody ( ). get ( ) ; $newline$ $indentation$ block. addstatement ( f ( $string$, $whitespace$ property. getsettermethodname ( ), $whitespace$ property. gettypenameforsetter ( ) ) ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ removemethod ) ; $newline$ $indentation$ return $whitespace$ methodname ; $newline$ $indentation$ }			
nodeListCheck	89	96	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/ReplaceMethodGenerator.java	0.0560507103800773	LOW	"		private String nodeListCheck(PropertyMetaModel property){
		    return f(""for (int i = 0; i < %s.size(); i++) {"" + ""  if (%s.get(i) == node) {"" + ""    %s.set(i, (%s) replacementNode);"" + ""    return true;"" + ""  }"" + ""}"", property.getName(), property.getName(), property.getName(), property.getTypeName());
		}"	$indentation$ private $whitespace$ string $whitespace$ nodelistcheck ( propertymetamodel $whitespace$ property ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ property . getname ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . gettypename ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ nodelistcheck ( propertymetamodel $whitespace$ property ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$, $whitespace$ property. getname ( ), $whitespace$ property. getname ( ), $whitespace$ property. gettypename ( ) ) ; $newline$ $indentation$ }			
generateNode	42	80	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/ReplaceMethodGenerator.java	0.0778333693742752	LOW	"		@Override
		protected void generateNode(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, ClassOrInterfaceDeclaration nodeCoid){
		    MethodDeclaration replaceNodeMethod = (MethodDeclaration) parseBodyDeclaration(""public boolean replace(Node node, Node replacementNode) {}"");
		    nodeCu.addImport(Node.class);
		    annotateWhenOverridden(nodeMetaModel, replaceNodeMethod);
		    final BlockStmt body = replaceNodeMethod.getBody().get();
		    body.addStatement(""if (node == null) { return false; }"");
		    int numberPropertiesDeclared = 0;
		    for (PropertyMetaModel property : nodeMetaModel.getDeclaredPropertyMetaModels()) {
		        if (!property.isNode()) {
		            continue;
		        }
		        String check;
		        if (property.isNodeList()) {
		            check = nodeListCheck(property);
		        } else {
		            check = attributeCheck(property, property.getSetterMethodName());
		        }
		        if (property.isOptional()) {
		            check = f(""if (%s != null) { %s }"", property.getName(), check);
		        }
		        body.addStatement(check);
		        numberPropertiesDeclared++;
		    }
		    if (nodeMetaModel.getSuperNodeMetaModel().isPresent()) {
		        body.addStatement(""return super.replace(node, replacementNode);"");
		    } else {
		        body.addStatement(""return false;"");
		    }
		    if (!nodeMetaModel.isRootNode() && numberPropertiesDeclared == 0) {
		        removeMethodWithSameSignature(nodeCoid, replaceNodeMethod);
		    } else {
		        addOrReplaceWhenSameSignature(nodeCoid, replaceNodeMethod);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ methoddeclaration $whitespace$ replacenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( $string$ ) ; $newline$ $indentation$ nodecu . addimport ( node . class ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ replacenodemethod ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ replacenodemethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ int $whitespace$ numberpropertiesdeclared $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ property $whitespace$ : $whitespace$ nodemetamodel . getdeclaredpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ check ; $newline$ $indentation$ if $whitespace$ ( property . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ nodelistcheck ( property ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ attributecheck ( property , $whitespace$ property . getsettermethodname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ property . getname ( ) , $whitespace$ check ) ; $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( check ) ; $newline$ $indentation$ numberpropertiesdeclared ++ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodemetamodel . getsupernodemetamodel ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! nodemetamodel . isrootnode ( ) $whitespace$ && $whitespace$ numberpropertiesdeclared $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ removemethodwithsamesignature ( nodecoid , $whitespace$ replacenodemethod ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ replacenodemethod ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatenode ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid ) { $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ node nodemetamodel. getdeclaredpropertymetamodels ( ). get ( ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ replacenodemethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. addstatement ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ property $whitespace$ : $whitespace$ nodemetamodel. getdeclaredpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! property. isnode ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ check ; $newline$ $indentation$ if $whitespace$ ( property. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ nodelistcheck ( property ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ check $whitespace$ = $whitespace$ attributecheck ( property, $whitespace$ property. getsettermethodname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property. isoptional ( ) ) $whitespace$			
attributeCheck	82	87	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/ReplaceMethodGenerator.java	0.2816596925258636	LOW	"		private String attributeCheck(PropertyMetaModel property, String attributeSetterName){
		    return f(""if (node == %s) {"" + ""    %s((%s) replacementNode);"" + ""    return true;\n"" + ""}"", property.getName(), attributeSetterName, property.getTypeName());
		}"	$indentation$ private $whitespace$ string $whitespace$ attributecheck ( propertymetamodel $whitespace$ property , $whitespace$ string $whitespace$ attributesettername ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ property . getname ( ) , $whitespace$ attributesettername , $whitespace$ property . gettypename ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ attributecheck ( propertymetamodel $whitespace$ property, $whitespace$ string $whitespace$ attributesettername ) { $newline$ $indentation$ return $whitespace$ f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$, $whitespace$ property. getname ( ), $whitespace$ attributesettername, $whitespace$ property. gettypename ( ) ) ; $newline$ $indentation$ }			
generateAsType	84	94	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/TypeCastingGenerator.java	0.1742451190948486	LOW	"		private void generateAsType(BaseNodeMetaModel nodeMetaModel, CompilationUnit baseCu, ClassOrInterfaceDeclaration nodeCoid, ClassOrInterfaceDeclaration baseCoid, String typeName){
		    baseCu.addImport(""com.github.javaparser.utils.CodeGenerationUtils.f"", true, false);
		    final MethodDeclaration asTypeBaseMethod = (MethodDeclaration) parseBodyDeclaration(f(""public %s as%s() { throw new IllegalStateException(f(\""%%s is not %s, it is %%s\"", this, this.getClass().getSimpleName())); }"", typeName, typeName, typeName));
		    final MethodDeclaration asTypeNodeMethod = (MethodDeclaration) parseBodyDeclaration(f(""@Override public %s as%s() { return this; }"", typeName, typeName));
		    annotateWhenOverridden(nodeMetaModel, asTypeNodeMethod);
		    addOrReplaceWhenSameSignature(baseCoid, asTypeBaseMethod);
		    addOrReplaceWhenSameSignature(nodeCoid, asTypeNodeMethod);
		}"	$indentation$ private $whitespace$ void $whitespace$ generateastype ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ basecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ classorinterfacedeclaration $whitespace$ basecoid , $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ basecu . addimport ( $string$ , $whitespace$ true , $whitespace$ false ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ astypebasemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ % % s $whitespace$ is $whitespace$ not $whitespace$ % s , $whitespace$ it $whitespace$ is $whitespace$ % % s \ $string$ , $whitespace$ typename , $whitespace$ typename , $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ astypenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ typename , $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ astypenodemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid , $whitespace$ astypebasemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ astypenodemethod ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generateastype ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ basecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ classorinterfacedeclaration $whitespace$ basecoid, $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ basecu. addimport ( $string$, $whitespace$ true, $whitespace$ false ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ astypebasemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ % % s $whitespace$ is $whitespace$ not $whitespace$ % s, $whitespace$ it $whitespace$ is $whitespace$ % % s \ $string$, $whitespace$ typename, $whitespace$ typename, $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ astypenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ typename, $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel, $whitespace$ astypenodemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid, $whitespace$ astypebasemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ astypenodemethod ) ; $newline$ $indentation$ }			
generateIsType	122	130	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/TypeCastingGenerator.java	0.2328131645917892	LOW	"		private void generateIsType(BaseNodeMetaModel nodeMetaModel, CompilationUnit baseCu, ClassOrInterfaceDeclaration nodeCoid, ClassOrInterfaceDeclaration baseCoid, String typeName){
		    final MethodDeclaration baseIsTypeMethod = (MethodDeclaration) parseBodyDeclaration(f(""public boolean is%s() { return false; }"", typeName));
		    final MethodDeclaration overriddenIsTypeMethod = (MethodDeclaration) parseBodyDeclaration(f(""@Override public boolean is%s() { return true; }"", typeName));
		    annotateWhenOverridden(nodeMetaModel, overriddenIsTypeMethod);
		    addOrReplaceWhenSameSignature(nodeCoid, overriddenIsTypeMethod);
		    addOrReplaceWhenSameSignature(baseCoid, baseIsTypeMethod);
		}"	$indentation$ private $whitespace$ void $whitespace$ generateistype ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ basecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ classorinterfacedeclaration $whitespace$ basecoid , $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ baseistypemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ overriddenistypemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ overriddenistypemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ overriddenistypemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid , $whitespace$ baseistypemethod ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generateistype ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ basecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ classorinterfacedeclaration $whitespace$ basecoid, $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ baseistypemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ overriddenistypemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel, $whitespace$ overriddenistypemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ overriddenistypemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid, $whitespace$ baseistypemethod ) ; $newline$ $indentation$ }			
generateToType	96	107	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/node/TypeCastingGenerator.java	0.2962603569030761	LOW	"		private void generateToType(BaseNodeMetaModel nodeMetaModel, CompilationUnit nodeCu, CompilationUnit baseCu, ClassOrInterfaceDeclaration nodeCoid, ClassOrInterfaceDeclaration baseCoid, String typeName){
		    baseCu.addImport(Optional.class);
		    nodeCu.addImport(Optional.class);
		    final MethodDeclaration toTypeBaseMethod = (MethodDeclaration) parseBodyDeclaration(f(""public Optional<%s> to%s() { return Optional.empty(); }"", typeName, typeName, typeName));
		    final MethodDeclaration toTypeNodeMethod = (MethodDeclaration) parseBodyDeclaration(f(""@Override public Optional<%s> to%s() { return Optional.of(this); }"", typeName, typeName));
		    annotateWhenOverridden(nodeMetaModel, toTypeNodeMethod);
		    addOrReplaceWhenSameSignature(baseCoid, toTypeBaseMethod);
		    addOrReplaceWhenSameSignature(nodeCoid, toTypeNodeMethod);
		}"	$indentation$ private $whitespace$ void $whitespace$ generatetotype ( basenodemetamodel $whitespace$ nodemetamodel , $whitespace$ compilationunit $whitespace$ nodecu , $whitespace$ compilationunit $whitespace$ basecu , $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid , $whitespace$ classorinterfacedeclaration $whitespace$ basecoid , $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ basecu . addimport ( optional . class ) ; $newline$ $indentation$ nodecu . addimport ( optional . class ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ totypebasemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ typename , $whitespace$ typename , $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ totypenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$ , $whitespace$ typename , $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel , $whitespace$ totypenodemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid , $whitespace$ totypebasemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid , $whitespace$ totypenodemethod ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generatetotype ( basenodemetamodel $whitespace$ nodemetamodel, $whitespace$ compilationunit $whitespace$ nodecu, $whitespace$ compilationunit $whitespace$ basecu, $whitespace$ classorinterfacedeclaration $whitespace$ nodecoid, $whitespace$ classorinterfacedeclaration $whitespace$ basecoid, $whitespace$ string $whitespace$ typename ) { $newline$ $indentation$ basecu. addimport ( optional. class ) ; $newline$ $indentation$ nodecu. addimport ( optional. class ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ totypebasemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ typename, $whitespace$ typename, $whitespace$ typename ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ totypenodemethod $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ parsebodydeclaration ( f ( $string$, $whitespace$ typename, $whitespace$ typename ) ) ; $newline$ $indentation$ annotatewhenoverridden ( nodemetamodel, $whitespace$ totypenodemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( basecoid, $whitespace$ totypebasemethod ) ; $newline$ $indentation$ addorreplacewhensamesignature ( nodecoid, $whitespace$ totypenodemethod ) ; $newline$ $indentation$ }			
generate	45	67	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/other/BndGenerator.java	0.0208978857845067	LOW	"		@Override
		public void generate() throws IOException{
		    Log.info(""Running %s"", () -> getClass().getSimpleName());
		    Path root = sourceRoot.getRoot();
		    Path projectRoot = root.getParent().getParent().getParent();
		    String lineSeparator = System.getProperty(""line.separator"");
		    try (Stream<Path> stream = Files.walk(root)) {
		        String packagesList = stream.filter(Files::isRegularFile).map(path -> getPackageName(root, path)).distinct().sorted().reduce(null, (packageList, packageName) -> concatPackageName(packageName, packageList, lineSeparator));
		        Path output = projectRoot.resolve(""bnd.bnd"");
		        try (Writer writer = Files.newBufferedWriter(output)) {
		            Path templateFile = projectRoot.resolve(""bnd.bnd.template"");
		            String template = new String(Files.readAllBytes(templateFile), StandardCharsets.UTF_8);
		            writer.write(template.replace(""{exportedPackages}"", packagesList));
		        }
		        Log.info(""Written "" + output);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ generate ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ path $whitespace$ root $whitespace$ = $whitespace$ sourceroot . getroot ( ) ; $newline$ $indentation$ path $whitespace$ projectroot $whitespace$ = $whitespace$ root . getparent ( ) . getparent ( ) . getparent ( ) ; $newline$ $indentation$ string $whitespace$ lineseparator $whitespace$ = $whitespace$ system . getproperty ( $string$ ) ; $newline$ $indentation$ try $whitespace$ ( stream < path > $whitespace$ stream $whitespace$ = $whitespace$ files . walk ( root ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ packageslist $whitespace$ = $whitespace$ stream . filter ( files : : isregularfile ) . map ( path $whitespace$ - > $whitespace$ getpackagename ( root , $whitespace$ path ) ) . distinct ( ) . sorted ( ) . reduce ( null , $whitespace$ ( packagelist , $whitespace$ packagename ) $whitespace$ - > $whitespace$ concatpackagename ( packagename , $whitespace$ packagelist , $whitespace$ lineseparator ) ) ; $newline$ $indentation$ path $whitespace$ output $whitespace$ = $whitespace$ projectroot . resolve ( $string$ ) ; $newline$ $indentation$ try $whitespace$ ( writer $whitespace$ writer $whitespace$ = $whitespace$ files . newbufferedwriter ( output ) ) $whitespace$ { $newline$ $indentation$ path $whitespace$ templatefile $whitespace$ = $whitespace$ projectroot . resolve ( $string$ ) ; $newline$ $indentation$ string $whitespace$ template $whitespace$ = $whitespace$ new $whitespace$ string ( files . readallbytes ( templatefile ) , $whitespace$ standardcharsets . utf_8 ) ; $newline$ $indentation$ writer . write ( template . replace ( $string$ , $whitespace$ packageslist ) ) ; $newline$ $indentation$ } $newline$ $indentation$ log . info ( $string$ $whitespace$ + $whitespace$ output ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ generate ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ log. info ( $string$, $whitespace$ getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ path $whitespace$ root $whitespace$ = $whitespace$ sourceroot. getroot ( ) ; $newline$ $indentation$ path $whitespace$ projectroot $whitespace$ = $whitespace$ root. getparent ( ). getparent ( ). getparent ( ) ; $newline$ $indentation$ string $whitespace$ lineseparator $whitespace$ = $whitespace$ system. getproperty ( $string$ ) ; $newline$ $indentation$ try $whitespace$ ( stream < path > $whitespace$ stream $whitespace$ = $whitespace$ files. walk ( root ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ packageslist $whitespace$ = $whitespace$ stream. filter ( files : : isregularfile ). map ( path $whitespace$ - > $whitespace$ getpackagename ( root, $whitespace$ path ) ). distinct ( ). sorted ( ). reduce ( null, $whitespace$ ( packagelist, $whitespace$ packagename ) $whitespace$ - > $whitespace$ concatpackagename ( packagename, $whitespace$ packagelist, $whitespace$ lineseparator ) ) ; $newline$ $indentation$ path $whitespace$ output $whitespace$ = $whitespace$ projectroot. resolve ( $string$ ) ; $newline$ $indentation$ try $whitespace$ ( writer $whitespace$ writer $whitespace$ = $whitespace$ files. newbufferedwriter ( output ) ) $whitespace$ { $newline$ $indentation$ path $whitespace$ templatefile $whitespace$ = $whitespace$ projectroot. resolve ( $string$ ) ; $newline$ $indentation$ string $whitespace$ template $whitespace$ = $whitespace$ new $whitespace$ string ( files. readallbytes ( templatefile ),			
generate	50	80	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/other/TokenKindGenerator.java	0.0033839920070022	LOW	"		@Override
		public void generate(){
		    Log.info(""Running %s"", () -> getClass().getSimpleName());
		    final CompilationUnit javaTokenCu = sourceRoot.parse(""com.github.javaparser"", ""JavaToken.java"");
		    final ClassOrInterfaceDeclaration javaToken = javaTokenCu.getClassByName(""JavaToken"").orElseThrow(() -> new AssertionError(""Can't find class in java file.""));
		    final EnumDeclaration kindEnum = javaToken.findFirst(EnumDeclaration.class, e -> ""Kind"".equals(e.getNameAsString())).orElseThrow(() -> new AssertionError(""Can't find class in java file.""));
		    kindEnum.getEntries().clear();
		    annotateGenerated(kindEnum);
		    final SwitchStmt valueOfSwitch = kindEnum.findFirst(SwitchStmt.class).orElseThrow(() -> new AssertionError(""Can't find valueOf switch.""));
		    valueOfSwitch.findAll(SwitchEntry.class).stream().filter(e -> e.getLabels().isNonEmpty()).forEach(Node::remove);
		    final CompilationUnit constantsCu = generatedJavaCcSourceRoot.parse(""com.github.javaparser"", ""GeneratedJavaParserConstants.java"");
		    final ClassOrInterfaceDeclaration constants = constantsCu.getInterfaceByName(""GeneratedJavaParserConstants"").orElseThrow(() -> new AssertionError(""Can't find class in java file.""));
		    for (BodyDeclaration<?> member : constants.getMembers()) {
		        member.toFieldDeclaration().filter(field -> {
		            String javadoc = field.getJavadocComment().get().getContent();
		            return javadoc.contains(""RegularExpression Id"") || javadoc.contains(""End of File"");
		        }).map(field -> field.getVariable(0)).ifPresent(var -> {
		            final String name = var.getNameAsString();
		            final IntegerLiteralExpr kind = var.getInitializer().get().asIntegerLiteralExpr();
		            generateEnumEntry(kindEnum, name, kind);
		            generateValueOfEntry(valueOfSwitch, name, kind);
		        });
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ generate ( ) { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ javatokencu $whitespace$ = $whitespace$ sourceroot . parse ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ javatoken $whitespace$ = $whitespace$ javatokencu . getclassbyname ( $string$ ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ final $whitespace$ enumdeclaration $whitespace$ kindenum $whitespace$ = $whitespace$ javatoken . findfirst ( enumdeclaration . class , $whitespace$ e $whitespace$ - > $whitespace$ $string$ . equals ( e . getnameasstring ( ) ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ kindenum . getentries ( ) . clear ( ) ; $newline$ $indentation$ annotategenerated ( kindenum ) ; $newline$ $indentation$ final $whitespace$ switchstmt $whitespace$ valueofswitch $whitespace$ = $whitespace$ kindenum . findfirst ( switchstmt . class ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ valueofswitch . findall ( switchentry . class ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . getlabels ( ) . isnonempty ( ) ) . foreach ( node : : remove ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ constantscu $whitespace$ = $whitespace$ generatedjavaccsourceroot . parse ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ constants $whitespace$ = $whitespace$ constantscu . getinterfacebyname ( $string$ ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ for $whitespace$ ( bodydeclaration < ? > $whitespace$ member $whitespace$ : $whitespace$ constants . getmembers ( ) ) $whitespace$ { $newline$ $indentation$ member . tofielddeclaration ( ) . filter ( field $whitespace$ - > $whitespace$ { $newline$ $indentation$ string $whitespace$ javadoc $whitespace$ = $whitespace$ field . getjavadoccomment ( ) . get ( ) . getcontent ( ) ; $newline$ $indentation$ return $whitespace$ javadoc . contains ( $string$ ) $whitespace$ || $whitespace$ javadoc . contains ( $string$ ) ; $newline$ $indentation$ } ) . map ( field $whitespace$ - > $whitespace$ field . getvariable ( $number$ ) ) . ifpresent ( var $whitespace$ - > $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ name $whitespace$ = $whitespace$ var . getnameasstring ( ) ; $newline$ $indentation$ final $whitespace$ integerliteralexpr $whitespace$ kind $whitespace$ = $whitespace$ var . getinitializer ( ) . get ( ) . asintegerliteralexpr ( ) ; $newline$ $indentation$ generateenumentry ( kindenum , $whitespace$ name , $whitespace$ kind ) ; $newline$ $indentation$ generatevalueofentry ( valueofswitch , $whitespace$ name , $whitespace$ kind ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ generate ( ) { $newline$ $indentation$ log. info ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ javatokencu $whitespace$ = $whitespace$ sourceroot. parse ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ javatoken $whitespace$ = $whitespace$ javatokencu. getclassbyname ( $string$ ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ final $whitespace$ enumdeclaration $whitespace$ kindenum $whitespace$ = $whitespace$ javatoken. findfirst ( enumdeclaration. class, $whitespace$ e $whitespace$ - > $whitespace$ $string$. equals ( e. getnameasstring ( ) ) ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ kindenum. getentries ( ). clear ( ) ; $newline$ $indentation$ annotategenerated ( kindenum ) ; $newline$ $indentation$ final $whitespace$ switchstmt $whitespace$ valueofswitch $whitespace$ = $whitespace$ kindenum. findfirst ( switchstmt. class ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ assertionerror ( $string$ ) ) ; $newline$ $indentation$ valueofswitch. findall ( switchentry. class ). stream ( ). filter ( e $whitespace$ - > $whitespace$ e. getlabels ( ). isnonempty ( ) ). foreach ( node : : remove ) ; $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ constantscu $whitespace$ = $whitespace$ generated			
getSimilarAssertionInBlock	186	206	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/quality/NotNullGenerator.java	0.0209803320467472	LOW	"		private Optional<? extends Statement> getSimilarAssertionInBlock(Statement assertion, BlockStmt blockStmt){
		    MethodCallExpr assertionCall = assertion.asExpressionStmt().getExpression().asMethodCallExpr();
		    List<MethodCallExpr> methodCallExpressions = blockStmt.findAll(MethodCallExpr.class);
		    for (MethodCallExpr blockMethodCall : methodCallExpressions) {
		        // Check if the method calls name match
		        if (blockMethodCall.getNameAsExpression().equals(assertionCall.getNameAsExpression()) && blockMethodCall.getScope().equals(assertionCall.getScope()) && blockMethodCall.getArguments().size() == 2 && blockMethodCall.getArguments().get(0).equals(assertionCall.getArgument(0))) {
		            return blockMethodCall.findAncestor(ExpressionStmt.class);
		        }
		    }
		    // TODO:
		    return Optional.empty();
		}"	$indentation$ private $whitespace$ optional < ? $whitespace$ extends $whitespace$ statement > $whitespace$ getsimilarassertioninblock ( statement $whitespace$ assertion , $whitespace$ blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ methodcallexpr $whitespace$ assertioncall $whitespace$ = $whitespace$ assertion . asexpressionstmt ( ) . getexpression ( ) . asmethodcallexpr ( ) ; $newline$ $indentation$ list < methodcallexpr > $whitespace$ methodcallexpressions $whitespace$ = $whitespace$ blockstmt . findall ( methodcallexpr . class ) ; $newline$ $indentation$ for $whitespace$ ( methodcallexpr $whitespace$ blockmethodcall $whitespace$ : $whitespace$ methodcallexpressions ) $whitespace$ { $newline$ $indentation$ $//·check·if·the·method·calls·name·match$ $newline$ $indentation$ if $whitespace$ ( blockmethodcall . getnameasexpression ( ) . equals ( assertioncall . getnameasexpression ( ) ) $whitespace$ && $whitespace$ blockmethodcall . getscope ( ) . equals ( assertioncall . getscope ( ) ) $whitespace$ && $whitespace$ blockmethodcall . getarguments ( ) . size ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ blockmethodcall . getarguments ( ) . get ( $number$ ) . equals ( assertioncall . getargument ( $number$ ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ blockmethodcall . findancestor ( expressionstmt . class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo:$ $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional <? $whitespace$ extends $whitespace$ statement > $whitespace$ getsimilarassertioninblock ( statement $whitespace$ assertion, $whitespace$ blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ methodcallexpr $whitespace$ assertioncall $whitespace$ = $whitespace$ assertion. asexpressionstmt ( ). getexpression ( ). asmethodcallexpr ( ) ; $newline$ $indentation$ list < methodcallexpr > $whitespace$ methodcallexpressions $whitespace$ = $whitespace$ blockstmt. findall ( methodcallexpr. class ) ; $newline$ $indentation$ for $whitespace$ ( methodcallexpr $whitespace$ blockmethodcall $whitespace$ : $whitespace$ methodcallexpressions ) $whitespace$ { $newline$ $indentation$ $indentation$ $// $newline$ $indentation$ if $whitespace$ ( blockmethodcall. getnameasexpression ( ). equals ( assertioncall. getnameasexpression ( ) ) $newline$ $indentation$ && $whitespace$ blockmethodcall. getscope ( ). equals ( assertioncall. getscope ( ) ) $newline$ $indentation$ && $whitespace$ blockmethodcall. getarguments ( ). size ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ blockmethodcall. getarguments ( ). get ( $number$ ). equals ( assertioncall. getargument ( $number$ ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ blockmethodcall. findancestor ( expressionstmt. class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
generateQualityForParameter	109	122	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/quality/NotNullGenerator.java	0.1741704791784286	LOW	"		protected void generateQualityForParameter(N callableDeclaration, NodeList<Parameter> parameters, BlockStmt blockStmt){
		    List<Statement> assertions = new ArrayList<>();
		    for (Parameter parameter : parameters) {
		        Optional<AnnotationExpr> nonNullAnnotation = parameter.getAnnotationByClass(NotNull.class);
		        if (nonNullAnnotation.isPresent()) {
		            assertions.add(createAssertion(parameter));
		        }
		    }
		    insertAssertionsInBlock(callableDeclaration, blockStmt, assertions);
		}"	$indentation$ protected $whitespace$ void $whitespace$ generatequalityforparameter ( n $whitespace$ callabledeclaration , $whitespace$ nodelist < parameter > $whitespace$ parameters , $whitespace$ blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ list < statement > $whitespace$ assertions $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ parameters ) $whitespace$ { $newline$ $indentation$ optional < annotationexpr > $whitespace$ nonnullannotation $whitespace$ = $whitespace$ parameter . getannotationbyclass ( notnull . class ) ; $newline$ $indentation$ if $whitespace$ ( nonnullannotation . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ assertions . add ( createassertion ( parameter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ insertassertionsinblock ( callabledeclaration , $whitespace$ blockstmt , $whitespace$ assertions ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ generatequalityforparameter ( n $whitespace$ callabledeclaration, $whitespace$ nodelist < parameter > $whitespace$ parameters, $whitespace$ blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ list < statement > $whitespace$ assertions $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ parameters ) $whitespace$ { $newline$ $indentation$ optional < annotationexpr > $whitespace$ nonnullannotation $whitespace$ = $whitespace$ parameter. getannotationbyclass ( notnull. class ) ; $newline$ $indentation$ if $whitespace$ ( nonnullannotation. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ assertions. add ( createassertion ( parameter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ insertassertionsinblock ( callabledeclaration, $whitespace$ blockstmt, $whitespace$ assertions ) ; $newline$ $indentation$ }			
castValue	49	55	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/utils/CodeUtils.java	0.643288254737854	MID	"		public static String castValue(String value, Type requiredType, String valueType){
		    String requiredTypeName = requiredType.asString();
		    if (requiredTypeName.equals(valueType))
		        return value;
		    return String.format(""(%s) %s"", requiredTypeName, value);
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ castvalue ( string $whitespace$ value , $whitespace$ type $whitespace$ requiredtype , $whitespace$ string $whitespace$ valuetype ) { $newline$ $indentation$ string $whitespace$ requiredtypename $whitespace$ = $whitespace$ requiredtype . asstring ( ) ; $newline$ $indentation$ if $whitespace$ ( requiredtypename . equals ( valuetype ) ) $newline$ $indentation$ return $whitespace$ value ; $newline$ $indentation$ return $whitespace$ string . format ( $string$ , $whitespace$ requiredtypename , $whitespace$ value ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ castvalue ( string $whitespace$ value, $whitespace$ type $whitespace$ requiredtype, $whitespace$ string $whitespace$ valuetype ) { $newline$ $indentation$ string $whitespace$ requiredtypename $whitespace$ = $whitespace$ requiredtype. asstring ( ) ; $newline$ $indentation$ if $whitespace$ ( requiredtypename. equals ( valuetype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ value ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string. format ( $string$, $whitespace$ requiredtypename, $whitespace$ value ) ; $newline$ $indentation$ }			
generateVisitMethodBody	44	85	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/CloneVisitorGenerator.java	0.0185881927609443	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		        final String getter = field.getGetterMethodName() + ""()"";
		        if (field.getNodeReference().isPresent()) {
		            if (field.isOptional() && field.isNodeList()) {
		                body.addStatement(f(""NodeList<%s> %s = cloneList(n.%s.orElse(null), arg);"", field.getTypeNameGenerified(), field.getName(), getter));
		            } else if (field.isNodeList()) {
		                body.addStatement(f(""NodeList<%s> %s = cloneList(n.%s, arg);"", field.getTypeNameGenerified(), field.getName(), getter));
		            } else {
		                body.addStatement(f(""%s %s = cloneNode(n.%s, arg);"", field.getTypeNameGenerified(), field.getName(), getter));
		            }
		        }
		    }
		    SeparatedItemStringBuilder builder = new SeparatedItemStringBuilder(f(""%s r = new %s("", node.getTypeNameGenerified(), node.getTypeNameGenerified()), "","", "");"");
		    builder.append(""n.getTokenRange().orElse(null)"");
		    for (PropertyMetaModel field : node.getConstructorParameters()) {
		        if (""comment"".equals(field.getName())) {
		            continue;
		        }
		        if (field.getNodeReference().isPresent()) {
		            builder.append(field.getName());
		        } else {
		            builder.append(f(""n.%s()"", field.getGetterMethodName()));
		        }
		    }
		    body.addStatement(builder.toString());
		    if (node instanceof CompilationUnitMetaModel) {
		        body.addStatement(""n.getStorage().ifPresent(s -> r.setStorage(s.getPath(), s.getEncoding()));"");
		    }
		    body.addStatement(""r.setComment(comment);"");
		    body.addStatement(""n.getOrphanComments().stream().map(Comment::clone).forEach(r::addOrphanComment);"");
		    body.addStatement(""copyData(n, r);"");
		    body.addStatement(""return r;"");
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) $whitespace$ && $whitespace$ field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ field . gettypenamegenerified ( ) , $whitespace$ field . getname ( ) , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ field . gettypenamegenerified ( ) , $whitespace$ field . getname ( ) , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ field . gettypenamegenerified ( ) , $whitespace$ field . getname ( ) , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ separateditemstringbuilder $whitespace$ builder $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( f ( $string$ , $whitespace$ node . gettypenamegenerified ( ) , $whitespace$ node . gettypenamegenerified ( ) ) , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ builder . append ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getconstructorparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( field . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ builder . append ( field . getname ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ builder . append ( f ( $string$ , $whitespace$ field . getgettermethodname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( builder . tostring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ compilationunitmetamodel ) $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node. getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field. getnodereference ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ field. gettypenamegenerified ( ), $whitespace$ field. getname ( ), $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ field. gettypenamegenerified ( ), $whitespace$ field. getname ( ), $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. add			
generateVisitMethodBody	42	68	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/EqualsVisitorGenerator.java	0.2623424828052521	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    body.addStatement(f(""final %s n2 = (%s) arg;"", node.getTypeName(), node.getTypeName()));
		    for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		        final String getter = field.getGetterMethodName() + ""()"";
		        if (field.getNodeReference().isPresent()) {
		            if (field.isNodeList()) {
		                body.addStatement(f(""if (!nodesEquals(n.%s, n2.%s)) return false;"", getter, getter));
		            } else {
		                body.addStatement(f(""if (!nodeEquals(n.%s, n2.%s)) return false;"", getter, getter));
		            }
		        } else {
		            body.addStatement(f(""if (!objEquals(n.%s, n2.%s)) return false;"", getter, getter));
		        }
		    }
		    if (body.getStatements().size() == 1) {
		        // Only the cast line was added, but nothing is using it, so remove it again.
		        body.getStatements().clear();
		    }
		    body.addStatement(""return true;"");
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ node . gettypename ( ) , $whitespace$ node . gettypename ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( body . getstatements ( ) . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·only·the·cast·line·was·added,·but·nothing·is·using·it,·so·remove·it·again.$ $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ node. gettypename ( ), $whitespace$ node. gettypename ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node. getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field. getnodereference ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter, $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter, $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter, $whitespace$ getter			
generateVisitMethodBody	46	76	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/GenericListVisitorAdapterGenerator.java	0.0103075839579105	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    body.addStatement(""List<R> result = new ArrayList<>();"");
		    body.addStatement(""List<R> tmp;"");
		    final String resultCheck = ""if (tmp != null) result.addAll(tmp);"";
		    for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		        final String getter = field.getGetterMethodName() + ""()"";
		        if (field.getNodeReference().isPresent()) {
		            if (field.isOptional()) {
		                body.addStatement(f(""if (n.%s.isPresent()) {"" + ""   tmp = n.%s.get().accept(this, arg);"" + ""   %s"" + ""}"", getter, getter, resultCheck));
		            } else {
		                body.addStatement(f(""{ tmp = n.%s.accept(this, arg); %s }"", getter, resultCheck));
		            }
		        }
		    }
		    body.addStatement(""return result;"");
		    Arrays.stream(new Class<?>[] { List.class, ArrayList.class }).filter(c -> compilationUnit.getImports().stream().noneMatch(i -> c.getName().equals(i.getName().asString()))).forEach(compilationUnit::addImport);
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ resultcheck $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ getter , $whitespace$ getter , $whitespace$ resultcheck ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ resultcheck ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ arrays . stream ( new $whitespace$ class < ? > [ ] $whitespace$ { $whitespace$ list . class , $whitespace$ arraylist . class $whitespace$ } ) . filter ( c $whitespace$ - > $whitespace$ compilationunit . getimports ( ) . stream ( ) . nonematch ( i $whitespace$ - > $whitespace$ c . getname ( ) . equals ( i . getname ( ) . asstring ( ) ) ) ) . foreach ( compilationunit : : addimport ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ value $whitespace$ = $whitespace$ node. getallpropertymetamodels ( ). get ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ value. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( value. getnodereference ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( $string$, $whitespace$ value. get ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter,			
generateVisitMethodBody	42	67	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/GenericVisitorAdapterGenerator.java	0.1262316554784774	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    body.addStatement(""R result;"");
		    final String resultCheck = ""if (result != null) return result;"";
		    for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		        final String getter = field.getGetterMethodName() + ""()"";
		        if (field.getNodeReference().isPresent()) {
		            if (field.isOptional()) {
		                body.addStatement(f(""if (n.%s.isPresent()) {"" + ""   result = n.%s.get().accept(this, arg);"" + ""   %s"" + ""}"", getter, getter, resultCheck));
		            } else {
		                body.addStatement(f(""{ result = n.%s.accept(this, arg); %s }"", getter, resultCheck));
		            }
		        }
		    }
		    body.addStatement(""return null;"");
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ resultcheck $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ getter , $whitespace$ getter , $whitespace$ resultcheck ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ resultcheck ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ weightcheck $whitespace$ = $whitespace$ node. getallpropertymetamodels ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ fieldmethod. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field. getnodereference ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ value. addstatement ( $string$, $whitespace$ weight, $whitespace$ weight ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter, $whitespace$ resultcheck ) ) ; $newline$ $indentation$ }			
generateVisitMethodBody	45	79	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/HashCodeVisitorGenerator.java	0.2823567390441894	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    final BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    final SeparatedItemStringBuilder builder = new SeparatedItemStringBuilder(""return "", ""* 31 +"", "";"");
		    final List<PropertyMetaModel> propertyMetaModels = node.getAllPropertyMetaModels();
		    if (propertyMetaModels.isEmpty()) {
		        builder.append(""0"");
		    } else {
		        for (PropertyMetaModel field : propertyMetaModels) {
		            final String getter = field.getGetterMethodName() + ""()"";
		            // Is this field another AST node? Visit it.
		            if (field.getNodeReference().isPresent()) {
		                if (field.isOptional()) {
		                    builder.append(""(n.%s.isPresent()? n.%s.get().accept(this, arg):0)"", getter, getter);
		                } else {
		                    builder.append(""(n.%s.accept(this, arg))"", getter);
		                }
		            } else {
		                Class<?> type = field.getType();
		                if (type.equals(boolean.class)) {
		                    builder.append(""(n.%s?1:0)"", getter);
		                } else if (type.equals(int.class)) {
		                    builder.append(""n.%s"", getter);
		                } else {
		                    builder.append(""(n.%s.hashCode())"", getter);
		                }
		            }
		        }
		    }
		    body.addStatement(parseStatement(builder.toString()));
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ final $whitespace$ separateditemstringbuilder $whitespace$ builder $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ list < propertymetamodel > $whitespace$ propertymetamodels $whitespace$ = $whitespace$ node . getallpropertymetamodels ( ) ; $newline$ $indentation$ if $whitespace$ ( propertymetamodels . isempty ( ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ propertymetamodels ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $//·is·this·field·another·ast·node?·visit·it.$ $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ class < ? > $whitespace$ type $whitespace$ = $whitespace$ field . gettype ( ) ; $newline$ $indentation$ if $whitespace$ ( type . equals ( boolean . class ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( type . equals ( int . class ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( parsestatement ( builder . tostring ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ compilationunit ( node. getbody ( ). get ( ) ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ final $whitespace$ separateditemstringbuilder $whitespace$ builder $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ list < propertymetamodel > $whitespace$ propertymetamodels $whitespace$ = $whitespace$ node. getallpropertymetamodels ( ) ; $newline$ $indentation$ if $whitespace$ ( propertymetamodels. isempty ( ) ) $whitespace$ { $newline$ $indentation$ builder. append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ propertymetamodels ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field. getnodereference ( ). ispresent ( ) ; $newline$ $indentation$			
generateVisitMethodBody	46	100	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/ModifierVisitorGenerator.java	0.0311661567538976	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    // FIXME: Bit of a hacky way to get this fixed order, and then have everything else (note this list is reversed)
		    List<String> order = Arrays.asList(//                ""comment"", ""name"", ""members"", ""parameters"", ""name"",
		    ""modifiers"", ""annotations"");
		    List<PropertyMetaModel> sortedPropertyMetaModels = node.getAllPropertyMetaModels().stream().sorted(Comparator.comparingInt((PropertyMetaModel o) -> order.indexOf(o.getName())).reversed()).collect(Collectors.toList());
		    //
		    sortedPropertyMetaModels.forEach(property -> extracted(body, property));
		    //
		    if (node.is(BinaryExpr.class)) {
		        body.addStatement(""if (left == null) return right;"");
		        body.addStatement(""if (right == null) return left;"");
		    } else {
		        final SeparatedItemStringBuilder collapseCheck = new SeparatedItemStringBuilder(""if("", ""||"", "") return null;"");
		        sortedPropertyMetaModels.forEach(property -> {
		            if (property.isRequired() && property.isNode()) {
		                if (property.isNodeList()) {
		                    if (property.isNonEmpty()) {
		                        collapseCheck.append(f(""%s.isEmpty()"", property.getName()));
		                    }
		                } else {
		                    collapseCheck.append(f(""%s==null"", property.getName()));
		                }
		            }
		        });
		        if (collapseCheck.hasItems()) {
		            body.addStatement(collapseCheck.toString());
		        }
		    }
		    //
		    sortedPropertyMetaModels.forEach(property -> {
		        if (property.isNode()) {
		            body.addStatement(f(""n.%s(%s);"", property.getSetterMethodName(), property.getName()));
		        }
		    });
		    //
		    body.addStatement(""return n;"");
		}"	"$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ $//·fixme:·bit·of·a·hacky·way·to·get·this·fixed·order,·and·then·have·everything·else·(note·this·list·is·reversed)$ $newline$ $indentation$ list < string > $whitespace$ order $whitespace$ = $whitespace$ arrays . aslist ( $//················""comment"",·""name"",·""members"",·""parameters"",·""name"",$ $newline$ $indentation$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ list < propertymetamodel > $whitespace$ sortedpropertymetamodels $whitespace$ = $whitespace$ node . getallpropertymetamodels ( ) . stream ( ) . sorted ( comparator . comparingint ( ( propertymetamodel $whitespace$ o ) $whitespace$ - > $whitespace$ order . indexof ( o . getname ( ) ) ) . reversed ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ // $newline$ $indentation$ sortedpropertymetamodels . foreach ( property $whitespace$ - > $whitespace$ extracted ( body , $whitespace$ property ) ) ; $newline$ $indentation$ // $newline$ $indentation$ if $whitespace$ ( node . is ( binaryexpr . class ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ final $whitespace$ separateditemstringbuilder $whitespace$ collapsecheck $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ sortedpropertymetamodels . foreach ( property $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isrequired ( ) $whitespace$ && $whitespace$ property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isnonempty ( ) ) $whitespace$ { $newline$ $indentation$ collapsecheck . append ( f ( $string$ , $whitespace$ property . getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ collapsecheck . append ( f ( $string$ , $whitespace$ property . getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ if $whitespace$ ( collapsecheck . hasitems ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( collapsecheck . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ // $newline$ $indentation$ sortedpropertymetamodels . foreach ( property $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . getsettermethodname ( ) , $whitespace$ property . getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ // $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ windowstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ // $newline$ $indentation$ insertkeysintotree ( node, $whitespace$ value ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ insertkeysintonode ( string $whitespace$ node ) $whitespace$ { $newline$ $indentation$ list < string > $whitespace$ order $whitespace$ = $whitespace$ arrays. aslist ( $////. get ( $number$ ) $whitespace$ - > $whitespace$ order. indexof ( o. getname ( ) ) ). reversed ( ) ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ // $newline$ $indentation$ sortedpropertymetamodels. foreach ( property $whitespace$ - > $whitespace$ extracted ( body, $whitespace$			
extracted	102	123	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/ModifierVisitorGenerator.java	0.0709969848394393	LOW	"		private void extracted(BlockStmt body, PropertyMetaModel property){
		    if (property.isNode()) {
		        if (property.isNodeList()) {
		            body.addStatement(f(""NodeList<%s> %s = modifyList(n.%s(), arg);"", property.getTypeNameGenerified(), property.getName(), property.getGetterMethodName()));
		        } else if (property.isOptional()) {
		            body.addStatement(f(""%s %s = n.%s().map(s -> (%s) s.accept(this, arg)).orElse(null);"", property.getTypeNameGenerified(), property.getName(), property.getGetterMethodName(), property.getTypeNameGenerified()));
		        } else {
		            body.addStatement(f(""%s %s = (%s) n.%s().accept(this, arg);"", property.getTypeNameGenerified(), property.getName(), property.getTypeNameGenerified(), property.getGetterMethodName()));
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ extracted ( blockstmt $whitespace$ body , $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ if $whitespace$ ( property . isnode ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . gettypenamegenerified ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . getgettermethodname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( property . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . gettypenamegenerified ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . getgettermethodname ( ) , $whitespace$ property . gettypenamegenerified ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ property . gettypenamegenerified ( ) , $whitespace$ property . getname ( ) , $whitespace$ property . gettypenamegenerified ( ) , $whitespace$ property . getgettermethodname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ extracted ( blockstmt $whitespace$ body, $whitespace$ propertymetamodel $whitespace$ property ) { $newline$ $indentation$ if $whitespace$ ( property. isnode ( ) $whitespace$ && $whitespace$ property. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ property. gettypenamegenerified ( ), $whitespace$ property. getname ( ), $whitespace$ property. getgettermethodname ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( property. isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ property. gettypenamegenerified ( ), $whitespace$ property. getname ( ), $whitespace$ property. getgettermethodname ( ), $whitespace$ property. gettypenamegenerified ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
generateVisitMethodBody	41	75	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/NoCommentEqualsVisitorGenerator.java	0.1038056388497352	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    if (!(node.equals(JavaParserMetaModel.lineCommentMetaModel) || node.equals(JavaParserMetaModel.blockCommentMetaModel) || node.equals(JavaParserMetaModel.javadocCommentMetaModel))) {
		        body.addStatement(f(""final %s n2 = (%s) arg;"", node.getTypeName(), node.getTypeName()));
		        for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		            final String getter = field.getGetterMethodName() + ""()"";
		            if (field.equals(JavaParserMetaModel.nodeMetaModel.commentPropertyMetaModel))
		                continue;
		            if (field.getNodeReference().isPresent()) {
		                if (field.isNodeList()) {
		                    body.addStatement(f(""if (!nodesEquals(n.%s, n2.%s)) return false;"", getter, getter));
		                } else {
		                    body.addStatement(f(""if (!nodeEquals(n.%s, n2.%s)) return false;"", getter, getter));
		                }
		            } else {
		                body.addStatement(f(""if (!objEquals(n.%s, n2.%s)) return false;"", getter, getter));
		            }
		        }
		        if (body.getStatements().size() == 1) {
		            // Only the cast line was added, but nothing is using it, so remove it again.
		            body.getStatements().clear();
		        }
		    }
		    body.addStatement(""return true;"");
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( node . equals ( javaparsermetamodel . linecommentmetamodel ) $whitespace$ || $whitespace$ node . equals ( javaparsermetamodel . blockcommentmetamodel ) $whitespace$ || $whitespace$ node . equals ( javaparsermetamodel . javadoccommentmetamodel ) ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ node . gettypename ( ) , $whitespace$ node . gettypename ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . equals ( javaparsermetamodel . nodemetamodel . commentpropertymetamodel ) ) $newline$ $indentation$ continue ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( body . getstatements ( ) . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·only·the·cast·line·was·added,·but·nothing·is·using·it,·so·remove·it·again.$ $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ if $whitespace$ (! node. equals ( javaparsermetamodel. linecommentmetamodel ) $whitespace$ || $whitespace$ node. equals ( javaparsermetamodel. blockcommentmetamodel ) $whitespace$ || $whitespace$ node. equals ( javaparsermetamodel. javadoccommentmetamodel ) ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ node. gettypename ( ), $whitespace$ node. gettypename ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( field. isnodereference ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$			
generateVisitMethodBody	44	88	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/NoCommentHashCodeVisitorGenerator.java	0.0900428518652916	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    final BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    final SeparatedItemStringBuilder builder = new SeparatedItemStringBuilder(""return "", ""* 31 +"", "";"");
		    final List<PropertyMetaModel> propertyMetaModels = node.getAllPropertyMetaModels();
		    if (node.equals(JavaParserMetaModel.lineCommentMetaModel) || node.equals(JavaParserMetaModel.blockCommentMetaModel) || node.equals(JavaParserMetaModel.javadocCommentMetaModel) || propertyMetaModels.isEmpty()) {
		        builder.append(""0"");
		    } else {
		        for (PropertyMetaModel field : propertyMetaModels) {
		            final String getter = field.getGetterMethodName() + ""()"";
		            if (field.equals(JavaParserMetaModel.nodeMetaModel.commentPropertyMetaModel)) {
		                if (propertyMetaModels.size() == 1) {
		                    builder.append(""0"");
		                    break;
		                }
		                continue;
		            }
		            // Is this field another AST node? Visit it.
		            if (field.getNodeReference().isPresent()) {
		                if (field.isOptional()) {
		                    builder.append(""(n.%s.isPresent()? n.%s.get().accept(this, arg):0)"", getter, getter);
		                } else {
		                    builder.append(""(n.%s.accept(this, arg))"", getter);
		                }
		            } else {
		                Class<?> type = field.getType();
		                if (type.equals(boolean.class)) {
		                    builder.append(""(n.%s?1:0)"", getter);
		                } else if (type.equals(int.class)) {
		                    builder.append(""n.%s"", getter);
		                } else {
		                    builder.append(""(n.%s.hashCode())"", getter);
		                }
		            }
		        }
		    }
		    body.addStatement(parseStatement(builder.toString()));
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ final $whitespace$ separateditemstringbuilder $whitespace$ builder $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ list < propertymetamodel > $whitespace$ propertymetamodels $whitespace$ = $whitespace$ node . getallpropertymetamodels ( ) ; $newline$ $indentation$ if $whitespace$ ( node . equals ( javaparsermetamodel . linecommentmetamodel ) $whitespace$ || $whitespace$ node . equals ( javaparsermetamodel . blockcommentmetamodel ) $whitespace$ || $whitespace$ node . equals ( javaparsermetamodel . javadoccommentmetamodel ) $whitespace$ || $whitespace$ propertymetamodels . isempty ( ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ propertymetamodels ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . equals ( javaparsermetamodel . nodemetamodel . commentpropertymetamodel ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( propertymetamodels . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ $//·is·this·field·another·ast·node?·visit·it.$ $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ class < ? > $whitespace$ type $whitespace$ = $whitespace$ field . gettype ( ) ; $newline$ $indentation$ if $whitespace$ ( type . equals ( boolean . class ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( type . equals ( int . class ) ) $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ builder . append ( $string$ , $whitespace$ getter ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ body . addstatement ( parsestatement ( builder . tostring ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ final $whitespace$ separateditemstringbuilder $whitespace$ builder $whitespace$ = $whitespace$ new $whitespace$ separateditemstringbuilder ( $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ list < propertymetamodel > $whitespace$ propertymetamodels $whitespace$ = $whitespace$ node. getallpropertymetamodels ( ) ; $newline$ $indentation$ if $whitespace$ ( node. equals ( javaparsermetamodel. linecommentmetamodel ) $whitespace$ || $whitespace$ node. equals ( javaparsermetamodel. blockcommentmetamodel ) $whitespace$ || $whitespace$ node. equals ( javaparsermetamodel. javadoccommentmetamodel ) $whitespace$ || $whitespace$ propertymetamodels. isempty ( ) ) $whitespace$ { $newline$ $indentation$ builder. append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ propertymetamodels ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field. getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$			
generateVisitMethodBody	42	63	javaparser/javaparser-core-generators/src/main/java/com/github/javaparser/generator/core/visitor/VoidVisitorAdapterGenerator.java	0.127212569117546	LOW	"		@Override
		protected void generateVisitMethodBody(BaseNodeMetaModel node, MethodDeclaration visitMethod, CompilationUnit compilationUnit){
		    visitMethod.getParameters().forEach(p -> p.setFinal(true));
		    BlockStmt body = visitMethod.getBody().get();
		    body.getStatements().clear();
		    for (PropertyMetaModel field : node.getAllPropertyMetaModels()) {
		        final String getter = field.getGetterMethodName() + ""()"";
		        if (field.getNodeReference().isPresent()) {
		            if (field.isOptional() && field.isNodeList()) {
		                body.addStatement(f(""n.%s.ifPresent( l -> l.forEach( v -> v.accept(this, arg)));"", getter));
		            } else if (field.isOptional()) {
		                body.addStatement(f(""n.%s.ifPresent(l -> l.accept(this, arg));"", getter));
		            } else if (field.isNodeList()) {
		                body.addStatement(f(""n.%s.forEach(p -> p.accept(this, arg));"", getter));
		            } else {
		                body.addStatement(f(""n.%s.accept(this, arg);"", getter));
		            }
		        }
		    }
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node , $whitespace$ methoddeclaration $whitespace$ visitmethod , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod . getparameters ( ) . foreach ( p $whitespace$ - > $whitespace$ p . setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod . getbody ( ) . get ( ) ; $newline$ $indentation$ body . getstatements ( ) . clear ( ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node . getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ getter $whitespace$ = $whitespace$ field . getgettermethodname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( field . getnodereference ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . isoptional ( ) $whitespace$ && $whitespace$ field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field . isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field . isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ body . addstatement ( f ( $string$ , $whitespace$ getter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ generatevisitmethodbody ( basenodemetamodel $whitespace$ node, $whitespace$ methoddeclaration $whitespace$ visitmethod, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ visitmethod. getparameters ( ). foreach ( value $whitespace$ - > $whitespace$ value. setfinal ( true ) ) ; $newline$ $indentation$ blockstmt $whitespace$ body $whitespace$ = $whitespace$ visitmethod. getbody ( ). get ( ) ; $newline$ $indentation$ body. getstatements ( ). clear ( ) ; $newline$ $indentation$ for $whitespace$ ( propertymetamodel $whitespace$ field $whitespace$ : $whitespace$ node. getallpropertymetamodels ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field. isoptional ( ) $whitespace$ && $whitespace$ field. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field. isoptional ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( field. isnodelist ( ) ) $whitespace$ { $newline$ $indentation$ body. addstatement ( f ( $string$, $whitespace$ getter ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ {			
getParsedCompilationUnitsFromSourceRoot	281	305	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.0060421219095587	LOW	"		protected List<CompilationUnit> getParsedCompilationUnitsFromSourceRoot(SourceRoot sourceRoot) throws IOException{
		    List<CompilationUnit> cus = sourceRoot.getCompilationUnits();
		    List<ParseResult<CompilationUnit>> parseResults = sourceRoot.tryToParse();
		    boolean allParsed = parseResults.stream().allMatch(ParseResult::isSuccessful);
		    if (!allParsed) {
		        List<ParseResult<CompilationUnit>> problemResults = parseResults.stream().filter(compilationUnitParseResult -> !compilationUnitParseResult.isSuccessful()).collect(Collectors.toList());
		        for (int i = 0; i < problemResults.size(); i++) {
		            ParseResult<CompilationUnit> parseResult = problemResults.get(i);
		            List<Problem> problems = parseResult.getProblems();
		            Log.info("""");
		            Log.info(""Problems ("" + (i + 1) + "" of "" + problemResults.size() + ""): "");
		            Log.info(problems.toString());
		        }
		        throw new IllegalStateException(""Expected all files to parse."");
		    }
		    Log.info(""parseResults.size() = "" + parseResults.size());
		    return parseResults.stream().map(ParseResult::getResult).map(Optional::get).collect(Collectors.toList());
		}"	$indentation$ protected $whitespace$ list < compilationunit > $whitespace$ getparsedcompilationunitsfromsourceroot ( sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ list < compilationunit > $whitespace$ cus $whitespace$ = $whitespace$ sourceroot . getcompilationunits ( ) ; $newline$ $indentation$ list < parseresult < compilationunit >> $whitespace$ parseresults $whitespace$ = $whitespace$ sourceroot . trytoparse ( ) ; $newline$ $indentation$ boolean $whitespace$ allparsed $whitespace$ = $whitespace$ parseresults . stream ( ) . allmatch ( parseresult : : issuccessful ) ; $newline$ $indentation$ if $whitespace$ ( ! allparsed ) $whitespace$ { $newline$ $indentation$ list < parseresult < compilationunit >> $whitespace$ problemresults $whitespace$ = $whitespace$ parseresults . stream ( ) . filter ( compilationunitparseresult $whitespace$ - > $whitespace$ ! compilationunitparseresult . issuccessful ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ problemresults . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ problemresults . get ( i ) ; $newline$ $indentation$ list < problem > $whitespace$ problems $whitespace$ = $whitespace$ parseresult . getproblems ( ) ; $newline$ $indentation$ log . info ( $string$ ) ; $newline$ $indentation$ log . info ( $string$ $whitespace$ + $whitespace$ ( i $whitespace$ + $whitespace$ $number$ ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ problemresults . size ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ log . info ( problems . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log . info ( $string$ $whitespace$ + $whitespace$ parseresults . size ( ) ) ; $newline$ $indentation$ return $whitespace$ parseresults . stream ( ) . map ( parseresult : : getresult ) . map ( optional : : get ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ list < compilationunit > $whitespace$ getparsedcompilationunitsfromsourceroot ( sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ list < compilationunit > $whitespace$ cus $whitespace$ = $whitespace$ sourceroot. getcompilationunits ( ) ; $newline$ $indentation$ list < parseresult < compilationunit >> $whitespace$ parseresults $whitespace$ = $whitespace$ sourceroot. trytoparse ( ) ; $newline$ $indentation$ boolean $whitespace$ allparsed $whitespace$ = $whitespace$ parseresults. stream ( ). allmatch ( parseresult : : issuccessful ) ; $newline$ $indentation$ if $whitespace$ (! allparsed ) $whitespace$ { $newline$ $indentation$ list < parseresult < compilationunit >> $whitespace$ problemresults $whitespace$ = $whitespace$ parseresults. stream ( ). filter ( compilationunitparseresult $whitespace$ - > $whitespace$! compilationunitparseresult. issuccessful ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ problemresults. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ problemresults. get ( i ) ; $newline$ $indentation$ list < problem > $whitespace$ problems $whitespace$ = $whitespace$ parseresult. getproblems ( ) ; $newline$ $indentation$ log. info ( $string$ ) ; $newline$ $indentation$ log. info ( $string$ $whitespace$ + $whitespace$ ( i $whitespace$ + $whitespace$ $number$ ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ problemresults. size ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$			
addOrReplaceMethod	105	150	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.0237899124622344	LOW	"		private void addOrReplaceMethod(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable, Runnable onNoExistingMethod){
		    List<CallableDeclaration<?>> existingMatchingCallables = containingClassOrInterface.getCallablesWithSignature(callable.getSignature());
		    if (existingMatchingCallables.isEmpty()) {
		        // A matching callable exists -- will now normally add/insert.
		        onNoExistingMethod.run();
		    } else {
		        // A matching callable doe NOT exist -- will now normally replace.
		        if (existingMatchingCallables.size() > 1) {
		            throw new AssertionError(f(""Wanted to regenerate a method with signature %s in %s, but found more than one, and unable to disambiguate."", callable.getSignature(), containingClassOrInterface.getNameAsString()));
		        }
		        final CallableDeclaration<?> existingCallable = existingMatchingCallables.get(0);
		        // Attempt to retain any existing javadoc.
		        // TODO: Confirm what is done with normal comments...
		        Optional<JavadocComment> callableJavadocComment = callable.getJavadocComment();
		        Optional<JavadocComment> existingCallableJavadocComment = existingCallable.getJavadocComment();
		        Optional<Comment> callableComment = callable.getComment();
		        Optional<Comment> existingCallableComment = existingCallable.getComment();
		        callable.setComment(callableComment.orElseGet(() -> existingCallable.getComment().orElse(null)));
		        //            callable.setJavadocComment(callableJavadocComment.orElse(existingCallableJavadocComment.orElse(null)));
		        // Mark the method as having been fully/partially generated.
		        annotateGenerated(callable);
		        if (callable.isMethodDeclaration()) {
		            // We want the methods that we generate/insert to be pretty printed.
		            MethodDeclaration prettyMethodDeclaration = prettyPrint(callable.asMethodDeclaration(), ""    "");
		            // Do the replacement.
		            containingClassOrInterface.getMembers().replace(existingCallable, prettyMethodDeclaration);
		        } else {
		            // TODO: Unable to parse a constructor directly...?
		            // Do the replacement.
		            containingClassOrInterface.getMembers().replace(existingCallable, callable);
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ addorreplacemethod ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable , $whitespace$ runnable $whitespace$ onnoexistingmethod ) { $newline$ $indentation$ list < callabledeclaration < ? >> $whitespace$ existingmatchingcallables $whitespace$ = $whitespace$ containingclassorinterface . getcallableswithsignature ( callable . getsignature ( ) ) ; $newline$ $indentation$ if $whitespace$ ( existingmatchingcallables . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·a·matching·callable·exists·--·will·now·normally·add/insert.$ $newline$ $indentation$ onnoexistingmethod . run ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·a·matching·callable·doe·not·exist·--·will·now·normally·replace.$ $newline$ $indentation$ if $whitespace$ ( existingmatchingcallables . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$ , $whitespace$ callable . getsignature ( ) , $whitespace$ containingclassorinterface . getnameasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ callabledeclaration < ? > $whitespace$ existingcallable $whitespace$ = $whitespace$ existingmatchingcallables . get ( $number$ ) ; $newline$ $indentation$ $//·attempt·to·retain·any·existing·javadoc.$ $newline$ $indentation$ $//·todo:·confirm·what·is·done·with·normal·comments...$ $newline$ $indentation$ optional < javadoccomment > $whitespace$ callablejavadoccomment $whitespace$ = $whitespace$ callable . getjavadoccomment ( ) ; $newline$ $indentation$ optional < javadoccomment > $whitespace$ existingcallablejavadoccomment $whitespace$ = $whitespace$ existingcallable . getjavadoccomment ( ) ; $newline$ $indentation$ optional < comment > $whitespace$ callablecomment $whitespace$ = $whitespace$ callable . getcomment ( ) ; $newline$ $indentation$ optional < comment > $whitespace$ existingcallablecomment $whitespace$ = $whitespace$ existingcallable . getcomment ( ) ; $newline$ $indentation$ callable . setcomment ( callablecomment . orelseget ( ( ) $whitespace$ - > $whitespace$ existingcallable . getcomment ( ) . orelse ( null ) ) ) ; $newline$ $indentation$ $//············callable.setjavadoccomment(callablejavadoccomment.orelse(existingcallablejavadoccomment.orelse(null)));$ $newline$ $indentation$ $//·mark·the·method·as·having·been·fully/partially·generated.$ $newline$ $indentation$ annotategenerated ( callable ) ; $newline$ $indentation$ if $whitespace$ ( callable . ismethoddeclaration ( ) ) $whitespace$ { $newline$ $indentation$ $//·we·want·the·methods·that·we·generate/insert·to·be·pretty·printed.$ $newline$ $indentation$ methoddeclaration $whitespace$ prettymethoddeclaration $whitespace$ = $whitespace$ prettyprint ( callable . asmethoddeclaration ( ) , $whitespace$ $string$ ) ; $newline$ $indentation$ $//·do·the·replacement.$ $newline$ $indentation$ containingclassorinterface . getmembers ( ) . replace ( existingcallable , $whitespace$ prettymethoddeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·todo:·unable·to·parse·a·constructor·directly...?$ $newline$ $indentation$ $//·do·the·replacement.$ $newline$ $indentation$ containingclassorinterface . getmembers ( ) . replace ( existingcallable , $whitespace$ callable ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ addorreplacemethod ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable, $whitespace$ runnable $whitespace$ onnoexistingmethod ) { $newline$ $indentation$ list < callabledeclaration <? >> $whitespace$ existingmatchingcallables $whitespace$ = $whitespace$ containingclassorinterface. getcallableswithsignature ( callable. getsignature ( ) ) ; $newline$ $indentation$ if $whitespace$ ( existingmatchingcallables. isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//space$ = $whitespace$ existingmatchingcallables. get ( $number$ ) ; $newline$ $indentation$ onnoexistingmethod. run ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//space$ = $whitespace$ existingmatchingcallables. get ( $number$ ) ; $newline$ $indentation$ $whitespace$// $whitespace$ = $whitespace$ existingmatchingcallables. get ( $number$ ) ; $newline$ $indentation$ $whitespace$// $whitespace$ = $whitespace$ existingmatchingcallables. get ( $number$ ) ; $newline$ $indentation$ $whitespace$// $whitespace$ = $whitespace$ existingmatchingcallables. get ( $number$ ) ;			
removeAnnotationImportIfUnused	219	237	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.0408533364534378	LOW	"		protected void removeAnnotationImportIfUnused(CompilationUnit compilationUnit, Class<?> annotation){
		    List<AnnotationExpr> staleAnnotations = compilationUnit.findAll(AnnotationExpr.class).stream().filter(annotationExpr -> annotationExpr.getName().asString().equals(annotation.getSimpleName())).collect(Collectors.toList());
		    if (staleAnnotations.isEmpty()) {
		        // If there are no usages of this annotation, remove the import.
		        boolean isRemoved = compilationUnit.getImports().removeIf(importDeclaration -> {
		            return importDeclaration.getNameAsString().equals(annotation.getCanonicalName());
		        });
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ removeannotationimportifunused ( compilationunit $whitespace$ compilationunit , $whitespace$ class < ? > $whitespace$ annotation ) { $newline$ $indentation$ list < annotationexpr > $whitespace$ staleannotations $whitespace$ = $whitespace$ compilationunit . findall ( annotationexpr . class ) . stream ( ) . filter ( annotationexpr $whitespace$ - > $whitespace$ annotationexpr . getname ( ) . asstring ( ) . equals ( annotation . getsimplename ( ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( staleannotations . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·there·are·no·usages·of·this·annotation,·remove·the·import.$ $newline$ $indentation$ boolean $whitespace$ isremoved $whitespace$ = $whitespace$ compilationunit . getimports ( ) . removeif ( importdeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ return $whitespace$ importdeclaration . getnameasstring ( ) . equals ( annotation . getcanonicalname ( ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ removeannotationimportifunused ( compilationunit $whitespace$ compilationunit, $whitespace$ class <? > $whitespace$ annotation ) { $newline$ $indentation$ list < annotationexpr > $whitespace$ staleannotations $whitespace$ = $whitespace$ compilationunit. findall ( annotationexpr. class ). stream ( ) $newline$ $indentation$. filter ( annotationexpr $whitespace$ - > $whitespace$ annotationexpr. getname ( ). asstring ( ) ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( staleannotations. isempty ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isremoved $whitespace$ = $whitespace$ compilationunit. getimports ( ). removeif ( importdeclaration $whitespace$ - > $whitespace$ annotation. getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
replaceWhenSameSignature	270	278	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.0996347367763519	LOW	"		protected void replaceWhenSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable){
		    addOrReplaceMethod(containingClassOrInterface, callable, () -> {
		        throw new AssertionError(f(""Wanted to regenerate a method with signature %s in %s, but it wasn't there."", callable.getSignature(), containingClassOrInterface.getNameAsString()));
		    });
		}"	$indentation$ protected $whitespace$ void $whitespace$ replacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable ) { $newline$ $indentation$ addorreplacemethod ( containingclassorinterface , $whitespace$ callable , $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$ , $whitespace$ callable . getsignature ( ) , $whitespace$ containingclassorinterface . getnameasstring ( ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ replacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable ) { $newline$ $indentation$ addorreplacemethod ( containingclassorinterface, $whitespace$ callable, $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$, $whitespace$ callable. getsignature ( ), $whitespace$ containingclassorinterface. getnameasstring ( ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }			
annotate	176	192	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.105547159910202	LOW	"		private void annotate(T node, Class<?> annotation, Expression content){
		    NodeList<AnnotationExpr> annotations = node.getAnnotations().stream().filter(a -> !a.getNameAsString().equals(annotation.getSimpleName())).collect(toNodeList());
		    node.setAnnotations(annotations);
		    if (content != null) {
		        node.addSingleMemberAnnotation(annotation.getSimpleName(), content);
		    } else {
		        node.addMarkerAnnotation(annotation.getSimpleName());
		    }
		    // The annotation class will normally need to be imported.
		    node.tryAddImportToParentCompilationUnit(annotation);
		}"	$indentation$ private $whitespace$ void $whitespace$ annotate ( t $whitespace$ node , $whitespace$ class < ? > $whitespace$ annotation , $whitespace$ expression $whitespace$ content ) { $newline$ $indentation$ nodelist < annotationexpr > $whitespace$ annotations $whitespace$ = $whitespace$ node . getannotations ( ) . stream ( ) . filter ( a $whitespace$ - > $whitespace$ ! a . getnameasstring ( ) . equals ( annotation . getsimplename ( ) ) ) . collect ( tonodelist ( ) ) ; $newline$ $indentation$ node . setannotations ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( content $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ node . addsinglememberannotation ( annotation . getsimplename ( ) , $whitespace$ content ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ node . addmarkerannotation ( annotation . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·annotation·class·will·normally·need·to·be·imported.$ $newline$ $indentation$ node . tryaddimporttoparentcompilationunit ( annotation ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ annotate ( t $whitespace$ node, $whitespace$ class <? > $whitespace$ annotation, $whitespace$ expression $whitespace$ content ) { $newline$ $indentation$ nodelist < annotationexpr > $whitespace$ annotations $whitespace$ = $whitespace$ node. getannotations ( ). stream ( ) $newline$ $indentation$. filter ( a $whitespace$ - > $whitespace$! a. getnameasstring ( ). equals ( annotation. getsimplename ( ) ) ) $newline$ $indentation$. collect ( tonodelist ( ) ) ; $newline$ $indentation$ node. setannotations ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( content $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ node. addsinglememberannotation ( annotation. getsimplename ( ), $whitespace$ content ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ node. addmarkerannotation ( annotation. getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ node. getcreate ( ) ; $newline$ $indentation$ node. addmarkerannotation ( annotation. getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ node. addmarkerannotation ( annotation. getsimplename ( ) ) ; $newline$ $indentation$ node. tryaddimporttoparentcompilationunit ( annotation ) ; $newline$ $indentation$ }			
removeAnnotation	202	213	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.1388282775878906	LOW	"		protected void removeAnnotation(T node, Class<?> annotation){
		    node.getAnnotations().removeIf(annotationExpr -> annotationExpr.getName().asString().equals(annotation.getSimpleName()));
		    node.findAncestor(CompilationUnit.class).ifPresent(compilationUnit -> {
		        removeAnnotationImportIfUnused(compilationUnit, annotation);
		    });
		}"	$indentation$ protected $whitespace$ void $whitespace$ removeannotation ( t $whitespace$ node , $whitespace$ class < ? > $whitespace$ annotation ) { $newline$ $indentation$ node . getannotations ( ) . removeif ( annotationexpr $whitespace$ - > $whitespace$ annotationexpr . getname ( ) . asstring ( ) . equals ( annotation . getsimplename ( ) ) ) ; $newline$ $indentation$ node . findancestor ( compilationunit . class ) . ifpresent ( compilationunit $whitespace$ - > $whitespace$ { $newline$ $indentation$ removeannotationimportifunused ( compilationunit , $whitespace$ annotation ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ removeannotation ( t $whitespace$ node, $whitespace$ class <? > $whitespace$ annotation ) { $newline$ $indentation$ node. getannotations ( ). removeif ( annotationexpr $whitespace$ - > $whitespace$ annotationexpr. getname ( ). asstring ( ). equals ( annotation. getsimplename ( ) ) ) ; $newline$ $indentation$ node. findancestor ( compilationunit. class ). ifpresent ( compilationunit $whitespace$ - > $whitespace$ { $newline$ $indentation$ removeannotationimportifunused ( compilationunit, $whitespace$ annotation ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }			
removeMethodWithSameSignature	259	263	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.1646838039159774	LOW	"		protected void removeMethodWithSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable){
		    for (CallableDeclaration<?> existingCallable : containingClassOrInterface.getCallablesWithSignature(callable.getSignature())) {
		        containingClassOrInterface.remove(existingCallable);
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ removemethodwithsamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable ) { $newline$ $indentation$ for $whitespace$ ( callabledeclaration < ? > $whitespace$ existingcallable $whitespace$ : $whitespace$ containingclassorinterface . getcallableswithsignature ( callable . getsignature ( ) ) ) $whitespace$ { $newline$ $indentation$ containingclassorinterface . remove ( existingcallable ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ removemethodwithsamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable ) { $newline$ $indentation$ for $whitespace$ ( callabledeclaration <? > $whitespace$ existingcallable $whitespace$ : $whitespace$ containingclassorinterface. getcallableswithsignature ( callable. getsignature ( ) ) ) $whitespace$ { $newline$ $indentation$ containingclassorinterface. remove ( existingcallable ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
addOrReplaceWhenSameSignature	156	165	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/AbstractGenerator.java	0.2539977133274078	LOW	"		protected void addOrReplaceWhenSameSignature(ClassOrInterfaceDeclaration containingClassOrInterface, CallableDeclaration<?> callable){
		    addOrReplaceMethod(containingClassOrInterface, callable, () -> {
		        annotateGenerated(callable);
		        containingClassOrInterface.addMember(callable);
		    });
		}"	$indentation$ protected $whitespace$ void $whitespace$ addorreplacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface , $whitespace$ callabledeclaration < ? > $whitespace$ callable ) { $newline$ $indentation$ addorreplacemethod ( containingclassorinterface , $whitespace$ callable , $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ annotategenerated ( callable ) ; $newline$ $indentation$ containingclassorinterface . addmember ( callable ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ addorreplacewhensamesignature ( classorinterfacedeclaration $whitespace$ containingclassorinterface, $whitespace$ callabledeclaration <? > $whitespace$ callable ) { $newline$ $indentation$ addorreplacemethod ( containingclassorinterface, $whitespace$ callable, $whitespace$ ( ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ callablegenerated ( callable ) ; $newline$ $indentation$ containingclassorinterface. addmember ( callable ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }			
generate	39	54	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/InitializeConstructorParametersStatementsGenerator.java	0.0331474244594574	LOW	"		 void generate(Class<? extends Node> nodeClass, NodeList<Statement> initializeConstructorParametersStatements){
		    if (nodeClass == Node.class) {
		        return;
		    }
		    Constructor<?> constructor = findAllFieldsConstructor(nodeClass);
		    for (java.lang.reflect.Parameter parameter : constructor.getParameters()) {
		        Field field = findFieldInClass(nodeClass, parameter.getName());
		        String addFieldStatement = f(""%s.getConstructorParameters().add(%s.%s);"", nodeMetaModelFieldName(nodeClass), nodeMetaModelFieldName(field.getDeclaringClass()), propertyMetaModelFieldName(field));
		        initializeConstructorParametersStatements.add(parseStatement(addFieldStatement));
		    }
		}"	$indentation$ void $whitespace$ generate ( class < ? $whitespace$ extends $whitespace$ node > $whitespace$ nodeclass , $whitespace$ nodelist < statement > $whitespace$ initializeconstructorparametersstatements ) { $newline$ $indentation$ if $whitespace$ ( nodeclass $whitespace$ == $whitespace$ node . class ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ constructor < ? > $whitespace$ constructor $whitespace$ = $whitespace$ findallfieldsconstructor ( nodeclass ) ; $newline$ $indentation$ for $whitespace$ ( java . lang . reflect . parameter $whitespace$ parameter $whitespace$ : $whitespace$ constructor . getparameters ( ) ) $whitespace$ { $newline$ $indentation$ field $whitespace$ field $whitespace$ = $whitespace$ findfieldinclass ( nodeclass , $whitespace$ parameter . getname ( ) ) ; $newline$ $indentation$ string $whitespace$ addfieldstatement $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ nodemetamodelfieldname ( nodeclass ) , $whitespace$ nodemetamodelfieldname ( field . getdeclaringclass ( ) ) , $whitespace$ propertymetamodelfieldname ( field ) ) ; $newline$ $indentation$ initializeconstructorparametersstatements . add ( parsestatement ( addfieldstatement ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ void $whitespace$ generate ( class <? $whitespace$ extends $whitespace$ node > $whitespace$ nodeclass, $whitespace$ nodelist < statement > $whitespace$ initializeconstructorparametersstatements ) { $newline$ $indentation$ constructor <? > $whitespace$ constructor $whitespace$ = $whitespace$ findallfieldsconstructor ( nodeclass ) ; $newline$ $indentation$ for $whitespace$ ( java. lang. reflect. parameter $whitespace$ parameter $whitespace$ : $whitespace$ constructor. getparameters ( ) ) $whitespace$ { $newline$ $indentation$ field $whitespace$ field $whitespace$ = $whitespace$ findfieldinclass ( nodeclass, $whitespace$ parameter. getname ( ) ) ; $newline$ $indentation$ string $whitespace$ addfieldstatement $whitespace$ = $whitespace$ f ( $string$, $whitespace$ nodemetamodelfieldname ( nodeclass ), $whitespace$ nodemetamodelfieldname ( field. getdeclaringclass ( ) ), $whitespace$ propertymetamodelfieldname ( field ) ) ; $newline$ $indentation$ initializeconstructorparametersstatements. add ( parsestatement ( addfieldstatement ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
findFieldInClass	56	67	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/InitializeConstructorParametersStatementsGenerator.java	0.2611241936683655	LOW	"		private Field findFieldInClass(Class<?> nodeClass, String name){
		    Class<?> searchClass = nodeClass;
		    do {
		        for (Field field : searchClass.getDeclaredFields()) {
		            if (field.getName().equals(name)) {
		                return field;
		            }
		        }
		        searchClass = searchClass.getSuperclass();
		    } while (searchClass != null);
		    throw new AssertionError(f(""Couldn't find constructor parameter %s as a field, class %s"", name, nodeClass.getSimpleName()));
		}"	$indentation$ private $whitespace$ field $whitespace$ findfieldinclass ( class < ? > $whitespace$ nodeclass , $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ class < ? > $whitespace$ searchclass $whitespace$ = $whitespace$ nodeclass ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ searchclass . getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ field ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ searchclass $whitespace$ = $whitespace$ searchclass . getsuperclass ( ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ ( searchclass $whitespace$ != $whitespace$ null ) ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$ , $whitespace$ name , $whitespace$ nodeclass . getsimplename ( ) ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ field $whitespace$ findfieldinclass ( class <? > $whitespace$ nodeclass, $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ class <? > $whitespace$ searchclass $whitespace$ = $whitespace$ nodeclass ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ searchclass. getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field. getname ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ searchclass ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ searchclass $whitespace$ = $whitespace$ searchclass. getsuperclass ( ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ ( searchclass $whitespace$!= $whitespace$ null ) ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( f ( $string$, $whitespace$ name, $whitespace$ nodeclass. getsimplename ( ) ) ) ; $newline$ $indentation$ }			
generateDerivedProperty	64	85	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/InitializePropertyMetaModelsStatementsGenerator.java	0.0042856680229306	LOW	"		 void generateDerivedProperty(Method method, ClassOrInterfaceDeclaration nodeMetaModelClass, String nodeMetaModelFieldName, NodeList<Statement> initializePropertyMetaModelsStatements){
		    final AstTypeAnalysis returnTypeAnalysis = new AstTypeAnalysis(method.getGenericReturnType());
		    final Class<?> innermostReturnType = returnTypeAnalysis.innerType;
		    final String typeName = innermostReturnType.getTypeName().replace('$', '.');
		    final String propertyMetaModelFieldName = getterToPropertyName(method.getName()) + ""PropertyMetaModel"";
		    nodeMetaModelClass.addField(""PropertyMetaModel"", propertyMetaModelFieldName, PUBLIC);
		    final String propertyInitializer = f(""new PropertyMetaModel(%s, \""%s\"", %s.class, %s, %s, %s, %s, %s)"", nodeMetaModelFieldName, getterToPropertyName(method.getName()), typeName, optionalOf(decapitalize(nodeMetaModelName(innermostReturnType)), isNode(innermostReturnType)), returnTypeAnalysis.isOptional, isNonEmpty(method), returnTypeAnalysis.isNodeList, returnTypeAnalysis.isSelfType);
		    final String fieldSetting = f(""%s.%s=%s;"", nodeMetaModelFieldName, propertyMetaModelFieldName, propertyInitializer);
		    final String fieldAddition = f(""%s.getDerivedPropertyMetaModels().add(%s.%s);"", nodeMetaModelFieldName, nodeMetaModelFieldName, propertyMetaModelFieldName);
		    initializePropertyMetaModelsStatements.add(parseStatement(fieldSetting));
		    initializePropertyMetaModelsStatements.add(parseStatement(fieldAddition));
		}"	$indentation$ void $whitespace$ generatederivedproperty ( method $whitespace$ method , $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass , $whitespace$ string $whitespace$ nodemetamodelfieldname , $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements ) { $newline$ $indentation$ final $whitespace$ asttypeanalysis $whitespace$ returntypeanalysis $whitespace$ = $whitespace$ new $whitespace$ asttypeanalysis ( method . getgenericreturntype ( ) ) ; $newline$ $indentation$ final $whitespace$ class < ? > $whitespace$ innermostreturntype $whitespace$ = $whitespace$ returntypeanalysis . innertype ; $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ innermostreturntype . gettypename ( ) . replace ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertymetamodelfieldname $whitespace$ = $whitespace$ gettertopropertyname ( method . getname ( ) ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ nodemetamodelclass . addfield ( $string$ , $whitespace$ propertymetamodelfieldname , $whitespace$ public ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertyinitializer $whitespace$ = $whitespace$ f ( $string$ % s \ $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ gettertopropertyname ( method . getname ( ) ) , $whitespace$ typename , $whitespace$ optionalof ( decapitalize ( nodemetamodelname ( innermostreturntype ) ) , $whitespace$ isnode ( innermostreturntype ) ) , $whitespace$ returntypeanalysis . isoptional , $whitespace$ isnonempty ( method ) , $whitespace$ returntypeanalysis . isnodelist , $whitespace$ returntypeanalysis . isselftype ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldsetting $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ propertymetamodelfieldname , $whitespace$ propertyinitializer ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldaddition $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ nodemetamodelfieldname , $whitespace$ propertymetamodelfieldname ) ; $newline$ $indentation$ initializepropertymetamodelsstatements . add ( parsestatement ( fieldsetting ) ) ; $newline$ $indentation$ initializepropertymetamodelsstatements . add ( parsestatement ( fieldaddition ) ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ generatederivedproperty ( method $whitespace$ method, $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass, $whitespace$ string $whitespace$ nodemetamodelfieldname, $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements ) { $newline$ $indentation$ final $whitespace$ asttypeanalysis $whitespace$ returntypeanalysis $whitespace$ = $whitespace$ new $whitespace$ asttypeanalysis ( method. getgenericreturntype ( ) ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ innermostreturntype. gettypename ( ). replace ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertymetamodelfieldname $whitespace$ = $whitespace$ gettertopropertyname ( method. getname ( ) ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ nodemetamodelclass. addfield ( $string$, $whitespace$ propertymetamodelfieldname, $whitespace$ public ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertyinitializer $whitespace$ = $whitespace$ f ( $string$ % s \ $string$, $whitespace$ nodemetamodelfieldname, $whitespace$ gettertopropertyname ( method. getname ( ) ), $whitespace$ typename, $whitespace$ optionalof ( decapitalize ( nodemetamodelname ( innermostreturntype ) ), $whitespace$ returntypeanalysis. isoptional, $whitespace$ isnonempty ( method ), $whitespace$ returntypeanalysis. isnodelist, $whitespace$ returntypeanalysis. isselftype ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldsetting $whitespace$ = $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass, $whitespace$ string $whitespace$ nodemetamodelfieldname, $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements ) { $newline$ $			
generate	41	62	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/InitializePropertyMetaModelsStatementsGenerator.java	0.0099756065756082	LOW	"		 void generate(Field field, ClassOrInterfaceDeclaration nodeMetaModelClass, String nodeMetaModelFieldName, NodeList<Statement> initializePropertyMetaModelsStatements){
		    final AstTypeAnalysis fieldTypeAnalysis = new AstTypeAnalysis(field.getGenericType());
		    final Class<?> fieldType = fieldTypeAnalysis.innerType;
		    final String typeName = fieldType.getTypeName().replace('$', '.');
		    final String propertyMetaModelFieldName = field.getName() + ""PropertyMetaModel"";
		    nodeMetaModelClass.addField(""PropertyMetaModel"", propertyMetaModelFieldName, PUBLIC);
		    final String propertyInitializer = f(""new PropertyMetaModel(%s, \""%s\"", %s.class, %s, %s, %s, %s, %s)"", nodeMetaModelFieldName, field.getName(), typeName, optionalOf(decapitalize(nodeMetaModelName(fieldType)), isNode(fieldType)), isOptional(field), isNonEmpty(field), fieldTypeAnalysis.isNodeList, fieldTypeAnalysis.isSelfType);
		    final String fieldSetting = f(""%s.%s=%s;"", nodeMetaModelFieldName, propertyMetaModelFieldName, propertyInitializer);
		    final String fieldAddition = f(""%s.getDeclaredPropertyMetaModels().add(%s.%s);"", nodeMetaModelFieldName, nodeMetaModelFieldName, propertyMetaModelFieldName);
		    initializePropertyMetaModelsStatements.add(parseStatement(fieldSetting));
		    initializePropertyMetaModelsStatements.add(parseStatement(fieldAddition));
		}"	$indentation$ void $whitespace$ generate ( field $whitespace$ field , $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass , $whitespace$ string $whitespace$ nodemetamodelfieldname , $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements ) { $newline$ $indentation$ final $whitespace$ asttypeanalysis $whitespace$ fieldtypeanalysis $whitespace$ = $whitespace$ new $whitespace$ asttypeanalysis ( field . getgenerictype ( ) ) ; $newline$ $indentation$ final $whitespace$ class < ? > $whitespace$ fieldtype $whitespace$ = $whitespace$ fieldtypeanalysis . innertype ; $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ fieldtype . gettypename ( ) . replace ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertymetamodelfieldname $whitespace$ = $whitespace$ field . getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ nodemetamodelclass . addfield ( $string$ , $whitespace$ propertymetamodelfieldname , $whitespace$ public ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertyinitializer $whitespace$ = $whitespace$ f ( $string$ % s \ $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ field . getname ( ) , $whitespace$ typename , $whitespace$ optionalof ( decapitalize ( nodemetamodelname ( fieldtype ) ) , $whitespace$ isnode ( fieldtype ) ) , $whitespace$ isoptional ( field ) , $whitespace$ isnonempty ( field ) , $whitespace$ fieldtypeanalysis . isnodelist , $whitespace$ fieldtypeanalysis . isselftype ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldsetting $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ propertymetamodelfieldname , $whitespace$ propertyinitializer ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldaddition $whitespace$ = $whitespace$ f ( $string$ , $whitespace$ nodemetamodelfieldname , $whitespace$ nodemetamodelfieldname , $whitespace$ propertymetamodelfieldname ) ; $newline$ $indentation$ initializepropertymetamodelsstatements . add ( parsestatement ( fieldsetting ) ) ; $newline$ $indentation$ initializepropertymetamodelsstatements . add ( parsestatement ( fieldaddition ) ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ generate ( field $whitespace$ field, $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass, $whitespace$ string $whitespace$ nodemetamodelfieldname, $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements ) { $newline$ $indentation$ final $whitespace$ asttypeanalysis $whitespace$ fieldtypeanalysis $whitespace$ = $whitespace$ new $whitespace$ asttypeanalysis ( field. getgenerictype ( ) ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ fieldtype. gettypename ( ). replace ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertymetamodelfieldname $whitespace$ = $whitespace$ field. getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ nodemetamodelclass. addfield ( $string$, $whitespace$ propertymetamodelfieldname, $whitespace$ public ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ propertyinitializer $whitespace$ = $whitespace$ f ( $string$ % s \ $string$, $whitespace$ nodemetamodelfieldname, $whitespace$ field. getname ( ), $whitespace$ typename, $whitespace$ optionalof ( decapitalize ( nodemetamodelname ( fieldtype ) ), $whitespace$ isnode ( fieldtype ) ), $whitespace$ isoptional ( field ), $whitespace$ isnonempty ( field ), $whitespace$ fieldtypeanalysis. isnodelist, $whitespace$ fieldtypeanalysis. isselftype ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ fieldsetting $whitespace$ = $whitespace$ f ( $string$, $whitespace$ nodemetamodelfieldname, $whitespace$ propertymetamodelfield			
generateNodeMetaModels	224	265	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/MetaModelGenerator.java	0.0681047886610031	LOW	"		private void generateNodeMetaModels(CompilationUnit javaParserMetaModelCu, SourceRoot sourceRoot) throws NoSuchMethodException{
		    final ClassOrInterfaceDeclaration metaModelCoid = javaParserMetaModelCu.getClassByName(""JavaParserMetaModel"").get();
		    // Initialiser methods
		    final MethodDeclaration initializeNodeMetaModelsMethod = metaModelCoid.getMethodsByName(""initializeNodeMetaModels"").get(0);
		    final MethodDeclaration initializePropertyMetaModelsMethod = metaModelCoid.getMethodsByName(""initializePropertyMetaModels"").get(0);
		    final MethodDeclaration initializeConstructorParametersVariable = metaModelCoid.getMethodsByName(""initializeConstructorParameters"").get(0);
		    // Ensure annotation `@Generated` is added to indicate the contents of each are generated.
		    annotateGenerated(initializeNodeMetaModelsMethod);
		    annotateGenerated(initializePropertyMetaModelsMethod);
		    annotateGenerated(initializeConstructorParametersVariable);
		    // Empty the body of the initialiser methods, to be (re-)generated below.
		    final NodeList<Statement> initializeNodeMetaModelsStatements = initializeNodeMetaModelsMethod.getBody().get().getStatements();
		    final NodeList<Statement> initializePropertyMetaModelsStatements = initializePropertyMetaModelsMethod.getBody().get().getStatements();
		    final NodeList<Statement> initializeConstructorParametersStatements = initializeConstructorParametersVariable.getBody().get().getStatements();
		    initializeNodeMetaModelsStatements.clear();
		    initializePropertyMetaModelsStatements.clear();
		    initializeConstructorParametersStatements.clear();
		    // Remove fields, to be (re-)generated  below.
		    metaModelCoid.getFields().stream().filter(f -> f.getVariable(0).getNameAsString().endsWith(""MetaModel"")).forEach(Node::remove);
		    // Do the generation of each node metamodel class.
		    final NodeMetaModelGenerator nodeMetaModelGenerator = new NodeMetaModelGenerator(sourceRoot);
		    for (Class<? extends Node> nodeClass : ALL_NODE_CLASSES) {
		        nodeMetaModelGenerator.generate(nodeClass, metaModelCoid, initializeNodeMetaModelsStatements, initializePropertyMetaModelsStatements, initializeConstructorParametersStatements, sourceRoot);
		    }
		    // TODO: Document why sorting occurs.
		    initializeNodeMetaModelsStatements.sort(Comparator.comparing(Node::toString));
		}"	$indentation$ private $whitespace$ void $whitespace$ generatenodemetamodels ( compilationunit $whitespace$ javaparsermetamodelcu , $whitespace$ sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ nosuchmethodexception { $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ metamodelcoid $whitespace$ = $whitespace$ javaparsermetamodelcu . getclassbyname ( $string$ ) . get ( ) ; $newline$ $indentation$ $//·initialiser·methods$ $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializenodemetamodelsmethod $whitespace$ = $whitespace$ metamodelcoid . getmethodsbyname ( $string$ ) . get ( $number$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializepropertymetamodelsmethod $whitespace$ = $whitespace$ metamodelcoid . getmethodsbyname ( $string$ ) . get ( $number$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializeconstructorparametersvariable $whitespace$ = $whitespace$ metamodelcoid . getmethodsbyname ( $string$ ) . get ( $number$ ) ; $newline$ $indentation$ $//·ensure·annotation·`@generated`·is·added·to·indicate·the·contents·of·each·are·generated.$ $newline$ $indentation$ annotategenerated ( initializenodemetamodelsmethod ) ; $newline$ $indentation$ annotategenerated ( initializepropertymetamodelsmethod ) ; $newline$ $indentation$ annotategenerated ( initializeconstructorparametersvariable ) ; $newline$ $indentation$ $//·empty·the·body·of·the·initialiser·methods,·to·be·(re-)generated·below.$ $newline$ $indentation$ final $whitespace$ nodelist < statement > $whitespace$ initializenodemetamodelsstatements $whitespace$ = $whitespace$ initializenodemetamodelsmethod . getbody ( ) . get ( ) . getstatements ( ) ; $newline$ $indentation$ final $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements $whitespace$ = $whitespace$ initializepropertymetamodelsmethod . getbody ( ) . get ( ) . getstatements ( ) ; $newline$ $indentation$ final $whitespace$ nodelist < statement > $whitespace$ initializeconstructorparametersstatements $whitespace$ = $whitespace$ initializeconstructorparametersvariable . getbody ( ) . get ( ) . getstatements ( ) ; $newline$ $indentation$ initializenodemetamodelsstatements . clear ( ) ; $newline$ $indentation$ initializepropertymetamodelsstatements . clear ( ) ; $newline$ $indentation$ initializeconstructorparametersstatements . clear ( ) ; $newline$ $indentation$ $//·remove·fields,·to·be·(re-)generated··below.$ $newline$ $indentation$ metamodelcoid . getfields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . getvariable ( $number$ ) . getnameasstring ( ) . endswith ( $string$ ) ) . foreach ( node : : remove ) ; $newline$ $indentation$ $//·do·the·generation·of·each·node·metamodel·class.$ $newline$ $indentation$ final $whitespace$ nodemetamodelgenerator $whitespace$ nodemetamodelgenerator $whitespace$ = $whitespace$ new $whitespace$ nodemetamodelgenerator ( sourceroot ) ; $newline$ $indentation$ for $whitespace$ ( class < ? $whitespace$ extends $whitespace$ node > $whitespace$ nodeclass $whitespace$ : $whitespace$ all_node_classes ) $whitespace$ { $newline$ $indentation$ nodemetamodelgenerator . generate ( nodeclass , $whitespace$ metamodelcoid , $whitespace$ initializenodemetamodelsstatements , $whitespace$ initializepropertymetamodelsstatements , $whitespace$ initializeconstructorparametersstatements , $whitespace$ sourceroot ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo:·document·why·sorting·occurs.$ $newline$ $indentation$ initializenodemetamodelsstatements . sort ( comparator . comparing ( node : : tostring ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ generatenodemetamodels ( compilationunit $whitespace$ javaparsermetamodelcu, $whitespace$ sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ nosuchmethodexception { $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ metamodelcoid $whitespace$ = $whitespace$ javaparsermetamodelcu. getclassbyname ( $string$ ). get ( ) ; $newline$ $indentation$ $////里$initialiseriseriser $whitespace$ = $whitespace$ $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializenodemetamodelsmethod $whitespace$ = $whitespace$ metamodelcoid. getmethodsbyname ( $string$ ). get ( $number$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializepropertymetamodelsmethod $whitespace$ = $whitespace$ metamodelcoid. getmethodsbyname ( $string$ ). get ( $number$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializeconstructorparametersvariable $whitespace$ = $whitespace$ metamodelcoid. getmethodsbyname ( $string$ ). get ( $number$ ) ; $newline$ $indentation$ $////gg $whitespace$ = $whitespace$ $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ initializeconstructorparametersvariable $whitespace$ = $whitespace$ $newline$ $indentation$ final $whitespace$ nodelist < statement > $whitespace$ initializenodemetamodelsstatements $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ;			
main	198	215	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/MetaModelGenerator.java	0.1232658326625824	LOW	"		public static void main(String[] args) throws Exception{
		    if (args.length != 1) {
		        throw new RuntimeException(""Need 1 parameter: the JavaParser source checkout root directory."");
		    }
		    final Path root = Paths.get(args[0], "".."", ""javaparser-core"", ""src"", ""main"", ""java"");
		    final ParserConfiguration parserConfiguration = new ParserConfiguration().setLanguageLevel(ParserConfiguration.LanguageLevel.RAW).setStoreTokens(false);
		    final SourceRoot sourceRoot = new SourceRoot(root, parserConfiguration);
		    PrinterConfiguration config = new DefaultPrinterConfiguration().addOption(new DefaultConfigurationOption(ConfigOption.END_OF_LINE_CHARACTER, (""\n"")));
		    Printer printer = new DefaultPrettyPrinter(config);
		    sourceRoot.setPrinter(printer::print);
		    StaticJavaParser.setConfiguration(parserConfiguration);
		    new MetaModelGenerator(sourceRoot).generate();
		    sourceRoot.saveAll();
		}"	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ main ( string [ ] $whitespace$ args ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ if $whitespace$ ( args . length $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ path $whitespace$ root $whitespace$ = $whitespace$ paths . get ( args [ $number$ ] , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ parserconfiguration $whitespace$ parserconfiguration $whitespace$ = $whitespace$ new $whitespace$ parserconfiguration ( ) . setlanguagelevel ( parserconfiguration . languagelevel . raw ) . setstoretokens ( false ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ sourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( root , $whitespace$ parserconfiguration ) ; $newline$ $indentation$ printerconfiguration $whitespace$ config $whitespace$ = $whitespace$ new $whitespace$ defaultprinterconfiguration ( ) . addoption ( new $whitespace$ defaultconfigurationoption ( configoption . end_of_line_character , $whitespace$ ( $string$ ) ) ) ; $newline$ $indentation$ printer $whitespace$ printer $whitespace$ = $whitespace$ new $whitespace$ defaultprettyprinter ( config ) ; $newline$ $indentation$ sourceroot . setprinter ( printer : : print ) ; $newline$ $indentation$ staticjavaparser . setconfiguration ( parserconfiguration ) ; $newline$ $indentation$ new $whitespace$ metamodelgenerator ( sourceroot ) . generate ( ) ; $newline$ $indentation$ sourceroot . saveall ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ main ( string [ ] $whitespace$ args ) $whitespace$ throws $whitespace$ exception { $newline$ $indentation$ if $whitespace$ ( args. length $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ path $whitespace$ root $whitespace$ = $whitespace$ paths. get ( args [ $number$ ], $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ final $whitespace$ parserconfiguration $whitespace$ parserconfiguration $whitespace$ = $whitespace$ new $whitespace$ parserconfiguration ( ). setlanguagelevel ( parserconfiguration. languagelevel. raw ). setstoretokens ( false ) ; $newline$ $indentation$ final $whitespace$ sourceroot $whitespace$ sourceroot $whitespace$ = $whitespace$ new $whitespace$ sourceroot ( root, $whitespace$ parserconfiguration ) ; $newline$ $indentation$ printerconfiguration $whitespace$ config $whitespace$ = $whitespace$ new $whitespace$ defaultprinterconfiguration ( ). addoption ( new $whitespace$ defaultconfigurationoption ( configoption. end_of_line_character, $whitespace$ ( $string$ ) ) ) ; $newline$ $indentation$ printer $whitespace$ printer $whitespace$ = $whitespace$ new $whitespace$ defaultprettyprinter ( config ) ; $newline$ $indentation$ sourceroot. setprinter ( printer : : print ) ; $newline$ $indentation$ staticjavaparser. setconfiguration ( parserconfiguration ) ; $newline$ $indentation$ new $whitespace$ metamodelgenerator ( sourceroot ). generate ( ) ; $newline$ $indentation$ sourceroot. saveall ( ) ; $newline$ $indentation$ }			
generate	65	169	javaparser/javaparser-core-metamodel-generator/src/main/java/com/github/javaparser/generator/metamodel/NodeMetaModelGenerator.java	6.782230775570497e-05	LOW	"		public void generate(Class<? extends Node> nodeClass, ClassOrInterfaceDeclaration metaModelCoid, NodeList<Statement> initializeNodeMetaModelsStatements, NodeList<Statement> initializePropertyMetaModelsStatements, NodeList<Statement> initializeConstructorParametersStatements, SourceRoot sourceRoot) throws NoSuchMethodException{
		    metaModelCoid.setJavadocComment(GENERATED_JAVADOC_COMMENT);
		    final AstTypeAnalysis typeAnalysis = new AstTypeAnalysis(nodeClass);
		    final String className = MetaModelGenerator.nodeMetaModelName(nodeClass);
		    final String nodeMetaModelFieldName = decapitalize(className);
		    metaModelCoid.getFieldByName(nodeMetaModelFieldName).ifPresent(Node::remove);
		    initializeNodeMetaModelsStatements.add(parseStatement(f(""nodeMetaModels.add(%s);"", nodeMetaModelFieldName)));
		    this.initializeConstructorParametersStatementsGenerator.generate(nodeClass, initializeConstructorParametersStatements);
		    final Class<?> superclass = nodeClass.getSuperclass();
		    final String superNodeMetaModel = MetaModelGenerator.nodeMetaModelName(superclass);
		    final boolean isRootNode = !MetaModelGenerator.isNode(superclass);
		    final FieldDeclaration nodeField = metaModelCoid.addField(className, nodeMetaModelFieldName, PUBLIC, STATIC, FINAL);
		    annotateGenerated(nodeField);
		    nodeField.getVariable(0).setInitializer(parseExpression(f(""new %s(%s)"", className, optionalOf(decapitalize(superNodeMetaModel), !isRootNode))));
		    // The node-specific metamodel file
		    final CompilationUnit classMetaModelJavaFile = new CompilationUnit(MetaModelGenerator.METAMODEL_PACKAGE);
		    classMetaModelJavaFile.setBlockComment(COPYRIGHT_NOTICE_JP_CORE);
		    classMetaModelJavaFile.addImport(Optional.class);
		    classMetaModelJavaFile.addImport(nodeClass);
		    //
		    final ClassOrInterfaceDeclaration nodeMetaModelClass = classMetaModelJavaFile.addClass(className, PUBLIC);
		    annotateGenerated(nodeMetaModelClass);
		    nodeMetaModelClass.setJavadocComment(GENERATED_CLASS_COMMENT);
		    if (isRootNode) {
		        nodeMetaModelClass.addExtendedType(MetaModelGenerator.BASE_NODE_META_MODEL);
		    } else {
		        nodeMetaModelClass.addExtendedType(superNodeMetaModel);
		    }
		    // Constructors
		    final ConstructorDeclaration classMMConstructor = nodeMetaModelClass.addConstructor().addParameter(f(""Optional<%s>"", MetaModelGenerator.BASE_NODE_META_MODEL), f(""super%s"", MetaModelGenerator.BASE_NODE_META_MODEL));
		    classMMConstructor.getBody().addStatement(parseExplicitConstructorInvocationStmt(f(""super(super%s, %s.class, \""%s\"", \""%s\"", %s, %s);"", MetaModelGenerator.BASE_NODE_META_MODEL, nodeClass.getSimpleName(), nodeClass.getSimpleName(), nodeClass.getPackage().getName(), typeAnalysis.isAbstract, typeAnalysis.isSelfType)));
		    annotateGenerated(classMMConstructor);
		    // ?Abstract protected constructor?
		    if (typeAnalysis.isAbstract) {
		        classMetaModelJavaFile.addImport(Node.class);
		        BodyDeclaration<?> bodyDeclaration = parseBodyDeclaration(f(""protected %s(Optional<%s> superNodeMetaModel, Class<? extends Node> type, String name, String packageName, boolean isAbstract, boolean hasWildcard) {"" + ""super(superNodeMetaModel, type, name, packageName, isAbstract, hasWildcard);"" + "" }"", className, MetaModelGenerator.BASE_NODE_META_MODEL));
		        annotateGenerated(bodyDeclaration);
		        nodeMetaModelClass.addMember(bodyDeclaration);
		    }
		    // Fields, sorted by name.
		    final List<Field> fields = new ArrayList<>(Arrays.asList(nodeClass.getDeclaredFields()));
		    fields.sort(Comparator.comparing(Field::getName));
		    for (Field field : fields) {
		        if (this.fieldShouldBeIgnored(field)) {
		            continue;
		        }
		        this.initializePropertyMetaModelsStatementsGenerator.generate(field, nodeMetaModelClass, nodeMetaModelFieldName, initializePropertyMetaModelsStatements);
		    }
		    // Methods, sorted by name.
		    final List<Method> methods = new ArrayList<>(Arrays.asList(nodeClass.getMethods()));
		    methods.sort(Comparator.comparing(Method::getName));
		    for (Method method : methods) {
		        if (method.isAnnotationPresent(DerivedProperty.class)) {
		            this.initializePropertyMetaModelsStatementsGenerator.generateDerivedProperty(method, nodeMetaModelClass, nodeMetaModelFieldName, initializePropertyMetaModelsStatements);
		        }
		    }
		    this.moveStaticInitializeToTheEndOfTheClassBecauseWeNeedTheFieldsToInitializeFirst(metaModelCoid);
		    // Add the file to the source root, enabling it to be saved later.
		    sourceRoot.add(MetaModelGenerator.METAMODEL_PACKAGE, className + "".java"", classMetaModelJavaFile);
		}"	$indentation$ public $whitespace$ void $whitespace$ generate ( class < ? $whitespace$ extends $whitespace$ node > $whitespace$ nodeclass , $whitespace$ classorinterfacedeclaration $whitespace$ metamodelcoid , $whitespace$ nodelist < statement > $whitespace$ initializenodemetamodelsstatements , $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements , $whitespace$ nodelist < statement > $whitespace$ initializeconstructorparametersstatements , $whitespace$ sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ nosuchmethodexception { $newline$ $indentation$ metamodelcoid . setjavadoccomment ( generated_javadoc_comment ) ; $newline$ $indentation$ final $whitespace$ asttypeanalysis $whitespace$ typeanalysis $whitespace$ = $whitespace$ new $whitespace$ asttypeanalysis ( nodeclass ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ classname $whitespace$ = $whitespace$ metamodelgenerator . nodemetamodelname ( nodeclass ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ nodemetamodelfieldname $whitespace$ = $whitespace$ decapitalize ( classname ) ; $newline$ $indentation$ metamodelcoid . getfieldbyname ( nodemetamodelfieldname ) . ifpresent ( node : : remove ) ; $newline$ $indentation$ initializenodemetamodelsstatements . add ( parsestatement ( f ( $string$ , $whitespace$ nodemetamodelfieldname ) ) ) ; $newline$ $indentation$ this . initializeconstructorparametersstatementsgenerator . generate ( nodeclass , $whitespace$ initializeconstructorparametersstatements ) ; $newline$ $indentation$ final $whitespace$ class < ? > $whitespace$ superclass $whitespace$ = $whitespace$ nodeclass . getsuperclass ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ supernodemetamodel $whitespace$ = $whitespace$ metamodelgenerator . nodemetamodelname ( superclass ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isrootnode $whitespace$ = $whitespace$ ! metamodelgenerator . isnode ( superclass ) ; $newline$ $indentation$ final $whitespace$ fielddeclaration $whitespace$ nodefield $whitespace$ = $whitespace$ metamodelcoid . addfield ( classname , $whitespace$ nodemetamodelfieldname , $whitespace$ public , $whitespace$ static , $whitespace$ final ) ; $newline$ $indentation$ annotategenerated ( nodefield ) ; $newline$ $indentation$ nodefield . getvariable ( $number$ ) . setinitializer ( parseexpression ( f ( $string$ , $whitespace$ classname , $whitespace$ optionalof ( decapitalize ( supernodemetamodel ) , $whitespace$ ! isrootnode ) ) ) ) ; $newline$ $indentation$ $//·the·node-specific·metamodel·file$ $newline$ $indentation$ final $whitespace$ compilationunit $whitespace$ classmetamodeljavafile $whitespace$ = $whitespace$ new $whitespace$ compilationunit ( metamodelgenerator . metamodel_package ) ; $newline$ $indentation$ classmetamodeljavafile . setblockcomment ( copyright_notice_jp_core ) ; $newline$ $indentation$ classmetamodeljavafile . addimport ( optional . class ) ; $newline$ $indentation$ classmetamodeljavafile . addimport ( nodeclass ) ; $newline$ $indentation$ // $newline$ $indentation$ final $whitespace$ classorinterfacedeclaration $whitespace$ nodemetamodelclass $whitespace$ = $whitespace$ classmetamodeljavafile . addclass ( classname , $whitespace$ public ) ; $newline$ $indentation$ annotategenerated ( nodemetamodelclass ) ; $newline$ $indentation$ nodemetamodelclass . setjavadoccomment ( generated_class_comment ) ; $newline$ $indentation$ if $whitespace$ ( isrootnode ) $whitespace$ { $newline$ $indentation$ nodemetamodelclass . addextendedtype ( metamodelgenerator . base_node_meta_model ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ nodemetamodelclass . addextendedtype ( supernodemetamodel ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·constructors$ $newline$ $indentation$ final $whitespace$ constructordeclaration $whitespace$ classmmconstructor $whitespace$ = $whitespace$ nodemetamodelclass . addconstructor ( ) . addparameter ( f ( $string$ , $whitespace$ metamodelgenerator . base_node_meta_model ) , $whitespace$ f ( $string$ , $whitespace$ metamodelgenerator . base_node_meta_model ) ) ; $newline$ $indentation$ classmmconstructor . getbody ( ) . addstatement ( parseexplicitconstructorinvocationstmt ( f ( $string$ % s \ $string$ % s \ $string$ , $whitespace$ metamodelgenerator . base_node_meta_model , $whitespace$ nodeclass . getsimplename ( ) , $whitespace$ nodeclass . getsimplename ( ) , $whitespace$ nodeclass . getpackage ( ) . getname ( ) , $whitespace$ typeanalysis . isabstract , $whitespace$ typeanalysis . isselftype ) ) ) ; $newline$ $indentation$ annotategenerated ( classmmconstructor ) ; $newline$ $indentation$ $//·?abstract·protected·constructor?$ $newline$ $indentation$ if $whitespace$ ( typeanalysis . isabstract ) $whitespace$ { $newline$ $indentation$ classmetamodeljavafile . addimport ( node . class ) ; $newline$ $indentation$ bodydeclaration < ? > $whitespace$ bodydeclaration $whitespace$ = $whitespace$ parsebodydeclaration ( f ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ classname , $whitespace$ metamodelgenerator . base_node_meta_model ) ) ; $newline$ $indentation$ annotategenerated ( bodydeclaration ) ; $newline$ $indentation$ nodemetamodelclass . addmember ( bodydeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·fields,·sorted·by·name.$ $newline$ $indentation$ final $whitespace$ list < field > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( arrays . aslist ( nodeclass . getdeclaredfields ( ) ) ) ; $newline$ $indentation$ fields . sort ( comparator . comparing ( field : : getname ) ) ; $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ fields ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this . fieldshouldbeignored ( field ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ this . initializepropertymetamodelsstatementsgenerator . generate ( field , $whitespace$ nodemetamodelclass , $whitespace$ nodemetamodelfieldname , $whitespace$ initializepropertymetamodelsstatements ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·methods,·sorted·by·name.$ $newline$ $indentation$ final $whitespace$ list < method > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( arrays . aslist ( nodeclass . getmethods ( ) ) ) ; $newline$ $indentation$ methods . sort ( comparator . comparing ( method : : getname ) ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ methods ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method . isannotationpresent ( derivedproperty . class ) ) $whitespace$ { $newline$ $indentation$ this . initializepropertymetamodelsstatementsgenerator . generatederivedproperty ( method , $whitespace$ nodemetamodelclass , $whitespace$ nodemetamodelfieldname , $whitespace$ initializepropertymetamodelsstatements ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ this . movestaticinitializetotheendoftheclassbecauseweneedthefieldstoinitializefirst ( metamodelcoid ) ; $newline$ $indentation$ $//·add·the·file·to·the·source·root,·enabling·it·to·be·saved·later.$ $newline$ $indentation$ sourceroot . add ( metamodelgenerator . metamodel_package , $whitespace$ classname $whitespace$ + $whitespace$ $string$ , $whitespace$ classmetamodeljavafile ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ generate ( class <? $whitespace$ extends $whitespace$ node > $whitespace$ nodeclass, $whitespace$ classorinterfacedeclaration $whitespace$ metamodelcoid, $whitespace$ nodelist < statement > $whitespace$ initializenodemetamodelsstatements, $whitespace$ nodelist < statement > $whitespace$ initializepropertymetamodelsstatements, $whitespace$ nodelist < statement > $whitespace$ initializeconstructorparametersstatements, $whitespace$ sourceroot $whitespace$ sourceroot ) $whitespace$ throws $whitespace$ nosuchmethodexception { $newline$ $indentation$ final $whitespace$ string $whitespace$ classname $whitespace$ = $whitespace$ metamodelgenerator. nodemetamodelname ( nodeclass ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ nodemetamodelfieldname $whitespace$ = $whitespace$ decapitalize ( classname ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ nodemetamodelfieldname $whitespace$ = $whitespace$ decapitalize ( classname ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ supernodemetamodel $whitespace$ = $whitespace$ metamodelgenerator. nodemetamodelname ( superclass ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ supernodemetamodel $whitespace$ = $whitespace$ metamodelgenerator. nodemetamodelname ( superclass ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isrootnode $whitespace$ =			
readRange	151	166	javaparser/javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java	0.2332076281309127	LOW	"		protected boolean readRange(String name, JsonValue jsonValue, Node node){
		    if (name.equals(JsonNode.RANGE.propertyKey)) {
		        JsonObject jsonObject = (JsonObject) jsonValue;
		        Position begin = new Position(jsonObject.getInt(JsonRange.BEGIN_LINE.propertyKey), jsonObject.getInt(JsonRange.BEGIN_COLUMN.propertyKey));
		        Position end = new Position(jsonObject.getInt(JsonRange.END_LINE.propertyKey), jsonObject.getInt(JsonRange.END_COLUMN.propertyKey));
		        node.setRange(new Range(begin, end));
		        return true;
		    }
		    return false;
		}"	$indentation$ protected $whitespace$ boolean $whitespace$ readrange ( string $whitespace$ name , $whitespace$ jsonvalue $whitespace$ jsonvalue , $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( name . equals ( jsonnode . range . propertykey ) ) $whitespace$ { $newline$ $indentation$ jsonobject $whitespace$ jsonobject $whitespace$ = $whitespace$ ( jsonobject ) $whitespace$ jsonvalue ; $newline$ $indentation$ position $whitespace$ begin $whitespace$ = $whitespace$ new $whitespace$ position ( jsonobject . getint ( jsonrange . begin_line . propertykey ) , $whitespace$ jsonobject . getint ( jsonrange . begin_column . propertykey ) ) ; $newline$ $indentation$ position $whitespace$ end $whitespace$ = $whitespace$ new $whitespace$ position ( jsonobject . getint ( jsonrange . end_line . propertykey ) , $whitespace$ jsonobject . getint ( jsonrange . end_column . propertykey ) ) ; $newline$ $indentation$ node . setrange ( new $whitespace$ range ( begin , $whitespace$ end ) ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ boolean $whitespace$ readrange ( string $whitespace$ name, $whitespace$ jsonvalue $whitespace$ jsonvalue, $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( name. equals ( jsonnode. range. propertykey ) ) $whitespace$ { $newline$ $indentation$ jsonobject $whitespace$ jsonobject $whitespace$ = $whitespace$ ( jsonobject ) $whitespace$ jsonvalue ; $newline$ $indentation$ position $whitespace$ beginbound $whitespace$ = $whitespace$ new $whitespace$ position ( jsonobject. getint ( jsonrange. begin_line. propertykey ), $whitespace$ jsonobject. getint ( jsonrange. begin_column. propertykey ) ) ; $newline$ $indentation$ position $whitespace$ endbound $whitespace$ = $whitespace$ new $whitespace$ position ( jsonobject. getint ( jsonrange. end_line. propertykey ), $whitespace$ jsonobject. getint ( jsonrange. end_column. propertykey ) ) ; $newline$ $indentation$ node. setrange ( new $whitespace$ range ( begin, $whitespace$ end ) ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
deserializeObject	55	59	javaparser/javaparser-core-serialization/src/main/java/com/github/javaparser/serialization/JavaParserJsonDeserializer.java	0.7198895812034607	MID	"		public Node deserializeObject(JsonReader reader){
		    Log.info(""Deserializing JSON to Node."");
		    JsonObject jsonObject = reader.readObject();
		    return deserializeObject(jsonObject);
		}"	$indentation$ public $whitespace$ node $whitespace$ deserializeobject ( jsonreader $whitespace$ reader ) { $newline$ $indentation$ log . info ( $string$ ) ; $newline$ $indentation$ jsonobject $whitespace$ jsonobject $whitespace$ = $whitespace$ reader . readobject ( ) ; $newline$ $indentation$ return $whitespace$ deserializeobject ( jsonobject ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ node $whitespace$ deserializeobject ( jsonreader $whitespace$ reader ) { $newline$ $indentation$ log. info ( $string$ ) ; $newline$ $indentation$ jsonobject $whitespace$ jsonobject $whitespace$ = $whitespace$ reader. readobject ( ) ; $newline$ $indentation$ return $whitespace$ deserializeobject ( jsonobject ) ; $newline$ $indentation$ }			
attributeLineCommentsOnSameLine	140	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/CommentsInserter.java	0.048305969685316	LOW	"		private void attributeLineCommentsOnSameLine(TreeSet<Comment> commentsToAttribute, List<Node> children){
		    /* I can attribute in line comments to elements preceeding them, if
		         there is something contained in their line */
		    List<Comment> attributedComments = new LinkedList<>();
		    commentsToAttribute.stream().filter(comment -> comment.hasRange()).filter(Comment::isLineComment).forEach(comment -> children.stream().filter(child -> child.hasRange()).forEach(child -> {
		        Range commentRange = comment.getRange().get();
		        Range childRange = child.getRange().get();
		        if (childRange.end.line == commentRange.begin.line && attributeLineCommentToNodeOrChild(child, comment.asLineComment())) {
		            attributedComments.add(comment);
		        }
		    }));
		    commentsToAttribute.removeAll(attributedComments);
		}"	$indentation$ private $whitespace$ void $whitespace$ attributelinecommentsonsameline ( treeset < comment > $whitespace$ commentstoattribute , $whitespace$ list < node > $whitespace$ children ) { $newline$ $indentation$ $/*·i·can·attribute·in·line·comments·to·elements·preceeding·them,·if············there·is·something·contained·in·their·line·*/$ $newline$ $indentation$ list < comment > $whitespace$ attributedcomments $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ commentstoattribute . stream ( ) . filter ( comment $whitespace$ - > $whitespace$ comment . hasrange ( ) ) . filter ( comment : : islinecomment ) . foreach ( comment $whitespace$ - > $whitespace$ children . stream ( ) . filter ( child $whitespace$ - > $whitespace$ child . hasrange ( ) ) . foreach ( child $whitespace$ - > $whitespace$ { $newline$ $indentation$ range $whitespace$ commentrange $whitespace$ = $whitespace$ comment . getrange ( ) . get ( ) ; $newline$ $indentation$ range $whitespace$ childrange $whitespace$ = $whitespace$ child . getrange ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( childrange . end . line $whitespace$ == $whitespace$ commentrange . begin . line $whitespace$ && $whitespace$ attributelinecommenttonodeorchild ( child , $whitespace$ comment . aslinecomment ( ) ) ) $whitespace$ { $newline$ $indentation$ attributedcomments . add ( comment ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ) ; $newline$ $indentation$ commentstoattribute . removeall ( attributedcomments ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ attributelinecommentsonsameline ( treeset < comment > $whitespace$ commentstoattribute, $whitespace$ list < node > $whitespace$ children ) { $newline$ $indentation$ $/*ation$ for $whitespace$ ( comment $whitespace$ comment $whitespace$ : $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( comment. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ double $whitespace$ value $whitespace$ = $whitespace$ getvalue ( comment ) ; $newline$ $indentation$ range $whitespace$ commentrange $whitespace$ = $whitespace$ comment. getrange ( ). get ( ) ; $newline$ $indentation$ range $whitespace$ childrange $whitespace$ = $whitespace$ child. getrange ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ ( childrange. end. line $whitespace$ == $whitespace$ commentrange. begin. line $whitespace$ && $whitespace$ attributelinecommenttonodeorchild ( child, $whitespace$ comment. aslinecomment ( ) ) ) $whitespace$ { $newline$ $indentation$ attributedcomments. add ( comment ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ list < comment > $whitespace$ attributedcomments $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ commentstoattribute. stream ( ) $newline$ $indentation$. filter ( comment $whitespace$ - > $whitespace$ comment. hasrange ( ) ) $newline$ $indentation$. filter ( comment : : islinecomment ) $newline$ $indentation$. foreach ( comment $whitespace$ - > $whitespace$ children. stream ( ). filter ( child $whitespace$ - > $whitespace$ child. hasrange ( ) ) ) $newline$ $indentation$. foreach ( child $whitespace$ - > $whitespace$ { $newline$ $indentation$ range $whitespace			
thereAreLinesBetween	180	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/CommentsInserter.java	0.6806634664535522	MID	"		private boolean thereAreLinesBetween(Node a, Node b){
		    if (!a.hasRange() || !b.hasRange()) {
		        return true;
		    }
		    if (!PositionUtils.areInOrder(a, b)) {
		        return thereAreLinesBetween(b, a);
		    }
		    int endOfA = a.getEnd().get().line;
		    return b.getBegin().get().line > endOfA + 1;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ therearelinesbetween ( node $whitespace$ a , $whitespace$ node $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ ( ! a . hasrange ( ) $whitespace$ || $whitespace$ ! b . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! positionutils . areinorder ( a , $whitespace$ b ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ therearelinesbetween ( b , $whitespace$ a ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ endofa $whitespace$ = $whitespace$ a . getend ( ) . get ( ) . line ; $newline$ $indentation$ return $whitespace$ b . getbegin ( ) . get ( ) . line $whitespace$ > $whitespace$ endofa $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ therearelinesbetween ( node $whitespace$ a, $whitespace$ node $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ (! a. hasrange ( ) $whitespace$ || $whitespace$! b. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! positionutils. areinorder ( a, $whitespace$ b ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ therearelinesbetween ( b, $whitespace$ a ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ endofa $whitespace$ = $whitespace$ a. getend ( ). get ( ). line ; $newline$ $indentation$ return $whitespace$ b. getbegin ( ). get ( ). line $whitespace$ > $whitespace$ endofa $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ }			
handleResult	78	84	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaParserAdapter.java	0.6263253092765808	MID	"		private T handleResult(ParseResult<T> result){
		    if (result.isSuccessful()) {
		        return result.getResult().orElse(null);
		    }
		    throw new ParseProblemException(result.getProblems());
		}"	$indentation$ private $whitespace$ t $whitespace$ handleresult ( parseresult < t > $whitespace$ result ) { $newline$ $indentation$ if $whitespace$ ( result . issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ result . getresult ( ) . orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ parseproblemexception ( result . getproblems ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ t $whitespace$ handleresult ( parseresult < t > $whitespace$ result ) { $newline$ $indentation$ if $whitespace$ ( result. issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ result. getresult ( ). orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ parseproblemexception ( result. getproblems ( ) ) ; $newline$ $indentation$ }			
valueOf	418	725	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	6.896935106359692e-11	LOW	"		public static Kind valueOf(int kind){
		    switch(kind) {
		        case 150:
		            return CTRL_Z;
		        case 149:
		            return GT;
		        case 148:
		            return RSIGNEDSHIFT;
		        case 147:
		            return RUNSIGNEDSHIFT;
		        case 146:
		            return RUNSIGNEDSHIFTASSIGN;
		        case 145:
		            return RSIGNEDSHIFTASSIGN;
		        case 144:
		            return LSHIFTASSIGN;
		        case 143:
		            return REMASSIGN;
		        case 142:
		            return XORASSIGN;
		        case 141:
		            return ORASSIGN;
		        case 140:
		            return ANDASSIGN;
		        case 139:
		            return SLASHASSIGN;
		        case 138:
		            return STARASSIGN;
		        case 137:
		            return MINUSASSIGN;
		        case 136:
		            return PLUSASSIGN;
		        case 135:
		            return LSHIFT;
		        case 134:
		            return REM;
		        case 133:
		            return XOR;
		        case 132:
		            return BIT_OR;
		        case 131:
		            return BIT_AND;
		        case 130:
		            return SLASH;
		        case 129:
		            return STAR;
		        case 128:
		            return MINUS;
		        case 127:
		            return PLUS;
		        case 126:
		            return DECR;
		        case 125:
		            return INCR;
		        case 124:
		            return SC_OR;
		        case 123:
		            return SC_AND;
		        case 122:
		            return NE;
		        case 121:
		            return LE;
		        case 120:
		            return GE;
		        case 119:
		            return EQ;
		        case 118:
		            return ARROW;
		        case 117:
		            return COLON;
		        case 116:
		            return HOOK;
		        case 115:
		            return TILDE;
		        case 114:
		            return BANG;
		        case 113:
		            return LT;
		        case 112:
		            return ASSIGN;
		        case 111:
		            return DOUBLECOLON;
		        case 110:
		            return AT;
		        case 109:
		            return ELLIPSIS;
		        case 108:
		            return DOT;
		        case 107:
		            return COMMA;
		        case 106:
		            return SEMICOLON;
		        case 105:
		            return RBRACKET;
		        case 104:
		            return LBRACKET;
		        case 103:
		            return RBRACE;
		        case 102:
		            return LBRACE;
		        case 101:
		            return RPAREN;
		        case 100:
		            return LPAREN;
		        case 99:
		            return PART_LETTER;
		        case 98:
		            return LETTER;
		        case 97:
		            return IDENTIFIER;
		        case 96:
		            return TEXT_BLOCK_CONTENT;
		        case 95:
		            return TEXT_BLOCK_LITERAL;
		        case 94:
		            return ENTER_TEXT_BLOCK;
		        case 93:
		            return STRING_LITERAL;
		        case 92:
		            return CHARACTER_LITERAL;
		        case 91:
		            return UNICODE_ESCAPE;
		        case 90:
		            return HEX_DIGITS;
		        case 89:
		            return HEXADECIMAL_EXPONENT;
		        case 88:
		            return HEXADECIMAL_FLOATING_POINT_LITERAL;
		        case 87:
		            return DECIMAL_EXPONENT;
		        case 86:
		            return DECIMAL_FLOATING_POINT_LITERAL;
		        case 85:
		            return FLOATING_POINT_LITERAL;
		        case 84:
		            return BINARY_LITERAL;
		        case 83:
		            return OCTAL_LITERAL;
		        case 82:
		            return HEX_LITERAL;
		        case 81:
		            return DECIMAL_LITERAL;
		        case 80:
		            return INTEGER_LITERAL;
		        case 79:
		            return LONG_LITERAL;
		        case 78:
		            return TRANSITIVE;
		        case 77:
		            return PROVIDES;
		        case 76:
		            return EXPORTS;
		        case 75:
		            return MODULE;
		        case 74:
		            return USES;
		        case 73:
		            return OPENS;
		        case 72:
		            return OPEN;
		        case 71:
		            return WITH;
		        case 70:
		            return TO;
		        case 69:
		            return REQUIRES;
		        case 68:
		            return YIELD;
		        case 67:
		            return WHILE;
		        case 66:
		            return VOLATILE;
		        case 65:
		            return VOID;
		        case 64:
		            return TRY;
		        case 63:
		            return TRUE;
		        case 62:
		            return TRANSIENT;
		        case 61:
		            return THROWS;
		        case 60:
		            return THROW;
		        case 59:
		            return THIS;
		        case 58:
		            return SYNCHRONIZED;
		        case 57:
		            return SWITCH;
		        case 56:
		            return SUPER;
		        case 55:
		            return STRICTFP;
		        case 54:
		            return STATIC;
		        case 53:
		            return SHORT;
		        case 52:
		            return SEALED;
		        case 51:
		            return RETURN;
		        case 50:
		            return RECORD;
		        case 49:
		            return PUBLIC;
		        case 48:
		            return PROTECTED;
		        case 47:
		            return PRIVATE;
		        case 46:
		            return PERMITS;
		        case 45:
		            return PACKAGE;
		        case 44:
		            return NULL;
		        case 43:
		            return NON_SEALED;
		        case 42:
		            return NEW;
		        case 41:
		            return NATIVE;
		        case 40:
		            return LONG;
		        case 39:
		            return INTERFACE;
		        case 38:
		            return INT;
		        case 37:
		            return INSTANCEOF;
		        case 36:
		            return IMPORT;
		        case 35:
		            return IMPLEMENTS;
		        case 34:
		            return IF;
		        case 33:
		            return GOTO;
		        case 32:
		            return FOR;
		        case 31:
		            return FLOAT;
		        case 30:
		            return FINALLY;
		        case 29:
		            return FINAL;
		        case 28:
		            return FALSE;
		        case 27:
		            return EXTENDS;
		        case 26:
		            return ENUM;
		        case 25:
		            return ELSE;
		        case 24:
		            return DOUBLE;
		        case 23:
		            return DO;
		        case 22:
		            return _DEFAULT;
		        case 21:
		            return CONTINUE;
		        case 20:
		            return CONST;
		        case 19:
		            return CLASS;
		        case 18:
		            return CHAR;
		        case 17:
		            return CATCH;
		        case 16:
		            return CASE;
		        case 15:
		            return BYTE;
		        case 14:
		            return BREAK;
		        case 13:
		            return BOOLEAN;
		        case 12:
		            return ASSERT;
		        case 11:
		            return ABSTRACT;
		        case 10:
		            return COMMENT_CONTENT;
		        case 9:
		            return MULTI_LINE_COMMENT;
		        case 8:
		            return JAVADOC_COMMENT;
		        case 7:
		            return ENTER_MULTILINE_COMMENT;
		        case 6:
		            return ENTER_JAVADOC_COMMENT;
		        case 5:
		            return SINGLE_LINE_COMMENT;
		        case 4:
		            return OLD_MAC_EOL;
		        case 3:
		            return UNIX_EOL;
		        case 2:
		            return WINDOWS_EOL;
		        case 1:
		            return SPACE;
		        case 0:
		            return EOF;
		        default:
		            throw new IllegalArgumentException(f(""Token kind %i is unknown."", kind));
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ kind $whitespace$ valueof ( int $whitespace$ kind ) { $newline$ $indentation$ switch ( kind ) $whitespace$ { $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ ctrl_z ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ gt ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rsignedshift ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ runsignedshift ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ runsignedshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rsignedshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ remassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ xorassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ orassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ andassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ slashassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ starassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ minusassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ plusassign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lshift ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rem ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ xor ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ bit_or ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ bit_and ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ slash ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ star ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ minus ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ plus ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ decr ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ incr ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ sc_or ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ sc_and ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ ne ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ le ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ ge ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ eq ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ arrow ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ colon ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ hook ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ tilde ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ bang ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lt ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ assign ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ doublecolon ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ at ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ ellipsis ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ dot ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ comma ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ semicolon ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rbracket ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lbracket ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rbrace ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lbrace ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ rparen ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ lparen ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ part_letter ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ letter ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ identifier ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ text_block_content ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ text_block_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ enter_text_block ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ string_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ character_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ unicode_escape ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ hex_digits ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ hexadecimal_exponent ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ hexadecimal_floating_point_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ decimal_exponent ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ decimal_floating_point_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ floating_point_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ binary_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ octal_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ hex_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ decimal_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ integer_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ long_literal ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ transitive ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ provides ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ exports ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ module ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ uses ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ opens ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ open ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ with ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ to ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ requires ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ yield ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ while ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ volatile ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ void ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ try ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ transient ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ throws ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ throw ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ synchronized ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ switch ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ super ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ strictfp ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ static ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ short ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ sealed ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ return ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ record ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ public ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ protected ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ private ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ permits ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ package ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ non_sealed ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ new ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ native ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ long ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ interface ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ int ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ instanceof ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ import ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ implements ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ if ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ goto ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ for ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ float ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ finally ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ final ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ extends ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ enum ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ else ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ double ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ do ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ _default ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ const ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ class ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ char ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ catch ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ case ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ byte ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ break ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ boolean ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ assert ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ abstract ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ comment_content ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ multi_line_comment ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ javadoc_comment ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ enter_multiline_comment ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ enter_javadoc_comment ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ single_line_comment ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ old_mac_eol ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ unix_eol ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ windows_eol ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ space ; $newline$ $indentation$ case $whitespace$ $number$ : $newline$ $indentation$ return $whitespace$ eof ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( f ( $string$ , $whitespace$ kind ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ kind $whitespace$ valueof ( int $whitespace$ kind ) { $newline$ $indentation$ switch $whitespace$ ( kind ) $whitespace$ { $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ ctrl_z ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ gt ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ rsignedshift ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ runsignedshift ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ runsignedshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ initializesignedshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ initializesignedshiftassign ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$ $indentation$ case $whitespace$ $number$ $whitespace$ - > $whitespace$ new $whitespace$ string ( ) ; $newline$			
deleteToken	769	774	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.2494400739669799	LOW	"		public void deleteToken(){
		    final Optional<JavaToken> nextToken = getNextToken();
		    final Optional<JavaToken> previousToken = getPreviousToken();
		    previousToken.ifPresent(p -> p.nextToken = nextToken.orElse(null));
		    nextToken.ifPresent(n -> n.previousToken = previousToken.orElse(null));
		}"	$indentation$ public $whitespace$ void $whitespace$ deletetoken ( ) { $newline$ $indentation$ final $whitespace$ optional < javatoken > $whitespace$ nexttoken $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ final $whitespace$ optional < javatoken > $whitespace$ previoustoken $whitespace$ = $whitespace$ getprevioustoken ( ) ; $newline$ $indentation$ previoustoken . ifpresent ( p $whitespace$ - > $whitespace$ p . nexttoken $whitespace$ = $whitespace$ nexttoken . orelse ( null ) ) ; $newline$ $indentation$ nexttoken . ifpresent ( n $whitespace$ - > $whitespace$ n . previoustoken $whitespace$ = $whitespace$ previoustoken . orelse ( null ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ deletetoken ( ) { $newline$ $indentation$ final $whitespace$ optional < javatoken > $whitespace$ nexttoken $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ final $whitespace$ optional < javatoken > $whitespace$ previoustoken $whitespace$ = $whitespace$ getprevioustoken ( ) ; $newline$ $indentation$ previoustoken. ifpresent ( p $whitespace$ - > $whitespace$ p. nexttoken $whitespace$ = $whitespace$ nexttoken. orelse ( null ) ) ; $newline$ $indentation$ nexttoken. ifpresent ( n $whitespace$ - > $whitespace$ n. previoustoken $whitespace$ = $whitespace$ previoustoken. orelse ( null ) ) ; $newline$ $indentation$ }			
toString	185	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.2961175143718719	LOW	"		@Override
		public String toString(){
		    String text = getText().replace(""\n"", ""\\n"").replace(""\r"", ""\\r"").replace(""\r\n"", ""\\r\\n"").replace(""\t"", ""\\t"");
		    return f(""\""%s\""   <%s>   %s"", text, getKind(), getRange().map(Range::toString).orElse(""(?)-(?)""));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ string $whitespace$ text $whitespace$ = $whitespace$ gettext ( ) . replace ( $string$ , $whitespace$ $string$ ) . replace ( $string$ , $whitespace$ $string$ ) . replace ( $string$ , $whitespace$ $string$ ) . replace ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ f ( $string$ % s \ $string$ , $whitespace$ text , $whitespace$ getkind ( ) , $whitespace$ getrange ( ) . map ( range : : tostring ) . orelse ( $string$ ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ string $whitespace$ text $whitespace$ = $whitespace$ gettext ( ). replace ( $string$, $whitespace$ $string$ ). replace ( $string$, $whitespace$ $string$ ). replace ( $string$, $whitespace$ $string$ ). replace ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ f ( $string$ % s \ $string$, $whitespace$ text, $whitespace$ getkind ( ), $whitespace$ getrange ( ). map ( range : : tostring ). orelse ( $string$ ) ) ; $newline$ $indentation$ }			
insertAfter	756	764	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.6313633918762207	MID	"		public void insertAfter(JavaToken newToken){
		    assertNotNull(newToken);
		    getNextToken().ifPresent(n -> {
		        n.previousToken = newToken;
		        newToken.nextToken = n;
		    });
		    nextToken = newToken;
		    newToken.previousToken = this;
		}"	$indentation$ public $whitespace$ void $whitespace$ insertafter ( javatoken $whitespace$ newtoken ) { $newline$ $indentation$ assertnotnull ( newtoken ) ; $newline$ $indentation$ getnexttoken ( ) . ifpresent ( n $whitespace$ - > $whitespace$ { $newline$ $indentation$ n . previoustoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken . nexttoken $whitespace$ = $whitespace$ n ; $newline$ $indentation$ } ) ; $newline$ $indentation$ nexttoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken . previoustoken $whitespace$ = $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ insertafter ( javatoken $whitespace$ newtoken ) { $newline$ $indentation$ assertnotnull ( newtoken ) ; $newline$ $indentation$ assertnotoken ( newtoken ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ assertnotoken ( int $whitespace$ n ) $whitespace$ { $newline$ $indentation$ n. previoustoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken. nexttoken $whitespace$ = $whitespace$ n ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ asserttoken ( string $whitespace$ newtoken ) { $newline$ $indentation$ newtoken. previoustoken $whitespace$ = $whitespace$ this ; $newline$ $indentation$ }			
insert	743	751	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.6634330749511719	MID	"		public void insert(JavaToken newToken){
		    assertNotNull(newToken);
		    getPreviousToken().ifPresent(p -> {
		        p.nextToken = newToken;
		        newToken.previousToken = p;
		    });
		    previousToken = newToken;
		    newToken.nextToken = this;
		}"	$indentation$ public $whitespace$ void $whitespace$ insert ( javatoken $whitespace$ newtoken ) { $newline$ $indentation$ assertnotnull ( newtoken ) ; $newline$ $indentation$ getprevioustoken ( ) . ifpresent ( p $whitespace$ - > $whitespace$ { $newline$ $indentation$ p . nexttoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken . previoustoken $whitespace$ = $whitespace$ p ; $newline$ $indentation$ } ) ; $newline$ $indentation$ previoustoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken . nexttoken $whitespace$ = $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ insert ( javatoken $whitespace$ newtoken ) { $newline$ $indentation$ assertnotnull ( newtoken ) ; $newline$ $indentation$ assertnull ( newtoken ) ; $newline$ $indentation$ assertnull ( newtoken ) ; $newline$ $indentation$ assertnull ( newtoken ) ; $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ var $whitespace$ params $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ assertnull ( var. previoustoken $whitespace$ - > $whitespace$ { $newline$ $indentation$ newtoken. previoustoken $whitespace$ = $whitespace$ p ; $newline$ $indentation$ } ) ; $newline$ $indentation$ previoustoken $whitespace$ = $whitespace$ newtoken ; $newline$ $indentation$ newtoken. nexttoken $whitespace$ = $whitespace$ this ; $newline$ $indentation$ }			
equals	820	832	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.6773761510848999	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavaToken javaToken = (JavaToken) o;
		    if (kind != javaToken.kind)
		        return false;
		    if (!text.equals(javaToken.text))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javatoken $whitespace$ javatoken $whitespace$ = $whitespace$ ( javatoken ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( kind $whitespace$ != $whitespace$ javatoken . kind ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! text . equals ( javatoken . text ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo $whitespace$ && $whitespace$ this. equals ( ( todo ) $whitespace$ o ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( equals ( other ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$! text. equals ( this. text ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isempty ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( this $whitespace$ == $whitespace$ other. getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isempty ( ) ; $newline$ $indentation$ }			
hashCode	813	818	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavaToken.java	0.8790836334228516	HIGH	"		@Override
		public int hashCode(){
		    int result = kind;
		    result = 31 * result + text.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ kind ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ text . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ kind. tostring ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ text. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
cleanLines	91	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java	0.0625443756580352	LOW	"		private static List<String> cleanLines(String content){
		    String[] lines = content.split(SYSTEM_EOL);
		    if (lines.length == 0) {
		        return Collections.emptyList();
		    }
		    List<String> cleanedLines = Arrays.stream(lines).map(l -> {
		        int asteriskIndex = startsWithAsterisk(l);
		        if (asteriskIndex == -1) {
		            return l;
		        }
		        if (l.length() > (asteriskIndex + 1)) {
		            char c = l.charAt(asteriskIndex + 1);
		            if (c == ' ' || c == '\t') {
		                return l.substring(asteriskIndex + 2);
		            }
		        }
		        return l.substring(asteriskIndex + 1);
		    }).collect(Collectors.toList());
		    // lines containing only whitespace are normalized to empty lines
		    cleanedLines = cleanedLines.stream().map(l -> l.trim().isEmpty() ? """" : l).collect(Collectors.toList());
		    // if the first starts with a space, remove it
		    if (!cleanedLines.get(0).isEmpty() && (cleanedLines.get(0).charAt(0) == ' ' || cleanedLines.get(0).charAt(0) == '\t')) {
		        cleanedLines.set(0, cleanedLines.get(0).substring(1));
		    }
		    // drop empty lines at the beginning and at the end
		    while (cleanedLines.size() > 0 && cleanedLines.get(0).trim().isEmpty()) {
		        cleanedLines = cleanedLines.subList(1, cleanedLines.size());
		    }
		    while (cleanedLines.size() > 0 && cleanedLines.get(cleanedLines.size() - 1).trim().isEmpty()) {
		        cleanedLines = cleanedLines.subList(0, cleanedLines.size() - 1);
		    }
		    return cleanedLines;
		}"	$indentation$ private $whitespace$ static $whitespace$ list < string > $whitespace$ cleanlines ( string $whitespace$ content ) { $newline$ $indentation$ string [ ] $whitespace$ lines $whitespace$ = $whitespace$ content . split ( system_eol ) ; $newline$ $indentation$ if $whitespace$ ( lines . length $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < string > $whitespace$ cleanedlines $whitespace$ = $whitespace$ arrays . stream ( lines ) . map ( l $whitespace$ - > $whitespace$ { $newline$ $indentation$ int $whitespace$ asteriskindex $whitespace$ = $whitespace$ startswithasterisk ( l ) ; $newline$ $indentation$ if $whitespace$ ( asteriskindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ l ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( l . length ( ) $whitespace$ > $whitespace$ ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ char $whitespace$ c $whitespace$ = $whitespace$ l . charat ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ if $whitespace$ ( c $whitespace$ == $whitespace$ $string$ $whitespace$ || $whitespace$ c $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ l . substring ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ l . substring ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·lines·containing·only·whitespace·are·normalized·to·empty·lines$ $newline$ $indentation$ cleanedlines $whitespace$ = $whitespace$ cleanedlines . stream ( ) . map ( l $whitespace$ - > $whitespace$ l . trim ( ) . isempty ( ) $whitespace$ ? $whitespace$ $string$ $whitespace$ : $whitespace$ l ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·if·the·first·starts·with·a·space,·remove·it$ $newline$ $indentation$ if $whitespace$ ( ! cleanedlines . get ( $number$ ) . isempty ( ) $whitespace$ && $whitespace$ ( cleanedlines . get ( $number$ ) . charat ( $number$ ) $whitespace$ == $whitespace$ $string$ $whitespace$ || $whitespace$ cleanedlines . get ( $number$ ) . charat ( $number$ ) $whitespace$ == $whitespace$ $string$ ) ) $whitespace$ { $newline$ $indentation$ cleanedlines . set ( $number$ , $whitespace$ cleanedlines . get ( $number$ ) . substring ( $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·drop·empty·lines·at·the·beginning·and·at·the·end$ $newline$ $indentation$ while $whitespace$ ( cleanedlines . size ( ) $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ cleanedlines . get ( $number$ ) . trim ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ cleanedlines $whitespace$ = $whitespace$ cleanedlines . sublist ( $number$ , $whitespace$ cleanedlines . size ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ while $whitespace$ ( cleanedlines . size ( ) $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ cleanedlines . get ( cleanedlines . size ( ) $whitespace$ - $whitespace$ $number$ ) . trim ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ cleanedlines $whitespace$ = $whitespace$ cleanedlines . sublist ( $number$ , $whitespace$ cleanedlines . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ cleanedlines ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < string > $whitespace$ cleanlines ( string $whitespace$ content ) { $newline$ $indentation$ string [ ] $whitespace$ lines $whitespace$ = $whitespace$ content. split ( system_eol ) ; $newline$ $indentation$ return $whitespace$ lines. length $whitespace$ == $whitespace$ $number$ $whitespace$? $whitespace$ collections. emptylist ( ) $whitespace$ : $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ list < string > $whitespace$ cleanedlines $whitespace$ = $whitespace$ arrays. stream ( lines ). map ( l $whitespace$ - > $whitespace$ { $newline$ $indentation$ int $whitespace$ asteriskindex $whitespace$ = $whitespace$ startswithasterisk ( l ) ; $newline$ $indentation$ if $whitespace$ ( asteriskindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ l ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( l. length ( ) $whitespace$ > $whitespace$ ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ char $whitespace$ c $whitespace$ = $whitespace$ l. charat ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ if $whitespace$ ( c $whitespace$ == $whitespace$ $string$ $whitespace$ || $whitespace$ c $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ l. substring ( asteriskindex $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ l. substring ( asteriskindex $whitespace$ + $whitespace$ $number$			
parse	50	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java	0.0638066157698631	LOW	"		public static Javadoc parse(String commentContent){
		    List<String> cleanLines = cleanLines(normalizeEolInTextBlock(commentContent, SYSTEM_EOL));
		    int indexOfFirstBlockTag = cleanLines.stream().filter(JavadocParser::isABlockLine).map(cleanLines::indexOf).findFirst().orElse(-1);
		    List<String> blockLines;
		    String descriptionText;
		    if (indexOfFirstBlockTag == -1) {
		        descriptionText = trimRight(String.join(SYSTEM_EOL, cleanLines));
		        blockLines = Collections.emptyList();
		    } else {
		        descriptionText = trimRight(String.join(SYSTEM_EOL, cleanLines.subList(0, indexOfFirstBlockTag)));
		        // Combine cleaned lines, but only starting with the first block tag till the end
		        // In this combined string it is easier to handle multiple lines which actually belong together
		        String tagBlock = cleanLines.subList(indexOfFirstBlockTag, cleanLines.size()).stream().collect(Collectors.joining(SYSTEM_EOL));
		        // Split up the entire tag back again, considering now that some lines belong to the same block tag.
		        // The pattern splits the block at each new line starting with the '@' symbol, thus the symbol
		        // then needs to be added again so that the block parsers handles everything correctly.
		        blockLines = BLOCK_PATTERN.splitAsStream(tagBlock).filter(s1 -> !s1.isEmpty()).map(s -> BLOCK_TAG_PREFIX + s).collect(Collectors.toList());
		    }
		    Javadoc document = new Javadoc(JavadocDescription.parseText(descriptionText));
		    blockLines.forEach(l -> document.addBlockTag(parseBlockTag(l)));
		    return document;
		}"	$indentation$ public $whitespace$ static $whitespace$ javadoc $whitespace$ parse ( string $whitespace$ commentcontent ) { $newline$ $indentation$ list < string > $whitespace$ cleanlines $whitespace$ = $whitespace$ cleanlines ( normalizeeolintextblock ( commentcontent , $whitespace$ system_eol ) ) ; $newline$ $indentation$ int $whitespace$ indexoffirstblocktag $whitespace$ = $whitespace$ cleanlines . stream ( ) . filter ( javadocparser : : isablockline ) . map ( cleanlines : : indexof ) . findfirst ( ) . orelse ( $number$ ) ; $newline$ $indentation$ list < string > $whitespace$ blocklines ; $newline$ $indentation$ string $whitespace$ descriptiontext ; $newline$ $indentation$ if $whitespace$ ( indexoffirstblocktag $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ descriptiontext $whitespace$ = $whitespace$ trimright ( string . join ( system_eol , $whitespace$ cleanlines ) ) ; $newline$ $indentation$ blocklines $whitespace$ = $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ descriptiontext $whitespace$ = $whitespace$ trimright ( string . join ( system_eol , $whitespace$ cleanlines . sublist ( $number$ , $whitespace$ indexoffirstblocktag ) ) ) ; $newline$ $indentation$ $//·combine·cleaned·lines,·but·only·starting·with·the·first·block·tag·till·the·end$ $newline$ $indentation$ $//·in·this·combined·string·it·is·easier·to·handle·multiple·lines·which·actually·belong·together$ $newline$ $indentation$ string $whitespace$ tagblock $whitespace$ = $whitespace$ cleanlines . sublist ( indexoffirstblocktag , $whitespace$ cleanlines . size ( ) ) . stream ( ) . collect ( collectors . joining ( system_eol ) ) ; $newline$ $indentation$ $//·split·up·the·entire·tag·back·again,·considering·now·that·some·lines·belong·to·the·same·block·tag.$ $newline$ $indentation$ $//·the·pattern·splits·the·block·at·each·new·line·starting·with·the·'@'·symbol,·thus·the·symbol$ $newline$ $indentation$ $//·then·needs·to·be·added·again·so·that·the·block·parsers·handles·everything·correctly.$ $newline$ $indentation$ blocklines $whitespace$ = $whitespace$ block_pattern . splitasstream ( tagblock ) . filter ( s1 $whitespace$ - > $whitespace$ ! s1 . isempty ( ) ) . map ( s $whitespace$ - > $whitespace$ block_tag_prefix $whitespace$ + $whitespace$ s ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ javadoc $whitespace$ document $whitespace$ = $whitespace$ new $whitespace$ javadoc ( javadocdescription . parsetext ( descriptiontext ) ) ; $newline$ $indentation$ blocklines . foreach ( l $whitespace$ - > $whitespace$ document . addblocktag ( parseblocktag ( l ) ) ) ; $newline$ $indentation$ return $whitespace$ document ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ javadoc $whitespace$ parse ( string $whitespace$ commentcontent ) { $newline$ $indentation$ list < string > $whitespace$ cleanlines $whitespace$ = $whitespace$ cleanlines ( normalizeeolintextblock ( commentcontent, $whitespace$ system_eol ) ) ; $newline$ $indentation$ int $whitespace$ indexoffirstblocktag $whitespace$ = $whitespace$ cleanlines. stream ( ). filter ( javadocparser : : isablockline ). map ( cleanlines : : indexof ). findfirst ( ). orelse ( $number$ ) ; $newline$ $indentation$ list < string > $whitespace$ blocklines ; $newline$ $indentation$ string $whitespace$ descriptiontext ; $newline$ $indentation$ if $whitespace$ ( indexoffirstblocktag $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ descriptiontext $whitespace$ = $whitespace$ trimright ( string. join ( system_eol, $whitespace$ cleanlines ) ) ; $newline$ $indentation$ blocklines $whitespace$ = $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ descriptiontext $whitespace$ = $whitespace$ trimright ( string. join ( system_eol, $whitespace$ cleanlines. sublist ( $number$, $whitespace$ indexoffirstblocktag ) ) ) ; $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ trimright ( string. join ( system_eol, $whitespace$ cleanlines. sublist ( $number$, $whitespace$ indexoffirstblocktag ) ) ) ; $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ trimright ( string. join ( system_eol, $whitespace$ cleanlines. sublist ( $number$, $whitespace$ indexoffirstblocktag ) ) ) ; $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ trimright ( string. join ( system_			
parseBlockTag	73	78	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java	0.6234411597251892	MID	"		private static JavadocBlockTag parseBlockTag(String line){
		    line = line.trim().substring(1);
		    String tagName = nextWord(line);
		    String rest = line.substring(tagName.length()).trim();
		    return new JavadocBlockTag(tagName, rest);
		}"	$indentation$ private $whitespace$ static $whitespace$ javadocblocktag $whitespace$ parseblocktag ( string $whitespace$ line ) { $newline$ $indentation$ line $whitespace$ = $whitespace$ line . trim ( ) . substring ( $number$ ) ; $newline$ $indentation$ string $whitespace$ tagname $whitespace$ = $whitespace$ nextword ( line ) ; $newline$ $indentation$ string $whitespace$ rest $whitespace$ = $whitespace$ line . substring ( tagname . length ( ) ) . trim ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javadocblocktag ( tagname , $whitespace$ rest ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ javadocblocktag $whitespace$ parseblocktag ( string $whitespace$ line ) { $newline$ $indentation$ line $whitespace$ = $whitespace$ line. trim ( ). substring ( $number$ ) ; $newline$ $indentation$ string $whitespace$ tagname $whitespace$ = $whitespace$ nextword ( line ) ; $newline$ $indentation$ string $whitespace$ rest $whitespace$ = $whitespace$ line. substring ( tagname. length ( ) ). trim ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javadocblocktag ( tagname, $whitespace$ rest ) ; $newline$ $indentation$ }			
startsWithAsterisk	126	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java	0.6377550959587097	MID	"		 static int startsWithAsterisk(String line){
		    if (line.startsWith(""*"")) {
		        return 0;
		    }
		    if ((line.startsWith("" "") || line.startsWith(""\t"")) && line.length() > 1) {
		        int res = startsWithAsterisk(line.substring(1));
		        if (res == -1) {
		            return -1;
		        }
		        return 1 + res;
		    }
		    return -1;
		}"	$indentation$ static $whitespace$ int $whitespace$ startswithasterisk ( string $whitespace$ line ) { $newline$ $indentation$ if $whitespace$ ( line . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ( line . startswith ( $string$ ) $whitespace$ || $whitespace$ line . startswith ( $string$ ) ) $whitespace$ && $whitespace$ line . length ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ res $whitespace$ = $whitespace$ startswithasterisk ( line . substring ( $number$ ) ) ; $newline$ $indentation$ if $whitespace$ ( res $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ static $whitespace$ int $whitespace$ startswithasterisk ( string $whitespace$ line ) { $newline$ $indentation$ if $whitespace$ ( line. startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ( line. startswith ( $string$ ) $whitespace$ || $whitespace$ line. startswith ( $string$ ) ) $whitespace$ && $whitespace$ line. length ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ res $whitespace$ = $whitespace$ startswithasterisk ( line. substring ( $number$ ) ) ; $newline$ $indentation$ if $whitespace$ ( res $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }			
trimRight	84	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/JavadocParser.java	0.657027006149292	MID	"		private static String trimRight(String string){
		    while (!string.isEmpty() && Character.isWhitespace(string.charAt(string.length() - 1))) {
		        string = string.substring(0, string.length() - 1);
		    }
		    return string;
		}"	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ trimright ( string $whitespace$ string ) { $newline$ $indentation$ while $whitespace$ ( ! string . isempty ( ) $whitespace$ && $whitespace$ character . iswhitespace ( string . charat ( string . length ( ) $whitespace$ - $whitespace$ $number$ ) ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ = $whitespace$ string . substring ( $number$ , $whitespace$ string . length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ trimright ( string $whitespace$ string ) { $newline$ $indentation$ while $whitespace$ (! string. isempty ( ) $whitespace$ && $whitespace$ character. iswhitespace ( string. charat ( string. length ( ) $whitespace$ - $whitespace$ $number$ ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ string. substring ( $number$, $whitespace$ string. length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string ; $newline$ $indentation$ }			
createMessage	48	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/ParseProblemException.java	0.636466920375824	MID	"		private static String createMessage(List<Problem> problems){
		    StringBuilder message = new StringBuilder();
		    for (Problem problem : problems) {
		        message.append(problem.toString()).append(SYSTEM_EOL);
		    }
		    return message.toString();
		}"	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ createmessage ( list < problem > $whitespace$ problems ) { $newline$ $indentation$ stringbuilder $whitespace$ message $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( problem $whitespace$ problem $whitespace$ : $whitespace$ problems ) $whitespace$ { $newline$ $indentation$ message . append ( problem . tostring ( ) ) . append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ message . tostring ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ createmessage ( list < problem > $whitespace$ problems ) { $newline$ $indentation$ stringbuilder $whitespace$ message $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ while $whitespace$ ( problems $whitespace$ - > $whitespace$ $whitespace$ message. append ( problem. tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ message. append ( problem. tostring ( ) ). append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ message. tostring ( ) ; $newline$ $indentation$ }			
toString	98	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/ParseResult.java	0.6303023099899292	MID	"		@Override
		public String toString(){
		    if (isSuccessful()) {
		        return ""Parsing successful"";
		    }
		    StringBuilder message = new StringBuilder(""Parsing failed:"").append(SYSTEM_EOL);
		    for (Problem problem : problems) {
		        message.append(problem.toString()).append(SYSTEM_EOL);
		    }
		    return message.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ if $whitespace$ ( issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ message $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( $string$ ) . append ( system_eol ) ; $newline$ $indentation$ for $whitespace$ ( problem $whitespace$ problem $whitespace$ : $whitespace$ problems ) $whitespace$ { $newline$ $indentation$ message . append ( problem . tostring ( ) ) . append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ message . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ system. out. printf ( $string$, $whitespace$ board [ $number$ ]. length ) ; $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ message $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( $string$ ). append ( system_eol ) ; $newline$ $indentation$ for $whitespace$ ( problem $whitespace$ problem $whitespace$ : $whitespace$ problems ) $whitespace$ { $newline$ $indentation$ message. append ( problem. tostring ( ) ). append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ message. tostring ( ) ; $newline$ $indentation$ }			
ifSuccessful	64	68	javaparser/javaparser-core/src/main/java/com/github/javaparser/ParseResult.java	0.7267999053001404	MID	"		public void ifSuccessful(Consumer<T> consumer){
		    if (isSuccessful()) {
		        consumer.accept(result);
		    }
		}"	$indentation$ public $whitespace$ void $whitespace$ ifsuccessful ( consumer < t > $whitespace$ consumer ) { $newline$ $indentation$ if $whitespace$ ( issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ consumer . accept ( result ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ ifsuccessful ( consumer < t > $whitespace$ consumer ) { $newline$ $indentation$ if $whitespace$ ( issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ consumer. accept ( result ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
postProcess	249	259	javaparser/javaparser-core/src/main/java/com/github/javaparser/ParserConfiguration.java	0.2282624691724777	LOW	"		@Override
		public void postProcess(ParseResult<? extends Node> result, ParserConfiguration configuration){
		    if (isPreprocessUnicodeEscapes()) {
		        result.getResult().ifPresent(root -> {
		            PositionMapping mapping = _unicodeDecoder.getPositionMapping();
		            if (!mapping.isEmpty()) {
		                root.walk(node -> node.getRange().ifPresent(range -> node.setRange(mapping.transform(range))));
		            }
		        });
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ postprocess ( parseresult < ? $whitespace$ extends $whitespace$ node > $whitespace$ result , $whitespace$ parserconfiguration $whitespace$ configuration ) { $newline$ $indentation$ if $whitespace$ ( ispreprocessunicodeescapes ( ) ) $whitespace$ { $newline$ $indentation$ result . getresult ( ) . ifpresent ( root $whitespace$ - > $whitespace$ { $newline$ $indentation$ positionmapping $whitespace$ mapping $whitespace$ = $whitespace$ _unicodedecoder . getpositionmapping ( ) ; $newline$ $indentation$ if $whitespace$ ( ! mapping . isempty ( ) ) $whitespace$ { $newline$ $indentation$ root . walk ( node $whitespace$ - > $whitespace$ node . getrange ( ) . ifpresent ( range $whitespace$ - > $whitespace$ node . setrange ( mapping . transform ( range ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ postprocess ( parseresult <? $whitespace$ extends $whitespace$ node > $whitespace$ result, $whitespace$ parserconfiguration $whitespace$ configuration ) { $newline$ $indentation$ if $whitespace$ ( ispreprocessunicodeescapes ( ) $whitespace$ && $whitespace$! mapping. isempty ( ) ) $whitespace$ { $newline$ $indentation$ nodemapping $whitespace$ mapping $whitespace$ = $whitespace$ _unicodedecoder. getpositionmapping ( ) ; $newline$ $indentation$ if $whitespace$ (! mapping. isempty ( ) ) $whitespace$ { $newline$ $indentation$ root. walk ( node $whitespace$ - > $whitespace$ node. getrange ( ). ifpresent ( range $whitespace$ - > $whitespace$ node. setrange ( mapping. transform ( range ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }			
orIfInvalid	138	144	javaparser/javaparser-core/src/main/java/com/github/javaparser/Position.java	0.7150942087173462	MID	"		public Position orIfInvalid(Position alternativePosition){
		    assertNotNull(alternativePosition);
		    if (this.valid()) {
		        return this;
		    }
		    return alternativePosition.valid() ? alternativePosition : this;
		}"	$indentation$ public $whitespace$ position $whitespace$ orifinvalid ( position $whitespace$ alternativeposition ) { $newline$ $indentation$ assertnotnull ( alternativeposition ) ; $newline$ $indentation$ if $whitespace$ ( this . valid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ alternativeposition . valid ( ) $whitespace$ ? $whitespace$ alternativeposition $whitespace$ : $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ position $whitespace$ orifinvalid ( position $whitespace$ alternativeposition ) { $newline$ $indentation$ assertnotnull ( alternativeposition ) ; $newline$ $indentation$ return $whitespace$ this. valid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ test $newline$ $indentation$ public $whitespace$ void $whitespace$ no ( ) $whitespace$ { $newline$ $indentation$ assertnull ( alternativeposition ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ alternativeposition. valid ( ) $whitespace$? $whitespace$ alternativeposition $whitespace$ : $whitespace$ this ; $newline$ $indentation$ }			
compareTo	178	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/Position.java	0.733875572681427	MID	"		@Override
		public int compareTo(Position otherPosition){
		    assertNotNull(otherPosition);
		    if (isBefore(otherPosition)) {
		        return -1;
		    }
		    if (isAfter(otherPosition)) {
		        return 1;
		    }
		    return 0;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compareto ( position $whitespace$ otherposition ) { $newline$ $indentation$ assertnotnull ( otherposition ) ; $newline$ $indentation$ if $whitespace$ ( isbefore ( otherposition ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isafter ( otherposition ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compareto ( position $whitespace$ otherposition ) { $newline$ $indentation$ assertthat ( otherposition ). isequalto ( otherposition ) ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ int $whitespace$ compareto ( position $whitespace$ otherposition ) { $newline$ $indentation$ assertthat ( otherposition ). isequalto ( otherposition ) ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }			
provider	45	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/Providers.java	0.8743095397949219	HIGH	"		public static Provider provider(InputStream input, Charset encoding){
		    assertNotNull(input);
		    assertNotNull(encoding);
		    try {
		        return new StreamProvider(input, encoding.name());
		    } catch (IOException e) {
		        // The only one that is thrown is UnsupportedCharacterEncodingException,
		        // and that's a fundamental problem, so runtime exception.
		        throw new RuntimeException(e);
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ provider $whitespace$ provider ( inputstream $whitespace$ input , $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ assertnotnull ( input ) ; $newline$ $indentation$ assertnotnull ( encoding ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ streamprovider ( input , $whitespace$ encoding . name ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·the·only·one·that·is·thrown·is·unsupportedcharacterencodingexception,$ $newline$ $indentation$ $//·and·that's·a·fundamental·problem,·so·runtime·exception.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ provider $whitespace$ provider ( inputstream $whitespace$ input, $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ assertnotnull ( input ) ; $newline$ $indentation$ assertnotnull ( encoding ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ streamprovider ( input, $whitespace$ encoding. name ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ new $whitespace$ streamprovider ( input, $whitespace$ encoding. name ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
equals	228	236	javaparser/javaparser-core/src/main/java/com/github/javaparser/Range.java	0.7036843299865723	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    Range range = (Range) o;
		    return begin.equals(range.begin) && end.equals(range.end);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ range $whitespace$ range $whitespace$ = $whitespace$ ( range ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ begin . equals ( range . begin ) $whitespace$ && $whitespace$ end . equals ( range . end ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ range $whitespace$ range $whitespace$ = $whitespace$ ( range ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ begin. equals ( range. begin ) $whitespace$ && $whitespace$ end. equals ( range. end ) ; $newline$ $indentation$ }			
parse	92	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/StaticJavaParser.java	0.6635001301765442	MID	"		@Deprecated
		public static CompilationUnit parse(@NotNull final InputStream in, @NotNull Charset encoding){
		    Preconditions.checkNotNull(in, ""Parameter in can't be null."");
		    Preconditions.checkNotNull(encoding, ""Parameter encoding can't be null."");
		    return handleResult(newParser().parse(in, encoding));
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ static $whitespace$ compilationunit $whitespace$ parse ( @ notnull $whitespace$ final $whitespace$ inputstream $whitespace$ in , $whitespace$ @ notnull $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ preconditions . checknotnull ( in , $whitespace$ $string$ ) ; $newline$ $indentation$ preconditions . checknotnull ( encoding , $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ handleresult ( newparser ( ) . parse ( in , $whitespace$ encoding ) ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ static $whitespace$ compilationunit $whitespace$ parse ( @ notnull $whitespace$ final $whitespace$ inputstream $whitespace$ in, $whitespace$ @ notnull $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ preconditions. checknotnull ( in, $whitespace$ $string$ ) ; $newline$ $indentation$ preconditions. checknotnull ( encoding, $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ handleresult ( newparser ( ). parse ( in, $whitespace$ encoding ) ) ; $newline$ $indentation$ }			
handleResult	543	549	javaparser/javaparser-core/src/main/java/com/github/javaparser/StaticJavaParser.java	0.668307363986969	MID	"		@Deprecated
		private static T handleResult(ParseResult<T> result){
		    if (result.isSuccessful()) {
		        return result.getResult().get();
		    }
		    throw new ParseProblemException(result.getProblems());
		}"	$indentation$ @ deprecated $newline$ $indentation$ private $whitespace$ static $whitespace$ t $whitespace$ handleresult ( parseresult < t > $whitespace$ result ) { $newline$ $indentation$ if $whitespace$ ( result . issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ result . getresult ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ parseproblemexception ( result . getproblems ( ) ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ private $whitespace$ static $whitespace$ t $whitespace$ handleresult ( parseresult < t > $whitespace$ result ) { $newline$ $indentation$ if $whitespace$ (! result. issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ parseproblemexception ( result. getproblems ( ) ) ; $newline$ $indentation$ }			
iterator	76	105	javaparser/javaparser-core/src/main/java/com/github/javaparser/TokenRange.java	0.6714329322179159	MID	"		@Override
		public Iterator<JavaToken> iterator(){
		    return new Iterator<JavaToken>() {
		
		        private boolean hasNext = true;
		
		        private JavaToken current = begin;
		
		        @Override
		        public boolean hasNext() {
		            return hasNext;
		        }
		
		        @Override
		        public JavaToken next() {
		            JavaToken retval = current;
		            if (current == null) {
		                throw new IllegalStateException(""Attempting to move past end of range."");
		            }
		            if (current == end) {
		                hasNext = false;
		            }
		            current = current.getNextToken().orElse(null);
		            if (current == null && hasNext) {
		                throw new IllegalStateException(""End token is not linked to begin token."");
		            }
		            return retval;
		        }
		    };
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < javatoken > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < javatoken > ( ) $whitespace$ { $newline$ $indentation$ private $whitespace$ boolean $whitespace$ hasnext $whitespace$ = $whitespace$ true ; $newline$ $indentation$ private $whitespace$ javatoken $whitespace$ current $whitespace$ = $whitespace$ begin ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ hasnext ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ javatoken $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ retval $whitespace$ = $whitespace$ current ; $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ end ) $whitespace$ { $newline$ $indentation$ hasnext $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ current $whitespace$ = $whitespace$ current . getnexttoken ( ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ null $whitespace$ && $whitespace$ hasnext ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ retval ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < javatoken > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < javatoken > ( ) $whitespace$ { $newline$ $indentation$ private $whitespace$ boolean $whitespace$ hasnext $whitespace$ = $whitespace$ true ; $newline$ $indentation$ private $whitespace$ javatoken $whitespace$ current $whitespace$ = $whitespace$ begin ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ hasnext ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ javatoken $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ retval $whitespace$ = $whitespace$ current ; $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ end ) $whitespace$ { $newline$ $indentation$ hasnext $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ current $whitespace$ = $whitespace$ current. getnexttoken ( ). orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( current $whitespace$ == $whitespace$ null $whitespace$ && $whitespace$ hasnext ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ retval ; $newline$ $indentation$ }			
getCategory	97	262	javaparser/javaparser-core/src/main/java/com/github/javaparser/TokenTypes.java	0.6071355938911438	MID	"		public static JavaToken.Category getCategory(int kind){
		    switch(kind) {
		        case WINDOWS_EOL:
		        case UNIX_EOL:
		        case OLD_MAC_EOL:
		            return JavaToken.Category.EOL;
		        case EOF:
		        case SPACE:
		        case CTRL_Z:
		            return JavaToken.Category.WHITESPACE_NO_EOL;
		        case SINGLE_LINE_COMMENT:
		        case JAVADOC_COMMENT:
		        case MULTI_LINE_COMMENT:
		            return JavaToken.Category.COMMENT;
		        case ABSTRACT:
		        case ASSERT:
		        case BOOLEAN:
		        case BREAK:
		        case BYTE:
		        case CASE:
		        case CATCH:
		        case CHAR:
		        case CLASS:
		        case CONST:
		        case CONTINUE:
		        case _DEFAULT:
		        case DO:
		        case DOUBLE:
		        case ELSE:
		        case ENUM:
		        case EXTENDS:
		        case FINAL:
		        case FINALLY:
		        case FLOAT:
		        case FOR:
		        case GOTO:
		        case IF:
		        case IMPLEMENTS:
		        case IMPORT:
		        case INSTANCEOF:
		        case INT:
		        case INTERFACE:
		        case LONG:
		        case NATIVE:
		        case NEW:
		        case PACKAGE:
		        case PRIVATE:
		        case PROTECTED:
		        case PUBLIC:
		        case RECORD:
		        case RETURN:
		        case SHORT:
		        case STATIC:
		        case STRICTFP:
		        case SUPER:
		        case SWITCH:
		        case SYNCHRONIZED:
		        case THIS:
		        case THROW:
		        case THROWS:
		        case TRANSIENT:
		        case TRY:
		        case VOID:
		        case VOLATILE:
		        case WHILE:
		        case YIELD:
		        case REQUIRES:
		        case TO:
		        case WITH:
		        case OPEN:
		        case OPENS:
		        case USES:
		        case MODULE:
		        case EXPORTS:
		        case PROVIDES:
		        case TRANSITIVE:
		        case PERMITS:
		        case SEALED:
		        case NON_SEALED:
		            return JavaToken.Category.KEYWORD;
		        case LONG_LITERAL:
		        case INTEGER_LITERAL:
		        case DECIMAL_LITERAL:
		        case HEX_LITERAL:
		        case OCTAL_LITERAL:
		        case BINARY_LITERAL:
		        case FLOATING_POINT_LITERAL:
		        case DECIMAL_FLOATING_POINT_LITERAL:
		        case DECIMAL_EXPONENT:
		        case HEXADECIMAL_FLOATING_POINT_LITERAL:
		        case HEXADECIMAL_EXPONENT:
		        case CHARACTER_LITERAL:
		        case STRING_LITERAL:
		        case TEXT_BLOCK_LITERAL:
		        case TRUE:
		        case FALSE:
		        case NULL:
		            return JavaToken.Category.LITERAL;
		        case IDENTIFIER:
		            return JavaToken.Category.IDENTIFIER;
		        case LPAREN:
		        case RPAREN:
		        case LBRACE:
		        case RBRACE:
		        case LBRACKET:
		        case RBRACKET:
		        case SEMICOLON:
		        case COMMA:
		        case DOT:
		        case ELLIPSIS:
		        case AT:
		        case DOUBLECOLON:
		            return JavaToken.Category.SEPARATOR;
		        case ASSIGN:
		        case LT:
		        case BANG:
		        case TILDE:
		        case HOOK:
		        case COLON:
		        case EQ:
		        case LE:
		        case GE:
		        case NE:
		        case SC_OR:
		        case SC_AND:
		        case INCR:
		        case DECR:
		        case PLUS:
		        case MINUS:
		        case STAR:
		        case SLASH:
		        case BIT_AND:
		        case BIT_OR:
		        case XOR:
		        case REM:
		        case LSHIFT:
		        case PLUSASSIGN:
		        case MINUSASSIGN:
		        case STARASSIGN:
		        case SLASHASSIGN:
		        case ANDASSIGN:
		        case ORASSIGN:
		        case XORASSIGN:
		        case REMASSIGN:
		        case LSHIFTASSIGN:
		        case RSIGNEDSHIFTASSIGN:
		        case RUNSIGNEDSHIFTASSIGN:
		        case ARROW:
		        case RUNSIGNEDSHIFT:
		        case RSIGNEDSHIFT:
		        case GT:
		            return JavaToken.Category.OPERATOR;
		        // The following are tokens that are only used internally by the lexer
		        case ENTER_JAVADOC_COMMENT:
		        case ENTER_MULTILINE_COMMENT:
		        case COMMENT_CONTENT:
		        case HEX_DIGITS:
		        case LETTER:
		        case UNICODE_ESCAPE:
		        case PART_LETTER:
		        case TEXT_BLOCK_CONTENT:
		        case ENTER_TEXT_BLOCK:
		        default:
		            throw new AssertionError(""Unable to categorise token kind "" + kind + "" -- has it recently been added to the grammar but not classified within TokenTypes.java, perhaps?"");
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ javatoken . category $whitespace$ getcategory ( int $whitespace$ kind ) { $newline$ $indentation$ switch ( kind ) $whitespace$ { $newline$ $indentation$ case $whitespace$ windows_eol : $newline$ $indentation$ case $whitespace$ unix_eol : $newline$ $indentation$ case $whitespace$ old_mac_eol : $newline$ $indentation$ return $whitespace$ javatoken . category . eol ; $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ case $whitespace$ space : $newline$ $indentation$ case $whitespace$ ctrl_z : $newline$ $indentation$ return $whitespace$ javatoken . category . whitespace_no_eol ; $newline$ $indentation$ case $whitespace$ single_line_comment : $newline$ $indentation$ case $whitespace$ javadoc_comment : $newline$ $indentation$ case $whitespace$ multi_line_comment : $newline$ $indentation$ return $whitespace$ javatoken . category . comment ; $newline$ $indentation$ case $whitespace$ abstract : $newline$ $indentation$ case $whitespace$ assert : $newline$ $indentation$ case $whitespace$ boolean : $newline$ $indentation$ case $whitespace$ break : $newline$ $indentation$ case $whitespace$ byte : $newline$ $indentation$ case $whitespace$ case : $newline$ $indentation$ case $whitespace$ catch : $newline$ $indentation$ case $whitespace$ char : $newline$ $indentation$ case $whitespace$ class : $newline$ $indentation$ case $whitespace$ const : $newline$ $indentation$ case $whitespace$ continue : $newline$ $indentation$ case $whitespace$ _default : $newline$ $indentation$ case $whitespace$ do : $newline$ $indentation$ case $whitespace$ double : $newline$ $indentation$ case $whitespace$ else : $newline$ $indentation$ case $whitespace$ enum : $newline$ $indentation$ case $whitespace$ extends : $newline$ $indentation$ case $whitespace$ final : $newline$ $indentation$ case $whitespace$ finally : $newline$ $indentation$ case $whitespace$ float : $newline$ $indentation$ case $whitespace$ for : $newline$ $indentation$ case $whitespace$ goto : $newline$ $indentation$ case $whitespace$ if : $newline$ $indentation$ case $whitespace$ implements : $newline$ $indentation$ case $whitespace$ import : $newline$ $indentation$ case $whitespace$ instanceof : $newline$ $indentation$ case $whitespace$ int : $newline$ $indentation$ case $whitespace$ interface : $newline$ $indentation$ case $whitespace$ long : $newline$ $indentation$ case $whitespace$ native : $newline$ $indentation$ case $whitespace$ new : $newline$ $indentation$ case $whitespace$ package : $newline$ $indentation$ case $whitespace$ private : $newline$ $indentation$ case $whitespace$ protected : $newline$ $indentation$ case $whitespace$ public : $newline$ $indentation$ case $whitespace$ record : $newline$ $indentation$ case $whitespace$ return : $newline$ $indentation$ case $whitespace$ short : $newline$ $indentation$ case $whitespace$ static : $newline$ $indentation$ case $whitespace$ strictfp : $newline$ $indentation$ case $whitespace$ super : $newline$ $indentation$ case $whitespace$ switch : $newline$ $indentation$ case $whitespace$ synchronized : $newline$ $indentation$ case $whitespace$ this : $newline$ $indentation$ case $whitespace$ throw : $newline$ $indentation$ case $whitespace$ throws : $newline$ $indentation$ case $whitespace$ transient : $newline$ $indentation$ case $whitespace$ try : $newline$ $indentation$ case $whitespace$ void : $newline$ $indentation$ case $whitespace$ volatile : $newline$ $indentation$ case $whitespace$ while : $newline$ $indentation$ case $whitespace$ yield : $newline$ $indentation$ case $whitespace$ requires : $newline$ $indentation$ case $whitespace$ to : $newline$ $indentation$ case $whitespace$ with : $newline$ $indentation$ case $whitespace$ open : $newline$ $indentation$ case $whitespace$ opens : $newline$ $indentation$ case $whitespace$ uses : $newline$ $indentation$ case $whitespace$ module : $newline$ $indentation$ case $whitespace$ exports : $newline$ $indentation$ case $whitespace$ provides : $newline$ $indentation$ case $whitespace$ transitive : $newline$ $indentation$ case $whitespace$ permits : $newline$ $indentation$ case $whitespace$ sealed : $newline$ $indentation$ case $whitespace$ non_sealed : $newline$ $indentation$ return $whitespace$ javatoken . category . keyword ; $newline$ $indentation$ case $whitespace$ long_literal : $newline$ $indentation$ case $whitespace$ integer_literal : $newline$ $indentation$ case $whitespace$ decimal_literal : $newline$ $indentation$ case $whitespace$ hex_literal : $newline$ $indentation$ case $whitespace$ octal_literal : $newline$ $indentation$ case $whitespace$ binary_literal : $newline$ $indentation$ case $whitespace$ floating_point_literal : $newline$ $indentation$ case $whitespace$ decimal_floating_point_literal : $newline$ $indentation$ case $whitespace$ decimal_exponent : $newline$ $indentation$ case $whitespace$ hexadecimal_floating_point_literal : $newline$ $indentation$ case $whitespace$ hexadecimal_exponent : $newline$ $indentation$ case $whitespace$ character_literal : $newline$ $indentation$ case $whitespace$ string_literal : $newline$ $indentation$ case $whitespace$ text_block_literal : $newline$ $indentation$ case $whitespace$ true : $newline$ $indentation$ case $whitespace$ false : $newline$ $indentation$ case $whitespace$ null : $newline$ $indentation$ return $whitespace$ javatoken . category . literal ; $newline$ $indentation$ case $whitespace$ identifier : $newline$ $indentation$ return $whitespace$ javatoken . category . identifier ; $newline$ $indentation$ case $whitespace$ lparen : $newline$ $indentation$ case $whitespace$ rparen : $newline$ $indentation$ case $whitespace$ lbrace : $newline$ $indentation$ case $whitespace$ rbrace : $newline$ $indentation$ case $whitespace$ lbracket : $newline$ $indentation$ case $whitespace$ rbracket : $newline$ $indentation$ case $whitespace$ semicolon : $newline$ $indentation$ case $whitespace$ comma : $newline$ $indentation$ case $whitespace$ dot : $newline$ $indentation$ case $whitespace$ ellipsis : $newline$ $indentation$ case $whitespace$ at : $newline$ $indentation$ case $whitespace$ doublecolon : $newline$ $indentation$ return $whitespace$ javatoken . category . separator ; $newline$ $indentation$ case $whitespace$ assign : $newline$ $indentation$ case $whitespace$ lt : $newline$ $indentation$ case $whitespace$ bang : $newline$ $indentation$ case $whitespace$ tilde : $newline$ $indentation$ case $whitespace$ hook : $newline$ $indentation$ case $whitespace$ colon : $newline$ $indentation$ case $whitespace$ eq : $newline$ $indentation$ case $whitespace$ le : $newline$ $indentation$ case $whitespace$ ge : $newline$ $indentation$ case $whitespace$ ne : $newline$ $indentation$ case $whitespace$ sc_or : $newline$ $indentation$ case $whitespace$ sc_and : $newline$ $indentation$ case $whitespace$ incr : $newline$ $indentation$ case $whitespace$ decr : $newline$ $indentation$ case $whitespace$ plus : $newline$ $indentation$ case $whitespace$ minus : $newline$ $indentation$ case $whitespace$ star : $newline$ $indentation$ case $whitespace$ slash : $newline$ $indentation$ case $whitespace$ bit_and : $newline$ $indentation$ case $whitespace$ bit_or : $newline$ $indentation$ case $whitespace$ xor : $newline$ $indentation$ case $whitespace$ rem : $newline$ $indentation$ case $whitespace$ lshift : $newline$ $indentation$ case $whitespace$ plusassign : $newline$ $indentation$ case $whitespace$ minusassign : $newline$ $indentation$ case $whitespace$ starassign : $newline$ $indentation$ case $whitespace$ slashassign : $newline$ $indentation$ case $whitespace$ andassign : $newline$ $indentation$ case $whitespace$ orassign : $newline$ $indentation$ case $whitespace$ xorassign : $newline$ $indentation$ case $whitespace$ remassign : $newline$ $indentation$ case $whitespace$ lshiftassign : $newline$ $indentation$ case $whitespace$ rsignedshiftassign : $newline$ $indentation$ case $whitespace$ runsignedshiftassign : $newline$ $indentation$ case $whitespace$ arrow : $newline$ $indentation$ case $whitespace$ runsignedshift : $newline$ $indentation$ case $whitespace$ rsignedshift : $newline$ $indentation$ case $whitespace$ gt : $newline$ $indentation$ return $whitespace$ javatoken . category . operator ; $newline$ $indentation$ $//·the·following·are·tokens·that·are·only·used·internally·by·the·lexer$ $newline$ $indentation$ case $whitespace$ enter_javadoc_comment : $newline$ $indentation$ case $whitespace$ enter_multiline_comment : $newline$ $indentation$ case $whitespace$ comment_content : $newline$ $indentation$ case $whitespace$ hex_digits : $newline$ $indentation$ case $whitespace$ letter : $newline$ $indentation$ case $whitespace$ unicode_escape : $newline$ $indentation$ case $whitespace$ part_letter : $newline$ $indentation$ case $whitespace$ text_block_content : $newline$ $indentation$ case $whitespace$ enter_text_block : $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ $whitespace$ + $whitespace$ kind $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ javatoken. category $whitespace$ getcategory ( int $whitespace$ kind ) { $newline$ $indentation$ switch ( kind ) $whitespace$ { $newline$ $indentation$ case $whitespace$ windows_eol : $newline$ $indentation$ case $whitespace$ unix_eol : $newline$ $indentation$ case $whitespace$ old_mac_eol : $newline$ $indentation$ return $whitespace$ javatoken. category. eol ; $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ case $whitespace$ space : $newline$ $indentation$ case $whitespace$ ctrl_z : $newline$ $indentation$ return $whitespace$ javatoken. category. whitespace_no_eol ; $newline$ $indentation$ case $whitespace$ single_line_comment : $newline$ $indentation$ case $whitespace$ javadoc_comment : $newline$ $indentation$ case $whitespace$ multi_line_comment : $newline$ $indentation$ return $whitespace$ javatoken. category. comment ; $newline$ $indentation$ case $whitespace$ abstract : $newline$ $indentation$ case $whitespace$ assert : $newline$ $indentation$ case $whitespace$ break : $newline$ $indentation$ case $whitespace$ byte : $newline$ $indentation$ case $whitespace$ case : $newline$ $indentation$ case $whitespace$ case : $newline$ $indentation$ case $whitespace$ annotation : $newline$ $indentation$ case $whitespace$ j : $newline$ $indentation$ case $whitespace$ _default : $newline$ $indentation$ case $whitespace$ do : $newline$ $indentation$ case $whitespace$ double : $newline$ $indentation$ case $whitespace$ else : $newline$ $indentation$			
readDigits	188	224	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.0802137702703476	LOW	"		private int readDigits(int uCnt, int next3) throws IOException{
		    int digit3 = digit(next3);
		    if (digit3 < 0) {
		        pushBack(next3);
		        pushBackUs(uCnt);
		        return BACKSLASH;
		    }
		    int next2 = nextInputChar();
		    int digit2 = digit(next2);
		    if (digit2 < 0) {
		        pushBack(next2);
		        pushBack(next3);
		        pushBackUs(uCnt);
		        return BACKSLASH;
		    }
		    int next1 = nextInputChar();
		    int digit1 = digit(next1);
		    if (digit1 < 0) {
		        pushBack(next1);
		        pushBack(next2);
		        pushBack(next3);
		        pushBackUs(uCnt);
		        return BACKSLASH;
		    }
		    int next0 = nextInputChar();
		    int digit0 = digit(next0);
		    if (digit0 < 0) {
		        pushBack(next0);
		        pushBack(next1);
		        pushBack(next2);
		        pushBack(next3);
		        pushBackUs(uCnt);
		        return BACKSLASH;
		    }
		    int ch = digit3 << 12 | digit2 << 8 | digit1 << 4 | digit0;
		    return clearBackSlashSeen(ch);
		}"	$indentation$ private $whitespace$ int $whitespace$ readdigits ( int $whitespace$ ucnt , $whitespace$ int $whitespace$ next3 ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ digit3 $whitespace$ = $whitespace$ digit ( next3 ) ; $newline$ $indentation$ if $whitespace$ ( digit3 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ next2 $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ int $whitespace$ digit2 $whitespace$ = $whitespace$ digit ( next2 ) ; $newline$ $indentation$ if $whitespace$ ( digit2 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next2 ) ; $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ next1 $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ int $whitespace$ digit1 $whitespace$ = $whitespace$ digit ( next1 ) ; $newline$ $indentation$ if $whitespace$ ( digit1 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next1 ) ; $newline$ $indentation$ pushback ( next2 ) ; $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ next0 $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ int $whitespace$ digit0 $whitespace$ = $whitespace$ digit ( next0 ) ; $newline$ $indentation$ if $whitespace$ ( digit0 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next0 ) ; $newline$ $indentation$ pushback ( next1 ) ; $newline$ $indentation$ pushback ( next2 ) ; $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ ch $whitespace$ = $whitespace$ digit3 $whitespace$ << $whitespace$ $number$ $whitespace$ | $whitespace$ digit2 $whitespace$ << $whitespace$ $number$ $whitespace$ | $whitespace$ digit1 $whitespace$ << $whitespace$ $number$ $whitespace$ | $whitespace$ digit0 ; $newline$ $indentation$ return $whitespace$ clearbackslashseen ( ch ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ readdigits ( int $whitespace$ ucnt, $whitespace$ int $whitespace$ next3 ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ digit3 $whitespace$ = $whitespace$ digit ( next3 ) ; $newline$ $indentation$ if $whitespace$ ( digit3 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ next2 $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ int $whitespace$ digit2 $whitespace$ = $whitespace$ digit ( next2 ) ; $newline$ $indentation$ if $whitespace$ ( digit2 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next2 ) ; $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ next1 $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ int $whitespace$ digit1 $whitespace$ = $whitespace$ digit ( next1 ) ; $newline$ $indentation$ if $whitespace$ ( digit1 $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ pushback ( next1 ) ; $newline$ $indentation$ pushback ( next2 ) ; $newline$ $indentation$ pushback ( next3 ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ int $whitespace$ next1 $			
transform	397	403	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.6735174059867859	MID	"		 Position transform(Position pos){
		    int line = pos.line;
		    int column = pos.column;
		    int transformedLine = transformLine(line);
		    int transformedColumn = transformColumn(column);
		    return new Position(transformedLine, transformedColumn);
		}"	$indentation$ position $whitespace$ transform ( position $whitespace$ pos ) { $newline$ $indentation$ int $whitespace$ line $whitespace$ = $whitespace$ pos . line ; $newline$ $indentation$ int $whitespace$ column $whitespace$ = $whitespace$ pos . column ; $newline$ $indentation$ int $whitespace$ transformedline $whitespace$ = $whitespace$ transformline ( line ) ; $newline$ $indentation$ int $whitespace$ transformedcolumn $whitespace$ = $whitespace$ transformcolumn ( column ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ position ( transformedline , $whitespace$ transformedcolumn ) ; $newline$ $indentation$ }	$indentation$ position $whitespace$ transform ( position $whitespace$ pos ) { $newline$ $indentation$ int $whitespace$ line $whitespace$ = $whitespace$ pos. line ; $newline$ $indentation$ int $whitespace$ column $whitespace$ = $whitespace$ pos. column ; $newline$ $indentation$ int $whitespace$ transformedline $whitespace$ = $whitespace$ transformline ( line ) ; $newline$ $indentation$ int $whitespace$ transformedcolumn $whitespace$ = $whitespace$ transformcolumn ( column ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ position ( transformedline, $whitespace$ transformedcolumn ) ; $newline$ $indentation$ }			
lookup	344	355	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.7117566466331482	MID	"		public PositionUpdate lookup(Position position){
		    int result = Collections.binarySearch(_deltas, position);
		    if (result >= 0) {
		        return _deltas.get(result);
		    }
		    int insertIndex = -result - 1;
		    if (insertIndex == 0) {
		        // Before the first delta info, identity mapping.
		        return PositionUpdate.NONE;
		    }
		    return _deltas.get(insertIndex - 1);
		}"	$indentation$ public $whitespace$ positionupdate $whitespace$ lookup ( position $whitespace$ position ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ collections . binarysearch ( _deltas , $whitespace$ position ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ >= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ _deltas . get ( result ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ insertindex $whitespace$ = $whitespace$ - result $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( insertindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·before·the·first·delta·info,·identity·mapping.$ $newline$ $indentation$ return $whitespace$ positionupdate . none ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ _deltas . get ( insertindex $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ positionupdate $whitespace$ lookup ( position $whitespace$ position ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ collections. binarysearch ( _deltas, $whitespace$ position ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ >= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ _deltas. get ( position ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ insertindex $whitespace$ = $whitespace$ - result $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( insertindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////beforejndijndibeforejndijndifirst $whitespace$ = $whitespace$ sharereader. tostring ( ) ; $newline$ $indentation$ return $whitespace$ positionupdate. none ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ _deltas. get ( insertindex $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ }			
unicodeStartSeen	165	186	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.8480075001716614	HIGH	"		private int unicodeStartSeen() throws IOException{
		    int uCnt = 1;
		    while (true) {
		        int next = nextInputChar();
		        switch(next) {
		            case EOF:
		                {
		                    pushBackUs(uCnt);
		                    return BACKSLASH;
		                }
		            case 'u':
		                {
		                    uCnt++;
		                    continue;
		                }
		            default:
		                {
		                    return readDigits(uCnt, next);
		                }
		        }
		    }
		}"	$indentation$ private $whitespace$ int $whitespace$ unicodestartseen ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ ucnt $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ { $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ { $newline$ $indentation$ ucnt ++ ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ readdigits ( ucnt , $whitespace$ next ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ unicodestartseen ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ ucnt $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ { $newline$ $indentation$ pushbackus ( ucnt ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ { $newline$ $indentation$ ucnt ++ ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ readdigits ( ucnt, $whitespace$ next ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }			
pushBack	283	307	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.8722913265228271	HIGH	"		private void pushBack(int ch){
		    if (ch < 0) {
		        return;
		    }
		    if (isBufferEmpty()) {
		        _pos = _data.length;
		        _len = _data.length;
		    } else if (_pos == 0) {
		        if (_len == _data.length) {
		            // Buffer is completely full, no push possible, enlarge buffer.
		            char[] newData = new char[_data.length + 1024];
		            _len = newData.length;
		            _pos = newData.length - _data.length;
		            System.arraycopy(_data, 0, newData, _pos, _data.length);
		            _data = newData;
		        } else {
		            // Move contents to the right.
		            int cnt = _len - _pos;
		            _pos = _data.length - _len;
		            _len = _data.length;
		            System.arraycopy(_data, 0, _data, _pos, cnt);
		        }
		    }
		    _data[--_pos] = (char) ch;
		}"	$indentation$ private $whitespace$ void $whitespace$ pushback ( int $whitespace$ ch ) { $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isbufferempty ( ) ) $whitespace$ { $newline$ $indentation$ _pos $whitespace$ = $whitespace$ _data . length ; $newline$ $indentation$ _len $whitespace$ = $whitespace$ _data . length ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( _pos $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( _len $whitespace$ == $whitespace$ _data . length ) $whitespace$ { $newline$ $indentation$ $//·buffer·is·completely·full,·no·push·possible,·enlarge·buffer.$ $newline$ $indentation$ char [ ] $whitespace$ newdata $whitespace$ = $whitespace$ new $whitespace$ char [ _data . length $whitespace$ + $whitespace$ $number$ ] ; $newline$ $indentation$ _len $whitespace$ = $whitespace$ newdata . length ; $newline$ $indentation$ _pos $whitespace$ = $whitespace$ newdata . length $whitespace$ - $whitespace$ _data . length ; $newline$ $indentation$ system . arraycopy ( _data , $whitespace$ $number$ , $whitespace$ newdata , $whitespace$ _pos , $whitespace$ _data . length ) ; $newline$ $indentation$ _data $whitespace$ = $whitespace$ newdata ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·move·contents·to·the·right.$ $newline$ $indentation$ int $whitespace$ cnt $whitespace$ = $whitespace$ _len $whitespace$ - $whitespace$ _pos ; $newline$ $indentation$ _pos $whitespace$ = $whitespace$ _data . length $whitespace$ - $whitespace$ _len ; $newline$ $indentation$ _len $whitespace$ = $whitespace$ _data . length ; $newline$ $indentation$ system . arraycopy ( _data , $whitespace$ $number$ , $whitespace$ _data , $whitespace$ _pos , $whitespace$ cnt ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ _data [ -- _pos ] $whitespace$ = $whitespace$ ( char ) $whitespace$ ch ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ pushback ( int $whitespace$ ch ) { $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isbufferempty ( ) ) $whitespace$ { $newline$ $indentation$ _pos $whitespace$ = $whitespace$ _data. length ; $newline$ $indentation$ _len $whitespace$ = $whitespace$ _data. length ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( _pos $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( _len $whitespace$ == $whitespace$ _data. length ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ newdata. length $whitespace$ - $whitespace$ _data. length ; $newline$ $indentation$ system. arraycopy ( _data, $whitespace$ $number$, $whitespace$ newdata, $whitespace$ _pos, $whitespace$ _data. length ) ; $newline$ $indentation$ _data $whitespace$ = $whitespace$ newdata ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ _ $whitespace$ = $whitespace$ newdata ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ;			
read	92	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.8735813498497009	HIGH	"		@Override
		public int read(char[] buffer, final int offset, int len) throws IOException{
		    int pos = offset;
		    int stop = offset + len;
		    while (pos < stop) {
		        int ch = _outputLine.process(nextOutputChar());
		        if (ch < 0) {
		            if (pos == offset) {
		                // Nothing read yet, this is the end of the stream.
		                return EOF;
		            }
		            break;
		        }
		        _mappingBuilder.update();
		        buffer[pos++] = (char) ch;
		    }
		    return pos - offset;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ read ( char [ ] $whitespace$ buffer , $whitespace$ final $whitespace$ int $whitespace$ offset , $whitespace$ int $whitespace$ len ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ offset ; $newline$ $indentation$ int $whitespace$ stop $whitespace$ = $whitespace$ offset $whitespace$ + $whitespace$ len ; $newline$ $indentation$ while $whitespace$ ( pos $whitespace$ < $whitespace$ stop ) $whitespace$ { $newline$ $indentation$ int $whitespace$ ch $whitespace$ = $whitespace$ _outputline . process ( nextoutputchar ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( pos $whitespace$ == $whitespace$ offset ) $whitespace$ { $newline$ $indentation$ $//·nothing·read·yet,·this·is·the·end·of·the·stream.$ $newline$ $indentation$ return $whitespace$ eof ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ _mappingbuilder . update ( ) ; $newline$ $indentation$ buffer [ pos ++ ] $whitespace$ = $whitespace$ ( char ) $whitespace$ ch ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pos $whitespace$ - $whitespace$ offset ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ read ( char [ ] $whitespace$ buffer, $whitespace$ final $whitespace$ int $whitespace$ offset, $whitespace$ int $whitespace$ len ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ offset ; $newline$ $indentation$ int $whitespace$ stop $whitespace$ = $whitespace$ offset $whitespace$ + $whitespace$ len ; $newline$ $indentation$ while $whitespace$ ( pos $whitespace$ < $whitespace$ stop ) $whitespace$ { $newline$ $indentation$ int $whitespace$ ch $whitespace$ = $whitespace$ _outputline. process ( nextoutputchar ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( pos $whitespace$ == $whitespace$ offset ) $whitespace$ { $newline$ $indentation$ $//gli $whitespace$ = $whitespace$ eof ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ _mappingbuilder. update ( ) ; $newline$ $indentation$ buffer [ pos ++ ] $whitespace$ = $whitespace$ ( char ) $whitespace$ ch ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pos $whitespace$ - $whitespace$ offset ; $newline$ $indentation$ }			
nextOutputChar	121	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.8960837125778198	HIGH	"		private int nextOutputChar() throws IOException{
		    int next = nextInputChar();
		    switch(next) {
		        case EOF:
		            return EOF;
		        case BACKSLASH:
		            {
		                if (_backslashSeen) {
		                    return clearBackSlashSeen(next);
		                }
		                return backSlashSeen();
		            }
		        default:
		            {
		                // An arbitrary character.
		                return clearBackSlashSeen(next);
		            }
		    }
		}"	$indentation$ private $whitespace$ int $whitespace$ nextoutputchar ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ return $whitespace$ eof ; $newline$ $indentation$ case $whitespace$ backslash : $newline$ $indentation$ { $newline$ $indentation$ if $whitespace$ ( _backslashseen ) $whitespace$ { $newline$ $indentation$ return $whitespace$ clearbackslashseen ( next ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ backslashseen ( ) ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ $//·an·arbitrary·character.$ $newline$ $indentation$ return $whitespace$ clearbackslashseen ( next ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ nextoutputchar ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch $whitespace$ ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ return $whitespace$ eof ; $newline$ $indentation$ case $whitespace$ backslash : $newline$ $indentation$ { $newline$ $indentation$ if $whitespace$ ( _backslashseen ) $whitespace$ { $newline$ $indentation$ return $whitespace$ clearbackslashseen ( next ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ backslashseen ( ) ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ $//g$an143示示 $newline$ $indentation$ return $whitespace$ clearbackslashseen ( next ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
backSlashSeen	146	163	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.910548985004425	HIGH	"		private int backSlashSeen() throws IOException{
		    _backslashSeen = true;
		    int next = nextInputChar();
		    switch(next) {
		        case EOF:
		            // End of file after backslash produces the backslash itself.
		            return BACKSLASH;
		        case 'u':
		            {
		                return unicodeStartSeen();
		            }
		        default:
		            {
		                pushBack(next);
		                return BACKSLASH;
		            }
		    }
		}"	$indentation$ private $whitespace$ int $whitespace$ backslashseen ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ _backslashseen $whitespace$ = $whitespace$ true ; $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ $//·end·of·file·after·backslash·produces·the·backslash·itself.$ $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ unicodestartseen ( ) ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ pushback ( next ) ; $newline$ $indentation$ return $whitespace$ backslash ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ backslashseen ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ _backslashseen $whitespace$ = $whitespace$ true ; $newline$ $indentation$ int $whitespace$ next $whitespace$ = $whitespace$ nextinputchar ( ) ; $newline$ $indentation$ switch $whitespace$ ( next ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ $////// $newline$ $indentation$$ does does does ( next ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ unicodestartseen ( ) ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ level ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }			
pushBackUs	226	230	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.9350054860115052	HIGH	"		private void pushBackUs(int cnt){
		    for (int n = 0; n < cnt; n++) {
		        pushBack('u');
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ pushbackus ( int $whitespace$ cnt ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ n $whitespace$ = $whitespace$ $number$ ; $whitespace$ n $whitespace$ < $whitespace$ cnt ; $whitespace$ n ++ ) $whitespace$ { $newline$ $indentation$ pushback ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ pushbackus ( int $whitespace$ cnt ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ n $whitespace$ = $whitespace$ $number$ ; $whitespace$ n $whitespace$ < $whitespace$ cnt ; $whitespace$ n ++ ) $whitespace$ { $newline$ $indentation$ pushbackresult ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
process	556	585	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.9537665843963624	HIGH	"		public int process(int ch){
		    switch(ch) {
		        case EOF:
		            {
		                break;
		            }
		        case CR:
		            {
		                incLine();
		                _crSeen = true;
		                break;
		            }
		        case LF:
		            {
		                // CR LF does only count as a single line terminator.
		                if (_crSeen) {
		                    _crSeen = false;
		                } else {
		                    incLine();
		                }
		                break;
		            }
		        default:
		            {
		                _crSeen = false;
		                _column++;
		            }
		    }
		    return ch;
		}"	$indentation$ public $whitespace$ int $whitespace$ process ( int $whitespace$ ch ) { $newline$ $indentation$ switch ( ch ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ cr : $newline$ $indentation$ { $newline$ $indentation$ incline ( ) ; $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ true ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ lf : $newline$ $indentation$ { $newline$ $indentation$ $//·cr·lf·does·only·count·as·a·single·line·terminator.$ $newline$ $indentation$ if $whitespace$ ( _crseen ) $whitespace$ { $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ incline ( ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ false ; $newline$ $indentation$ _column ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ch ; $newline$ $indentation$ }	$indentation$ public $whitespace$ int $whitespace$ process ( int $whitespace$ ch ) { $newline$ $indentation$ switch ( ch ) $whitespace$ { $newline$ $indentation$ case $whitespace$ eof : $newline$ $indentation$ { $newline$ $indentation$ case $whitespace$ cr : $newline$ $indentation$ { $newline$ $indentation$ incline ( ) ; $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ true ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ lf : $newline$ $indentation$ { $newline$ $indentation$ $whitespace$//g$cr = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ lf : $newline$ $indentation$ { $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ default : $newline$ $indentation$ { $newline$ $indentation$ _crseen $whitespace$ = $whitespace$ false ; $newline$ $indentation$ _column ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ch ; $newline$ $indentation$ }			
digit	232	243	javaparser/javaparser-core/src/main/java/com/github/javaparser/UnicodeEscapeProcessingProvider.java	0.9648612141609192	HIGH	"		private static int digit(int ch){
		    if (ch >= '0' && ch <= '9') {
		        return ch - '0';
		    }
		    if (ch >= 'A' && ch <= 'F') {
		        return 10 + ch - 'A';
		    }
		    if (ch >= 'a' && ch <= 'f') {
		        return 10 + ch - 'a';
		    }
		    return -1;
		}"	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ digit ( int $whitespace$ ch ) { $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ >= $whitespace$ $string$ $whitespace$ && $whitespace$ ch $whitespace$ <= $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ >= $whitespace$ $string$ $whitespace$ && $whitespace$ ch $whitespace$ <= $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ch $whitespace$ >= $whitespace$ $string$ $whitespace$ && $whitespace$ ch $whitespace$ <= $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ digit ( int $whitespace$ ch ) { $newline$ $indentation$ if $whitespace$ (! iswholeboardfilled ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( iswholeboardfilled ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( iswholeboardfilled ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ + $whitespace$ ch $whitespace$ - $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }			
remove	140	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java	0.6732451319694519	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.remove(i);
		            return true;
		        }
		    }
		    if (dimension != null) {
		        if (node == dimension) {
		            removeDimension();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( dimension $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ dimension ) $whitespace$ { $newline$ $indentation$ removedimension ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( dimension $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ dimension ) $whitespace$ { $newline$ $indentation$ removedimension ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
replace	173	192	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java	0.7025920748710632	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.set(i, (AnnotationExpr) replacementNode);
		            return true;
		        }
		    }
		    if (dimension != null) {
		        if (node == dimension) {
		            setDimension((Expression) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . set ( i , $whitespace$ ( annotationexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( dimension $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ dimension ) $whitespace$ { $newline$ $indentation$ setdimension ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$			
setDimension	98	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java	0.7139843106269836	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayCreationLevel setDimension(final Expression dimension){
		    if (dimension == this.dimension) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.DIMENSION, this.dimension, dimension);
		    if (this.dimension != null)
		        this.dimension.setParentNode(null);
		    this.dimension = dimension;
		    setAsParentNodeOf(dimension);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevel $whitespace$ setdimension ( final $whitespace$ expression $whitespace$ dimension ) { $newline$ $indentation$ if $whitespace$ ( dimension $whitespace$ == $whitespace$ this . dimension ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . dimension , $whitespace$ this . dimension , $whitespace$ dimension ) ; $newline$ $indentation$ if $whitespace$ ( this . dimension $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . dimension . setparentnode ( null ) ; $newline$ $indentation$ this . dimension $whitespace$ = $whitespace$ dimension ; $newline$ $indentation$ setasparentnodeof ( dimension ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevel $whitespace$ setdimension ( final $whitespace$ expression $whitespace$ dimension ) { $newline$ $indentation$ if $whitespace$ ( dimension $whitespace$ == $whitespace$ this. dimension ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. dimension, $whitespace$ this. dimension, $whitespace$ dimension ) ; $newline$ $indentation$ if $whitespace$ ( this. dimension $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. dimension. setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( dimension ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getMetaModel	167	171	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java	0.7142295241355896	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ArrayCreationLevelMetaModel getMetaModel(){
		    return JavaParserMetaModel.arrayCreationLevelMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevelmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . arraycreationlevelmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevelmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. arraycreationlevelmetamodel ; $newline$ $indentation$ }			
setAnnotations	121	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ArrayCreationLevel.java	0.8300620317459106	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayCreationLevel setAnnotations(final NodeList<AnnotationExpr> annotations){
		    assertNotNull(annotations);
		    if (annotations == this.annotations) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ANNOTATIONS, this.annotations, annotations);
		    if (this.annotations != null)
		        this.annotations.setParentNode(null);
		    this.annotations = annotations;
		    setAsParentNodeOf(annotations);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevel $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this . annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . annotations , $whitespace$ this . annotations , $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this . annotations $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . annotations . setparentnode ( null ) ; $newline$ $indentation$ this . annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationlevel $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this. annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. annotations, $whitespace$ this. annotations, $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this. annotations $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. annotations. setparentnode ( null ) ; $newline$ $indentation$ this. annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
addImport	278	286	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.0260052271187305	LOW	"		public CompilationUnit addImport(ImportDeclaration importDeclaration){
		    if (importDeclaration.isAsterisk()) {
		        getImports().removeIf(im -> Objects.equals(getImportPackageName(im).get(), getImportPackageName(importDeclaration).orElse(null)));
		    }
		    if (!isImplicitImport(importDeclaration) && getImports().stream().noneMatch(im -> im.equals(importDeclaration) || (im.isAsterisk() && Objects.equals(getImportPackageName(im).get(), getImportPackageName(importDeclaration).orElse(null))))) {
		        getImports().add(importDeclaration);
		    }
		    return this;
		}"	$indentation$ public $whitespace$ compilationunit $whitespace$ addimport ( importdeclaration $whitespace$ importdeclaration ) { $newline$ $indentation$ if $whitespace$ ( importdeclaration . isasterisk ( ) ) $whitespace$ { $newline$ $indentation$ getimports ( ) . removeif ( im $whitespace$ - > $whitespace$ objects . equals ( getimportpackagename ( im ) . get ( ) , $whitespace$ getimportpackagename ( importdeclaration ) . orelse ( null ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! isimplicitimport ( importdeclaration ) $whitespace$ && $whitespace$ getimports ( ) . stream ( ) . nonematch ( im $whitespace$ - > $whitespace$ im . equals ( importdeclaration ) $whitespace$ || $whitespace$ ( im . isasterisk ( ) $whitespace$ && $whitespace$ objects . equals ( getimportpackagename ( im ) . get ( ) , $whitespace$ getimportpackagename ( importdeclaration ) . orelse ( null ) ) ) ) ) $whitespace$ { $newline$ $indentation$ getimports ( ) . add ( importdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ compilationunit $whitespace$ addimport ( importdeclaration $whitespace$ importdeclaration ) { $newline$ $indentation$ if $whitespace$ ( importdeclaration. isasterisk ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ ( debug $whitespace$ = $whitespace$ importdeclaration. getimports ( ). get ( ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isasterisk $whitespace$ = $whitespace$ importdeclaration. isasterisk ( ) $whitespace$ || $whitespace$ ( im. isasterisk ( ) $whitespace$ && $whitespace$ objects. equals ( getimportpackagename ( im ). get ( ), $whitespace$ getimportpackagename ( importdeclaration ). orelse ( null ) ) ; $newline$ $indentation$ if $whitespace$ (! isimplicitimport ( importdeclaration ) $whitespace$ && $whitespace$ isimports ( ). stream ( ). nonematch ( im $whitespace$ - > $whitespace$ im. equals ( importdeclaration ) $whitespace$ || $whitespace$ ( im. isasterisk ( ) $whitespace$ && $whitespace$ objects. equals ( getimportpackagename ( im ). get ( ), $whitespace$ getimportpackagename ( importdeclaration ). orelse ( null ) ) ) ) $whitespace$ { $newline$ $indentation$ getimports ( ). add ( importdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getComments	171	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.6173617243766785	MID	"		@Deprecated
		public List<Comment> getComments(){
		    List<Comment> comments = this.getAllContainedComments();
		    this.getComment().ifPresent(comments::add);
		    return comments;
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ list < comment > $whitespace$ getcomments ( ) { $newline$ $indentation$ list < comment > $whitespace$ comments $whitespace$ = $whitespace$ this . getallcontainedcomments ( ) ; $newline$ $indentation$ this . getcomment ( ) . ifpresent ( comments : : add ) ; $newline$ $indentation$ return $whitespace$ comments ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ list < comment > $whitespace$ getcomments ( ) { $newline$ $indentation$ list < comment > $whitespace$ comments $whitespace$ = $whitespace$ this. getallcontainedcomments ( ) ; $newline$ $indentation$ this. getcomment ( ). ifpresent ( comments : : add ) ; $newline$ $indentation$ return $whitespace$ comments ; $newline$ $indentation$ }			
getAllComments	189	193	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.6324092149734497	MID	"		public List<Comment> getAllComments(){
		    List<Comment> comments = this.getAllContainedComments();
		    this.getComment().ifPresent(comments::add);
		    return comments;
		}"	$indentation$ public $whitespace$ list < comment > $whitespace$ getallcomments ( ) { $newline$ $indentation$ list < comment > $whitespace$ comments $whitespace$ = $whitespace$ this . getallcontainedcomments ( ) ; $newline$ $indentation$ this . getcomment ( ) . ifpresent ( comments : : add ) ; $newline$ $indentation$ return $whitespace$ comments ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < comment > $whitespace$ getallcomments ( ) { $newline$ $indentation$ list < comment > $whitespace$ comments $whitespace$ = $whitespace$ this. getallcontainedcomments ( ) ; $newline$ $indentation$ if ( comments : : add ) $whitespace$ { $newline$ $indentation$ return $whitespace$ comments ; $newline$ $indentation$ }			
isImplicitImport	292	307	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.6628932952880859	MID	"		private boolean isImplicitImport(ImportDeclaration importDeclaration){
		    Optional<Name> importPackageName = getImportPackageName(importDeclaration);
		    if (importPackageName.isPresent()) {
		        if (parseName(JAVA_LANG).equals(importPackageName.get())) {
		            // java.lang is implicitly imported
		            return true;
		        }
		        if (packageDeclaration != null) {
		            // the import is within the same package
		            Name currentPackageName = packageDeclaration.getName();
		            return currentPackageName.equals(importPackageName.get());
		        }
		        return false;
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitimport ( importdeclaration $whitespace$ importdeclaration ) { $newline$ $indentation$ optional < name > $whitespace$ importpackagename $whitespace$ = $whitespace$ getimportpackagename ( importdeclaration ) ; $newline$ $indentation$ if $whitespace$ ( importpackagename . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parsename ( java_lang ) . equals ( importpackagename . get ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·java.lang·is·implicitly·imported$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( packagedeclaration $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·the·import·is·within·the·same·package$ $newline$ $indentation$ name $whitespace$ currentpackagename $whitespace$ = $whitespace$ packagedeclaration . getname ( ) ; $newline$ $indentation$ return $whitespace$ currentpackagename . equals ( importpackagename . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitimport ( importdeclaration $whitespace$ importdeclaration ) { $newline$ $indentation$ optional < name > $whitespace$ importpackagename $whitespace$ = $whitespace$ getimportpackagename ( importdeclaration ) ; $newline$ $indentation$ if $whitespace$ ( importpackagename. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( packagedeclaration $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getMetaModel	816	820	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.7156317830085754	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public CompilationUnitMetaModel getMetaModel(){
		    return JavaParserMetaModel.compilationUnitMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunitmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . compilationunitmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunitmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. compilationunitmetamodel ; $newline$ $indentation$ }			
getPrinter	146	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.840951144695282	HIGH	"		@Override
		protected Printer getPrinter(){
		    if (!containsData(PRINTER_KEY)) {
		        // create a default printer
		        Printer printer = createDefaultPrinter();
		        printer(printer);
		    }
		    return getData(PRINTER_KEY);
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ printer $whitespace$ getprinter ( ) { $newline$ $indentation$ if $whitespace$ ( ! containsdata ( printer_key ) ) $whitespace$ { $newline$ $indentation$ $//·create·a·default·printer$ $newline$ $indentation$ printer $whitespace$ printer $whitespace$ = $whitespace$ createdefaultprinter ( ) ; $newline$ $indentation$ printer ( printer ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getdata ( printer_key ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ printer $whitespace$ getprinter ( ) { $newline$ $indentation$ return $whitespace$! containsdata ( printer_key ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isvalider ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$! containsdata ( printer_key ) ; $newline$ $indentation$ } $newline$ $indentation$			
setTypes	334	346	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.8589380979537964	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public CompilationUnit setTypes(final NodeList<TypeDeclaration<?>> types){
		    assertNotNull(types);
		    if (types == this.types) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPES, this.types, types);
		    if (this.types != null)
		        this.types.setParentNode(null);
		    this.types = types;
		    setAsParentNodeOf(types);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunit $whitespace$ settypes ( final $whitespace$ nodelist < typedeclaration < ? >> $whitespace$ types ) { $newline$ $indentation$ assertnotnull ( types ) ; $newline$ $indentation$ if $whitespace$ ( types $whitespace$ == $whitespace$ this . types ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . types , $whitespace$ this . types , $whitespace$ types ) ; $newline$ $indentation$ if $whitespace$ ( this . types $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . types . setparentnode ( null ) ; $newline$ $indentation$ this . types $whitespace$ = $whitespace$ types ; $newline$ $indentation$ setasparentnodeof ( types ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunit $whitespace$ settypes ( final $whitespace$ nodelist < typedeclaration <? >> $whitespace$ types ) { $newline$ $indentation$ assertnotnull ( types ) ; $newline$ $indentation$ if $whitespace$ ( types $whitespace$ == $whitespace$ this. types ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. types, $whitespace$ this. types, $whitespace$ types ) ; $newline$ $indentation$ if $whitespace$ ( this. types $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. types. setparentnode ( null ) ; $newline$ $indentation$ this. types $whitespace$ = $whitespace$ types ; $newline$ $indentation$ setasparentnodeof ( types ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setImports	252	264	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/CompilationUnit.java	0.8650756478309631	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public CompilationUnit setImports(final NodeList<ImportDeclaration> imports){
		    assertNotNull(imports);
		    if (imports == this.imports) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.IMPORTS, this.imports, imports);
		    if (this.imports != null)
		        this.imports.setParentNode(null);
		    this.imports = imports;
		    setAsParentNodeOf(imports);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunit $whitespace$ setimports ( final $whitespace$ nodelist < importdeclaration > $whitespace$ imports ) { $newline$ $indentation$ assertnotnull ( imports ) ; $newline$ $indentation$ if $whitespace$ ( imports $whitespace$ == $whitespace$ this . imports ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . imports , $whitespace$ this . imports , $whitespace$ imports ) ; $newline$ $indentation$ if $whitespace$ ( this . imports $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . imports . setparentnode ( null ) ; $newline$ $indentation$ this . imports $whitespace$ = $whitespace$ imports ; $newline$ $indentation$ setasparentnodeof ( imports ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compilationunit $whitespace$ setimports ( final $whitespace$ nodelist < importdeclaration > $whitespace$ imports ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isimported $whitespace$ = $whitespace$ imports ; $newline$ $indentation$ if $whitespace$ ( imports $whitespace$ == $whitespace$ this. imports ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. imports, $whitespace$ this. imports, $whitespace$ imports ) ; $newline$ $indentation$ if $whitespace$ ( this. imports $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. imports. setparentnode ( null ) ; $newline$ $indentation$ this. imports $whitespace$ = $whitespace$ imports ; $newline$ $indentation$ setasparentnodeof ( imports ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getMetaModel	153	157	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ImportDeclaration.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ImportDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.importDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ importdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . importdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ importdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. importdeclarationmetamodel ; $newline$ $indentation$ }			
accept	80	84	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ImportDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
replace	159	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ImportDeclaration.java	0.8389257192611694	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ replacementnode ; $newline$ $indentation$ }			
setName	123	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/ImportDeclaration.java	0.8657823801040649	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ImportDeclaration setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ importdeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ importdeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ asserttrue ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
clone	189	193	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Modifier.java	0.8417680859565735	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Modifier clone(){
		    return (Modifier) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modifier $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( modifier ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modifier $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( modifier ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
isPhantom	1175	1181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.0741122663021087	LOW	"		private boolean isPhantom(Node node){
		    if (!node.containsData(PHANTOM_KEY)) {
		        boolean res = (node.getParentNode().isPresent() && node.getParentNode().get().hasRange() && node.hasRange() && !node.getParentNode().get().getRange().get().contains(node.getRange().get()) || inPhantomNode(node, LEVELS_TO_EXPLORE));
		        node.setData(PHANTOM_KEY, res);
		    }
		    return node.getData(PHANTOM_KEY);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isphantom ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ! node . containsdata ( phantom_key ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ res $whitespace$ = $whitespace$ ( node . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ node . getparentnode ( ) . get ( ) . hasrange ( ) $whitespace$ && $whitespace$ node . hasrange ( ) $whitespace$ && $whitespace$ ! node . getparentnode ( ) . get ( ) . getrange ( ) . get ( ) . contains ( node . getrange ( ) . get ( ) ) $whitespace$ || $whitespace$ inphantomnode ( node , $whitespace$ levels_to_explore ) ) ; $newline$ $indentation$ node . setdata ( phantom_key , $whitespace$ res ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node . getdata ( phantom_key ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isphantom ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ (! node. containsdata ( phantom_key ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ res $whitespace$ = $whitespace$ ( node. getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ node. getparentnode ( ). get ( ). hasrange ( ) $whitespace$ && $whitespace$ node. hasrange ( ) $whitespace$ && $whitespace$! node. getparentnode ( ). get ( ). getrange ( ). get ( ). contains ( node. getrange ( ). get ( ) ) $whitespace$ || $whitespace$ inphantomnode ( node, $whitespace$ levels_to_explore ) ) ; $newline$ $indentation$ node. setdata ( phantom_key, $whitespace$ res ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node. getdata ( phantom_key ) ; $newline$ $indentation$ }			
fillStackToLeaf	1116	1126	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6109988689422607	MID	"		private void fillStackToLeaf(Node node){
		    while (true) {
		        List<Node> childNodes = node.getChildNodes();
		        if (childNodes.isEmpty()) {
		            break;
		        }
		        nodesStack.push(childNodes);
		        cursorStack.push(0);
		        node = childNodes.get(0);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ fillstacktoleaf ( node $whitespace$ node ) { $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ list < node > $whitespace$ childnodes $whitespace$ = $whitespace$ node . getchildnodes ( ) ; $newline$ $indentation$ if $whitespace$ ( childnodes . isempty ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ nodesstack . push ( childnodes ) ; $newline$ $indentation$ cursorstack . push ( $number$ ) ; $newline$ $indentation$ node $whitespace$ = $whitespace$ childnodes . get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ fillstacktoleaf ( node $whitespace$ node ) { $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ nodesstack. push ( childnodes ) ; $newline$ $indentation$ cursorstack. push ( $number$ ) ; $newline$ $indentation$ node $whitespace$ = $whitespace$ childnodes. get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
findData	533	539	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6399542689323425	MID	"		@SuppressWarnings(""unchecked"")
		public Optional<M> findData(final DataKey<M> key){
		    if (containsData(key)) {
		        return Optional.of(getData(key));
		    }
		    return Optional.empty();
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < m > $whitespace$ finddata ( final $whitespace$ datakey < m > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( containsdata ( key ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( getdata ( key ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < m > $whitespace$ finddata ( final $whitespace$ datakey < m > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( containsdata ( key ) ) $whitespace$ return $whitespace$ optional. of ( getdata ( key ) ) ; $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
setData	562	567	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6533541083335876	MID	"		public void setData(DataKey<M> key, M object){
		    if (data == null) {
		        data = new IdentityHashMap<>();
		    }
		    data.put(key, object);
		}"	$indentation$ public $whitespace$ void $whitespace$ setdata ( datakey < m > $whitespace$ key , $whitespace$ m $whitespace$ object ) { $newline$ $indentation$ if $whitespace$ ( data $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ data $whitespace$ = $whitespace$ new $whitespace$ identityhashmap < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ data . put ( key , $whitespace$ object ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ setdata ( datakey < m > $whitespace$ key, $whitespace$ m $whitespace$ object ) { $newline$ $indentation$ if $whitespace$ ( data $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ data $whitespace$ = $whitespace$ new $whitespace$ identityhashmap < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ data. put ( key, $whitespace$ object ) ; $newline$ $indentation$ }			
getData	513	523	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6548972725868225	MID	"		@SuppressWarnings(""unchecked"")
		public M getData(final DataKey<M> key){
		    if (data == null) {
		        throw new IllegalStateException(""No data of this type found. Use containsData to check for this first."");
		    }
		    M value = (M) data.get(key);
		    if (value == null) {
		        throw new IllegalStateException(""No data of this type found. Use containsData to check for this first."");
		    }
		    return value;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ m $whitespace$ getdata ( final $whitespace$ datakey < m > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( data $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ m $whitespace$ value $whitespace$ = $whitespace$ ( m ) $whitespace$ data . get ( key ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ value ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ m $whitespace$ getdata ( final $whitespace$ datakey < m > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( key $whitespace$ == $whitespace$ null ) $whitespace$ return $whitespace$ null ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ m $whitespace$ value $whitespace$ = $whitespace$ ( m ) $whitespace$ data. get ( key ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ null ) $whitespace$ return $whitespace$ null ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ return $whitespace$ value ; $newline$ $indentation$ }			
getLineEndingStyle	798	814	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.683976411819458	MID	"		public LineSeparator getLineEndingStyle(){
		    Node current = this;
		    // First check this node
		    if (current.containsData(Node.LINE_SEPARATOR_KEY)) {
		        LineSeparator lineSeparator = current.getData(Node.LINE_SEPARATOR_KEY);
		        return lineSeparator;
		    }
		    // Then check parent/ancestor nodes
		    while (current.getParentNode().isPresent()) {
		        current = current.getParentNode().get();
		        if (current.containsData(Node.LINE_SEPARATOR_KEY)) {
		            return current.getData(Node.LINE_SEPARATOR_KEY);
		        }
		    }
		    // Default to the system line separator if it's not already set within the parsed node/code.
		    return LineSeparator.SYSTEM;
		}"	$indentation$ public $whitespace$ lineseparator $whitespace$ getlineendingstyle ( ) { $newline$ $indentation$ node $whitespace$ current $whitespace$ = $whitespace$ this ; $newline$ $indentation$ $//·first·check·this·node$ $newline$ $indentation$ if $whitespace$ ( current . containsdata ( node . line_separator_key ) ) $whitespace$ { $newline$ $indentation$ lineseparator $whitespace$ lineseparator $whitespace$ = $whitespace$ current . getdata ( node . line_separator_key ) ; $newline$ $indentation$ return $whitespace$ lineseparator ; $newline$ $indentation$ } $newline$ $indentation$ $//·then·check·parent/ancestor·nodes$ $newline$ $indentation$ while $whitespace$ ( current . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ current $whitespace$ = $whitespace$ current . getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( current . containsdata ( node . line_separator_key ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ current . getdata ( node . line_separator_key ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·default·to·the·system·line·separator·if·it's·not·already·set·within·the·parsed·node/code.$ $newline$ $indentation$ return $whitespace$ lineseparator . system ; $newline$ $indentation$ }	$indentation$ public $whitespace$ lineseparator $whitespace$ getlineendingstyle ( ) { $newline$ $indentation$ node $whitespace$ current $whitespace$ = $whitespace$ this ; $newline$ $indentation$ if $whitespace$ ( current. containsdata ( node. line_separator_key ) ) $whitespace$ { $newline$ $indentation$ lineseparator $whitespace$ lineseparator $whitespace$ = $whitespace$ current. getdata ( node. line_separator_key ) ; $newline$ $indentation$ return $whitespace$ lineseparator ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ get $whitespace$ the $whitespace$ current $whitespace$ item $whitespace$ that $whitespace$ line $whitespace$ contains $whitespace$ the $whitespace$ same $whitespace$ item $whitespace$ in $whitespace$ line $newline$ $indentation$ boolean $whitespace$ is $whitespace$ = $whitespace$ current. getparentnode ( ). ispresent ( ) ; $newline$ $indentation$ current $whitespace$ = $whitespace$ current. getparentnode ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ ( is $whitespace$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ current. getdata ( node. line_separator_key ) ;			
setParentNode	431	453	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6890727281570435	MID	"		@Override
		public Node setParentNode(Node newParentNode){
		    if (newParentNode == parentNode) {
		        return this;
		    }
		    observers.forEach(o -> o.parentChange(this, parentNode, newParentNode));
		    // remove from old parent, if any
		    if (parentNode != null) {
		        final ArrayList<Node> parentChildNodes = parentNode.childNodes;
		        for (int i = 0; i < parentChildNodes.size(); i++) {
		            if (parentChildNodes.get(i) == this) {
		                parentChildNodes.remove(i);
		            }
		        }
		        parentChildNodes.trimToSize();
		    }
		    parentNode = newParentNode;
		    // add to new parent, if any
		    if (parentNode != null) {
		        parentNode.childNodes.add(this);
		    }
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setparentnode ( node $whitespace$ newparentnode ) { $newline$ $indentation$ if $whitespace$ ( newparentnode $whitespace$ == $whitespace$ parentnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ observers . foreach ( o $whitespace$ - > $whitespace$ o . parentchange ( this , $whitespace$ parentnode , $whitespace$ newparentnode ) ) ; $newline$ $indentation$ $//·remove·from·old·parent,·if·any$ $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ final $whitespace$ arraylist < node > $whitespace$ parentchildnodes $whitespace$ = $whitespace$ parentnode . childnodes ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parentchildnodes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parentchildnodes . get ( i ) $whitespace$ == $whitespace$ this ) $whitespace$ { $newline$ $indentation$ parentchildnodes . remove ( i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ parentchildnodes . trimtosize ( ) ; $newline$ $indentation$ } $newline$ $indentation$ parentnode $whitespace$ = $whitespace$ newparentnode ; $newline$ $indentation$ $//·add·to·new·parent,·if·any$ $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ parentnode . childnodes . add ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setparentnode ( node $whitespace$ newparentnode ) { $newline$ $indentation$ if $whitespace$ ( newparentnode $whitespace$ == $whitespace$ parentnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ observers. foreach ( o $whitespace$ - > $whitespace$ o. parentchange ( this, $whitespace$ parentnode, $whitespace$ newparentnode ) ) ; $newline$ $indentation$ $////////////////////////////////////removes : : : newparentchildnodes $whitespace$ = $whitespace$ parentnode. childnodes ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parentchildnodes. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parentchildnodes. get ( i ) $whitespace$ == $whitespace$ this ) $whitespace$ { $newline$ $indentation$ parentchildnodes. remove ( i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ parentnode $whitespace$ = $whitespace$ newparentnode ; $newline$ $indentation$ $whitespace$//////////////////////////////////addline$ $indentation$ // $whitespace$ find $whitespace$ the $whitespace$ current $whitespace$ node $whitespace$ only $whitespace$ once $whitespace$ the $whitespace$ parent $whitespace$ is $whitespace$ being $whitespace$ r $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ parent			
findCompilationUnit	783	789	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6929060816764832	MID	"		public Optional<CompilationUnit> findCompilationUnit(){
		    Node rootNode = findRootNode();
		    if (rootNode instanceof CompilationUnit) {
		        return Optional.of((CompilationUnit) rootNode);
		    }
		    return Optional.empty();
		}"	$indentation$ public $whitespace$ optional < compilationunit > $whitespace$ findcompilationunit ( ) { $newline$ $indentation$ node $whitespace$ rootnode $whitespace$ = $whitespace$ findrootnode ( ) ; $newline$ $indentation$ if $whitespace$ ( rootnode $whitespace$ instanceof $whitespace$ compilationunit ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( ( compilationunit ) $whitespace$ rootnode ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < compilationunit > $whitespace$ findcompilationunit ( ) { $newline$ $indentation$ node $whitespace$ rootnode $whitespace$ = $whitespace$ findrootnode ( ) ; $newline$ $indentation$ return $whitespace$ optional. of ( rootnode ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ optional <decodesession > $whitespace$ findcompilationunit ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( ( compilationunit ) $whitespace$ rootnode ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ optional <decodesession > $whitespace$ findcompilationunit ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
setAsParentNodeOf	455	459	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.6966997385025024	MID	"		protected void setAsParentNodeOf(Node childNode){
		    if (childNode != null) {
		        childNode.setParentNode(getParentNodeForChildren());
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ setasparentnodeof ( node $whitespace$ childnode ) { $newline$ $indentation$ if $whitespace$ ( childnode $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ childnode . setparentnode ( getparentnodeforchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ setasparentnodeof ( node $whitespace$ childnode ) { $newline$ $indentation$ if $whitespace$ ( childnode $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ childnode. setparentnode ( getparentnodeforchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
addOrphanComment	375	379	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.7047105431556702	MID	"		public void addOrphanComment(Comment comment){
		    notifyPropertyChange(ObservableProperty.COMMENT, null, comment);
		    orphanComments.add(comment);
		    comment.setParentNode(this);
		}"	$indentation$ public $whitespace$ void $whitespace$ addorphancomment ( comment $whitespace$ comment ) { $newline$ $indentation$ notifypropertychange ( observableproperty . comment , $whitespace$ null , $whitespace$ comment ) ; $newline$ $indentation$ orphancomments . add ( comment ) ; $newline$ $indentation$ comment . setparentnode ( this ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ addorphancomment ( comment $whitespace$ comment ) { $newline$ $indentation$ notifypropertychange ( observableproperty. comment, $whitespace$ null, $whitespace$ comment ) ; $newline$ $indentation$ orphancomments. add ( comment ) ; $newline$ $indentation$ comment. setparentnode ( this ) ; $newline$ $indentation$ }			
removeOrphanComment	381	389	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.7333922982215881	MID	"		public boolean removeOrphanComment(Comment comment){
		    boolean removed = orphanComments.remove(comment);
		    if (removed) {
		        notifyPropertyChange(ObservableProperty.COMMENT, comment, null);
		        comment.setParentNode(null);
		        orphanComments.trimToSize();
		    }
		    return removed;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ removeorphancomment ( comment $whitespace$ comment ) { $newline$ $indentation$ boolean $whitespace$ removed $whitespace$ = $whitespace$ orphancomments . remove ( comment ) ; $newline$ $indentation$ if $whitespace$ ( removed ) $whitespace$ { $newline$ $indentation$ notifypropertychange ( observableproperty . comment , $whitespace$ comment , $whitespace$ null ) ; $newline$ $indentation$ comment . setparentnode ( null ) ; $newline$ $indentation$ orphancomments . trimtosize ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removed ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ removeorphancomment ( comment $whitespace$ comment ) { $newline$ $indentation$ boolean $whitespace$ removed $whitespace$ = $whitespace$ orphancomments. remove ( comment ) ; $newline$ $indentation$ boolean $whitespace$ ballinplay $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( removed ) $whitespace$ { $newline$ $indentation$ notifypropertychange ( observableproperty. comment, $whitespace$ comment, $whitespace$ null ) ; $newline$ $indentation$ comment. setparentnode ( null ) ; $newline$ $indentation$ orphancomments. trimtosize ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removed ; $newline$ $indentation$ }			
nextFromLevel	1152	1157	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.7348772287368774	MID	"		private Node nextFromLevel(){
		    final List<Node> nodes = nodesStack.peek();
		    final int cursor = cursorStack.pop();
		    cursorStack.push(cursor + 1);
		    return nodes.get(cursor);
		}"	$indentation$ private $whitespace$ node $whitespace$ nextfromlevel ( ) { $newline$ $indentation$ final $whitespace$ list < node > $whitespace$ nodes $whitespace$ = $whitespace$ nodesstack . peek ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ cursor $whitespace$ = $whitespace$ cursorstack . pop ( ) ; $newline$ $indentation$ cursorstack . push ( cursor $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ nodes . get ( cursor ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ node $whitespace$ nextfromlevel ( ) { $newline$ $indentation$ final $whitespace$ list < node > $whitespace$ nodes $whitespace$ = $whitespace$ nodesstack. peek ( ) ; $newline$ $indentation$ nodestack. push ( cursor $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ nodes. get ( cursor ) ; $newline$ $indentation$ }			
containsData	573	578	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.8366772532463074	HIGH	"		public boolean containsData(DataKey<?> key){
		    if (data == null) {
		        return false;
		    }
		    return data.containsKey(key);
		}"	$indentation$ public $whitespace$ boolean $whitespace$ containsdata ( datakey < ? > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( data $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ data . containskey ( key ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ containsdata ( datakey <? > $whitespace$ key ) { $newline$ $indentation$ if $whitespace$ ( data $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ data. containskey ( key ) ; $newline$ $indentation$ }			
unregister	648	652	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.8381261229515076	HIGH	"		@Override
		public void unregister(AstObserver observer){
		    this.observers.remove(observer);
		    this.observers.trimToSize();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ unregister ( astobserver $whitespace$ observer ) { $newline$ $indentation$ this . observers . remove ( observer ) ; $newline$ $indentation$ this . observers . trimtosize ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ unregister ( astobserver $whitespace$ observer ) { $newline$ $indentation$ this. observers. remove ( observer ) ; $newline$ $indentation$ this. observers. trimtosize ( ) ; $newline$ $indentation$ }			
clone	725	729	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.8710301518440247	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Node clone(){
		    return (Node) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ node $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( node ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ node $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( node ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
findRootNode	772	778	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.8739544153213501	HIGH	"		public Node findRootNode(){
		    Node n = this;
		    while (n.getParentNode().isPresent()) {
		        n = n.getParentNode().get();
		    }
		    return n;
		}"	$indentation$ public $whitespace$ node $whitespace$ findrootnode ( ) { $newline$ $indentation$ node $whitespace$ n $whitespace$ = $whitespace$ this ; $newline$ $indentation$ while $whitespace$ ( n . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n $whitespace$ = $whitespace$ n . getparentnode ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }	$indentation$ public $whitespace$ node $whitespace$ findrootnode ( ) { $newline$ $indentation$ node $whitespace$ n $whitespace$ = $whitespace$ this ; $newline$ $indentation$ while $whitespace$ ( n. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ nextnode $whitespace$ = $whitespace$ n. getparentnode ( ). get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }			
setRange	269	277	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.8791580200195312	HIGH	"		@Override
		public Node setRange(Range range){
		    if (this.range == range) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.RANGE, this.range, range);
		    this.range = range;
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setrange ( range $whitespace$ range ) { $newline$ $indentation$ if $whitespace$ ( this . range $whitespace$ == $whitespace$ range ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . range , $whitespace$ this . range , $whitespace$ range ) ; $newline$ $indentation$ this . range $whitespace$ = $whitespace$ range ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setrange ( range $whitespace$ range ) { $newline$ $indentation$ if $whitespace$ ( israngeclicked ( range ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. range, $whitespace$ this. range, $whitespace$ range ) ; $newline$ $indentation$ this. range $whitespace$ = $whitespace$ range ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
replace	610	615	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.9207753539085388	HIGH	"		public boolean replace(Node node){
		    if (parentNode == null) {
		        return false;
		    }
		    return parentNode.replace(this, node);
		}"	$indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ parentnode . replace ( this , $whitespace$ node ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ parentnode. replace ( this, $whitespace$ node ) ; $newline$ $indentation$ }			
register	654	661	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.93388569355011	HIGH	"		@Override
		public void register(AstObserver observer){
		    // Check if the observer is not registered yet.
		    // In this case we use a List instead of Set to save on memory space.
		    if (!this.observers.contains(observer)) {
		        this.observers.add(observer);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ register ( astobserver $whitespace$ observer ) { $newline$ $indentation$ $//·check·if·the·observer·is·not·registered·yet.$ $newline$ $indentation$ $//·in·this·case·we·use·a·list·instead·of·set·to·save·on·memory·space.$ $newline$ $indentation$ if $whitespace$ ( ! this . observers . contains ( observer ) ) $whitespace$ { $newline$ $indentation$ this . observers . add ( observer ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ register ( astobserver $whitespace$ observer ) { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ this. observers. contains ( observer ) ; $newline$ $indentation$ if $whitespace$ (! this. observers. contains ( observer ) ) $whitespace$ { $newline$ $indentation$ this. observers. add ( observer ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
equals	352	358	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.9391489028930664	HIGH	"		@Override
		public boolean equals(final Object obj){
		    if (!(obj instanceof Node)) {
		        return false;
		    }
		    return EqualsVisitor.equals(this, (Node) obj);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( ! ( obj $whitespace$ instanceof $whitespace$ node ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ equalsvisitor . equals ( this , $whitespace$ ( node ) $whitespace$ obj ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ (! ( obj $whitespace$ instanceof $whitespace$ node ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ equalsvisitor. equals ( this, $whitespace$ ( node ) $whitespace$ obj ) ; $newline$ $indentation$ }			
remove	597	602	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/Node.java	0.945132851600647	HIGH	"		public boolean remove(){
		    if (parentNode == null) {
		        return false;
		    }
		    return parentNode.remove(this);
		}"	$indentation$ public $whitespace$ boolean $whitespace$ remove ( ) { $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ parentnode . remove ( this ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ remove ( ) { $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ parentnode. remove ( this ) ; $newline$ $indentation$ }			
set	140	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.2962467968463897	LOW	"		@Override
		public N set(int index, N element){
		    if (index < 0 || index >= innerList.size()) {
		        throw new IllegalArgumentException(""Illegal index. The index should be between 0 and "" + innerList.size() + "" excluded. It is instead "" + index);
		    }
		    if (element == innerList.get(index)) {
		        return element;
		    }
		    notifyElementReplaced(index, element);
		    innerList.get(index).setParentNode(null);
		    setAsParentNodeOf(element);
		    return innerList.set(index, element);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ set ( int $whitespace$ index , $whitespace$ n $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ innerlist . size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ innerlist . size ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ index ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( element $whitespace$ == $whitespace$ innerlist . get ( index ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ element ; $newline$ $indentation$ } $newline$ $indentation$ notifyelementreplaced ( index , $whitespace$ element ) ; $newline$ $indentation$ innerlist . get ( index ) . setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( element ) ; $newline$ $indentation$ return $whitespace$ innerlist . set ( index , $whitespace$ element ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ set ( int $whitespace$ index, $whitespace$ n $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ innerlist. size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ innerlist. size ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ index ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( element $whitespace$ == $whitespace$ innerlist. get ( index ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ element ; $newline$ $indentation$ } $newline$ $indentation$ notifyelementreplaced ( index, $whitespace$ element ) ; $newline$ $indentation$ innerlist. get ( index ). setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( element ) ; $newline$ $indentation$ return $whitespace$ innerlist. set ( index, $whitespace$ element ) ; $newline$ $indentation$ }			
retainAll	369	378	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.6430168151855469	MID	"		@Override
		public boolean retainAll(Collection<?> c){
		    boolean changed = false;
		    for (Object e : this.stream().filter(it -> !c.contains(it)).toArray()) {
		        if (!c.contains(e)) {
		            changed = remove(e) || changed;
		        }
		    }
		    return changed;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection < ? > $whitespace$ c ) { $newline$ $indentation$ boolean $whitespace$ changed $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( object $whitespace$ e $whitespace$ : $whitespace$ this . stream ( ) . filter ( it $whitespace$ - > $whitespace$ ! c . contains ( it ) ) . toarray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! c . contains ( e ) ) $whitespace$ { $newline$ $indentation$ changed $whitespace$ = $whitespace$ remove ( e ) $whitespace$ || $whitespace$ changed ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ changed ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection <? > $whitespace$ c ) { $newline$ $indentation$ if $whitespace$ (! c. contains ( it ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( object $whitespace$ e $whitespace$ : $whitespace$ this. stream ( ). filter ( it $whitespace$ - > $whitespace$! c. contains ( it ) ). toarray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! c. contains ( e ) ) $whitespace$ { $newline$ $indentation$ changed $whitespace$ = $whitespace$ remove ( e ) $whitespace$ || $whitespace$ changed ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ changed ; $newline$ $indentation$ }			
addAfter	207	214	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.6924856901168823	MID	"		public NodeList<N> addAfter(N node, N afterThisNode){
		    int i = indexOf(afterThisNode);
		    if (i == -1) {
		        throw new IllegalArgumentException(""Can't find node to insert after."");
		    }
		    add(i + 1, node);
		    return this;
		}"	$indentation$ public $whitespace$ nodelist < n > $whitespace$ addafter ( n $whitespace$ node , $whitespace$ n $whitespace$ afterthisnode ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ indexof ( afterthisnode ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ add ( i $whitespace$ + $whitespace$ $number$ , $whitespace$ node ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ nodelist < n > $whitespace$ addafter ( n $whitespace$ node, $whitespace$ n $whitespace$ afterthisnode ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ indexof ( afterthisnode ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ add ( i $whitespace$ + $whitespace$ $number$, $whitespace$ node ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setParentNode	261	266	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.7167866230010986	MID	"		@Override
		public NodeList<N> setParentNode(Node parentNode){
		    this.parentNode = parentNode;
		    setAsParentNodeOf(innerList);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ nodelist < n > $whitespace$ setparentnode ( node $whitespace$ parentnode ) { $newline$ $indentation$ this . parentnode $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ setasparentnodeof ( innerlist ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ nodelist < n > $whitespace$ setparentnode ( node $whitespace$ parentnode ) { $newline$ $indentation$ this. parentnode $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ setasparentnodeof ( parentnode ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
addBefore	221	228	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.729276716709137	MID	"		public NodeList<N> addBefore(N node, N beforeThisNode){
		    int i = indexOf(beforeThisNode);
		    if (i == -1) {
		        throw new IllegalArgumentException(""Can't find node to insert before."");
		    }
		    add(i, node);
		    return this;
		}"	$indentation$ public $whitespace$ nodelist < n > $whitespace$ addbefore ( n $whitespace$ node , $whitespace$ n $whitespace$ beforethisnode ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ indexof ( beforethisnode ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ add ( i , $whitespace$ node ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ nodelist < n > $whitespace$ addbefore ( n $whitespace$ node, $whitespace$ n $whitespace$ beforethisnode ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ indexof ( beforethisnode ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ add ( i, $whitespace$ node ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
add	70	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8327010869979858	HIGH	"		@Override
		public boolean add(N node){
		    notifyElementAdded(innerList.size(), node);
		    own(node);
		    return innerList.add(node);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ add ( n $whitespace$ node ) { $newline$ $indentation$ notifyelementadded ( innerlist . size ( ) , $whitespace$ node ) ; $newline$ $indentation$ own ( node ) ; $newline$ $indentation$ return $whitespace$ innerlist . add ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ add ( n $whitespace$ node ) { $newline$ $indentation$ notifyelementadded ( node ) ; $newline$ $indentation$ return $whitespace$ innerlist. add ( node ) ; $newline$ $indentation$ }			
getLast	243	248	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8401760458946228	HIGH	"		public Optional<N> getLast(){
		    if (isEmpty()) {
		        return Optional.empty();
		    }
		    return Optional.of(get(size() - 1));
		}"	$indentation$ public $whitespace$ optional < n > $whitespace$ getlast ( ) { $newline$ $indentation$ if $whitespace$ ( isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( get ( size ( ) $whitespace$ - $whitespace$ $number$ ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < n > $whitespace$ getlast ( ) { $newline$ $indentation$ if $whitespace$ ( isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( get ( size ( ) $whitespace$ - $whitespace$ $number$ ) ) ; $newline$ $indentation$ }			
removeAll	357	364	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8423845767974854	HIGH	"		@Override
		public boolean removeAll(Collection<?> c){
		    boolean changed = false;
		    for (Object e : c) {
		        changed = remove(e) || changed;
		    }
		    return changed;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ removeall ( collection < ? > $whitespace$ c ) { $newline$ $indentation$ boolean $whitespace$ changed $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( object $whitespace$ e $whitespace$ : $whitespace$ c ) $whitespace$ { $newline$ $indentation$ changed $whitespace$ = $whitespace$ remove ( e ) $whitespace$ || $whitespace$ changed ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ changed ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ removeall ( collection <? > $whitespace$ c ) { $newline$ $indentation$ boolean $whitespace$ changed $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( object $whitespace$ e $whitespace$ : $whitespace$ c ) $whitespace$ { $newline$ $indentation$ changed $whitespace$ = $whitespace$ remove ( e ) $whitespace$ || $whitespace$ changed ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ changed ; $newline$ $indentation$ }			
listIterator	447	451	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8471351265907288	HIGH	"		@Override
		public ListIterator<N> listIterator(){
		    // Custom iterator required, to ensure that the relevant `notifyElement...` methods are called.
		    return new NodeListIterator(innerList);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ listiterator < n > $whitespace$ listiterator ( ) { $newline$ $indentation$ $//·custom·iterator·required,·to·ensure·that·the·relevant·`notifyelement...`·methods·are·called.$ $newline$ $indentation$ return $whitespace$ new $whitespace$ nodelistiterator ( innerlist ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ listiterator < n > $whitespace$ listiterator ( ) { $newline$ $indentation$ $//samples $whitespace$ = $whitespace$ new $whitespace$ nodelistiterator ( innerlist ) ; $newline$ $indentation$ }			
replace	520	527	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8472330570220947	HIGH	"		public boolean replace(N old, N replacement){
		    int i = indexOf(old);
		    if (i == -1) {
		        return false;
		    }
		    set(i, replacement);
		    return true;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ replace ( n $whitespace$ old , $whitespace$ n $whitespace$ replacement ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ indexof ( old ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ set ( i , $whitespace$ replacement ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ replace ( n $whitespace$ old, $whitespace$ n $whitespace$ replacement ) { $newline$ $indentation$ return $whitespace$ indexof ( old ) $whitespace$ < $whitespace$ replacement ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( n $whitespace$ old, $whitespace$ string $whitespace$ replacement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
register	503	508	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8553396463394165	HIGH	"		@Override
		public void register(AstObserver observer){
		    if (!this.observers.contains(observer)) {
		        this.observers.add(observer);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ register ( astobserver $whitespace$ observer ) { $newline$ $indentation$ if $whitespace$ ( ! this . observers . contains ( observer ) ) $whitespace$ { $newline$ $indentation$ this . observers . add ( observer ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ register ( astobserver $whitespace$ observer ) { $newline$ $indentation$ if $whitespace$ (! this. observers. contains ( observer ) ) $whitespace$ { $newline$ $indentation$ this. observers. add ( observer ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
previous	598	602	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8564667701721191	HIGH	"		@Override
		public N previous(){
		    current = iterator.previous();
		    return current;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ previous ( ) { $newline$ $indentation$ current $whitespace$ = $whitespace$ iterator . previous ( ) ; $newline$ $indentation$ return $whitespace$ current ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ previous ( ) { $newline$ $indentation$ current $whitespace$ = $whitespace$ iterator. previous ( ) ; $newline$ $indentation$ return $whitespace$ current ; $newline$ $indentation$ }			
getFirst	233	238	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8681109547615051	HIGH	"		public Optional<N> getFirst(){
		    if (isEmpty()) {
		        return Optional.empty();
		    }
		    return Optional.of(get(0));
		}"	$indentation$ public $whitespace$ optional < n > $whitespace$ getfirst ( ) { $newline$ $indentation$ if $whitespace$ ( isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( get ( $number$ ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < n > $whitespace$ getfirst ( ) { $newline$ $indentation$ if $whitespace$ ( isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( get ( $number$ ) ) ; $newline$ $indentation$ }			
iterator	134	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8705196976661682	HIGH	"		@Override
		public Iterator<N> iterator(){
		    // Custom iterator required, to ensure that the relevant `notifyElement...` methods are called.
		    return new NodeListIterator(innerList);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ $//·custom·iterator·required,·to·ensure·that·the·relevant·`notifyelement...`·methods·are·called.$ $newline$ $indentation$ return $whitespace$ new $whitespace$ nodelistiterator ( innerlist ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ new $whitespace$ nodelistiterator ( innerlist ) ; $newline$ $indentation$ }			
next	587	591	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.8850369453430176	HIGH	"		@Override
		public N next(){
		    current = iterator.next();
		    return current;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) { $newline$ $indentation$ current $whitespace$ = $whitespace$ iterator . next ( ) ; $newline$ $indentation$ return $whitespace$ current ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) { $newline$ $indentation$ current $whitespace$ = $whitespace$ iterator. next ( ) ; $newline$ $indentation$ return $whitespace$ current ; $newline$ $indentation$ }			
own	77	82	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.9090112447738647	HIGH	"		private void own(N node){
		    if (node == null) {
		        return;
		    }
		    setAsParentNodeOf(node);
		}"	$indentation$ private $whitespace$ void $whitespace$ own ( n $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ setasparentnodeof ( node ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ own ( n $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ setasparentnodeof ( node ) ; $newline$ $indentation$ } $newline$ $indentation$ setasparentnodeof ( node ) ; $newline$ $indentation$ }			
clear	405	410	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/NodeList.java	0.9381542205810548	HIGH	"		@Override
		public void clear(){
		    while (!isEmpty()) {
		        remove(0);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ clear ( ) { $newline$ $indentation$ while $whitespace$ ( ! isempty ( ) ) $whitespace$ { $newline$ $indentation$ remove ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ clear ( ) { $newline$ $indentation$ for ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ $number$ ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ remove ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
getMetaModel	164	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/PackageDeclaration.java	0.7104626893997192	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public PackageDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.packageDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ packagedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . packagedeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ packagedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. packagedeclarationmetamodel ; $newline$ $indentation$ }			
replace	170	187	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/PackageDeclaration.java	0.7108686566352844	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.set(i, (AnnotationExpr) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . set ( i , $whitespace$ ( annotationexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ node. get ( $number$ ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
accept	74	78	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/PackageDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setName	129	141	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/PackageDeclaration.java	0.8606417179107666	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public PackageDeclaration setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ packagedeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ packagedeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifAnnotationDeclaration	108	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationDeclaration.java	0.6526363492012024	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifAnnotationDeclaration(Consumer<AnnotationDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifannotationdeclaration ( consumer < annotationdeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifannotationdeclaration ( consumer < annotationdeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toAnnotationDeclaration	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationDeclaration.java	0.7050027251243591	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<AnnotationDeclaration> toAnnotationDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < annotationdeclaration > $whitespace$ toannotationdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < annotationdeclaration > $whitespace$ getannotationdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	90	94	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationDeclaration.java	0.7064561247825623	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public AnnotationDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.annotationDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . annotationdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. annotationdeclarationmetamodel ; $newline$ $indentation$ }			
isAnnotationDeclaration	96	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationDeclaration.java	0.8859739303588867	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isAnnotationDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
remove	199	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.6619640588760376	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (defaultValue != null) {
		        if (node == defaultValue) {
		            removeDefaultValue();
		            return true;
		        }
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( defaultvalue $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ defaultvalue ) $whitespace$ { $newline$ $indentation$ removedefaultvalue ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ defaultvalue ) $whitespace$ { $newline$ $indentation$ removedefaultvalue ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
toAnnotationMemberDeclaration	284	288	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.6782469153404236	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<AnnotationMemberDeclaration> toAnnotationMemberDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < annotationmemberdeclaration > $whitespace$ toannotationmemberdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < annotationmemberdeclaration > $whitespace$ toannotationmemberdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	226	230	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.6829789876937866	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public AnnotationMemberDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.annotationMemberDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . annotationmemberdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. annotationmemberdeclarationmetamodel ; $newline$ $indentation$ }			
clone	220	224	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.73427814245224	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public AnnotationMemberDeclaration clone(){
		    return (AnnotationMemberDeclaration) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( annotationmemberdeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( annotationmemberdeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
accept	95	99	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setName	171	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.8332308530807495	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AnnotationMemberDeclaration setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setModifiers	157	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.8510433435440063	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AnnotationMemberDeclaration setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ modifiers $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ this. modifiers $whitespace$ : $whitespace$ modifiers ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setType	185	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.851947546005249	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AnnotationMemberDeclaration setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationmemberdeclaration $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isAnnotationMemberDeclaration	261	265	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/AnnotationMemberDeclaration.java	0.8720458745956421	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isAnnotationMemberDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationmemberdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationmemberdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
clone	108	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/BodyDeclaration.java	0.6044329404830933	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public BodyDeclaration<?> clone(){
		    return (BodyDeclaration<?>) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ bodydeclaration < ? > $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( bodydeclaration < ? > ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ bodydeclaration <? > $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( bodydeclaration <? > ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
getMetaModel	114	118	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/BodyDeclaration.java	0.7193578481674194	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public BodyDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.bodyDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ bodydeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . bodydeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ bodydeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. bodydeclarationmetamodel ; $newline$ $indentation$ }			
remove	218	255	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.137395441532135	LOW	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < parameters.size(); i++) {
		        if (parameters.get(i) == node) {
		            parameters.remove(i);
		            return true;
		        }
		    }
		    if (receiverParameter != null) {
		        if (node == receiverParameter) {
		            removeReceiverParameter();
		            return true;
		        }
		    }
		    for (int i = 0; i < thrownExceptions.size(); i++) {
		        if (thrownExceptions.get(i) == node) {
		            thrownExceptions.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < typeParameters.size(); i++) {
		        if (typeParameters.get(i) == node) {
		            typeParameters.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( receiverparameter $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ receiverparameter ) $whitespace$ { $newline$ $indentation$ removereceiverparameter ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ thrownexceptions . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( thrownexceptions . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ thrownexceptions . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typeparameters . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ childt. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( childt $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ childt. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ childt. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( receiverparameter $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ receiverparameter ) $whitespace$ { $newline$ $indentation$ removereceiverparameter ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (			
replace	353	394	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.138835147023201	LOW	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.set(i, (Modifier) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    for (int i = 0; i < parameters.size(); i++) {
		        if (parameters.get(i) == node) {
		            parameters.set(i, (Parameter) replacementNode);
		            return true;
		        }
		    }
		    if (receiverParameter != null) {
		        if (node == receiverParameter) {
		            setReceiverParameter((ReceiverParameter) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < thrownExceptions.size(); i++) {
		        if (thrownExceptions.get(i) == node) {
		            thrownExceptions.set(i, (ReferenceType) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < typeParameters.size(); i++) {
		        if (typeParameters.get(i) == node) {
		            typeParameters.set(i, (TypeParameter) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . set ( i , $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters . set ( i , $whitespace$ ( parameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( receiverparameter $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ receiverparameter ) $whitespace$ { $newline$ $indentation$ setreceiverparameter ( ( receiverparameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ thrownexceptions . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( thrownexceptions . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ thrownexceptions . set ( i , $whitespace$ ( referencetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typeparameters . set ( i , $whitespace$ ( typeparameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ tree ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ childnode. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers. set ( i, $whitespace$ ( modifier ) $whitespace$ parametersnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ parametersnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters. set ( i, $whitespace$ ( parameter ) $whitespace$ parametersnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $			
equals	281	293	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.6400837898254395	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    Signature signature = (Signature) o;
		    if (!name.equals(signature.name))
		        return false;
		    if (!parameterTypes.equals(signature.parameterTypes))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ signature $whitespace$ signature $whitespace$ = $whitespace$ ( signature ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! name . equals ( signature . name ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! parametertypes . equals ( signature . parametertypes ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! name. equals ( signature. name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! name. equals ( signature. name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! parametertypes. equals ( signature. parametertypes ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
appendThrowsIfRequested	201	216	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.6424117684364319	MID	"		protected String appendThrowsIfRequested(boolean includingThrows){
		    StringBuilder sb = new StringBuilder();
		    if (includingThrows) {
		        boolean firstThrow = true;
		        for (ReferenceType thr : getThrownExceptions()) {
		            if (firstThrow) {
		                firstThrow = false;
		                sb.append("" throws "");
		            } else {
		                sb.append("", "");
		            }
		            sb.append(thr.toString(prettyPrinterNoCommentsConfiguration));
		        }
		    }
		    return sb.toString();
		}"	$indentation$ protected $whitespace$ string $whitespace$ appendthrowsifrequested ( boolean $whitespace$ includingthrows ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingthrows ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ firstthrow $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( referencetype $whitespace$ thr $whitespace$ : $whitespace$ getthrownexceptions ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstthrow ) $whitespace$ { $newline$ $indentation$ firstthrow $whitespace$ = $whitespace$ false ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb . append ( thr . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ string $whitespace$ appendthrowsifrequested ( boolean $whitespace$ includingthrows ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingthrows ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ firstthrow $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( referencetype $whitespace$ thr $whitespace$ : $whitespace$ getthrownexceptions ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstthrow ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb. append ( thr. tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
ifCallableDeclaration	408	412	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.6613953709602356	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifCallableDeclaration(Consumer<CallableDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcallabledeclaration ( consumer < callabledeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcallabledeclaration ( consumer < callabledeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
stripGenerics	323	328	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.6848748922348022	MID	"		private Type stripGenerics(Type type){
		    if (type instanceof NodeWithTypeArguments) {
		        ((NodeWithTypeArguments) type).setTypeArguments((NodeList<Type>) null);
		    }
		    return type;
		}"	$indentation$ private $whitespace$ type $whitespace$ stripgenerics ( type $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nodewithtypearguments ) $whitespace$ { $newline$ $indentation$ ( ( nodewithtypearguments ) $whitespace$ type ) . settypearguments ( ( nodelist < type > ) $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ private $whitespace$ type $whitespace$ stripgenerics ( type $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nodewithtypearguments ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( nodewithtypearguments ) $whitespace$ type ). settypearguments ( ( nodelist < type > ) $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
getThrownExceptions	157	161	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.6853474378585815	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NodeList<ReferenceType> getThrownExceptions(){
		    return thrownExceptions;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < referencetype > $whitespace$ getthrownexceptions ( ) { $newline$ $indentation$ return $whitespace$ thrownexceptions ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < referencetype > $whitespace$ getthrownexceptions ( ) { $newline$ $indentation$ return $whitespace$ thrownexceptions ; $newline$ $indentation$ }			
getTypeParameters	179	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.700580358505249	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NodeList<TypeParameter> getTypeParameters(){
		    return typeParameters;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < typeparameter > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ typeparameters ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < typeparameter > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ typeparameters ; $newline$ $indentation$ }			
getMetaModel	347	351	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.7062127590179443	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public CallableDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.callableDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ callabledeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . callabledeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ callabledeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. callabledeclarationmetamodel ; $newline$ $indentation$ }			
toCallableDeclaration	438	442	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.7216286659240723	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<CallableDeclaration> toCallableDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < callabledeclaration > $whitespace$ tocallabledeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < callabledeclaration > $whitespace$ tocallabledeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asCallableDeclaration	402	406	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.8342312574386597	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public CallableDeclaration asCallableDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ callabledeclaration $whitespace$ ascallabledeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ callabledeclaration $whitespace$ ascallabledeclaration ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setModifiers	97	111	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.8401302099227905	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		@SuppressWarnings(""unchecked"")
		public T setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return (T) this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return (T) this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ t $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ t $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $newline$ $indentation$? $whitespace$ ( t ) $whitespace$ this : $whitespace$ keys ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ t $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ }			
setParameters	141	155	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.8414021730422974	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		@SuppressWarnings(""unchecked"")
		public T setParameters(final NodeList<Parameter> parameters){
		    assertNotNull(parameters);
		    if (parameters == this.parameters) {
		        return (T) this;
		    }
		    notifyPropertyChange(ObservableProperty.PARAMETERS, this.parameters, parameters);
		    if (this.parameters != null)
		        this.parameters.setParentNode(null);
		    this.parameters = parameters;
		    setAsParentNodeOf(parameters);
		    return (T) this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ t $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertnotnull ( parameters ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this . parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . parameters , $whitespace$ this . parameters , $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this . parameters $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . parameters . setparentnode ( null ) ; $newline$ $indentation$ this . parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ t $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertthat ( parameters ). asparentnode ( ). operations ( ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this. parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. parameters, $whitespace$ this. parameters, $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this. parameters $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. parameters. setparentnode ( null ) ; $newline$ $indentation$ this. parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ ( t ) $whitespace$ this ; $newline$ $indentation$ }			
getName	113	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.8730396628379822	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SimpleName getName(){
		    return name;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ simplename $whitespace$ getname ( ) { $newline$ $indentation$ return $whitespace$ name ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ simplename $whitespace$ getname ( ) { $newline$ $indentation$ return $whitespace$ name ; $newline$ $indentation$ }			
isCallableDeclaration	396	400	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.891045331954956	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isCallableDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscallabledeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscallabledeclaration ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getTypeWithVarargsAsArray	330	339	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CallableDeclaration.java	0.915968120098114	HIGH	"		private Type getTypeWithVarargsAsArray(Parameter p){
		    /* A signature includes the varargs ellipsis.
		         This is a field on parameter which we lose when we only get the type,
		         so we represent it as an additional [] on the type. */
		    Type t = p.getType().clone();
		    if (p.isVarArgs()) {
		        t = new ArrayType(t);
		    }
		    return t;
		}"	$indentation$ private $whitespace$ type $whitespace$ gettypewithvarargsasarray ( parameter $whitespace$ p ) { $newline$ $indentation$ $/*·a·signature·includes·the·varargs·ellipsis.············this·is·a·field·on·parameter·which·we·lose·when·we·only·get·the·type,············so·we·represent·it·as·an·additional·[]·on·the·type.·*/$ $newline$ $indentation$ type $whitespace$ t $whitespace$ = $whitespace$ p . gettype ( ) . clone ( ) ; $newline$ $indentation$ if $whitespace$ ( p . isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ t $whitespace$ = $whitespace$ new $whitespace$ arraytype ( t ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t ; $newline$ $indentation$ }	$indentation$ private $whitespace$ type $whitespace$ gettypewithvarargsasarray ( parameter $whitespace$ p ) { $newline$ $indentation$ $/* $whitespace$ = $whitespace$ratioratio $whitespace$ = $whitespace$ $whitespace$ gettypefromvarargs ( p ) ; $newline$ $indentation$ if $whitespace$ ( p. isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ t $whitespace$ = $whitespace$ new $whitespace$ arraytype ( t ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ t $whitespace$ = $whitespace$ p. gettype ( ). clone ( ) ; $newline$ $indentation$ return $whitespace$ t ; $newline$ $indentation$ }			
getMetaModel	259	263	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.6769787073135376	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ClassOrInterfaceDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.classOrInterfaceDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . classorinterfacedeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. classorinterfacedeclarationmetamodel ; $newline$ $indentation$ }			
toClassOrInterfaceDeclaration	321	325	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.6782469153404236	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ClassOrInterfaceDeclaration> toClassOrInterfaceDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < classorinterfacedeclaration > $whitespace$ toclassorinterfacedeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < classorinterfacedeclaration > $whitespace$ getclassorinterfacedeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
setInterface	173	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.7186287045478821	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ClassOrInterfaceDeclaration setInterface(final boolean isInterface){
		    if (isInterface == this.isInterface) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INTERFACE, this.isInterface, isInterface);
		    this.isInterface = isInterface;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclaration $whitespace$ setinterface ( final $whitespace$ boolean $whitespace$ isinterface ) { $newline$ $indentation$ if $whitespace$ ( isinterface $whitespace$ == $whitespace$ this . isinterface ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . interface , $whitespace$ this . isinterface , $whitespace$ isinterface ) ; $newline$ $indentation$ this . isinterface $whitespace$ = $whitespace$ isinterface ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclaration $whitespace$ setinterface ( final $whitespace$ boolean $whitespace$ isinterface ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isinterface $whitespace$ = $whitespace$ this. isinterface ; $newline$ $indentation$ if $whitespace$ ( isinterface $whitespace$ == $whitespace$ this. isinterface ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. interface, $whitespace$ this. isinterface, $whitespace$ isinterface ) ; $newline$ $indentation$ this. isinterface $whitespace$ = $whitespace$ isinterface ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
clone	253	257	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.73427814245224	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public ClassOrInterfaceDeclaration clone(){
		    return (ClassOrInterfaceDeclaration) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclaration $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( classorinterfacedeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacedeclaration $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( classorinterfacedeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
accept	94	98	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
isClassOrInterfaceDeclaration	298	302	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ClassOrInterfaceDeclaration.java	0.8699805736541748	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isClassOrInterfaceDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassorinterfacedeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassorinterfacedeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
appendThrowsIfRequested	254	269	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.6424117684364319	MID	"		protected String appendThrowsIfRequested(boolean includingThrows){
		    StringBuilder sb = new StringBuilder();
		    if (includingThrows) {
		        boolean firstThrow = true;
		        for (ReferenceType thr : getThrownExceptions()) {
		            if (firstThrow) {
		                firstThrow = false;
		                sb.append("" throws "");
		            } else {
		                sb.append("", "");
		            }
		            sb.append(thr.toString(prettyPrinterNoCommentsConfiguration));
		        }
		    }
		    return sb.toString();
		}"	$indentation$ protected $whitespace$ string $whitespace$ appendthrowsifrequested ( boolean $whitespace$ includingthrows ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingthrows ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ firstthrow $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( referencetype $whitespace$ thr $whitespace$ : $whitespace$ getthrownexceptions ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstthrow ) $whitespace$ { $newline$ $indentation$ firstthrow $whitespace$ = $whitespace$ false ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb . append ( thr . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ string $whitespace$ appendthrowsifrequested ( boolean $whitespace$ includingthrows ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingthrows ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ firstthrow $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( referencetype $whitespace$ thr $whitespace$ : $whitespace$ getthrownexceptions ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstthrow ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb. append ( thr. tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
toCompactConstructorDeclaration	368	372	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.6565027236938477	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<CompactConstructorDeclaration> toCompactConstructorDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < compactconstructordeclaration > $whitespace$ tocompactconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < compactconstructordeclaration > $whitespace$ tocompactconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	304	308	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.6766848564147949	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public CompactConstructorDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.compactConstructorDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compactconstructordeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . compactconstructordeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compactconstructordeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. compactconstructordeclarationmetamodel ; $newline$ $indentation$ }			
getThrownExceptions	193	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.6853474378585815	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NodeList<ReferenceType> getThrownExceptions(){
		    return thrownExceptions;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < referencetype > $whitespace$ getthrownexceptions ( ) { $newline$ $indentation$ return $whitespace$ thrownexceptions ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < referencetype > $whitespace$ getthrownexceptions ( ) { $newline$ $indentation$ return $whitespace$ thrownexceptions ; $newline$ $indentation$ }			
getTypeParameters	214	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.700580358505249	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NodeList<TypeParameter> getTypeParameters(){
		    return typeParameters;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < typeparameter > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ typeparameters ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < typeparameter > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ typeparameters ; $newline$ $indentation$ }			
clone	298	302	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.7288342118263245	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public CompactConstructorDeclaration clone(){
		    return (CompactConstructorDeclaration) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compactconstructordeclaration $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( compactconstructordeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compactconstructordeclaration $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( compactconstructordeclaration ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
accept	112	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setModifiers	157	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.8358003497123718	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public CompactConstructorDeclaration setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ compactconstructordeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ compactconstructordeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ modifiers ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ compactconstructordeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. modifiers, $whitespace$ this. keys, $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this. modifiers $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. keys. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isCompactConstructorDeclaration	345	349	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.8635285496711731	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isCompactConstructorDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscompactconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscompactconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getName	172	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.8730396628379822	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SimpleName getName(){
		    return name;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ simplename $whitespace$ getname ( ) { $newline$ $indentation$ return $whitespace$ name ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ simplename $whitespace$ getname ( ) { $newline$ $indentation$ return $whitespace$ name ; $newline$ $indentation$ }			
getBody	124	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/CompactConstructorDeclaration.java	0.8757314085960388	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BlockStmt getBody(){
		    return body;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ getbody ( ) { $newline$ $indentation$ return $whitespace$ body ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ getbody ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ body ; $newline$ $indentation$ }			
ifConstructorDeclaration	235	239	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.6385279297828674	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifConstructorDeclaration(Consumer<ConstructorDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifconstructordeclaration ( consumer < constructordeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifconstructordeclaration ( consumer < constructordeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	204	208	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.6944940686225891	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ConstructorDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.constructorDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ constructordeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . constructordeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ constructordeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. constructordeclarationmetamodel ; $newline$ $indentation$ }			
toConstructorDeclaration	246	250	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.7027578353881836	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ConstructorDeclaration> toConstructorDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < constructordeclaration > $whitespace$ toconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ optional < constructordeclaration > $whitespace$ getcommonclass ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
replace	210	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.8337408304214478	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == body) {
		        setBody((BlockStmt) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ setbody ( ( blockstmt ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
getBody	101	105	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.8757314085960388	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BlockStmt getBody(){
		    return body;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ getbody ( ) { $newline$ $indentation$ return $whitespace$ body ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ getbody ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ body ; $newline$ $indentation$ }			
isConstructorDeclaration	223	227	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ConstructorDeclaration.java	0.8814594745635986	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isConstructorDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isconstructordeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
replace	188	211	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.6030399799346924	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < arguments.size(); i++) {
		        if (arguments.get(i) == node) {
		            arguments.set(i, (Expression) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < classBody.size(); i++) {
		        if (classBody.get(i) == node) {
		            classBody.set(i, (BodyDeclaration) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( arguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ arguments . set ( i , $whitespace$ ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ classbody . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( classbody . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ classbody . set ( i , $whitespace$ ( bodydeclaration ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( arguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ arguments. set ( i, $whitespace$ ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$			
ifEnumConstantDeclaration	225	229	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.626791775226593	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifEnumConstantDeclaration(Consumer<EnumConstantDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifenumconstantdeclaration ( consumer < enumconstantdeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifenum_declaration ( consumer < enumconstantdeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
remove	155	174	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.6747457981109619	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < arguments.size(); i++) {
		        if (arguments.get(i) == node) {
		            arguments.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < classBody.size(); i++) {
		        if (classBody.get(i) == node) {
		            classBody.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( arguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ arguments . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ classbody . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( classbody . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ classbody . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( arguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ arguments. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ classbody. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( classbody. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ classbody. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
toEnumConstantDeclaration	236	240	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.692721962928772	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<EnumConstantDeclaration> toEnumConstantDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < enumconstantdeclaration > $whitespace$ toenumconstantdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum $whitespace$ mainaction $whitespace$ { $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	182	186	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.6952804327011108	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public EnumConstantDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.enumConstantDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . enumconstantdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. enumconstantdeclarationmetamodel ; $newline$ $indentation$ }			
setName	141	153	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.8363056778907776	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public EnumConstantDeclaration setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclaration $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclaration $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setArguments	113	125	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.8398644924163818	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public EnumConstantDeclaration setArguments(final NodeList<Expression> arguments){
		    assertNotNull(arguments);
		    if (arguments == this.arguments) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ARGUMENTS, this.arguments, arguments);
		    if (this.arguments != null)
		        this.arguments.setParentNode(null);
		    this.arguments = arguments;
		    setAsParentNodeOf(arguments);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclaration $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ this . arguments ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . arguments , $whitespace$ this . arguments , $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this . arguments $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . arguments . setparentnode ( null ) ; $newline$ $indentation$ this . arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumconstantdeclaration $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. arguments, $whitespace$ this. arguments, $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this. arguments $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. arguments. setparentnode ( null ) ; $newline$ $indentation$ this. arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isEnumConstantDeclaration	213	217	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumConstantDeclaration.java	0.8798850774765015	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isEnumConstantDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenumconstantdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenum_declaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
replace	183	202	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.6275449395179749	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < entries.size(); i++) {
		        if (entries.get(i) == node) {
		            entries.set(i, (EnumConstantDeclaration) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < implementedTypes.size(); i++) {
		        if (implementedTypes.get(i) == node) {
		            implementedTypes.set(i, (ClassOrInterfaceType) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ entries . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entries . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ entries . set ( i , $whitespace$ ( enumconstantdeclaration ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ implementedtypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( implementedtypes . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ implementedtypes . set ( i , $whitespace$ ( classorinterfacetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. stream ( ) $newline$ $indentation$. anymatch ( i $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ entries. set ( i, $whitespace$ ( enumconstantdeclaration ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
remove	150	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.6615815758705139	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < entries.size(); i++) {
		        if (entries.get(i) == node) {
		            entries.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < implementedTypes.size(); i++) {
		        if (implementedTypes.get(i) == node) {
		            implementedTypes.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ entries . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entries . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ entries . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ implementedtypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( implementedtypes . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ implementedtypes . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ entries. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( isunused ( entries. get ( i ) ) ) $whitespace$ { $newline$ $indentation$ entries. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
ifEnumDeclaration	216	220	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.6788556575775146	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifEnumDeclaration(Consumer<EnumDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifenumdeclaration ( consumer < enumdeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifenumdeclaration ( consumer < enumdeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	177	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.7174985408782959	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public EnumDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.enumDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . enumdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. enumdeclarationmetamodel ; $newline$ $indentation$ }			
accept	79	83	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setEntries	115	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.850624144077301	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public EnumDeclaration setEntries(final NodeList<EnumConstantDeclaration> entries){
		    assertNotNull(entries);
		    if (entries == this.entries) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ENTRIES, this.entries, entries);
		    if (this.entries != null)
		        this.entries.setParentNode(null);
		    this.entries = entries;
		    setAsParentNodeOf(entries);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclaration $whitespace$ setentries ( final $whitespace$ nodelist < enumconstantdeclaration > $whitespace$ entries ) { $newline$ $indentation$ assertnotnull ( entries ) ; $newline$ $indentation$ if $whitespace$ ( entries $whitespace$ == $whitespace$ this . entries ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . entries , $whitespace$ this . entries , $whitespace$ entries ) ; $newline$ $indentation$ if $whitespace$ ( this . entries $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . entries . setparentnode ( null ) ; $newline$ $indentation$ this . entries $whitespace$ = $whitespace$ entries ; $newline$ $indentation$ setasparentnodeof ( entries ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclaration $whitespace$ setentries ( final $whitespace$ nodelist < enumconstantdeclaration > $whitespace$ entries ) { $newline$ $indentation$ assertnotnull ( entries ) ; $newline$ $indentation$ if $whitespace$ ( isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. entries, $whitespace$ this. entries, $whitespace$ entries ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asEnumDeclaration	210	214	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.856945812702179	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public EnumDeclaration asEnumDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclaration $whitespace$ asenumdeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enumdeclaration $whitespace$ asenumdeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isEnumDeclaration	204	208	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/EnumDeclaration.java	0.9036316871643066	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isEnumDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenumdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenumdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
createSetter	206	224	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.0061548464000225	LOW	"		public MethodDeclaration createSetter(){
		    if (getVariables().size() != 1)
		        throw new IllegalStateException(""You can use this only when the field declares only 1 variable name"");
		    Optional<ClassOrInterfaceDeclaration> parentClass = findAncestor(ClassOrInterfaceDeclaration.class);
		    Optional<EnumDeclaration> parentEnum = findAncestor(EnumDeclaration.class);
		    if (!(parentClass.isPresent() || parentEnum.isPresent()) || (parentClass.isPresent() && parentClass.get().isInterface()))
		        throw new IllegalStateException(""You can use this only when the field is attached to a class or an enum"");
		    VariableDeclarator variable = getVariable(0);
		    String fieldName = variable.getNameAsString();
		    String fieldNameUpper = fieldName.toUpperCase().substring(0, 1) + fieldName.substring(1, fieldName.length());
		    final MethodDeclaration setter;
		    setter = parentClass.map(clazz -> clazz.addMethod(""set"" + fieldNameUpper, Modifier.Keyword.PUBLIC)).orElseGet(() -> parentEnum.get().addMethod(""set"" + fieldNameUpper, Modifier.Keyword.PUBLIC));
		    setter.setType(new VoidType());
		    setter.getParameters().add(new Parameter(variable.getType(), fieldName));
		    BlockStmt blockStmt2 = new BlockStmt();
		    setter.setBody(blockStmt2);
		    blockStmt2.addStatement(new AssignExpr(new NameExpr(""this."" + fieldName), new NameExpr(fieldName), Operator.ASSIGN));
		    return setter;
		}"	$indentation$ public $whitespace$ methoddeclaration $whitespace$ createsetter ( ) { $newline$ $indentation$ if $whitespace$ ( getvariables ( ) . size ( ) $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ parentclass $whitespace$ = $whitespace$ findancestor ( classorinterfacedeclaration . class ) ; $newline$ $indentation$ optional < enumdeclaration > $whitespace$ parentenum $whitespace$ = $whitespace$ findancestor ( enumdeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parentclass . ispresent ( ) $whitespace$ || $whitespace$ parentenum . ispresent ( ) ) $whitespace$ || $whitespace$ ( parentclass . ispresent ( ) $whitespace$ && $whitespace$ parentclass . get ( ) . isinterface ( ) ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ variabledeclarator $whitespace$ variable $whitespace$ = $whitespace$ getvariable ( $number$ ) ; $newline$ $indentation$ string $whitespace$ fieldname $whitespace$ = $whitespace$ variable . getnameasstring ( ) ; $newline$ $indentation$ string $whitespace$ fieldnameupper $whitespace$ = $whitespace$ fieldname . touppercase ( ) . substring ( $number$ , $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname . substring ( $number$ , $whitespace$ fieldname . length ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ setter ; $newline$ $indentation$ setter $whitespace$ = $whitespace$ parentclass . map ( clazz $whitespace$ - > $whitespace$ clazz . addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper , $whitespace$ modifier . keyword . public ) ) . orelseget ( ( ) $whitespace$ - > $whitespace$ parentenum . get ( ) . addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper , $whitespace$ modifier . keyword . public ) ) ; $newline$ $indentation$ setter . settype ( new $whitespace$ voidtype ( ) ) ; $newline$ $indentation$ setter . getparameters ( ) . add ( new $whitespace$ parameter ( variable . gettype ( ) , $whitespace$ fieldname ) ) ; $newline$ $indentation$ blockstmt $whitespace$ blockstmt2 $whitespace$ = $whitespace$ new $whitespace$ blockstmt ( ) ; $newline$ $indentation$ setter . setbody ( blockstmt2 ) ; $newline$ $indentation$ blockstmt2 . addstatement ( new $whitespace$ assignexpr ( new $whitespace$ nameexpr ( $string$ $whitespace$ + $whitespace$ fieldname ) , $whitespace$ new $whitespace$ nameexpr ( fieldname ) , $whitespace$ operator . assign ) ) ; $newline$ $indentation$ return $whitespace$ setter ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methoddeclaration $whitespace$ createsetter ( ) { $newline$ $indentation$ if $whitespace$ ( getvariables ( ). size ( ) $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ parentclass $whitespace$ = $whitespace$ findancestor ( classorinterfacedeclaration. class ) ; $newline$ $indentation$ optional < enumdeclaration > $whitespace$ parentenum $whitespace$ = $whitespace$ findancestor ( enumdeclaration. class ) ; $newline$ $indentation$ if $whitespace$ (! ( parentclass. ispresent ( ) $whitespace$ || $whitespace$ parentenum. ispresent ( ) ) $whitespace$ || $whitespace$ ( parentclass. ispresent ( ) $whitespace$ && $whitespace$ parentclass. get ( ). isinterface ( ) ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ setter ; $newline$ $indentation$ setter $whitespace$ = $whitespace$ parentclass. map ( clazz $whitespace$ - > $whitespace$ clazz. addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper, $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname. substring ( $number$, $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname. substring ( $number$, $whitespace$ fieldname. length ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ setter ; $newline$ $indentation$ setter $whitespace$ = $whitespace$ parentclass. map ( clazz $whitespace$ - > $whitespace$ clazz. addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper, $whitespace$			
createGetter	179	196	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.0146382758393883	LOW	"		public MethodDeclaration createGetter(){
		    if (getVariables().size() != 1)
		        throw new IllegalStateException(""You can use this only when the field declares only 1 variable name"");
		    Optional<ClassOrInterfaceDeclaration> parentClass = findAncestor(ClassOrInterfaceDeclaration.class);
		    Optional<EnumDeclaration> parentEnum = findAncestor(EnumDeclaration.class);
		    if (!(parentClass.isPresent() || parentEnum.isPresent()) || (parentClass.isPresent() && parentClass.get().isInterface()))
		        throw new IllegalStateException(""You can use this only when the field is attached to a class or an enum"");
		    VariableDeclarator variable = getVariable(0);
		    String fieldName = variable.getNameAsString();
		    String fieldNameUpper = fieldName.toUpperCase().substring(0, 1) + fieldName.substring(1, fieldName.length());
		    final MethodDeclaration getter;
		    getter = parentClass.map(clazz -> clazz.addMethod(""get"" + fieldNameUpper, Modifier.Keyword.PUBLIC)).orElseGet(() -> parentEnum.get().addMethod(""get"" + fieldNameUpper, Modifier.Keyword.PUBLIC));
		    getter.setType(variable.getType());
		    BlockStmt blockStmt = new BlockStmt();
		    getter.setBody(blockStmt);
		    blockStmt.addStatement(new ReturnStmt(fieldName));
		    return getter;
		}"	$indentation$ public $whitespace$ methoddeclaration $whitespace$ creategetter ( ) { $newline$ $indentation$ if $whitespace$ ( getvariables ( ) . size ( ) $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ parentclass $whitespace$ = $whitespace$ findancestor ( classorinterfacedeclaration . class ) ; $newline$ $indentation$ optional < enumdeclaration > $whitespace$ parentenum $whitespace$ = $whitespace$ findancestor ( enumdeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parentclass . ispresent ( ) $whitespace$ || $whitespace$ parentenum . ispresent ( ) ) $whitespace$ || $whitespace$ ( parentclass . ispresent ( ) $whitespace$ && $whitespace$ parentclass . get ( ) . isinterface ( ) ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ variabledeclarator $whitespace$ variable $whitespace$ = $whitespace$ getvariable ( $number$ ) ; $newline$ $indentation$ string $whitespace$ fieldname $whitespace$ = $whitespace$ variable . getnameasstring ( ) ; $newline$ $indentation$ string $whitespace$ fieldnameupper $whitespace$ = $whitespace$ fieldname . touppercase ( ) . substring ( $number$ , $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname . substring ( $number$ , $whitespace$ fieldname . length ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getter ; $newline$ $indentation$ getter $whitespace$ = $whitespace$ parentclass . map ( clazz $whitespace$ - > $whitespace$ clazz . addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper , $whitespace$ modifier . keyword . public ) ) . orelseget ( ( ) $whitespace$ - > $whitespace$ parentenum . get ( ) . addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper , $whitespace$ modifier . keyword . public ) ) ; $newline$ $indentation$ getter . settype ( variable . gettype ( ) ) ; $newline$ $indentation$ blockstmt $whitespace$ blockstmt $whitespace$ = $whitespace$ new $whitespace$ blockstmt ( ) ; $newline$ $indentation$ getter . setbody ( blockstmt ) ; $newline$ $indentation$ blockstmt . addstatement ( new $whitespace$ returnstmt ( fieldname ) ) ; $newline$ $indentation$ return $whitespace$ getter ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methoddeclaration $whitespace$ creategetter ( ) { $newline$ $indentation$ if $whitespace$ ( getvariables ( ). size ( ) $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ parentclass $whitespace$ = $whitespace$ findancestor ( classorinterfacedeclaration. class ) ; $newline$ $indentation$ optional < enumdeclaration > $whitespace$ parentenum $whitespace$ = $whitespace$ findancestor ( enumdeclaration. class ) ; $newline$ $indentation$ if $whitespace$ (! ( parentclass. ispresent ( ) $whitespace$ || $whitespace$ parentenum. ispresent ( ) ) $whitespace$ || $whitespace$ ( parentclass. ispresent ( ) $whitespace$ && $whitespace$ parentclass. get ( ). isinterface ( ) ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getter ; $newline$ $indentation$ getter $whitespace$ = $whitespace$ parentclass. map ( clazz $whitespace$ - > $whitespace$ clazz. addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper, $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname. substring ( $number$, $whitespace$ $number$ ) $whitespace$ + $whitespace$ fieldname. substring ( $number$, $whitespace$ fieldname. length ( ) ) ; $newline$ $indentation$ final $whitespace$ methoddeclaration $whitespace$ getter ; $newline$ $indentation$ getter $whitespace$ = $whitespace$ parentclass. map ( clazz $whitespace$ - > $whitespace$ clazz. addmethod ( $string$ $whitespace$ + $whitespace$ fieldnameupper, $whitespace$			
isDeclaredInInterface	269	276	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.0833941772580146	LOW	"		private boolean isDeclaredInInterface(){
		    Optional<TypeDeclaration> parentType = findAncestor(TypeDeclaration.class);
		    return parentType.filter(BodyDeclaration::isClassOrInterfaceDeclaration).map(BodyDeclaration::asClassOrInterfaceDeclaration).map(ClassOrInterfaceDeclaration::isInterface).orElse(false);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isdeclaredininterface ( ) { $newline$ $indentation$ optional < typedeclaration > $whitespace$ parenttype $whitespace$ = $whitespace$ findancestor ( typedeclaration . class ) ; $newline$ $indentation$ return $whitespace$ parenttype . filter ( bodydeclaration : : isclassorinterfacedeclaration ) . map ( bodydeclaration : : asclassorinterfacedeclaration ) . map ( classorinterfacedeclaration : : isinterface ) . orelse ( false ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isdeclaredininterface ( ) { $newline$ $indentation$ optional < typedeclaration > $whitespace$ parenttype $whitespace$ = $whitespace$ findancestor ( typedeclaration. class ) ; $newline$ $indentation$ return $whitespace$ parenttype. filter ( bodydeclaration : : isclassorinterfacedeclaration ). map ( bodydeclaration : : asclassorinterfacedeclaration ). map ( classorinterfacedeclaration : : isinterface ). orelse ( false ) ; $newline$ $indentation$ }			
replace	311	330	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.6464141607284546	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.set(i, (Modifier) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < variables.size(); i++) {
		        if (variables.get(i) == node) {
		            variables.set(i, (VariableDeclarator) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . set ( i , $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ variables . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( variables . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ variables . set ( i , $whitespace$ ( variabledeclarator ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ $newline$ $indentation$ node $whitespace$ succ $whitespace$ = $whitespace$ null ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ succ. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( succ. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers. set ( i, $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
remove	278	297	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.6747457981109619	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < variables.size(); i++) {
		        if (variables.get(i) == node) {
		            variables.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ variables . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( variables . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ variables . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ keys. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( keys. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
ifFieldDeclaration	344	348	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.6751959919929504	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifFieldDeclaration(Consumer<FieldDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iffielddeclaration ( consumer < fielddeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iffielddeclaration ( consumer < fielddeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getVariables	135	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.7199944257736206	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NodeList<VariableDeclarator> getVariables(){
		    return variables;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < variabledeclarator > $whitespace$ getvariables ( ) { $newline$ $indentation$ return $whitespace$ variables ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nodelist < floattoolargeexception > $whitespace$ getvariables ( ) { $newline$ $indentation$ return $whitespace$ variables ; $newline$ $indentation$ }			
getMetaModel	305	309	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.7239760756492615	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public FieldDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.fieldDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . fielddeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. fielddeclarationmetamodel ; $newline$ $indentation$ }			
accept	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setModifiers	141	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.8493773341178894	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public FieldDeclaration setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclaration $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ modifiers ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. modifiers, $whitespace$ this. modifiers, $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this. modifiers $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asFieldDeclaration	338	342	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.8513869643211365	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public FieldDeclaration asFieldDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclaration $whitespace$ asfielddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fielddeclaration $whitespace$ getfielddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isFieldDeclaration	332	336	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/FieldDeclaration.java	0.9014928340911864	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isFieldDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfielddeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfieldinterface ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifInitializerDeclaration	156	160	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.6342742443084717	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifInitializerDeclaration(Consumer<InitializerDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifinitializerdeclaration ( consumer < initializerdeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifinitializerdeclaration ( consumer < initializerdeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.6983804106712341	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public InitializerDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.initializerDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ initializerdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . initializerdeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ initializerdeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. initializerdeclarationmetamodel ; $newline$ $indentation$ }			
toInitializerDeclaration	162	166	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.7027578353881836	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<InitializerDeclaration> toInitializerDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < initializerdeclaration > $whitespace$ toinitializerdeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < initializerdeclaration > $whitespace$ getvariantcontext ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	73	77	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
replace	131	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.8337408304214478	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == body) {
		        setBody((BlockStmt) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ setbody ( ( blockstmt ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
setBody	95	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.8372612595558167	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public InitializerDeclaration setBody(final BlockStmt body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ initializerdeclaration $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ initializerdeclaration $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isInitializerDeclaration	144	148	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/InitializerDeclaration.java	0.8814594745635986	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isInitializerDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinitializerdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinitializerdeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isImplicitlyAbstract	283	288	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.0177070945501327	LOW	"		private boolean isImplicitlyAbstract(){
		    return hasParentNode() && getParentNode().get() instanceof ClassOrInterfaceDeclaration && ((ClassOrInterfaceDeclaration) getParentNode().get()).isInterface() && Arrays.asList(Keyword.STATIC, Keyword.DEFAULT, Keyword.PRIVATE).stream().noneMatch(modifier -> hasModifier(modifier));
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitlyabstract ( ) { $newline$ $indentation$ return $whitespace$ hasparentnode ( ) $whitespace$ && $whitespace$ getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ classorinterfacedeclaration $whitespace$ && $whitespace$ ( ( classorinterfacedeclaration ) $whitespace$ getparentnode ( ) . get ( ) ) . isinterface ( ) $whitespace$ && $whitespace$ arrays . aslist ( keyword . static , $whitespace$ keyword . default , $whitespace$ keyword . private ) . stream ( ) . nonematch ( modifier $whitespace$ - > $whitespace$ hasmodifier ( modifier ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitlyabstract ( ) { $newline$ $indentation$ return $whitespace$ hasparentnode ( ) $whitespace$ && $whitespace$ getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ classorinterfacedeclaration $whitespace$ && $whitespace$ ( ( classorinterfacedeclaration ) $whitespace$ getparentnode ( ). get ( ) ). isinterface ( ) $whitespace$ && $whitespace$ arrays. aslist ( keyword. static, $whitespace$ keyword. default, $whitespace$ keyword. private ). stream ( ). nonematch ( modifier $whitespace$ - > $whitespace$ hasmodifier ( modifier ) ) ; $newline$ $indentation$ }			
isImplicitlyPublic	267	272	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.1056760400533676	LOW	"		private boolean isImplicitlyPublic(){
		    return getAccessSpecifier() == AccessSpecifier.NONE && hasParentNode() && getParentNode().get() instanceof ClassOrInterfaceDeclaration && ((ClassOrInterfaceDeclaration) getParentNode().get()).isInterface();
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitlypublic ( ) { $newline$ $indentation$ return $whitespace$ getaccessspecifier ( ) $whitespace$ == $whitespace$ accessspecifier . none $whitespace$ && $whitespace$ hasparentnode ( ) $whitespace$ && $whitespace$ getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ classorinterfacedeclaration $whitespace$ && $whitespace$ ( ( classorinterfacedeclaration ) $whitespace$ getparentnode ( ) . get ( ) ) . isinterface ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isimplicitlypublic ( ) { $newline$ $indentation$ return $whitespace$ getaccessspecifier ( ) $whitespace$ == $whitespace$ accessspecifier. none $whitespace$ && $whitespace$ hasparentnode ( ) $whitespace$ && $whitespace$ getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ classorinterfacedeclaration $whitespace$ && $whitespace$ ( ( classorinterfacedeclaration ) $whitespace$ getparentnode ( ). get ( ) ). isinterface ( ) ; $newline$ $indentation$ }			
getDeclarationAsString	193	238	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.2410989701747894	LOW	"		@Override
		public String getDeclarationAsString(boolean includingModifiers, boolean includingThrows, boolean includingParameterName){
		    StringBuilder sb = new StringBuilder();
		    if (includingModifiers) {
		        AccessSpecifier accessSpecifier = getAccessSpecifier();
		        sb.append(accessSpecifier.asString()).append("" "");
		        if (isStatic()) {
		            sb.append(""static "");
		        }
		        if (isAbstract()) {
		            sb.append(""abstract "");
		        }
		        if (isFinal()) {
		            sb.append(""final "");
		        }
		        if (isNative()) {
		            sb.append(""native "");
		        }
		        if (isSynchronized()) {
		            sb.append(""synchronized "");
		        }
		    }
		    sb.append(getType().toString(prettyPrinterNoCommentsConfiguration));
		    sb.append("" "");
		    sb.append(getName().toString(prettyPrinterNoCommentsConfiguration));
		    sb.append(""("");
		    boolean firstParam = true;
		    for (Parameter param : getParameters()) {
		        if (firstParam) {
		            firstParam = false;
		        } else {
		            sb.append("", "");
		        }
		        if (includingParameterName) {
		            sb.append(param.toString(prettyPrinterNoCommentsConfiguration));
		        } else {
		            sb.append(param.getType().toString(prettyPrinterNoCommentsConfiguration));
		            if (param.isVarArgs()) {
		                sb.append(""..."");
		            }
		        }
		    }
		    sb.append("")"");
		    sb.append(appendThrowsIfRequested(includingThrows));
		    return sb.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getdeclarationasstring ( boolean $whitespace$ includingmodifiers , $whitespace$ boolean $whitespace$ includingthrows , $whitespace$ boolean $whitespace$ includingparametername ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingmodifiers ) $whitespace$ { $newline$ $indentation$ accessspecifier $whitespace$ accessspecifier $whitespace$ = $whitespace$ getaccessspecifier ( ) ; $newline$ $indentation$ sb . append ( accessspecifier . asstring ( ) ) . append ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( isstatic ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isabstract ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isfinal ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isnative ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issynchronized ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ sb . append ( gettype ( ) . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ sb . append ( getname ( ) . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ boolean $whitespace$ firstparam $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ param $whitespace$ : $whitespace$ getparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstparam ) $whitespace$ { $newline$ $indentation$ firstparam $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( includingparametername ) $whitespace$ { $newline$ $indentation$ sb . append ( param . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( param . gettype ( ) . tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ if $whitespace$ ( param . isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ sb . append ( appendthrowsifrequested ( includingthrows ) ) ; $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getdeclarationasstring ( boolean $whitespace$ includingmodifiers, $whitespace$ boolean $whitespace$ includingthrows, $whitespace$ boolean $whitespace$ includingparametername ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( includingmodifiers ) $whitespace$ { $newline$ $indentation$ accessspecifier $whitespace$ accessspecifier $whitespace$ = $whitespace$ getaccessspecifier ( ) ; $newline$ $indentation$ sb. append ( accessspecifier. asstring ( ) ). append ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( isstatic ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isabstract ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isfinal ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issynchronized ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ sb. append ( gettype ( ). tostring ( prettyprinternocommentsconfiguration ) ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ sb. append ( getname ( ) ) ;			
ifMethodDeclaration	380	384	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.6696603298187256	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifMethodDeclaration(Consumer<MethodDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethoddeclaration ( consumer < methoddeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethoddeclaration ( consumer < methoddeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	343	347	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public MethodDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.methodDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . methoddeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ methoddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. methoddeclarationmetamodel ; $newline$ $indentation$ }			
getBody	112	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.7270535230636597	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Optional<BlockStmt> getBody(){
		    return Optional.ofNullable(body);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < blockstmt > $whitespace$ getbody ( ) { $newline$ $indentation$ return $whitespace$ optional . ofnullable ( body ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < blockstmt > $whitespace$ getbody ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. ofnullable ( body ) ; $newline$ $indentation$ }			
toMethodDeclaration	391	395	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.7366869449615479	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<MethodDeclaration> toMethodDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < methoddeclaration > $whitespace$ tomethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < methoddeclaration > $whitespace$ tomethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	100	104	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	124	136	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8416385054588318	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MethodDeclaration setBody(final BlockStmt body){
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclaration $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclaration $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asMethodDeclaration	374	378	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8489890694618225	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public MethodDeclaration asMethodDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclaration $whitespace$ asmethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ methoddeclaration $whitespace$ asmethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
remove	316	329	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8518498539924622	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (body != null) {
		        if (node == body) {
		            removeBody();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( body $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ removebody ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( body $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ removebody ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
setType	144	157	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8523617386817932	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MethodDeclaration setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclaration $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methoddeclaration $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getType	138	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.8963356614112854	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Type getType(){
		    return type;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ gettype ( ) { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ gettype ( ) { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
isMethodDeclaration	368	372	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/MethodDeclaration.java	0.896767258644104	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isMethodDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethoddeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setAnnotations	185	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8332895636558533	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Parameter setAnnotations(final NodeList<AnnotationExpr> annotations){
		    assertNotNull(annotations);
		    if (annotations == this.annotations) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ANNOTATIONS, this.annotations, annotations);
		    if (this.annotations != null)
		        this.annotations.setParentNode(null);
		    this.annotations = annotations;
		    setAsParentNodeOf(annotations);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this . annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . annotations , $whitespace$ this . annotations , $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this . annotations $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . annotations . setparentnode ( null ) ; $newline$ $indentation$ this . annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this. annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. annotations, $whitespace$ this. annotations, $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this. annotations $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. annotations. setparentnode ( null ) ; $newline$ $indentation$ this. annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
clone	273	277	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8350070118904114	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Parameter clone(){
		    return (Parameter) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( parameter ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( parameter ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setName	199	211	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8483080267906189	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Parameter setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setModifiers	213	225	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8650616407394409	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Parameter setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ modifiers ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. modifiers, $whitespace$ this. modifiers, $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this. modifiers $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setType	133	145	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8667063117027283	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Parameter setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ parameter $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isFinal	334	345	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/Parameter.java	0.8914430141448975	HIGH	"		@Override
		public boolean isFinal(){
		    // RecordDeclaration-specific code
		    if (getParentNode().isPresent()) {
		        Node parentNode = getParentNode().get();
		        if (parentNode instanceof RecordDeclaration) {
		            return true;
		        }
		    }
		    // Otherwise use the default implementation.
		    return NodeWithFinalModifier.super.isFinal();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfinal ( ) { $newline$ $indentation$ $//·recorddeclaration-specific·code$ $newline$ $indentation$ if $whitespace$ ( getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ recorddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise·use·the·default·implementation.$ $newline$ $indentation$ return $whitespace$ nodewithfinalmodifier . super . isfinal ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfinal ( ) { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ = $whitespace$ getparentnode ( ). ispresent ( ) ; $newline$ $indentation$ if $whitespace$ ( getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ get $whitespace$ the $whitespace$ current $whitespace$ node $whitespace$ only $whitespace$ has $whitespace$ been $whitespace$ eliminated $newline$ $indentation$ return $whitespace$ nodewithfinalmodifier. super. isfinal ( ) ; $newline$ $indentation$ }			
replace	198	219	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java	0.6915895938873291	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.set(i, (AnnotationExpr) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    if (node == type) {
		        setType((Type) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . set ( i , $whitespace$ ( annotationexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ type ) $whitespace$ { $newline$ $indentation$ settype ( ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$			
getMetaModel	158	162	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java	0.7251062989234924	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ReceiverParameterMetaModel getMetaModel(){
		    return JavaParserMetaModel.receiverParameterMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparametermetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . receiverparametermetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparametermetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. receiverparametermetamodel ; $newline$ $indentation$ }			
accept	95	99	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setType	112	124	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java	0.8614523410797119	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ReceiverParameter setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparameter $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparameter $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	169	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/ReceiverParameter.java	0.8625456690788269	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ReceiverParameter setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparameter $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ receiverparameter $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
replace	259	290	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.2680456042289734	LOW	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < implementedTypes.size(); i++) {
		        if (implementedTypes.get(i) == node) {
		            implementedTypes.set(i, (ClassOrInterfaceType) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < parameters.size(); i++) {
		        if (parameters.get(i) == node) {
		            parameters.set(i, (Parameter) replacementNode);
		            return true;
		        }
		    }
		    if (receiverParameter != null) {
		        if (node == receiverParameter) {
		            setReceiverParameter((ReceiverParameter) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < typeParameters.size(); i++) {
		        if (typeParameters.get(i) == node) {
		            typeParameters.set(i, (TypeParameter) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ implementedtypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( implementedtypes . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ implementedtypes . set ( i , $whitespace$ ( classorinterfacetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters . set ( i , $whitespace$ ( parameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( receiverparameter $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ receiverparameter ) $whitespace$ { $newline$ $indentation$ setreceiverparameter ( ( receiverparameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typeparameters . set ( i , $whitespace$ ( typeparameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ graytypes. size ( ) ; $whitespace$ $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isallinlowercase ( ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ implementedtypes. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( implementedtypes. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ implementedtypes. set ( i, $whitespace$ ( classorinterfacetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$			
ifRecordDeclaration	220	224	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.6655811071395874	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifRecordDeclaration(Consumer<RecordDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifrecorddeclaration ( consumer < recorddeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifrecorddeclaration ( consumer < recorddeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	298	302	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public RecordDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.recordDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . recorddeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. recorddeclarationmetamodel ; $newline$ $indentation$ }			
toRecordDeclaration	214	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.7294933795928955	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<RecordDeclaration> toRecordDeclaration(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < recorddeclaration > $whitespace$ torecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < recorddeclaration > $whitespace$ torecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asRecordDeclaration	208	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.8489890694618225	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public RecordDeclaration asRecordDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclaration $whitespace$ asrecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclaration $whitespace$ asrecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setParameters	317	329	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.8666015863418579	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public RecordDeclaration setParameters(final NodeList<Parameter> parameters){
		    assertNotNull(parameters);
		    if (parameters == this.parameters) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.PARAMETERS, this.parameters, parameters);
		    if (this.parameters != null)
		        this.parameters.setParentNode(null);
		    this.parameters = parameters;
		    setAsParentNodeOf(parameters);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclaration $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertnotnull ( parameters ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this . parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . parameters , $whitespace$ this . parameters , $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this . parameters $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . parameters . setparentnode ( null ) ; $newline$ $indentation$ this . parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ recorddeclaration $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertnotnull ( parameters ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this. parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. parameters, $whitespace$ this. parameters, $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this. parameters $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. parameters. setparentnode ( null ) ; $newline$ $indentation$ this. parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isRecordDeclaration	202	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.896767258644104	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isRecordDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isrecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isrecorddeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isStatic	374	384	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/RecordDeclaration.java	0.902500331401825	HIGH	"		@Override
		public boolean isStatic(){
		    if (getParentNode().isPresent()) {
		        Node parentNode = getParentNode().get();
		        if (!(parentNode instanceof CompilationUnit)) {
		            return true;
		        }
		    }
		    // Otherwise use the default method.
		    return super.isStatic();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isstatic ( ) { $newline$ $indentation$ if $whitespace$ ( getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parentnode $whitespace$ instanceof $whitespace$ compilationunit ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise·use·the·default·method.$ $newline$ $indentation$ return $whitespace$ super . isstatic ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isstatic ( ) { $newline$ $indentation$ return $whitespace$ getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$! getparentnode ( ). get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ static $whitespace$ isstatic ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isstatic ( ) ; $newline$ $indentation$ } $newline$ $indentation$ static $whitespace$ node $whitespace$ parentnode $whitespace$ = $whitespace$ getparentnode ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentnode $whitespace$ instanceof $whitespace$ compilationunit ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getFullyQualifiedName	204	209	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.0108688902109861	LOW	"		public Optional<String> getFullyQualifiedName(){
		    if (isTopLevelType()) {
		        return findCompilationUnit().map(cu -> cu.getPackageDeclaration().map(pd -> pd.getNameAsString()).map(pkg -> pkg + ""."" + getNameAsString()).orElseGet(() -> getNameAsString()));
		    }
		    return findAncestor(TypeDeclaration.class).map(td -> (TypeDeclaration<?>) td).flatMap(td -> td.getFullyQualifiedName().map(fqn -> fqn + ""."" + getNameAsString()));
		}"	$indentation$ public $whitespace$ optional < string > $whitespace$ getfullyqualifiedname ( ) { $newline$ $indentation$ if $whitespace$ ( istopleveltype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ findcompilationunit ( ) . map ( cu $whitespace$ - > $whitespace$ cu . getpackagedeclaration ( ) . map ( pd $whitespace$ - > $whitespace$ pd . getnameasstring ( ) ) . map ( pkg $whitespace$ - > $whitespace$ pkg $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ getnameasstring ( ) ) . orelseget ( ( ) $whitespace$ - > $whitespace$ getnameasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ findancestor ( typedeclaration . class ) . map ( td $whitespace$ - > $whitespace$ ( typedeclaration < ? > ) $whitespace$ td ) . flatmap ( td $whitespace$ - > $whitespace$ td . getfullyqualifiedname ( ) . map ( fqn $whitespace$ - > $whitespace$ fqn $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ getnameasstring ( ) ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < string > $whitespace$ getfullyqualifiedname ( ) { $newline$ $indentation$ if $whitespace$ ( istopleveltype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ findcompilationunit ( ). map ( cu $whitespace$ - > $whitespace$ cu. getpackagedeclaration ( ). map ( pd $whitespace$ - > $whitespace$ pd. getnameasstring ( ) ). orelseget ( ( ) $whitespace$ - > $whitespace$ getnameasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ findancestor ( typedeclaration. class ). map ( td $whitespace$ - > $whitespace$ ( typedeclaration <? > ) $whitespace$ td ). flatmap ( td $whitespace$ - > $whitespace$ td. getfullyqualifiedname ( ). map ( e $whitespace$ - > $whitespace$ e. getnameasstring ( ) ) ) ; $newline$ $indentation$ }			
clone	219	223	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.6022332310676575	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public TypeDeclaration<?> clone(){
		    return (TypeDeclaration<?>) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclaration < ? > $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( typedeclaration < ? > ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclaration <? > $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( typedeclaration <? > ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
replace	231	254	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.6037211418151855	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < members.size(); i++) {
		        if (members.get(i) == node) {
		            members.set(i, (BodyDeclaration) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.set(i, (Modifier) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ members . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( members . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ members . set ( i , $whitespace$ ( bodydeclaration ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . set ( i , $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. stream ( ) $newline$ $indentation$. anymatch ( condition $whitespace$ - > $whitespace$ condition. set ( index, $whitespace$ replacementnode ) ) ; $newline$ $indentation$ } $newline$ $indentation$			
ifTypeDeclaration	268	272	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.6788556575775146	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifTypeDeclaration(Consumer<TypeDeclaration> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftypedeclaration ( consumer < typedeclaration > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftypedeclaration ( consumer < typedeclaration > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
remove	161	180	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.6803112030029297	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < members.size(); i++) {
		        if (members.get(i) == node) {
		            members.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ members . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( members . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ members . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ members. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( members. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
getMetaModel	225	229	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.7174985408782959	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public TypeDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.typeDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . typedeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. typedeclarationmetamodel ; $newline$ $indentation$ }			
asTypeDeclaration	262	266	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.8580688834190369	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public TypeDeclaration asTypeDeclaration(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclaration $whitespace$ astypedeclaration ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typedeclaration $whitespace$ $whitespace$ ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isTypeDeclaration	256	260	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/TypeDeclaration.java	0.9036316871643066	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isTypeDeclaration(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istypedeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istypedeclaration ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
propertyChange	117	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.1122121810913086	LOW	"		@Override
		public void propertyChange(Node observedNode, ObservableProperty property, Object oldValue, Object newValue){
		    if (property == ObservableProperty.TYPE) {
		        VariableDeclarator vd = VariableDeclarator.this;
		        if (vd.getParentNode().isPresent() && vd.getParentNode().get() instanceof NodeWithVariables) {
		            NodeWithVariables<?> nodeWithVariables = (NodeWithVariables<?>) vd.getParentNode().get();
		            // We calculate the value the property will assume after the change will be completed
		            Optional<Type> currentMaxCommonType = nodeWithVariables.getMaximumCommonType();
		            List<Type> types = new LinkedList<>();
		            int index = nodeWithVariables.getVariables().indexOf(vd);
		            for (int i = 0; i < nodeWithVariables.getVariables().size(); i++) {
		                if (i == index) {
		                    types.add((Type) newValue);
		                } else {
		                    types.add(nodeWithVariables.getVariable(i).getType());
		                }
		            }
		            Optional<Type> newMaxCommonType = NodeWithVariables.calculateMaximumCommonType(types);
		            ((Node) nodeWithVariables).notifyPropertyChange(ObservableProperty.MAXIMUM_COMMON_TYPE, currentMaxCommonType.orElse(null), newMaxCommonType.orElse(null));
		        }
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ propertychange ( node $whitespace$ observednode , $whitespace$ observableproperty $whitespace$ property , $whitespace$ object $whitespace$ oldvalue , $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty . type ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ vd $whitespace$ = $whitespace$ variabledeclarator . this ; $newline$ $indentation$ if $whitespace$ ( vd . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ vd . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ nodewithvariables ) $whitespace$ { $newline$ $indentation$ nodewithvariables < ? > $whitespace$ nodewithvariables $whitespace$ = $whitespace$ ( nodewithvariables < ? > ) $whitespace$ vd . getparentnode ( ) . get ( ) ; $newline$ $indentation$ $//·we·calculate·the·value·the·property·will·assume·after·the·change·will·be·completed$ $newline$ $indentation$ optional < type > $whitespace$ currentmaxcommontype $whitespace$ = $whitespace$ nodewithvariables . getmaximumcommontype ( ) ; $newline$ $indentation$ list < type > $whitespace$ types $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ nodewithvariables . getvariables ( ) . indexof ( vd ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodewithvariables . getvariables ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ index ) $whitespace$ { $newline$ $indentation$ types . add ( ( type ) $whitespace$ newvalue ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ types . add ( nodewithvariables . getvariable ( i ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ optional < type > $whitespace$ newmaxcommontype $whitespace$ = $whitespace$ nodewithvariables . calculatemaximumcommontype ( types ) ; $newline$ $indentation$ ( ( node ) $whitespace$ nodewithvariables ) . notifypropertychange ( observableproperty . maximum_common_type , $whitespace$ currentmaxcommontype . orelse ( null ) , $whitespace$ newmaxcommontype . orelse ( null ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ propertychange ( node $whitespace$ observednode, $whitespace$ observableproperty $whitespace$ property, $whitespace$ object $whitespace$ oldvalue, $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty. type ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ vd $whitespace$ = $whitespace$ variabledeclarator. this ; $newline$ $indentation$ if $whitespace$ ( vd. getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ vd. getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ nodewithvariables ) $whitespace$ { $newline$ $indentation$ nodewithvariables <? > $whitespace$ nodewithvariables $whitespace$ = $whitespace$ ( nodewithvariables <? > ) $whitespace$ vd. getparentnode ( ). get ( ) ; $newline$ $indentation$ $//gd $whitespace$ = $whitespace$ nodewithvariables. getmaximumcommontype ( ) ; $newline$ $indentation$ list < type > $whitespace$ types $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ nodewithvariables. getvariables ( ). indexof ( vd ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodewithvariables. getvariables ( ). size ( ) ; $whitespace$ i			
customInitialization	111	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.1437675692141056	LOW	"		@Override
		protected void customInitialization(){
		    // We register an observer on the type property. When it is changed the MaximumCommonType is changes as well,
		    // because it is derived from the type of the variables it contains, for this reason we notify about the change
		    register(new AstObserverAdapter() {
		
		        @Override
		        public void propertyChange(Node observedNode, ObservableProperty property, Object oldValue, Object newValue) {
		            if (property == ObservableProperty.TYPE) {
		                VariableDeclarator vd = VariableDeclarator.this;
		                if (vd.getParentNode().isPresent() && vd.getParentNode().get() instanceof NodeWithVariables) {
		                    NodeWithVariables<?> nodeWithVariables = (NodeWithVariables<?>) vd.getParentNode().get();
		                    // We calculate the value the property will assume after the change will be completed
		                    Optional<Type> currentMaxCommonType = nodeWithVariables.getMaximumCommonType();
		                    List<Type> types = new LinkedList<>();
		                    int index = nodeWithVariables.getVariables().indexOf(vd);
		                    for (int i = 0; i < nodeWithVariables.getVariables().size(); i++) {
		                        if (i == index) {
		                            types.add((Type) newValue);
		                        } else {
		                            types.add(nodeWithVariables.getVariable(i).getType());
		                        }
		                    }
		                    Optional<Type> newMaxCommonType = NodeWithVariables.calculateMaximumCommonType(types);
		                    ((Node) nodeWithVariables).notifyPropertyChange(ObservableProperty.MAXIMUM_COMMON_TYPE, currentMaxCommonType.orElse(null), newMaxCommonType.orElse(null));
		                }
		            }
		        }
		    });
		}"	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ custominitialization ( ) { $newline$ $indentation$ $//·we·register·an·observer·on·the·type·property.·when·it·is·changed·the·maximumcommontype·is·changes·as·well,$ $newline$ $indentation$ $//·because·it·is·derived·from·the·type·of·the·variables·it·contains,·for·this·reason·we·notify·about·the·change$ $newline$ $indentation$ register ( new $whitespace$ astobserveradapter ( ) $whitespace$ { $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ propertychange ( node $whitespace$ observednode , $whitespace$ observableproperty $whitespace$ property , $whitespace$ object $whitespace$ oldvalue , $whitespace$ object $whitespace$ newvalue ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty . type ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ vd $whitespace$ = $whitespace$ variabledeclarator . this ; $newline$ $indentation$ if $whitespace$ ( vd . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ vd . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ nodewithvariables ) $whitespace$ { $newline$ $indentation$ nodewithvariables < ? > $whitespace$ nodewithvariables $whitespace$ = $whitespace$ ( nodewithvariables < ? > ) $whitespace$ vd . getparentnode ( ) . get ( ) ; $newline$ $indentation$ $//·we·calculate·the·value·the·property·will·assume·after·the·change·will·be·completed$ $newline$ $indentation$ optional < type > $whitespace$ currentmaxcommontype $whitespace$ = $whitespace$ nodewithvariables . getmaximumcommontype ( ) ; $newline$ $indentation$ list < type > $whitespace$ types $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ nodewithvariables . getvariables ( ) . indexof ( vd ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodewithvariables . getvariables ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ == $whitespace$ index ) $whitespace$ { $newline$ $indentation$ types . add ( ( type ) $whitespace$ newvalue ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ types . add ( nodewithvariables . getvariable ( i ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ optional < type > $whitespace$ newmaxcommontype $whitespace$ = $whitespace$ nodewithvariables . calculatemaximumcommontype ( types ) ; $newline$ $indentation$ ( ( node ) $whitespace$ nodewithvariables ) . notifypropertychange ( observableproperty . maximum_common_type , $whitespace$ currentmaxcommontype . orelse ( null ) , $whitespace$ newmaxcommontype . orelse ( null ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ protected $whitespace$ void $whitespace$ custominitialization ( ) { $newline$ $indentation$ $number$ ) ; $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ if $whitespace$ there $whitespace$ is $whitespace$ a $whitespace$ valid $whitespace$ cors $whitespace$ request $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ */ $newline$ $indentation$ private $whitespace$ void $whitespace$ propertychange ( node $whitespace$ observednode, $whitespace$ observableproperty $whitespace$ property, $whitespace$ object $whitespace$ oldvalue, $whitespace$ object $whitespace$ newvalue ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty. type ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ vd $whitespace$ = $whitespace$ variabledeclarator. this ; $newline$ $indentation$ if $whitespace$ ( vd. getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ vd. getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ nodewithvariables ) $whitespace$ { $newline$ $indentation$ nodewithvariables <? > $whitespace$ nodewithvariables $whitespace$ = $whitespace$ ( node			
setInitializer	184	195	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.6486081480979919	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public VariableDeclarator setInitializer(final Expression initializer){
		    if (initializer == this.initializer) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INITIALIZER, this.initializer, initializer);
		    if (this.initializer != null)
		        this.initializer.setParentNode(null);
		    this.initializer = initializer;
		    setAsParentNodeOf(initializer);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ setinitializer ( final $whitespace$ expression $whitespace$ initializer ) { $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ == $whitespace$ this . initializer ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . initializer , $whitespace$ this . initializer , $whitespace$ initializer ) ; $newline$ $indentation$ if $whitespace$ ( this . initializer $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . initializer . setparentnode ( null ) ; $newline$ $indentation$ this . initializer $whitespace$ = $whitespace$ initializer ; $newline$ $indentation$ setasparentnodeof ( initializer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ setinitializer ( final $whitespace$ expression $whitespace$ initializer ) { $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ == $whitespace$ this. initializer ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. initializer, $whitespace$ this. initializer, $whitespace$ initializer ) ; $newline$ $indentation$ if $whitespace$ ( this. initializer $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. initializer. setparentnode ( null ) ; $newline$ $indentation$ this. initializer $whitespace$ = $whitespace$ initializer ; $newline$ $indentation$ setasparentnodeof ( initializer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getMetaModel	252	256	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.7104626893997192	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public VariableDeclaratorMetaModel getMetaModel(){
		    return JavaParserMetaModel.variableDeclaratorMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclaratormetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . variabledeclaratormetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclaratormetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. variabledeclaratormetamodel ; $newline$ $indentation$ }			
accept	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setName	164	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.8435918688774109	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public VariableDeclarator setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setType	212	224	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/body/VariableDeclarator.java	0.8595356941223145	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public VariableDeclarator setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarator $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifBlockComment	100	104	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java	0.6963191032409668	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifBlockComment(Consumer<BlockComment> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifblockcomment ( consumer < blockcomment > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifblockcomment ( consumer < blockcomment > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	82	86	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java	0.734086275100708	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public BlockCommentMetaModel getMetaModel(){
		    return JavaParserMetaModel.blockCommentMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockcommentmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . blockcommentmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ list < blockcommentmetamodel > $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. blockcommentmetamodel ; $newline$ $indentation$ }			
accept	64	68	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asBlockComment	94	98	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java	0.8770461082458496	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public BlockComment asBlockComment(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockcomment $whitespace$ asblockcomment ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enemytype $whitespace$ asblockcomment ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isBlockComment	88	92	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/BlockComment.java	0.9117472767829896	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isBlockComment(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isblockcomment ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isblockcomment ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
clone	167	171	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/Comment.java	0.8464812636375427	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Comment clone(){
		    return (Comment) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ comment $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( comment ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ comment $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( comment ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setContent	84	93	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/Comment.java	0.851716935634613	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Comment setContent(final String content){
		    assertNotNull(content);
		    if (content == this.content) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.CONTENT, this.content, content);
		    this.content = content;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ comment $whitespace$ setcontent ( final $whitespace$ string $whitespace$ content ) { $newline$ $indentation$ assertnotnull ( content ) ; $newline$ $indentation$ if $whitespace$ ( content $whitespace$ == $whitespace$ this . content ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . content , $whitespace$ this . content , $whitespace$ content ) ; $newline$ $indentation$ this . content $whitespace$ = $whitespace$ content ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ comment $whitespace$ setcontent ( final $whitespace$ string $whitespace$ content ) { $newline$ $indentation$ assertnotnull ( content ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ @ test $newline$ $indentation$ public $whitespace$ void $whitespace$ setcontent ( final $whitespace$ string $whitespace$ content ) { $newline$ $indentation$ assertnotnull ( content ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
findRootNode	157	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/Comment.java	0.8875291347503662	HIGH	"		@Override
		public Node findRootNode(){
		    // (Non-orphan) comments are not integrated into the normal AST; we need to get the commented node first.
		    Node n = getCommentedNode().orElse(this);
		    while (n.getParentNode().isPresent()) {
		        n = n.getParentNode().get();
		    }
		    return n;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ findrootnode ( ) { $newline$ $indentation$ $//·(non-orphan)·comments·are·not·integrated·into·the·normal·ast;·we·need·to·get·the·commented·node·first.$ $newline$ $indentation$ node $whitespace$ n $whitespace$ = $whitespace$ getcommentednode ( ) . orelse ( this ) ; $newline$ $indentation$ while $whitespace$ ( n . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n $whitespace$ = $whitespace$ n . getparentnode ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ findrootnode ( ) { $newline$ $indentation$ node $whitespace$ n $whitespace$ = $whitespace$ getcommentednode ( ). orelse ( this ) ; $newline$ $indentation$ while $whitespace$ ( n. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n $whitespace$ = $whitespace$ n. getparentnode ( ). get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }			
setComment	135	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/Comment.java	0.9133425951004028	HIGH	"		@Override
		public Node setComment(final Comment comment){
		    // comments on comments are not allowed, so we override setComment(Comment) here
		    if (comment != null) {
		        throw new IllegalArgumentException(""A comment cannot be commented."");
		    }
		    return super.setComment(comment);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setcomment ( final $whitespace$ comment $whitespace$ comment ) { $newline$ $indentation$ $//·comments·on·comments·are·not·allowed,·so·we·override·setcomment(comment)·here$ $newline$ $indentation$ if $whitespace$ ( comment $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . setcomment ( comment ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ node $whitespace$ setcomment ( final $whitespace$ comment $whitespace$ comment ) { $newline$ $indentation$ $////////////////////////////////////comments $whitespace$ = $whitespace$$. comment $whitespace$ ; $newline$ $indentation$ return $whitespace$ super. setcomment ( comment ) ; $newline$ $indentation$ }			
contains	62	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/CommentsCollection.java	0.2800817191600799	LOW	"		public boolean contains(Comment comment){
		    if (!comment.hasRange()) {
		        return false;
		    }
		    Range commentRange = comment.getRange().get();
		    for (Comment c : getComments()) {
		        if (!c.hasRange()) {
		            return false;
		        }
		        Range cRange = c.getRange().get();
		        // we tolerate a difference of one element in the end column:
		        // it depends how \r and \n are calculated...
		        if (cRange.begin.equals(commentRange.begin) && cRange.end.line == commentRange.end.line && Math.abs(cRange.end.column - commentRange.end.column) < 2) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ contains ( comment $whitespace$ comment ) { $newline$ $indentation$ if $whitespace$ ( ! comment . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ range $whitespace$ commentrange $whitespace$ = $whitespace$ comment . getrange ( ) . get ( ) ; $newline$ $indentation$ for $whitespace$ ( comment $whitespace$ c $whitespace$ : $whitespace$ getcomments ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! c . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ range $whitespace$ crange $whitespace$ = $whitespace$ c . getrange ( ) . get ( ) ; $newline$ $indentation$ $//·we·tolerate·a·difference·of·one·element·in·the·end·column:$ $newline$ $indentation$ $//·it·depends·how·\r·and·\n·are·calculated...$ $newline$ $indentation$ if $whitespace$ ( crange . begin . equals ( commentrange . begin ) $whitespace$ && $whitespace$ crange . end . line $whitespace$ == $whitespace$ commentrange . end . line $whitespace$ && $whitespace$ math . abs ( crange . end . column $whitespace$ - $whitespace$ commentrange . end . column ) $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ contains ( comment $whitespace$ comment ) { $newline$ $indentation$ if $whitespace$ (! comment. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ range $whitespace$ commentrange $whitespace$ = $whitespace$ comment. getrange ( ). get ( ) ; $newline$ $indentation$ for $whitespace$ ( comment $whitespace$ c $whitespace$ : $whitespace$ getcomments ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! c. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
minus	89	93	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/CommentsCollection.java	0.2845266759395599	LOW	"		public CommentsCollection minus(CommentsCollection other){
		    CommentsCollection result = new CommentsCollection();
		    result.comments.addAll(comments.stream().filter(comment -> !other.contains(comment)).collect(Collectors.toList()));
		    return result;
		}"	$indentation$ public $whitespace$ commentscollection $whitespace$ minus ( commentscollection $whitespace$ other ) { $newline$ $indentation$ commentscollection $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ commentscollection ( ) ; $newline$ $indentation$ result . comments . addall ( comments . stream ( ) . filter ( comment $whitespace$ - > $whitespace$ ! other . contains ( comment ) ) . collect ( collectors . tolist ( ) ) ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ public $whitespace$ commentscollection $whitespace$ minus ( commentscollection $whitespace$ other ) { $newline$ $indentation$ commentscollection $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ commentscollection ( ) ; $newline$ $indentation$ result. comments. addall ( comments. stream ( ). filter ( comment $whitespace$ - > $whitespace$! other. contains ( comment ) ). collect ( collectors. tolist ( ) ) ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
ifJavadocComment	103	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/JavadocComment.java	0.6876581907272339	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifJavadocComment(Consumer<JavadocComment> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifjavadoccomment ( consumer < javadoccomment > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifjavadoccomment ( consumer < e > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	63	67	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/JavadocComment.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asJavadocComment	97	101	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/JavadocComment.java	0.8627721071243286	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public JavadocComment asJavadocComment(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ javadoccomment $whitespace$ asjavadoccomment ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ javadoccomment $whitespace$ asjavadoccomment ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isJavadocComment	91	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/JavadocComment.java	0.9062368273735046	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isJavadocComment(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isjavadoccomment ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isjavadoccomment ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLineComment	99	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/LineComment.java	0.702133297920227	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLineComment(Consumer<LineComment> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflinecomment ( consumer < linecomment > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflinecomment ( consumer < linecomment > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	63	67	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/LineComment.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asLineComment	93	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/LineComment.java	0.8818251490592957	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public LineComment asLineComment(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ linecomment $whitespace$ aslinecomment ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ linecomment $whitespace$ aslinecomment ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLineComment	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/comments/LineComment.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLineComment(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islinecomment ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islinecomment ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifAnnotationExpr	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java	0.6876581907272339	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifAnnotationExpr(Consumer<AnnotationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifannotationexpr ( consumer < annotationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ onannotationexpr ( consumer < annotationexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
replace	100	111	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java	0.8389257192611694	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ replacementnode ; $newline$ $indentation$ }			
asAnnotationExpr	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java	0.8627721071243286	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public AnnotationExpr asAnnotationExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationexpr $whitespace$ asannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationexpr $whitespace$ asannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	74	86	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java	0.8674549460411072	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AnnotationExpr setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationexpr $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ annotationexpr $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ asserttokentype ( name, $whitespace$ this. name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isAnnotationExpr	113	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AnnotationExpr.java	0.9062368273735046	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isAnnotationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifArrayAccessExpr	162	166	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.6808562278747559	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifArrayAccessExpr(Consumer<ArrayAccessExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarrayaccessexpr ( consumer < arrayaccessexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	127	131	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.7156317830085754	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ArrayAccessExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.arrayAccessExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . arrayaccessexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ listaccessexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. arrayaccessexprmetamodel ; $newline$ $indentation$ }			
toArrayAccessExpr	168	172	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.73777174949646	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ArrayAccessExpr> toArrayAccessExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arrayaccessexpr > $whitespace$ toarrayaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arrayaccessexpr > $whitespace$ toarrayaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setIndex	93	105	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.8344060182571411	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayAccessExpr setIndex(final Expression index){
		    assertNotNull(index);
		    if (index == this.index) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INDEX, this.index, index);
		    if (this.index != null)
		        this.index.setParentNode(null);
		    this.index = index;
		    setAsParentNodeOf(index);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ setindex ( final $whitespace$ expression $whitespace$ index ) { $newline$ $indentation$ assertnotnull ( index ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ this . index ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . index , $whitespace$ this . index , $whitespace$ index ) ; $newline$ $indentation$ if $whitespace$ ( this . index $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . index . setparentnode ( null ) ; $newline$ $indentation$ this . index $whitespace$ = $whitespace$ index ; $newline$ $indentation$ setasparentnodeof ( index ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ setindex ( final $whitespace$ expression $whitespace$ index ) { $newline$ $indentation$ assertcurrentvalueis ( index ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. index, $whitespace$ this. index, $whitespace$ index ) ; $newline$ $indentation$ assertcurrentvalueis ( index ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	107	119	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.8461947441101074	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayAccessExpr setName(final Expression name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ setname ( final $whitespace$ expression $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ setname ( final $whitespace$ expression $whitespace$ name ) { $newline$ $indentation$ assertcurrentvalueisnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asArrayAccessExpr	156	160	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.8580688834190369	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ArrayAccessExpr asArrayAccessExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ asarrayaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayaccessexpr $whitespace$ asarrayaccessexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isArrayAccessExpr	150	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayAccessExpr.java	0.9036316871643066	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isArrayAccessExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarrayaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarrayaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setElementType	127	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.6126458644866943	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayCreationExpr setElementType(final Type elementType){
		    assertNotNull(elementType);
		    if (elementType == this.elementType) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ELEMENT_TYPE, this.elementType, elementType);
		    if (this.elementType != null)
		        this.elementType.setParentNode(null);
		    this.elementType = elementType;
		    setAsParentNodeOf(elementType);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setelementtype ( final $whitespace$ type $whitespace$ elementtype ) { $newline$ $indentation$ assertnotnull ( elementtype ) ; $newline$ $indentation$ if $whitespace$ ( elementtype $whitespace$ == $whitespace$ this . elementtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . element_type , $whitespace$ this . elementtype , $whitespace$ elementtype ) ; $newline$ $indentation$ if $whitespace$ ( this . elementtype $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . elementtype . setparentnode ( null ) ; $newline$ $indentation$ this . elementtype $whitespace$ = $whitespace$ elementtype ; $newline$ $indentation$ setasparentnodeof ( elementtype ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setelementtype ( final $whitespace$ type $whitespace$ elementtype ) { $newline$ $indentation$ assertnotnull ( elementtype ) ; $newline$ $indentation$ assertnonode ( elementtype ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ assertnotnull ( elementtype $whitespace$ elementtype ) { $newline$ $indentation$ if $whitespace$ ( elementtype $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. element_type, $whitespace$ this. elementtype, $whitespace$ elementtype ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ setasparentnodeof ( elementtype $whitespace$ elementtype ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( elementtype $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ this. elementtype. setparentnode ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
createdType	163	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.629679262638092	MID	"		public Type createdType(){
		    Type result = elementType;
		    for (int i = 0; i < levels.size(); i++) {
		        result = new ArrayType(result, ArrayType.Origin.TYPE, new NodeList<>());
		    }
		    return result;
		}"	$indentation$ public $whitespace$ type $whitespace$ createdtype ( ) { $newline$ $indentation$ type $whitespace$ result $whitespace$ = $whitespace$ elementtype ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ levels . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ new $whitespace$ arraytype ( result , $whitespace$ arraytype . origin . type , $whitespace$ new $whitespace$ nodelist < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ public $whitespace$ type $whitespace$ createdtype ( ) { $newline$ $indentation$ type $whitespace$ result $whitespace$ = $whitespace$ elementtype ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ levels. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ new $whitespace$ arraytype ( result, $whitespace$ arraytype. origin. type, $whitespace$ new $whitespace$ nodelist < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
replace	224	247	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.6353705525398254	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == elementType) {
		        setElementType((Type) replacementNode);
		        return true;
		    }
		    if (initializer != null) {
		        if (node == initializer) {
		            setInitializer((ArrayInitializerExpr) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < levels.size(); i++) {
		        if (levels.get(i) == node) {
		            levels.set(i, (ArrayCreationLevel) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ elementtype ) $whitespace$ { $newline$ $indentation$ setelementtype ( ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ initializer ) $whitespace$ { $newline$ $indentation$ setinitializer ( ( arrayinitializerexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ levels . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( levels . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ levels . set ( i , $whitespace$ ( arraycreationlevel ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ elementtype ) $whitespace$ { $newline$ $indentation$ setelementtype ( ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode )			
setInitializer	114	125	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.6581634283065796	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayCreationExpr setInitializer(final ArrayInitializerExpr initializer){
		    if (initializer == this.initializer) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INITIALIZER, this.initializer, initializer);
		    if (this.initializer != null)
		        this.initializer.setParentNode(null);
		    this.initializer = initializer;
		    setAsParentNodeOf(initializer);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setinitializer ( final $whitespace$ arrayinitializerexpr $whitespace$ initializer ) { $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ == $whitespace$ this . initializer ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . initializer , $whitespace$ this . initializer , $whitespace$ initializer ) ; $newline$ $indentation$ if $whitespace$ ( this . initializer $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . initializer . setparentnode ( null ) ; $newline$ $indentation$ this . initializer $whitespace$ = $whitespace$ initializer ; $newline$ $indentation$ setasparentnodeof ( initializer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setinitializer ( final $whitespace$ arrayinitializerexpr $whitespace$ initializer ) { $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ == $whitespace$ this. initializer ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. initializer, $whitespace$ this. initializer, $whitespace$ initializer ) ; $newline$ $indentation$ if $whitespace$ ( this. initializer $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. initializer. setparentnode ( null ) ; $newline$ $indentation$ this. initializer $whitespace$ = $whitespace$ initializer ; $newline$ $indentation$ setasparentnodeof ( initializer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifArrayCreationExpr	261	265	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.6655811071395874	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifArrayCreationExpr(Consumer<ArrayCreationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarraycreationexpr ( consumer < arraycreationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarraycreationexpr ( consumer < arraycreationexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
remove	186	205	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.6842694878578186	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (initializer != null) {
		        if (node == initializer) {
		            removeInitializer();
		            return true;
		        }
		    }
		    for (int i = 0; i < levels.size(); i++) {
		        if (levels.get(i) == node) {
		            levels.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ initializer ) $whitespace$ { $newline$ $indentation$ removeinitializer ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ levels . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( levels . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ levels . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( initializer $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ initializer ) $whitespace$ { $newline$ $indentation$ removeinitializer ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getMetaModel	218	222	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.7195759415626526	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ArrayCreationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.arrayCreationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . arraycreationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. arraycreationexprmetamodel ; $newline$ $indentation$ }			
toArrayCreationExpr	267	271	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.7331055998802185	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ArrayCreationExpr> toArrayCreationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arraycreationexpr > $whitespace$ toarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arraycreationexpr > $whitespace$ toarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	86	90	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asArrayCreationExpr	255	259	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.8478068709373474	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ArrayCreationExpr asArrayCreationExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ asarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ asarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setLevels	146	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.8683339953422546	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayCreationExpr setLevels(final NodeList<ArrayCreationLevel> levels){
		    assertNotNull(levels);
		    if (levels == this.levels) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.LEVELS, this.levels, levels);
		    if (this.levels != null)
		        this.levels.setParentNode(null);
		    this.levels = levels;
		    setAsParentNodeOf(levels);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setlevels ( final $whitespace$ nodelist < arraycreationlevel > $whitespace$ levels ) { $newline$ $indentation$ assertnotnull ( levels ) ; $newline$ $indentation$ if $whitespace$ ( levels $whitespace$ == $whitespace$ this . levels ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . levels , $whitespace$ this . levels , $whitespace$ levels ) ; $newline$ $indentation$ if $whitespace$ ( this . levels $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . levels . setparentnode ( null ) ; $newline$ $indentation$ this . levels $whitespace$ = $whitespace$ levels ; $newline$ $indentation$ setasparentnodeof ( levels ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraycreationexpr $whitespace$ setlevels ( final $whitespace$ nodelist < arraycreationlevel > $whitespace$ levels ) { $newline$ $indentation$ if $whitespace$ ( levels $whitespace$ == $whitespace$ this. levels ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. levels, $whitespace$ this. levels, $whitespace$ levels ) ; $newline$ $indentation$ if $whitespace$ ( this. levels $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. levels. setparentnode ( null ) ; $newline$ $indentation$ this. levels $whitespace$ = $whitespace$ levels ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isArrayCreationExpr	249	253	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayCreationExpr.java	0.896767258644104	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isArrayCreationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarraycreationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifArrayInitializerExpr	156	160	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.6541545987129211	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifArrayInitializerExpr(Consumer<ArrayInitializerExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarrayinitializerexpr ( consumer < arrayinitializerexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarrayinitializerexpr ( consumer < arrayinitializerexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	123	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.7031294107437134	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ArrayInitializerExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.arrayInitializerExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . arrayinitializerexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. arrayinitializerexprmetamodel ; $newline$ $indentation$ }			
toArrayInitializerExpr	162	166	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.7129606604576111	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ArrayInitializerExpr> toArrayInitializerExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arrayinitializerexpr > $whitespace$ toarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < arrayinitializerexpr > $whitespace$ toarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asArrayInitializerExpr	150	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.8320928812026978	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ArrayInitializerExpr asArrayInitializerExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexpr $whitespace$ asarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexpr $whitespace$ asarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setValues	88	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.8791515231132507	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayInitializerExpr setValues(final NodeList<Expression> values){
		    assertNotNull(values);
		    if (values == this.values) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.VALUES, this.values, values);
		    if (this.values != null)
		        this.values.setParentNode(null);
		    this.values = values;
		    setAsParentNodeOf(values);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexpr $whitespace$ setvalues ( final $whitespace$ nodelist < expression > $whitespace$ values ) { $newline$ $indentation$ assertnotnull ( values ) ; $newline$ $indentation$ if $whitespace$ ( values $whitespace$ == $whitespace$ this . values ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . values , $whitespace$ this . values , $whitespace$ values ) ; $newline$ $indentation$ if $whitespace$ ( this . values $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . values . setparentnode ( null ) ; $newline$ $indentation$ this . values $whitespace$ = $whitespace$ values ; $newline$ $indentation$ setasparentnodeof ( values ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arrayinitializerexpr $whitespace$ setvalues ( final $whitespace$ nodelist < expression > $whitespace$ values ) { $newline$ $indentation$ assertnotnull ( values ) ; $newline$ $indentation$ if $whitespace$ ( this. values $whitespace$ == $whitespace$ this. values ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. values, $whitespace$ this. values, $whitespace$ values ) ; $newline$ $indentation$ if $whitespace$ ( this. values $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. values. setparentnode ( null ) ; $newline$ $indentation$ this. values $whitespace$ = $whitespace$ values ; $newline$ $indentation$ setasparentnodeof ( values ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isArrayInitializerExpr	144	148	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ArrayInitializerExpr.java	0.8890807032585144	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isArrayInitializerExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarrayinitializerexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifAssignExpr	241	245	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java	0.7155272364616394	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifAssignExpr(Consumer<AssignExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifassignexpr ( consumer < assignexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ nextassignexpr ( consumer < assignexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
setTarget	172	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java	0.8328043818473816	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AssignExpr setTarget(final Expression target){
		    assertNotNull(target);
		    if (target == this.target) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TARGET, this.target, target);
		    if (this.target != null)
		        this.target.setParentNode(null);
		    this.target = target;
		    setAsParentNodeOf(target);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ settarget ( final $whitespace$ expression $whitespace$ target ) { $newline$ $indentation$ assertnotnull ( target ) ; $newline$ $indentation$ if $whitespace$ ( target $whitespace$ == $whitespace$ this . target ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . target , $whitespace$ this . target , $whitespace$ target ) ; $newline$ $indentation$ if $whitespace$ ( this . target $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . target . setparentnode ( null ) ; $newline$ $indentation$ this . target $whitespace$ = $whitespace$ target ; $newline$ $indentation$ setasparentnodeof ( target ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ settarget ( final $whitespace$ expression $whitespace$ target ) { $newline$ $indentation$ assertnull ( target ) ; $newline$ $indentation$ return $whitespace$ this. target ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ settarget ( final $whitespace$ expression $whitespace$ target ) { $newline$ $indentation$ assertnull ( target ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setValue	186	198	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java	0.8357177972793579	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AssignExpr setValue(final Expression value){
		    assertNotNull(value);
		    if (value == this.value) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.VALUE, this.value, value);
		    if (this.value != null)
		        this.value.setParentNode(null);
		    this.value = value;
		    setAsParentNodeOf(value);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ setvalue ( final $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ assertnotnull ( value ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ this . value ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . value , $whitespace$ this . value , $whitespace$ value ) ; $newline$ $indentation$ if $whitespace$ ( this . value $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . value . setparentnode ( null ) ; $newline$ $indentation$ this . value $whitespace$ = $whitespace$ value ; $newline$ $indentation$ setasparentnodeof ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ setvalue ( final $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ this. value ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. value, $whitespace$ this. value, $whitespace$ value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asAssignExpr	235	239	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java	0.8873354196548462	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public AssignExpr asAssignExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ asassignexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ assignexpr $whitespace$ asassignexpr ( ) $whitespace$ // $whitespace$ set $whitespace$ up $whitespace$ datastore $newline$ $indentation$ public $whitespace$ assignexpr $whitespace$ asassignexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isAssignExpr	229	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/AssignExpr.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isAssignExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifBinaryExpr	246	250	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.7173944115638733	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifBinaryExpr(Consumer<BinaryExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifbinaryexpr ( consumer < binaryexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifbinaryexpr ( consumer < binaryexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	139	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setRight	191	203	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.8382261395454407	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BinaryExpr setRight(final Expression right){
		    assertNotNull(right);
		    if (right == this.right) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.RIGHT, this.right, right);
		    if (this.right != null)
		        this.right.setParentNode(null);
		    this.right = right;
		    setAsParentNodeOf(right);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ setright ( final $whitespace$ expression $whitespace$ right ) { $newline$ $indentation$ assertnotnull ( right ) ; $newline$ $indentation$ if $whitespace$ ( right $whitespace$ == $whitespace$ this . right ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . right , $whitespace$ this . right , $whitespace$ right ) ; $newline$ $indentation$ if $whitespace$ ( this . right $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . right . setparentnode ( null ) ; $newline$ $indentation$ this . right $whitespace$ = $whitespace$ right ; $newline$ $indentation$ setasparentnodeof ( right ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ setright ( final $whitespace$ expression $whitespace$ right ) { $newline$ $indentation$ // $whitespace$ this $whitespace$ method $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ create $whitespace$ a $whitespace$ new $whitespace$ value $whitespace$ for $whitespace$ the $whitespace$ upcoming $whitespace$ element $whitespace$ (i.e. $whitespace$ does $whitespace$ not $whitespace$ equal $whitespace$ 0. $newline$ $indentation$ if $whitespace$ ( right $whitespace$ == $whitespace$ this. right ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. right, $whitespace$ this. right, $whitespace$ right ) ; $newline$ $indentation$ // $whitespace$ this $whitespace$ method $whitespace$ is $whitespace$ implemented $whitespace$ within $whitespace$ palette $whitespace$ properties $newline$ $indentation$ setasparentnode ( element ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asBinaryExpr	240	244	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.888251006603241	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public BinaryExpr asBinaryExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ asbinaryexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ asbinaryexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setLeft	166	178	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.9164649248123168	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BinaryExpr setLeft(final Expression left){
		    assertNotNull(left);
		    if (left == this.left) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.LEFT, this.left, left);
		    if (this.left != null)
		        this.left.setParentNode(null);
		    this.left = left;
		    setAsParentNodeOf(left);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ setleft ( final $whitespace$ expression $whitespace$ left ) { $newline$ $indentation$ assertnotnull ( left ) ; $newline$ $indentation$ if $whitespace$ ( left $whitespace$ == $whitespace$ this . left ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . left , $whitespace$ this . left , $whitespace$ left ) ; $newline$ $indentation$ if $whitespace$ ( this . left $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . left . setparentnode ( null ) ; $newline$ $indentation$ this . left $whitespace$ = $whitespace$ left ; $newline$ $indentation$ setasparentnodeof ( left ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ binaryexpr $whitespace$ setleft ( final $whitespace$ expression $whitespace$ left ) { $newline$ $indentation$ assertnull ( left ) ; $newline$ $indentation$ if $whitespace$ ( left $whitespace$ == $whitespace$ this. left ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. left, $whitespace$ this. left, $whitespace$ left ) ; $newline$ $indentation$ if $whitespace$ ( this. left $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. left. setparentnode ( null ) ; $newline$ $indentation$ this. left $whitespace$ = $whitespace$ left ; $newline$ $indentation$ setasparentnodeof ( left ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isBinaryExpr	234	238	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BinaryExpr.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isBinaryExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbinaryexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbinaryexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifBooleanLiteralExpr	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.6653704047203064	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifBooleanLiteralExpr(Consumer<BooleanLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifbooleanliteralexpr ( consumer < booleanliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( no ( consumer < booleanliteralexpr > $whitespace$ action ) ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	107	111	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.7104626893997192	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public BooleanLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.booleanLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . booleanliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexprmetamodel $whitespace$ getmetamodel ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. booleanliteralexprmetamodel ; $newline$ $indentation$ }			
toBooleanLiteralExpr	131	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.7220616936683655	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<BooleanLiteralExpr> toBooleanLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < booleanliteralexpr > $whitespace$ tobooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < booleanliteralexpr > $whitespace$ tobooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	66	70	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asBooleanLiteralExpr	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.8379365801811218	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public BooleanLiteralExpr asBooleanLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexpr $whitespace$ asbooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexpr $whitespace$ asbooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setValue	91	99	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.8862213492393494	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BooleanLiteralExpr setValue(final boolean value){
		    if (value == this.value) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.VALUE, this.value, value);
		    this.value = value;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexpr $whitespace$ setvalue ( final $whitespace$ boolean $whitespace$ value ) { $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ this . value ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . value , $whitespace$ this . value , $whitespace$ value ) ; $newline$ $indentation$ this . value $whitespace$ = $whitespace$ value ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanliteralexpr $whitespace$ setvalue ( final $whitespace$ boolean $whitespace$ value ) { $newline$ $indentation$ return $whitespace$ value $whitespace$ == $whitespace$ this. value ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ booleanliteralexpr $whitespace$ setvalue ( final $whitespace$ boolean $whitespace$ value ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. value, $whitespace$ this. value, $whitespace$ value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isBooleanLiteralExpr	113	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/BooleanLiteralExpr.java	0.8942615389823914	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isBooleanLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbooleanliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifCastExpr	165	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CastExpr.java	0.7221471667289734	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifCastExpr(Consumer<CastExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcastexpr ( consumer < castexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) { $newline$ $indentation$ // $whitespace$ the $whitespace$ actual $whitespace$ map $whitespace$ in $whitespace$ the $whitespace$ icon $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
asCastExpr	159	163	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CastExpr.java	0.8982763886451721	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public CastExpr asCastExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ castexpr $whitespace$ ascastexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ castexpr $whitespace$ ascastexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isCastExpr	153	157	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CastExpr.java	0.925080955028534	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isCastExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscastexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscastexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifCharLiteralExpr	137	141	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.6808562278747559	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifCharLiteralExpr(Consumer<CharLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcharliteralexpr ( consumer < charliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcharliteralexpr ( consumer < charliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.7174985408782959	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public CharLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.charLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ charliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . charliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ charliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. charliteralexprmetamodel ; $newline$ $indentation$ }			
toCharLiteralExpr	143	147	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.73777174949646	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<CharLiteralExpr> toCharLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < charliteralexpr > $whitespace$ tocharliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < charliteralexpr > $whitespace$ tocharliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	83	87	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asCharLiteralExpr	131	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.8558152914047241	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public CharLiteralExpr asCharLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ charliteralexpr $whitespace$ ascharliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ charliteralexpr $whitespace$ ascharliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isCharLiteralExpr	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/CharLiteralExpr.java	0.9044291377067566	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isCharLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ischarliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ischarliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifClassExpr	139	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifClassExpr(Consumer<ClassExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifclassexpr ( consumer < classexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ classexpr ( consumer < classexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
replace	114	125	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.8389257192611694	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == type) {
		        setType((Type) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ type ) $whitespace$ { $newline$ $indentation$ settype ( ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ type $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ replacementnode ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
setType	88	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.8667063117027283	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ClassExpr setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classexpr $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classexpr $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asClassExpr	133	137	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.8939412832260132	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ClassExpr asClassExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classexpr $whitespace$ asclassexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classexpr $whitespace$ asclassexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isClassExpr	127	131	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ClassExpr.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isClassExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setThenExpr	130	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.6536263227462769	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ConditionalExpr setThenExpr(final Expression thenExpr){
		    assertNotNull(thenExpr);
		    if (thenExpr == this.thenExpr) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.THEN_EXPR, this.thenExpr, thenExpr);
		    if (this.thenExpr != null)
		        this.thenExpr.setParentNode(null);
		    this.thenExpr = thenExpr;
		    setAsParentNodeOf(thenExpr);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexpr $whitespace$ setthenexpr ( final $whitespace$ expression $whitespace$ thenexpr ) { $newline$ $indentation$ assertnotnull ( thenexpr ) ; $newline$ $indentation$ if $whitespace$ ( thenexpr $whitespace$ == $whitespace$ this . thenexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . then_expr , $whitespace$ this . thenexpr , $whitespace$ thenexpr ) ; $newline$ $indentation$ if $whitespace$ ( this . thenexpr $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . thenexpr . setparentnode ( null ) ; $newline$ $indentation$ this . thenexpr $whitespace$ = $whitespace$ thenexpr ; $newline$ $indentation$ setasparentnodeof ( thenexpr ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexpr $whitespace$ setthenexpr ( final $whitespace$ expression $whitespace$ thenexpr ) { $newline$ $indentation$ assertnotnull ( thenexpr ) ; $newline$ $indentation$ if $whitespace$ ( thenexpr $whitespace$ == $whitespace$ this. thenexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. then_expr, $whitespace$ this. thenexpr, $whitespace$ thenexpr ) ; $newline$ $indentation$ if $whitespace$ ( this. thenexpr $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. thenexpr. setparentnode ( null ) ; $newline$ $indentation$ this. thenexpr $whitespace$ = $whitespace$ thenexpr ; $newline$ $indentation$ setasparentnodeof ( thenexpr ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setElseExpr	116	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.6639562845230103	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ConditionalExpr setElseExpr(final Expression elseExpr){
		    assertNotNull(elseExpr);
		    if (elseExpr == this.elseExpr) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ELSE_EXPR, this.elseExpr, elseExpr);
		    if (this.elseExpr != null)
		        this.elseExpr.setParentNode(null);
		    this.elseExpr = elseExpr;
		    setAsParentNodeOf(elseExpr);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexpr $whitespace$ setelseexpr ( final $whitespace$ expression $whitespace$ elseexpr ) { $newline$ $indentation$ assertnotnull ( elseexpr ) ; $newline$ $indentation$ if $whitespace$ ( elseexpr $whitespace$ == $whitespace$ this . elseexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . else_expr , $whitespace$ this . elseexpr , $whitespace$ elseexpr ) ; $newline$ $indentation$ if $whitespace$ ( this . elseexpr $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . elseexpr . setparentnode ( null ) ; $newline$ $indentation$ this . elseexpr $whitespace$ = $whitespace$ elseexpr ; $newline$ $indentation$ setasparentnodeof ( elseexpr ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexpr $whitespace$ setelseexpr ( final $whitespace$ expression $whitespace$ elseexpr ) { $newline$ $indentation$ assertnotnull ( elseexpr ) ; $newline$ $indentation$ if $whitespace$ ( this. elseexpr $whitespace$ == $whitespace$ this. elseexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. else_expr, $whitespace$ this. elseexpr, $whitespace$ elseexpr ) ; $newline$ $indentation$ if $whitespace$ ( this. elseexpr $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. elseexpr. setparentnode ( null ) ; $newline$ $indentation$ this. elseexpr $whitespace$ = $whitespace$ elseexpr ; $newline$ $indentation$ setasparentnodeof ( elseexpr ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifConditionalExpr	189	193	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.6808562278747559	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifConditionalExpr(Consumer<ConditionalExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifconditionalexpr ( consumer < conditionalexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifconditionalexpr ( consumer < conditionalexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	150	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.7174985408782959	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ConditionalExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.conditionalExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . conditionalexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. conditionalexprmetamodel ; $newline$ $indentation$ }			
toConditionalExpr	195	199	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.73777174949646	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ConditionalExpr> toConditionalExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < conditionalexpr > $whitespace$ toconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < conditionalexpr > $whitespace$ toconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asConditionalExpr	183	187	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.8580688834190369	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ConditionalExpr asConditionalExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ conditionalexpr $whitespace$ asconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ conditionalexpr $whitespace$ asconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isConditionalExpr	177	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ConditionalExpr.java	0.9044291377067566	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isConditionalExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isconditionalexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifDoubleLiteralExpr	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.6635321378707886	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifDoubleLiteralExpr(Consumer<DoubleLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifdoubleliteralexpr ( consumer < doubleliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ doubleliteralexpr ( consumer < doubleliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	101	105	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public DoubleLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.doubleLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ doubleliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . doubleliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ doubleliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. doubleliteralexprmetamodel ; $newline$ $indentation$ }			
toDoubleLiteralExpr	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.72767573595047	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<DoubleLiteralExpr> toDoubleLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < doubleliteralexpr > $whitespace$ todoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < doubleliteralexpr > $whitespace$ todoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	67	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asDoubleLiteralExpr	113	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.844214677810669	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public DoubleLiteralExpr asDoubleLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ doubleliteralexpr $whitespace$ asdoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ doubleliteralexpr $whitespace$ asdoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isDoubleLiteralExpr	107	111	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.8976150751113892	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isDoubleLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isdoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isdoubleliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
asDouble	82	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/DoubleLiteralExpr.java	0.9219143986701964	HIGH	"		public double asDouble(){
		    // Underscores are allowed in number literals for readability reasons but cause a NumberFormatException if
		    // passed along to Double#parseDouble. Hence, we apply a simple filter to remove all underscores.
		    // See https://github.com/javaparser/javaparser/issues/1980 for more information.
		    String noUnderscoreValue = value.replaceAll(""_"", """");
		    return Double.parseDouble(noUnderscoreValue);
		}"	$indentation$ public $whitespace$ double $whitespace$ asdouble ( ) { $newline$ $indentation$ $//·underscores·are·allowed·in·number·literals·for·readability·reasons·but·cause·a·numberformatexception·if$ $newline$ $indentation$ $//·passed·along·to·double#parsedouble.·hence,·we·apply·a·simple·filter·to·remove·all·underscores.$ $newline$ $indentation$ $//·see·https://github.com/javaparser/javaparser/issues/1980·for·more·information.$ $newline$ $indentation$ string $whitespace$ nounderscorevalue $whitespace$ = $whitespace$ value . replaceall ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ double . parsedouble ( nounderscorevalue ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ double $whitespace$ asdouble ( ) { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace			
ifEnclosedExpr	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.6963191032409668	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifEnclosedExpr(Consumer<EnclosedExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifenclosedexpr ( consumer < enclosedexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! consumer < enclosedexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.7286690473556519	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public EnclosedExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.enclosedExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . enclosedexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. enclosedexprmetamodel ; $newline$ $indentation$ }			
accept	68	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
replace	117	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.8313543796539307	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == inner) {
		        setInner((Expression) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ inner ) $whitespace$ { $newline$ $indentation$ setinner ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
setInner	91	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.840634286403656	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public EnclosedExpr setInner(final Expression inner){
		    assertNotNull(inner);
		    if (inner == this.inner) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INNER, this.inner, inner);
		    if (this.inner != null)
		        this.inner.setParentNode(null);
		    this.inner = inner;
		    setAsParentNodeOf(inner);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexpr $whitespace$ setinner ( final $whitespace$ expression $whitespace$ inner ) { $newline$ $indentation$ assertnotnull ( inner ) ; $newline$ $indentation$ if $whitespace$ ( inner $whitespace$ == $whitespace$ this . inner ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . inner , $whitespace$ this . inner , $whitespace$ inner ) ; $newline$ $indentation$ if $whitespace$ ( this . inner $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . inner . setparentnode ( null ) ; $newline$ $indentation$ this . inner $whitespace$ = $whitespace$ inner ; $newline$ $indentation$ setasparentnodeof ( inner ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexpr $whitespace$ setinner ( final $whitespace$ expression $whitespace$ inner ) { $newline$ $indentation$ if $whitespace$ ( inner $whitespace$ == $whitespace$ this. inner ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. inner, $whitespace$ this. inner, $whitespace$ inner ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asEnclosedExpr	136	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.8730261325836182	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public EnclosedExpr asEnclosedExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexpr $whitespace$ asenclosedexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enclosedexpr $whitespace$ asenclosedexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isEnclosedExpr	130	134	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/EnclosedExpr.java	0.912484049797058	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isEnclosedExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenclosedexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isenclosedexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
appearsInInvocationContext	851	856	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Expression.java	0.7132435441017151	MID	"		public final boolean appearsInInvocationContext(){
		    if (getParentNode().isPresent() && getParentNode().get() instanceof Expression) {
		        return ((Expression) getParentNode().get()).isInvocationContext();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ final $whitespace$ boolean $whitespace$ appearsininvocationcontext ( ) { $newline$ $indentation$ if $whitespace$ ( getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( expression ) $whitespace$ getparentnode ( ) . get ( ) ) . isinvocationcontext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ final $whitespace$ boolean $whitespace$ appearsininvocationcontext ( ) { $newline$ $indentation$ if $whitespace$ ( getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( expression ) $whitespace$ getparentnode ( ). get ( ) ). isinvocationcontext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
appearsInAssignmentContext	832	837	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Expression.java	0.7151197195053101	MID	"		public final boolean appearsInAssignmentContext(){
		    if (getParentNode().isPresent() && getParentNode().get() instanceof Expression) {
		        return ((Expression) getParentNode().get()).isAssignmentContext();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ final $whitespace$ boolean $whitespace$ appearsinassignmentcontext ( ) { $newline$ $indentation$ if $whitespace$ ( getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( expression ) $whitespace$ getparentnode ( ) . get ( ) ) . isassignmentcontext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ final $whitespace$ boolean $whitespace$ appearsinassignmentcontext ( ) { $newline$ $indentation$ if $whitespace$ ( getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( expression ) $whitespace$ getparentnode ( ). get ( ) ). isassignmentcontext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
clone	83	87	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Expression.java	0.8338221311569214	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Expression clone(){
		    return (Expression) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ expression $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( expression ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ expression $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( expression ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
replace	198	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.6556454300880432	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    if (node == scope) {
		        setScope((Expression) replacementNode);
		        return true;
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.set(i, (Type) replacementNode);
		                return true;
		            }
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setscope ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . set ( i , $whitespace$ ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ } $newline$ $indentation$			
ifFieldAccessExpr	235	239	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.6808562278747559	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifFieldAccessExpr(Consumer<FieldAccessExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iffieldaccessexpr ( consumer < fieldaccessexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iffieldaccessexpr ( consumer < fieldaccessexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
remove	181	196	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.7074044942855835	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.remove(i);
		                return true;
		            }
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
getMetaModel	175	179	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.7156317830085754	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public FieldAccessExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.fieldAccessExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . fieldaccessexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ list < fieldaccessexprmetamodel > $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. fieldaccessexprmetamodel ; $newline$ $indentation$ }			
accept	89	93	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setScope	131	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.8292633295059204	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public FieldAccessExpr setScope(final Expression scope){
		    assertNotNull(scope);
		    if (scope == this.scope) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.SCOPE, this.scope, scope);
		    if (this.scope != null)
		        this.scope.setParentNode(null);
		    this.scope = scope;
		    setAsParentNodeOf(scope);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ setscope ( final $whitespace$ expression $whitespace$ scope ) { $newline$ $indentation$ assertnotnull ( scope ) ; $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ == $whitespace$ this . scope ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . scope , $whitespace$ this . scope , $whitespace$ scope ) ; $newline$ $indentation$ if $whitespace$ ( this . scope $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . scope . setparentnode ( null ) ; $newline$ $indentation$ this . scope $whitespace$ = $whitespace$ scope ; $newline$ $indentation$ setasparentnodeof ( scope ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ setscope ( final $whitespace$ expression $whitespace$ scope ) { $newline$ $indentation$ assertnotnull ( scope ) ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. scope, $whitespace$ this. scope, $whitespace$ scope ) ; $newline$ $indentation$ // $whitespace$ this. scope $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ ensure $whitespace$ that $whitespace$ pieces $whitespace$ are $whitespace$ not $whitespace$ created) $newline$ $indentation$ if $whitespace$ ( this. scope $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. scope. setparentnode ( null ) ; $newline$ $indentation$ this. scope $whitespace$ = $whitespace$ scope ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	106	118	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.8437870144844055	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public FieldAccessExpr setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asFieldAccessExpr	229	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.8558152914047241	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public FieldAccessExpr asFieldAccessExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ asfieldaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ fieldaccessexpr $whitespace$ asfieldaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isFieldAccessExpr	223	227	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/FieldAccessExpr.java	0.9036316871643066	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isFieldAccessExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfieldaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isfieldaccessexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifInstanceOfExpr	193	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.6856805682182312	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifInstanceOfExpr(Consumer<InstanceOfExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifinstanceofexpr ( consumer < instanceofexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifinstanceofexpr ( consumer < instanceofexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	148	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
remove	205	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.838367223739624	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (pattern != null) {
		        if (node == pattern) {
		            removePattern();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( pattern $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ pattern ) $whitespace$ { $newline$ $indentation$ removepattern ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ pattern ) $whitespace$ { $newline$ $indentation$ removepattern ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
setType	275	287	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.841030478477478	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public InstanceOfExpr setType(final ReferenceType type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ instanceofexpr $whitespace$ settype ( final $whitespace$ referencetype $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ instanceofexpr $whitespace$ settype ( final $whitespace$ referencetype $whitespace$ type ) { $newline$ $indentation$ assertcurrentvalueisnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asInstanceOfExpr	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.8627721071243286	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public InstanceOfExpr asInstanceOfExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ instanceofexpr $whitespace$ asinstanceofexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ instanceofexpr $whitespace$ asinstanceofexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isInstanceOfExpr	199	203	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/InstanceOfExpr.java	0.9062368273735046	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isInstanceOfExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinstanceofexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinstanceofexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifIntegerLiteralExpr	172	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.6694508790969849	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifIntegerLiteralExpr(Consumer<IntegerLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifintegerliteralexpr ( consumer < integerliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifintegerliteralexpr ( consumer < integerliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.7123497724533081	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public IntegerLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.integerLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ integerliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . integerliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ integerliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. integerliteralexprmetamodel ; $newline$ $indentation$ }			
toIntegerLiteralExpr	178	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.7257358431816101	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<IntegerLiteralExpr> toIntegerLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < integerliteralexpr > $whitespace$ tointegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < integerliteralexpr > $whitespace$ tointegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asIntegerLiteralExpr	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.8391808867454529	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public IntegerLiteralExpr asIntegerLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ integerliteralexpr $whitespace$ asintegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ integerliteralexpr $whitespace$ asintegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setInt	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.8475517630577087	HIGH	"		@Deprecated
		public IntegerLiteralExpr setInt(int value){
		    this.value = String.valueOf(value);
		    return this;
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ integerliteralexpr $whitespace$ setint ( int $whitespace$ value ) { $newline$ $indentation$ this . value $whitespace$ = $whitespace$ string . valueof ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ integerliteralexpr $whitespace$ setint ( int $whitespace$ value ) { $newline$ $indentation$ this. value $whitespace$ = $whitespace$ getstring ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isIntegerLiteralExpr	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/IntegerLiteralExpr.java	0.8942615389823914	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isIntegerLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isintegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isintegerliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getExpressionBody	209	215	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.609166145324707	MID	"		@DerivedProperty
		public Optional<Expression> getExpressionBody(){
		    if (body.isExpressionStmt()) {
		        return Optional.of(body.asExpressionStmt().getExpression());
		    }
		    return Optional.empty();
		}"	$indentation$ @ derivedproperty $newline$ $indentation$ public $whitespace$ optional < expression > $whitespace$ getexpressionbody ( ) { $newline$ $indentation$ if $whitespace$ ( body . isexpressionstmt ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( body . asexpressionstmt ( ) . getexpression ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ derivedproperty $newline$ $indentation$ public $whitespace$ optional < expression > $whitespace$ getexpressionbody ( ) { $newline$ $indentation$ return $whitespace$ body. isexpressionstmt ( ) $whitespace$? $whitespace$ optional. of ( body. asexpressionstmt ( ). getexpression ( ) ) $whitespace$ : $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ optional < expression > $whitespace$ getexpressionbody ( ) { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
ifLambdaExpr	260	264	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.7155272364616394	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLambdaExpr(Consumer<LambdaExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflambdaexpr ( consumer < lambdaexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflambdaexpr ( consumer < lambdaexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
replace	229	246	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.7289885878562927	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == body) {
		        setBody((Statement) replacementNode);
		        return true;
		    }
		    for (int i = 0; i < parameters.size(); i++) {
		        if (parameters.get(i) == node) {
		            parameters.set(i, (Parameter) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ setbody ( ( statement ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters . set ( i , $whitespace$ ( parameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ deletednode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ body ) $whitespace$ { $newline$ $indentation$ setbody ( ( statement ) $whitespace$ deletednode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ parameters. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parameters. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ parameters. set ( i, $whitespace$ ( parameter ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
accept	163	167	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	149	161	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.8531636595726013	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public LambdaExpr setBody(final Statement body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ asserttrue ( body ) ; $newline$ $indentation$ return $whitespace$ body ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ assertnull ( final $whitespace$ statement $whitespace$ body ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setParameters	126	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.858493983745575	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public LambdaExpr setParameters(final NodeList<Parameter> parameters){
		    assertNotNull(parameters);
		    if (parameters == this.parameters) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.PARAMETERS, this.parameters, parameters);
		    if (this.parameters != null)
		        this.parameters.setParentNode(null);
		    this.parameters = parameters;
		    setAsParentNodeOf(parameters);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertnotnull ( parameters ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this . parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . parameters , $whitespace$ this . parameters , $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this . parameters $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . parameters . setparentnode ( null ) ; $newline$ $indentation$ this . parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ setparameters ( final $whitespace$ nodelist < parameter > $whitespace$ parameters ) { $newline$ $indentation$ assertnotnull ( parameters ) ; $newline$ $indentation$ if $whitespace$ ( parameters $whitespace$ == $whitespace$ this. parameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. parameters, $whitespace$ this. parameters, $whitespace$ parameters ) ; $newline$ $indentation$ if $whitespace$ ( this. parameters $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. parameters. setparentnode ( null ) ; $newline$ $indentation$ this. parameters $whitespace$ = $whitespace$ parameters ; $newline$ $indentation$ setasparentnodeof ( parameters ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asLambdaExpr	254	258	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.8873354196548462	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public LambdaExpr asLambdaExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ aslambdaexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ lambdaexpr $whitespace$ aslambdaexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLambdaExpr	248	252	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LambdaExpr.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLambdaExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islambdaexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islambdaexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLiteralExpr	78	82	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralExpr.java	0.7040520310401917	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLiteralExpr(Consumer<LiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifliteralexpr ( consumer < literalexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) { $newline$ $indentation$ // $whitespace$ the $whitespace$ url $whitespace$ if $whitespace$ the $whitespace$ header $whitespace$ does $whitespace$ not $whitespace$ contain $whitespace$ the $whitespace$ bearer $whitespace$ prefix $newline$ $indentation$ public $whitespace$ void $whitespace$ ifliteralexpr ( consumer < literalexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
asLiteralExpr	72	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralExpr.java	0.8808639645576477	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public LiteralExpr asLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalexpr $whitespace$ asliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalexpr $whitespace$ asliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLiteralExpr	66	70	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralExpr.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLiteralStringValueExpr	98	102	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java	0.6385279297828674	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLiteralStringValueExpr(Consumer<LiteralStringValueExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifliteralstringvalueexpr ( consumer < literalstringvalueexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) { $newline$ $indentation$ // $whitespace$ the $whitespace$ url $whitespace$ if $whitespace$ the $whitespace$ header $whitespace$ does $whitespace$ not $whitespace$ contain $whitespace$ the $whitespace$ bearer $whitespace$ prefix $newline$ $indentation$ public $whitespace$ void $whitespace$ ifliteralstringvalueexpr ( consumer < literalstringvalueexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	80	84	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java	0.6944940686225891	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public LiteralStringValueExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.literalStringValueExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalstringvalueexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . literalstringvalueexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalstringvalueexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. literalstringvalueexprmetamodel ; $newline$ $indentation$ }			
toLiteralStringValueExpr	104	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java	0.7027578353881836	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<LiteralStringValueExpr> toLiteralStringValueExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < literalstringvalueexpr > $whitespace$ toliteralstringvalueexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < literalstringvalueexpr > $whitespace$ toliteralstringvalueexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
setValue	63	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java	0.8459824323654175	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public LiteralStringValueExpr setValue(final String value){
		    assertNotNull(value);
		    if (value == this.value) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.VALUE, this.value, value);
		    this.value = value;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalstringvalueexpr $whitespace$ setvalue ( final $whitespace$ string $whitespace$ value ) { $newline$ $indentation$ assertnotnull ( value ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ this . value ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . value , $whitespace$ this . value , $whitespace$ value ) ; $newline$ $indentation$ this . value $whitespace$ = $whitespace$ value ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ literalstringvalueexpr $whitespace$ setvalue ( final $whitespace$ string $whitespace$ value ) { $newline$ $indentation$ assertnotnull ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLiteralStringValueExpr	86	90	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LiteralStringValueExpr.java	0.8824164867401123	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLiteralStringValueExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isliteralstringvalueexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isliteralstringvalueexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLongLiteralExpr	179	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.6788556575775146	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLongLiteralExpr(Consumer<LongLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflongliteralexpr ( consumer < longliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflongliteralexpr ( consumer < longliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	161	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.7193578481674194	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public LongLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.longLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ longliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . longliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ longliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. longliteralexprmetamodel ; $newline$ $indentation$ }			
toLongLiteralExpr	185	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.7359896302223206	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<LongLiteralExpr> toLongLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < longliteralexpr > $whitespace$ tolongliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < longliteralexpr > $whitespace$ tolongliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asLongLiteralExpr	173	177	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.856945812702179	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public LongLiteralExpr asLongLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ longliteralexpr $whitespace$ aslongliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ longliteralexpr $whitespace$ aslongliteralexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setLong	149	153	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.8605502843856812	HIGH	"		@Deprecated
		public LongLiteralExpr setLong(long value){
		    this.value = String.valueOf(value);
		    return this;
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ longliteralexpr $whitespace$ setlong ( long $whitespace$ value ) { $newline$ $indentation$ this . value $whitespace$ = $whitespace$ string . valueof ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ longliteralexpr $whitespace$ setlong ( long $whitespace$ value ) { $newline$ $indentation$ this. value $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLongLiteralExpr	167	171	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/LongLiteralExpr.java	0.9044291377067566	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLongLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islongliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islongliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifMarkerAnnotationExpr	103	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.6499840021133423	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifMarkerAnnotationExpr(Consumer<MarkerAnnotationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmarkerannotationexpr ( consumer < markerannotationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmarkerannotationexpr ( consumer < markerannotationexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.6992778778076172	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public MarkerAnnotationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.markerAnnotationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ markerannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . markerannotationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ markerannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. markerannotationexprmetamodel ; $newline$ $indentation$ }			
toMarkerAnnotationExpr	109	113	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.7110759615898132	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<MarkerAnnotationExpr> toMarkerAnnotationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < markerannotationexpr > $whitespace$ tomarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < markerannotationexpr > $whitespace$ tomarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	67	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asMarkerAnnotationExpr	97	101	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.8308048248291016	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public MarkerAnnotationExpr asMarkerAnnotationExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ markerannotationexpr $whitespace$ asmarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ markerannotationexpr $whitespace$ asmarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isMarkerAnnotationExpr	91	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MarkerAnnotationExpr.java	0.8881710767745972	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isMarkerAnnotationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismarkerannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getMetaModel	129	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MemberValuePair.java	0.7193578481674194	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public MemberValuePairMetaModel getMetaModel(){
		    return JavaParserMetaModel.memberValuePairMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepairmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . membervaluepairmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepairmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. membervaluepairmetamodel ; $newline$ $indentation$ }			
accept	73	77	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MemberValuePair.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setValue	109	121	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MemberValuePair.java	0.8344060182571411	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MemberValuePair setValue(final Expression value){
		    assertNotNull(value);
		    if (value == this.value) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.VALUE, this.value, value);
		    if (this.value != null)
		        this.value.setParentNode(null);
		    this.value = value;
		    setAsParentNodeOf(value);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepair $whitespace$ setvalue ( final $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ assertnotnull ( value ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ this . value ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . value , $whitespace$ this . value , $whitespace$ value ) ; $newline$ $indentation$ if $whitespace$ ( this . value $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . value . setparentnode ( null ) ; $newline$ $indentation$ this . value $whitespace$ = $whitespace$ value ; $newline$ $indentation$ setasparentnodeof ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepair $whitespace$ setvalue ( final $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ assertnull ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ membervaluepair $whitespace$ setvalue ( final $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ setasparentnodeof ( final $whitespace$ value ) { $newline$ $indentation$ this. value. setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ setasparentnodeof ( final $whitespace$ value ) { $newline$ $indentation$ this. value. setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	95	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MemberValuePair.java	0.8461947441101074	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MemberValuePair setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepair $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ membervaluepair $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifMethodCallExpr	298	302	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.6876581907272339	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifMethodCallExpr(Consumer<MethodCallExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethodcallexpr ( consumer < methodcallexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethodcallexpr ( consumer < methodcallexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
setArguments	142	154	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.8486536145210266	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MethodCallExpr setArguments(final NodeList<Expression> arguments){
		    assertNotNull(arguments);
		    if (arguments == this.arguments) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ARGUMENTS, this.arguments, arguments);
		    if (this.arguments != null)
		        this.arguments.setParentNode(null);
		    this.arguments = arguments;
		    setAsParentNodeOf(arguments);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ this . arguments ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . arguments , $whitespace$ this . arguments , $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this . arguments $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . arguments . setparentnode ( null ) ; $newline$ $indentation$ this . arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. arguments, $whitespace$ this. arguments, $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this. arguments $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. arguments. setparentnode ( null ) ; $newline$ $indentation$ this. arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isPolyExpression	337	359	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.8499302864074707	HIGH	"		@Override
		public boolean isPolyExpression(){
		    // A method invocation expression is a poly expression if all of the following are true:
		    //
		    // 1. The invocation appears in an assignment context or an invocation context (§5.2, §5.3).
		    if (!(appearsInAssignmentContext() || appearsInInvocationContext())) {
		        return false;
		    }
		    // 2. If the invocation is qualified (that is, any form of MethodInvocation except for the form [MethodName (
		    // [ArgumentList] )]), then the invocation elides TypeArguments to the left of the Identifier.
		    if (isQualified() && !elidesTypeArguments()) {
		        return false;
		    }
		    // 3. The method to be invoked, as determined by the following subsections, is generic (§8.4.4) and has a
		    // return type that mentions at least one of the method's type parameters.
		    // A method is generic if it declares one or more type variables (§4.4).
		    if (isGenericMethod() && hasParameterwithSameTypeThanResultType(resolve().getReturnType())) {
		        // it's a poly expression
		        return true;
		    }
		    // Otherwise, the method invocation expression is a standalone expression.
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ispolyexpression ( ) { $newline$ $indentation$ $//·a·method·invocation·expression·is·a·poly·expression·if·all·of·the·following·are·true:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·the·invocation·appears·in·an·assignment·context·or·an·invocation·context·(§5.2,·§5.3).$ $newline$ $indentation$ if $whitespace$ ( ! ( appearsinassignmentcontext ( ) $whitespace$ || $whitespace$ appearsininvocationcontext ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·if·the·invocation·is·qualified·(that·is,·any·form·of·methodinvocation·except·for·the·form·[methodname·($ $newline$ $indentation$ $//·[argumentlist]·)]),·then·the·invocation·elides·typearguments·to·the·left·of·the·identifier.$ $newline$ $indentation$ if $whitespace$ ( isqualified ( ) $whitespace$ && $whitespace$ ! elidestypearguments ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·3.·the·method·to·be·invoked,·as·determined·by·the·following·subsections,·is·generic·(§8.4.4)·and·has·a$ $newline$ $indentation$ $//·return·type·that·mentions·at·least·one·of·the·method's·type·parameters.$ $newline$ $indentation$ $//·a·method·is·generic·if·it·declares·one·or·more·type·variables·(§4.4).$ $newline$ $indentation$ if $whitespace$ ( isgenericmethod ( ) $whitespace$ && $whitespace$ hasparameterwithsametypethanresulttype ( resolve ( ) . getreturntype ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·it's·a·poly·expression$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·the·method·invocation·expression·is·a·standalone·expression.$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ispolyexpression ( ) { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$////////////////////////////////////1. $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$//////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$//////////////////////////////////////////////////////////////////// $newline$ $indent			
setName	156	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.8529492020606995	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public MethodCallExpr setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asMethodCallExpr	292	296	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.8616802096366882	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public MethodCallExpr asMethodCallExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ asmethodcallexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodcallexpr $whitespace$ asmethodcallexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isMethodCallExpr	286	290	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodCallExpr.java	0.9070149064064026	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isMethodCallExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethodcallexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethodcallexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifMethodReferenceExpr	223	227	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.6634507179260254	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifMethodReferenceExpr(Consumer<MethodReferenceExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethodreferenceexpr ( consumer < methodreferenceexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmethodreferenceexpr ( consumer < methodreferenceexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
replace	190	209	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.7057095766067505	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == scope) {
		        setScope((Expression) replacementNode);
		        return true;
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.set(i, (Type) replacementNode);
		                return true;
		            }
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setscope ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . set ( i , $whitespace$ ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setscope ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
getMetaModel	184	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.7062127590179443	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public MethodReferenceExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.methodReferenceExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodreferenceexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . methodreferenceexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodreferenceexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. methodreferenceexprmetamodel ; $newline$ $indentation$ }			
remove	161	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.7074044942855835	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.remove(i);
		                return true;
		            }
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
toMethodReferenceExpr	229	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.7197785377502441	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<MethodReferenceExpr> toMethodReferenceExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < methodreferenceexpr > $whitespace$ tomethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < methodreferenceexpr > $whitespace$ tomethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	90	94	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asMethodReferenceExpr	217	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.8342312574386597	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public MethodReferenceExpr asMethodReferenceExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodreferenceexpr $whitespace$ asmethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ methodreferenceexpr $whitespace$ asmethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isMethodReferenceExpr	211	215	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/MethodReferenceExpr.java	0.8919344544410706	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isMethodReferenceExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismethodreferenceexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setQualifier	128	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Name.java	0.7122957110404968	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Name setQualifier(final Name qualifier){
		    if (qualifier == this.qualifier) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.QUALIFIER, this.qualifier, qualifier);
		    if (this.qualifier != null)
		        this.qualifier.setParentNode(null);
		    this.qualifier = qualifier;
		    setAsParentNodeOf(qualifier);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ name $whitespace$ setqualifier ( final $whitespace$ name $whitespace$ qualifier ) { $newline$ $indentation$ if $whitespace$ ( qualifier $whitespace$ == $whitespace$ this . qualifier ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . qualifier , $whitespace$ this . qualifier , $whitespace$ qualifier ) ; $newline$ $indentation$ if $whitespace$ ( this . qualifier $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . qualifier . setparentnode ( null ) ; $newline$ $indentation$ this . qualifier $whitespace$ = $whitespace$ qualifier ; $newline$ $indentation$ setasparentnodeof ( qualifier ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ name $whitespace$ setqualifier ( final $whitespace$ name $whitespace$ qualifier ) { $newline$ $indentation$ if $whitespace$ ( qualifier $whitespace$ == $whitespace$ this. qualifier ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. qualifier, $whitespace$ this. qualifier, $whitespace$ qualifier ) ; $newline$ $indentation$ if $whitespace$ ( this. qualifier $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. qualifier. setparentnode ( null ) ; $newline$ $indentation$ this. qualifier $whitespace$ = $whitespace$ qualifier ; $newline$ $indentation$ setasparentnodeof ( qualifier ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
accept	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Name.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asString	116	121	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Name.java	0.8320347666740417	HIGH	"		public String asString(){
		    if (qualifier != null) {
		        return qualifier.asString() + ""."" + identifier;
		    }
		    return identifier;
		}"	$indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ if $whitespace$ ( qualifier $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifier . asstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ identifier ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ identifier ; $newline$ $indentation$ }	$indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ if $whitespace$ ( qualifier $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifier. asstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ identifier ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ identifier ; $newline$ $indentation$ }			
clone	161	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/Name.java	0.86275714635849	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Name clone(){
		    return (Name) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ name $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( name ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ name $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( name ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
ifNameExpr	146	150	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java	0.7239876985549927	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifNameExpr(Consumer<NameExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifnameexpr ( consumer < nameexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( consumer < nameexpr > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
replace	121	132	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java	0.8314456939697266	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
setName	95	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java	0.8507547974586487	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NameExpr setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nameexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nameexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asNameExpr	140	144	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java	0.8982763886451721	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public NameExpr asNameExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nameexpr $whitespace$ asnameexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nameexpr $whitespace$ asnameexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isNameExpr	134	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NameExpr.java	0.925080955028534	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isNameExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnameexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnameexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
addPair	112	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.6354672312736511	MID	"		public NormalAnnotationExpr addPair(String key, Expression value){
		    MemberValuePair memberValuePair = new MemberValuePair(key, value);
		    getPairs().add(memberValuePair);
		    return this;
		}"	$indentation$ public $whitespace$ normalannotationexpr $whitespace$ addpair ( string $whitespace$ key , $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ membervaluepair $whitespace$ membervaluepair $whitespace$ = $whitespace$ new $whitespace$ membervaluepair ( key , $whitespace$ value ) ; $newline$ $indentation$ getpairs ( ) . add ( membervaluepair ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ normalannotationexpr $whitespace$ addpair ( string $whitespace$ key, $whitespace$ expression $whitespace$ value ) { $newline$ $indentation$ membervaluepair $whitespace$ membervaluepair $whitespace$ = $whitespace$ new $whitespace$ membervaluepair ( key, $whitespace$ value ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifNormalAnnotationExpr	172	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.6520722508430481	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifNormalAnnotationExpr(Consumer<NormalAnnotationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifnormalannotationexpr ( consumer < normalannotationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! isadded ( ) ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	139	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.7012072205543518	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public NormalAnnotationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.normalAnnotationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ normalannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . normalannotationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ normalannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. normalannotationexprmetamodel ; $newline$ $indentation$ }			
toNormalAnnotationExpr	178	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.7110759615898132	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<NormalAnnotationExpr> toNormalAnnotationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < normalannotationexpr > $whitespace$ tonormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < normalannotationexpr > $whitespace$ tonormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	67	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asNormalAnnotationExpr	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.8308048248291016	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public NormalAnnotationExpr asNormalAnnotationExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ normalannotationexpr $whitespace$ asnormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ normalannotationexpr $whitespace$ asnormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setPairs	84	96	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.8819519877433777	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public NormalAnnotationExpr setPairs(final NodeList<MemberValuePair> pairs){
		    assertNotNull(pairs);
		    if (pairs == this.pairs) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.PAIRS, this.pairs, pairs);
		    if (this.pairs != null)
		        this.pairs.setParentNode(null);
		    this.pairs = pairs;
		    setAsParentNodeOf(pairs);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ normalannotationexpr $whitespace$ setpairs ( final $whitespace$ nodelist < membervaluepair > $whitespace$ pairs ) { $newline$ $indentation$ assertnotnull ( pairs ) ; $newline$ $indentation$ if $whitespace$ ( pairs $whitespace$ == $whitespace$ this . pairs ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . pairs , $whitespace$ this . pairs , $whitespace$ pairs ) ; $newline$ $indentation$ if $whitespace$ ( this . pairs $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . pairs . setparentnode ( null ) ; $newline$ $indentation$ this . pairs $whitespace$ = $whitespace$ pairs ; $newline$ $indentation$ setasparentnodeof ( pairs ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ normalannotationexpr $whitespace$ setpairs ( final $whitespace$ nodelist < membervaluepair > $whitespace$ pairs ) { $newline$ $indentation$ assertnotnull ( pairs ) ; $newline$ $indentation$ if $whitespace$ ( pairs $whitespace$ == $whitespace$ this. pairs ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. pairs, $whitespace$ this. pairs, $whitespace$ pairs ) ; $newline$ $indentation$ if $whitespace$ ( this. pairs $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. pairs. setparentnode ( null ) ; $newline$ $indentation$ this. pairs $whitespace$ = $whitespace$ pairs ; $newline$ $indentation$ setasparentnodeof ( pairs ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isNormalAnnotationExpr	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NormalAnnotationExpr.java	0.8881710767745972	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isNormalAnnotationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnormalannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifNullLiteralExpr	93	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java	0.6788556575775146	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifNullLiteralExpr(Consumer<NullLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifnullliteralexpr ( consumer < nullliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( no ( consumer < nullliteralexpr > $whitespace$ action ) ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java	0.7174985408782959	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public NullLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.nullLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nullliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . nullliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ nullliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. nullliteralexprmetamodel ; $newline$ $indentation$ }			
toNullLiteralExpr	99	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java	0.73777174949646	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<NullLiteralExpr> toNullLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < nullliteralexpr > $whitespace$ tonullliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < nullliteralexpr > $whitespace$ tonullliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asNullLiteralExpr	87	91	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java	0.8558152914047241	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public NullLiteralExpr asNullLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ nullliteralexpr $whitespace$ asnullliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ list < string > $whitespace$ asnullliteralexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isNullLiteralExpr	81	85	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/NullLiteralExpr.java	0.9044291377067566	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isNullLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnullliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isnullliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setAnonymousClassBody	157	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.2917174398899078	LOW	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ObjectCreationExpr setAnonymousClassBody(final NodeList<BodyDeclaration<?>> anonymousClassBody){
		    if (anonymousClassBody == this.anonymousClassBody) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ANONYMOUS_CLASS_BODY, this.anonymousClassBody, anonymousClassBody);
		    if (this.anonymousClassBody != null)
		        this.anonymousClassBody.setParentNode(null);
		    this.anonymousClassBody = anonymousClassBody;
		    setAsParentNodeOf(anonymousClassBody);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ setanonymousclassbody ( final $whitespace$ nodelist < bodydeclaration < ? >> $whitespace$ anonymousclassbody ) { $newline$ $indentation$ if $whitespace$ ( anonymousclassbody $whitespace$ == $whitespace$ this . anonymousclassbody ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . anonymous_class_body , $whitespace$ this . anonymousclassbody , $whitespace$ anonymousclassbody ) ; $newline$ $indentation$ if $whitespace$ ( this . anonymousclassbody $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . anonymousclassbody . setparentnode ( null ) ; $newline$ $indentation$ this . anonymousclassbody $whitespace$ = $whitespace$ anonymousclassbody ; $newline$ $indentation$ setasparentnodeof ( anonymousclassbody ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ setanonymousclassbody ( final $whitespace$ nodelist < bodydeclaration <? >> $whitespace$ anonymousclassbody ) { $newline$ $indentation$ // $whitespace$ return $whitespace$ this $whitespace$ method $whitespace$ is $whitespace$ implemented $whitespace$ within $whitespace$ palette $whitespace$ properties $newline$ $indentation$ if $whitespace$ ( anonymousclassbody $whitespace$ == $whitespace$ this. anonymousclassbody ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. anonymous_class_body, $whitespace$ this. anonymousclassbody, $whitespace$ anonymousclassbody ) ; $newline$ $indentation$ // $whitespace$ return $whitespace$ this. anonymousclassbody $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ this. anonymousclassbody $whitespace$ : $whitespace$ this. anonymousclassbody ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifObjectCreationExpr	348	352	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.6612650156021118	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifObjectCreationExpr(Consumer<ObjectCreationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifobjectcreationexpr ( consumer < objectcreationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ booleanobjectcreationexpr ( consumer < objectcreationexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	289	293	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.7142295241355896	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ObjectCreationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.objectCreationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . objectcreationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. objectcreationexprmetamodel ; $newline$ $indentation$ }			
toObjectCreationExpr	372	376	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.7220616936683655	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ObjectCreationExpr> toObjectCreationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < objectcreationexpr > $whitespace$ toobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < objectcreationexpr > $whitespace$ toobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setType	203	215	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.8332541584968567	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ObjectCreationExpr setType(final ClassOrInterfaceType type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ settype ( final $whitespace$ classorinterfacetype $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ settype ( final $whitespace$ classorinterfacetype $whitespace$ type ) { $newline$ $indentation$ assertcurrentvalueis ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ @ test $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ settype ( final $whitespace$ classorinterfacetype $whitespace$ type ) { $newline$ $indentation$ assertcurrentvalueis ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asObjectCreationExpr	342	346	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.8391808867454529	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ObjectCreationExpr asObjectCreationExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ asobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ asobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setArguments	170	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.8472123742103577	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ObjectCreationExpr setArguments(final NodeList<Expression> arguments){
		    assertNotNull(arguments);
		    if (arguments == this.arguments) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ARGUMENTS, this.arguments, arguments);
		    if (this.arguments != null)
		        this.arguments.setParentNode(null);
		    this.arguments = arguments;
		    setAsParentNodeOf(arguments);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ this . arguments ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . arguments , $whitespace$ this . arguments , $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this . arguments $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . arguments . setparentnode ( null ) ; $newline$ $indentation$ this . arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objectcreationexpr $whitespace$ setarguments ( final $whitespace$ nodelist < expression > $whitespace$ arguments ) { $newline$ $indentation$ assertnotnull ( arguments ) ; $newline$ $indentation$ if $whitespace$ ( arguments $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. arguments, $whitespace$ this. arguments, $whitespace$ arguments ) ; $newline$ $indentation$ if $whitespace$ ( this. arguments $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. arguments. setparentnode ( null ) ; $newline$ $indentation$ this. arguments $whitespace$ = $whitespace$ arguments ; $newline$ $indentation$ setasparentnodeof ( arguments ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isObjectCreationExpr	336	340	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ObjectCreationExpr.java	0.895127534866333	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isObjectCreationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isobjectcreationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
replace	179	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.6824155449867249	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.set(i, (Modifier) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    if (node == type) {
		        setType((ReferenceType) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . set ( i , $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ type ) $whitespace$ { $newline$ $indentation$ settype ( ( referencetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. stream ( ) $newline$ $indentation$. anymatch ( entry $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
ifPatternExpr	173	177	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.7040520310401917	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifPatternExpr(Consumer<PatternExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifpatternexpr ( consumer < patternexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( consumer < patternexpr > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	208	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.736973226070404	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public PatternExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.patternExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . patternexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. patternexprmetamodel ; $newline$ $indentation$ }			
accept	105	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setType	141	153	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.8452374935150146	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public PatternExpr setType(final ReferenceType type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    if (this.type != null)
		        this.type.setParentNode(null);
		    this.type = type;
		    setAsParentNodeOf(type);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ settype ( final $whitespace$ referencetype $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this . type $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . type . setparentnode ( null ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ settype ( final $whitespace$ referencetype $whitespace$ type ) { $newline$ $indentation$ assertcurrentvalueis ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( this. type $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. type. setparentnode ( null ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ setasparentnodeof ( type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	127	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.8475863337516785	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public PatternExpr setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setModifiers	219	231	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.8675692081451416	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public PatternExpr setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ m. modifiers ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ setmustbenull ( final $whitespace$ nodelist < string > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. modifiers, $whitespace$ this. modifiers, $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this. modifiers $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asPatternExpr	161	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.8798959851264954	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public PatternExpr asPatternExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ aspatternexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ patternexpr $whitespace$ aspatternexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isPatternExpr	155	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/PatternExpr.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isPatternExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ispatternexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ispatternexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
toSingleMemberAnnotationExpr	141	145	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SingleMemberAnnotationExpr.java	0.6810048818588257	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<SingleMemberAnnotationExpr> toSingleMemberAnnotationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < singlememberannotationexpr > $whitespace$ tosinglememberannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < singlememberannotationexpr > $whitespace$ getsinglememberannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	104	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SingleMemberAnnotationExpr.java	0.6871914863586426	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public SingleMemberAnnotationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.singleMemberAnnotationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ singlememberannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . singlememberannotationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ singlememberannotationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. singlememberannotationexprmetamodel ; $newline$ $indentation$ }			
accept	67	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SingleMemberAnnotationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
isSingleMemberAnnotationExpr	123	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SingleMemberAnnotationExpr.java	0.8714120388031006	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isSingleMemberAnnotationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issinglememberannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issinglememberannotationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifStringLiteralExpr	139	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.6655811071395874	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifStringLiteralExpr(Consumer<StringLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifstringliteralexpr ( consumer < stringliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( no ( consumer < stringliteralexpr > $whitespace$ action ) ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	121	125	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public StringLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.stringLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ stringliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . stringliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ stringliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. stringliteralexprmetamodel ; $newline$ $indentation$ }			
toStringLiteralExpr	145	149	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.72767573595047	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<StringLiteralExpr> toStringLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < stringliteralexpr > $whitespace$ tostringliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < stringliteralexpr > $whitespace$ tostringliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	74	78	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asStringLiteralExpr	133	137	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.845419704914093	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public StringLiteralExpr asStringLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ stringliteralexpr $whitespace$ asstringliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ stringliteralexpr $whitespace$ asstringliteralexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isStringLiteralExpr	127	131	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/StringLiteralExpr.java	0.8984567523002625	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isStringLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isstringliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isstringliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifSuperExpr	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifSuperExpr(Consumer<SuperExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifsuperexpr ( consumer < superexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifsuperexpr ( consumer < superexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	73	77	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
remove	103	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java	0.8327826857566833	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (typeName != null) {
		        if (node == typeName) {
		            removeTypeName();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ typename ) $whitespace$ { $newline$ $indentation$ removetypename ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typename $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ removetypename ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
asSuperExpr	136	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public SuperExpr asSuperExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ superexpr $whitespace$ assuperexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ superexpr $whitespace$ assuperexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isSuperExpr	130	134	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SuperExpr.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isSuperExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issuperexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issuperexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
replace	163	180	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.7001101970672607	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < entries.size(); i++) {
		        if (entries.get(i) == node) {
		            entries.set(i, (SwitchEntry) replacementNode);
		            return true;
		        }
		    }
		    if (node == selector) {
		        setSelector((Expression) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ entries . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entries . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ entries . set ( i , $whitespace$ ( switchentry ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ selector ) $whitespace$ { $newline$ $indentation$ setselector ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. size ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ node. set ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
ifSwitchExpr	200	204	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.7155272364616394	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifSwitchExpr(Consumer<SwitchExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifswitchexpr ( consumer < switchexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ switchexpr ( consumer < switchexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	88	92	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setEntries	114	126	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.8677583336830139	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SwitchExpr setEntries(final NodeList<SwitchEntry> entries){
		    assertNotNull(entries);
		    if (entries == this.entries) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ENTRIES, this.entries, entries);
		    if (this.entries != null)
		        this.entries.setParentNode(null);
		    this.entries = entries;
		    setAsParentNodeOf(entries);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchexpr $whitespace$ setentries ( final $whitespace$ nodelist < switchentry > $whitespace$ entries ) { $newline$ $indentation$ assertnotnull ( entries ) ; $newline$ $indentation$ if $whitespace$ ( entries $whitespace$ == $whitespace$ this . entries ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . entries , $whitespace$ this . entries , $whitespace$ entries ) ; $newline$ $indentation$ if $whitespace$ ( this . entries $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . entries . setparentnode ( null ) ; $newline$ $indentation$ this . entries $whitespace$ = $whitespace$ entries ; $newline$ $indentation$ setasparentnodeof ( entries ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchexpr $whitespace$ setentries ( final $whitespace$ nodelist < switchentry > $whitespace$ entries ) { $newline$ $indentation$ return $whitespace$ entries. stream ( ) $newline$ $indentation$. filter ( this : : isnull ) $newline$ $indentation$. map ( entries $whitespace$ - > $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ notifypropertychange ( observableproperty. entries, $whitespace$ this. entries, $whitespace$ entries ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this. entries $whitespace$ == $whitespace$ null ) $newline$ $indentation$ this. entries. setparentnode ( null ) ; $newline$ $indentation$ this. entries $whitespace$ = $whitespace$ entries ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asSwitchExpr	188	192	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.888251006603241	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public SwitchExpr asSwitchExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchexpr $whitespace$ asswitchexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ switchexpr $whitespace$ asswitchexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isSwitchExpr	182	186	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/SwitchExpr.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isSwitchExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isswitchexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isswitchexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
stripIndentOfLines	125	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.032832596451044	LOW	"		public Stream<String> stripIndentOfLines(){
		    /* Split the content of the text block at every LF, producing a list of individual lines. 
		        Note that any line in the content which was just an LF will become an empty line in the list of individual lines. */
		    String[] rawLines = getValue().split(""\\R"", -1);
		    /* Add all non-blank lines from the list of individual lines into a set of determining lines. 
		        (Blank lines -- lines that are empty or are composed wholly of white space -- have no visible influence on the indentation. 
		        Excluding blank lines from the set of determining lines avoids throwing off step 4 of the algorithm.) */
		    /* If the last line in the list of individual lines (i.e., the line with the closing delimiter) is blank, then add it to the set of determining lines. 
		        (The indentation of the closing delimiter should influence the indentation of the content as a whole -- a ""significant trailing line"" policy.) */
		    /* Compute the common white space prefix of the set of determining lines, by counting the number of leading white space characters on each line and taking the minimum count. */
		    int commonWhiteSpacePrefixSize = range(0, rawLines.length).mapToObj(nr -> new Pair<>(nr, rawLines[nr])).filter(l -> !emptyOrWhitespace(l.b) || isLastLine(rawLines, l.a)).map(l -> indentSize(l.b)).min(Integer::compare).orElse(0);
		    /* Remove the common white space prefix from each non-blank line in the list of individual lines. */
		    /* Remove all trailing white space from all lines in the modified list of individual lines from step 5. 
		        This step collapses wholly-whitespace lines in the modified list so that they are empty, but does not discard them. */
		    return Arrays.stream(rawLines).map(l -> l.length() < commonWhiteSpacePrefixSize ? l : l.substring(commonWhiteSpacePrefixSize)).map(this::trimTrailing);
		}"	"$indentation$ public $whitespace$ stream < string > $whitespace$ stripindentoflines ( ) { $newline$ $indentation$ $/*·split·the·content·of·the·text·block·at·every·lf,·producing·a·list·of·individual·lines.············note·that·any·line·in·the·content·which·was·just·an·lf·will·become·an·empty·line·in·the·list·of·individual·lines.·*/$ $newline$ $indentation$ string [ ] $whitespace$ rawlines $whitespace$ = $whitespace$ getvalue ( ) . split ( $string$ , $whitespace$ $number$ ) ; $newline$ $indentation$ $/*·add·all·non-blank·lines·from·the·list·of·individual·lines·into·a·set·of·determining·lines.············(blank·lines·--·lines·that·are·empty·or·are·composed·wholly·of·white·space·--·have·no·visible·influence·on·the·indentation.············excluding·blank·lines·from·the·set·of·determining·lines·avoids·throwing·off·step·4·of·the·algorithm.)·*/$ $newline$ $indentation$ $/*·if·the·last·line·in·the·list·of·individual·lines·(i.e.,·the·line·with·the·closing·delimiter)·is·blank,·then·add·it·to·the·set·of·determining·lines.············(the·indentation·of·the·closing·delimiter·should·influence·the·indentation·of·the·content·as·a·whole·--·a·""significant·trailing·line""·policy.)·*/$ $newline$ $indentation$ $/*·compute·the·common·white·space·prefix·of·the·set·of·determining·lines,·by·counting·the·number·of·leading·white·space·characters·on·each·line·and·taking·the·minimum·count.·*/$ $newline$ $indentation$ int $whitespace$ commonwhitespaceprefixsize $whitespace$ = $whitespace$ range ( $number$ , $whitespace$ rawlines . length ) . maptoobj ( nr $whitespace$ - > $whitespace$ new $whitespace$ pair < > ( nr , $whitespace$ rawlines [ nr ] ) ) . filter ( l $whitespace$ - > $whitespace$ ! emptyorwhitespace ( l . b ) $whitespace$ || $whitespace$ islastline ( rawlines , $whitespace$ l . a ) ) . map ( l $whitespace$ - > $whitespace$ indentsize ( l . b ) ) . min ( integer : : compare ) . orelse ( $number$ ) ; $newline$ $indentation$ $/*·remove·the·common·white·space·prefix·from·each·non-blank·line·in·the·list·of·individual·lines.·*/$ $newline$ $indentation$ $/*·remove·all·trailing·white·space·from·all·lines·in·the·modified·list·of·individual·lines·from·step·5.············this·step·collapses·wholly-whitespace·lines·in·the·modified·list·so·that·they·are·empty,·but·does·not·discard·them.·*/$ $newline$ $indentation$ return $whitespace$ arrays . stream ( rawlines ) . map ( l $whitespace$ - > $whitespace$ l . length ( ) $whitespace$ < $whitespace$ commonwhitespaceprefixsize $whitespace$ ? $whitespace$ l $whitespace$ : $whitespace$ l . substring ( commonwhitespaceprefixsize ) ) . map ( this : : trimtrailing ) ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ stream < string > $whitespace$ stripnewoflines ( ) { $newline$ $indentation$ $/*/*ation$$ subtasktherecordrecordrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr			
ifTextBlockLiteralExpr	103	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.6520722508430481	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifTextBlockLiteralExpr(Consumer<TextBlockLiteralExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftextblockliteralexpr ( consumer < textblockliteralexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftextblockliteralexpr ( consumer < textblockliteralexpr > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toTextBlockLiteralExpr	97	101	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.7110759615898132	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<TextBlockLiteralExpr> toTextBlockLiteralExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < textblockliteralexpr > $whitespace$ totextblockliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < textblockliteralexpr > $whitespace$ totextblockliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	115	119	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.7126321196556091	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public TextBlockLiteralExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.textBlockLiteralExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ textblockliteralexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . textblockliteralexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ textblockliteralexprmetamodel $whitespace$ getmetamodel ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. textblockliteralexprmetamodel ; $newline$ $indentation$ }			
accept	73	77	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asTextBlockLiteralExpr	91	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.8346456289291382	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public TextBlockLiteralExpr asTextBlockLiteralExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ textblockliteralexpr $whitespace$ astextblockliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ textblockliteralexpr $whitespace$ astextblockliteralexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
indentSize	182	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.8778582811355591	HIGH	"		private int indentSize(String s){
		    String content = s.trim();
		    if (content.isEmpty()) {
		        return s.length();
		    }
		    return s.indexOf(content);
		}"	$indentation$ private $whitespace$ int $whitespace$ indentsize ( string $whitespace$ s ) { $newline$ $indentation$ string $whitespace$ content $whitespace$ = $whitespace$ s . trim ( ) ; $newline$ $indentation$ if $whitespace$ ( content . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ s . length ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ s . indexof ( content ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ indentsize ( string $whitespace$ s ) { $newline$ $indentation$ string $whitespace$ content $whitespace$ = $whitespace$ s. trim ( ) ; $newline$ $indentation$ return $whitespace$ content. length ( ) $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ s. indexof ( content ) ; $newline$ $indentation$ }			
isTextBlockLiteralExpr	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.8872548341751099	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isTextBlockLiteralExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istextblockliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istextblockliteralexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
stripIndent	145	149	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TextBlockLiteralExpr.java	0.938387930393219	HIGH	"		public String stripIndent(){
		    /* Construct the result string by joining all the lines in the modified list of individual lines from step 6, using LF as the separator between lines. 
		        If the final line in the list from step 6 is empty, then the joining LF from the previous line will be the last character in the result string. */
		    return stripIndentOfLines().collect(joining(""\n""));
		}"	$indentation$ public $whitespace$ string $whitespace$ stripindent ( ) { $newline$ $indentation$ $/*·construct·the·result·string·by·joining·all·the·lines·in·the·modified·list·of·individual·lines·from·step·6,·using·lf·as·the·separator·between·lines.············if·the·final·line·in·the·list·from·step·6·is·empty,·then·the·joining·lf·from·the·previous·line·will·be·the·last·character·in·the·result·string.·*/$ $newline$ $indentation$ return $whitespace$ stripindentoflines ( ) . collect ( joining ( $string$ ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ string $whitespace$ strip ( ) { $newline$ $indentation$ $/*/* $whitespace$ $whitespace$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ $/* $whitespace$ = $whitespace$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ $newline$ $indentation$ private $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ = $whitespace$ striptrailing ( ) ; $newline$ $indentation$ return $whitespace$ striptrailing ; $newline$ $indentation$ }			
ifThisExpr	164	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java	0.7221471667289734	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifThisExpr(Consumer<ThisExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifthisexpr ( consumer < thisexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( consumer < thisexpr > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
remove	105	118	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java	0.8327826857566833	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (typeName != null) {
		        if (node == typeName) {
		            removeTypeName();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ typename ) $whitespace$ { $newline$ $indentation$ removetypename ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typename $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ removetypename ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
asThisExpr	158	162	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java	0.8991132378578186	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ThisExpr asThisExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ thisexpr $whitespace$ asthisexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ level $whitespace$ asthisexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isThisExpr	152	156	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/ThisExpr.java	0.925080955028534	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isThisExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isthisexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isthisexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifTypeExpr	140	144	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java	0.7239876985549927	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifTypeExpr(Consumer<TypeExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftypeexpr ( consumer < typeexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( consumer < typeexpr > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	72	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
replace	115	126	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java	0.8389257192611694	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == type) {
		        setType((Type) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ type ) $whitespace$ { $newline$ $indentation$ settype ( ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ type $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ replacementnode ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
asTypeExpr	134	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java	0.8982763886451721	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public TypeExpr asTypeExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeexpr $whitespace$ astypeexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeexpr $whitespace$ astypeexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isTypeExpr	128	132	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/TypeExpr.java	0.925080955028534	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isTypeExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istypeexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istypeexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifUnaryExpr	205	209	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/UnaryExpr.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifUnaryExpr(Consumer<UnaryExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifunaryexpr ( consumer < unaryexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifunaryexpr ( consumer < unaryexpr > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
setOperator	147	156	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/UnaryExpr.java	0.8350948691368103	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public UnaryExpr setOperator(final Operator operator){
		    assertNotNull(operator);
		    if (operator == this.operator) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.OPERATOR, this.operator, operator);
		    this.operator = operator;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unaryexpr $whitespace$ setoperator ( final $whitespace$ operator $whitespace$ operator ) { $newline$ $indentation$ assertnotnull ( operator ) ; $newline$ $indentation$ if $whitespace$ ( operator $whitespace$ == $whitespace$ this . operator ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . operator , $whitespace$ this . operator , $whitespace$ operator ) ; $newline$ $indentation$ this . operator $whitespace$ = $whitespace$ operator ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unaryexpr $whitespace$ setoperator ( final $whitespace$ operator $whitespace$ operator ) $whitespace$ { $newline$ $indentation$ assertnotnull ( operator ) ; $newline$ $indentation$ if $whitespace$ ( operator $whitespace$ == $whitespace$ this. operator ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. operator, $whitespace$ this. operator, $whitespace$ operator ) ; $newline$ $indentation$ this. operator $whitespace$ = $whitespace$ operator ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asUnaryExpr	199	203	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/UnaryExpr.java	0.8939412832260132	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public UnaryExpr asUnaryExpr(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unaryexpr $whitespace$ asunaryexpr ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unaryexpr $whitespace$ asunaryexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isUnaryExpr	193	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/UnaryExpr.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isUnaryExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunaryexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunaryexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifVariableDeclarationExpr	264	268	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.6332191824913025	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifVariableDeclarationExpr(Consumer<VariableDeclarationExpr> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvariabledeclarationexpr ( consumer < variabledeclarationexpr > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvariabledeclarationexpr ( consumer < string > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	219	223	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.6933295726776123	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public VariableDeclarationExprMetaModel getMetaModel(){
		    return JavaParserMetaModel.variableDeclarationExprMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . variabledeclarationexprmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarationexprmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. variabledeclarationexprmetamodel ; $newline$ $indentation$ }			
toVariableDeclarationExpr	270	274	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.7004919648170471	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<VariableDeclarationExpr> toVariableDeclarationExpr(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < variabledeclarationexpr > $whitespace$ tovariabledeclarationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < variabledeclarationexpr > $whitespace$ tovariabledeclarationexpr ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setModifiers	158	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.8545351028442383	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public VariableDeclarationExpr setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarationexpr $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ variabledeclarationexpr $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ modifiers $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ this. modifiers $whitespace$ : $whitespace$ this. modifiers ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isVariableDeclarationExpr	252	256	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/expr/VariableDeclarationExpr.java	0.8789102435112	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isVariableDeclarationExpr(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvariabledeclarationexpr ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvariabledeclarationexpr ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
replace	198	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.6077818274497986	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.set(i, (AnnotationExpr) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < directives.size(); i++) {
		        if (directives.get(i) == node) {
		            directives.set(i, (ModuleDirective) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . set ( i , $whitespace$ ( annotationexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ directives . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( directives . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ directives . set ( i , $whitespace$ ( moduledirective ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations. set ( i, $whitespace$ ( annotationexpr ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$			
remove	131	150	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.6560060977935791	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < annotations.size(); i++) {
		        if (annotations.get(i) == node) {
		            annotations.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < directives.size(); i++) {
		        if (directives.get(i) == node) {
		            directives.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ directives . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( directives . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ directives . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ annotations. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( annotations. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ annotations. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
getMetaModel	192	196	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.7158516049385071	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleDeclarationMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleDeclarationMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduledeclarationmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclarationmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduledeclarationmetamodel ; $newline$ $indentation$ }			
accept	81	85	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setDirectives	172	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.8464891910552979	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleDeclaration setDirectives(final NodeList<ModuleDirective> directives){
		    assertNotNull(directives);
		    if (directives == this.directives) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.DIRECTIVES, this.directives, directives);
		    if (this.directives != null)
		        this.directives.setParentNode(null);
		    this.directives = directives;
		    setAsParentNodeOf(directives);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclaration $whitespace$ setdirectives ( final $whitespace$ nodelist < moduledirective > $whitespace$ directives ) { $newline$ $indentation$ assertnotnull ( directives ) ; $newline$ $indentation$ if $whitespace$ ( directives $whitespace$ == $whitespace$ this . directives ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . directives , $whitespace$ this . directives , $whitespace$ directives ) ; $newline$ $indentation$ if $whitespace$ ( this . directives $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . directives . setparentnode ( null ) ; $newline$ $indentation$ this . directives $whitespace$ = $whitespace$ directives ; $newline$ $indentation$ setasparentnodeof ( directives ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclaration $whitespace$ setdirectives ( final $whitespace$ nodelist < moduledirective > $whitespace$ directives ) { $newline$ $indentation$ assertnotnull ( directives ) ; $newline$ $indentation$ if $whitespace$ ( directives $whitespace$ == $whitespace$ this. directives ) $whitespace$ { $newline$ $indentation$ switch ( this. directives ) $whitespace$ { $newline$ $indentation$ case $whitespace$ this. directives : $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ case $whitespace$ directives : $newline$ $indentation$ system. out. println ( $string$ ) ; $newline$ $indentation$ directives. setparentnode ( null ) ; $newline$ $indentation$ directives $whitespace$ = $whitespace$ directives ; $newline$ $indentation$ setasparentnodeof ( directives ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	98	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDeclaration.java	0.8647106885910034	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleDeclaration setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledeclaration $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getMetaModel	251	255	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleDirective.java	0.7193578481674194	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduledirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduledirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduledirectivemetamodel ; $newline$ $indentation$ }			
ifModuleExportsDirective	208	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.6364037394523621	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifModuleExportsDirective(Consumer<ModuleExportsDirective> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleexportsdirective ( consumer < moduleexportsdirective > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleexportsdirective ( consumer < moduleexportsdirective > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	214	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.6944940686225891	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleExportsDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleExportsDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduleexportsdirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduleexportsdirectivemetamodel ; $newline$ $indentation$ }			
toModuleExportsDirective	202	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.7008342742919922	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleExportsDirective> toModuleExportsDirective(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleexportsdirective > $whitespace$ tomoduleexportsdirective ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ optional < moduleexportsdirective > $whitespace$ tomoduleexportsdirective ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
replace	143	160	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.718061625957489	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < moduleNames.size(); i++) {
		        if (moduleNames.get(i) == node) {
		            moduleNames.set(i, (Name) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modulenames . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modulenames . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modulenames . set ( i , $whitespace$ ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ modulenames. size ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
toModuleExportsStmt	179	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.7184791564941406	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleExportsDirective> toModuleExportsStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleexportsdirective > $whitespace$ tomoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleexportsdirective > $whitespace$ tomoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	72	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asModuleExportsStmt	168	172	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.8368411660194397	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ModuleExportsDirective asModuleExportsStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirective $whitespace$ asmoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirective $whitespace$ asmoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	104	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.8583449721336365	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleExportsDirective setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleexportsdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isModuleExportsDirective	190	194	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.8833668231964111	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleExportsDirective(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleexportsdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleexportsdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isModuleExportsStmt	162	166	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleExportsDirective.java	0.8976150751113892	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleExportsStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleexportsstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifModuleOpensDirective	202	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.6520722508430481	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifModuleOpensDirective(Consumer<ModuleOpensDirective> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleopensdirective ( consumer < moduleopensdirective > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleopensdirective ( consumer < moduleopensdirective > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	208	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.7126321196556091	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleOpensDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleOpensDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduleopensdirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduleopensdirectivemetamodel ; $newline$ $indentation$ }			
toModuleOpensDirective	196	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.7167079448699951	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleOpensDirective> toModuleOpensDirective(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleopensdirective > $whitespace$ tomoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum < moduleopensdirective > $whitespace$ tomoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
replace	142	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.718061625957489	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < moduleNames.size(); i++) {
		        if (moduleNames.get(i) == node) {
		            moduleNames.set(i, (Name) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modulenames . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modulenames . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modulenames . set ( i , $whitespace$ ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ modulenames. size ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
toModuleOpensStmt	178	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.7330813407897949	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleOpensDirective> toModuleOpensStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleopensdirective > $whitespace$ tomoduleopensstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum < moduleopensdirective > $whitespace$ tomoduleopensstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asModuleOpensDirective	190	194	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.8320928812026978	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ModuleOpensDirective asModuleOpensDirective(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ asmoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ asmoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asModuleOpensStmt	167	171	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.8459599614143372	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ModuleOpensDirective asModuleOpensStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ asmoduleopensstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ asmoduleopensstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	103	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.8654361367225647	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleOpensDirective setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleopensdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isModuleOpensDirective	184	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.8890807032585144	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleOpensDirective(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleopensdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isModuleOpensStmt	161	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleOpensDirective.java	0.9044291377067566	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleOpensStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleopensstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleopensstmt ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifModuleProvidesDirective	202	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.6310818791389465	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifModuleProvidesDirective(Consumer<ModuleProvidesDirective> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleprovidesdirective ( consumer < moduleprovidesdirective > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleprovidesdirective ( consumer < moduleprovidesdirective > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toModuleProvidesDirective	196	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.692721962928772	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleProvidesDirective> toModuleProvidesDirective(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleprovidesdirective > $whitespace$ tomoduleprovidesdirective ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleprovidesdirective > $whitespace$ tomoduleprovidesdirective ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	208	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.6933295726776123	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleProvidesDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleProvidesDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleprovidesdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduleprovidesdirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleprovidesdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduleprovidesdirectivemetamodel ; $newline$ $indentation$ }			
toModuleProvidesStmt	121	125	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.7106440663337708	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleProvidesDirective> toModuleProvidesStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleprovidesdirective > $whitespace$ tomoduleprovidesstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleprovidesdirective > $whitespace$ tomoduleprovidesstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setName	132	144	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.8571375012397766	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleProvidesDirective setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleprovidesdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleprovidesdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isModuleProvidesDirective	184	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.8808531165122986	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleProvidesDirective(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleprovidesdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleprovidesdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isModuleProvidesStmt	104	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleProvidesDirective.java	0.8959872722625732	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleProvidesStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleprovidesstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleprovidesstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifModuleRequiresDirective	221	225	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.6310818791389465	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifModuleRequiresDirective(Consumer<ModuleRequiresDirective> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmodulerequiresdirective ( consumer < modulerequiresdirective > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmodulerequiresdirective ( consumer < modulerequiresdirective > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toModuleRequiresDirective	215	219	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.6907620429992676	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleRequiresDirective> toModuleRequiresDirective(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < modulerequiresdirective > $whitespace$ tomodulerequiresdirective ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum < modulerequiresdirective > $whitespace$ tomodulerequiresdirective ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	227	231	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.6933295726776123	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleRequiresDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleRequiresDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . modulerequiresdirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. modulerequiresdirectivemetamodel ; $newline$ $indentation$ }			
toModuleRequiresStmt	197	201	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.7087503671646118	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleRequiresDirective> toModuleRequiresStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < modulerequiresdirective > $whitespace$ tomodulerequiresstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < modulerequiresdirective > $whitespace$ tomodulerequiresstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
replace	161	178	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.7178447842597961	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < modifiers.size(); i++) {
		        if (modifiers.get(i) == node) {
		            modifiers.set(i, (Modifier) replacementNode);
		            return true;
		        }
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ modifiers . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifiers . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ modifiers . set ( i , $whitespace$ ( modifier ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. stream ( ) $newline$ $indentation$. anymatch ( sub $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setModifiers	88	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.8568053245544434	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleRequiresDirective setModifiers(final NodeList<Modifier> modifiers){
		    assertNotNull(modifiers);
		    if (modifiers == this.modifiers) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.MODIFIERS, this.modifiers, modifiers);
		    if (this.modifiers != null)
		        this.modifiers.setParentNode(null);
		    this.modifiers = modifiers;
		    setAsParentNodeOf(modifiers);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ assertnotnull ( modifiers ) ; $newline$ $indentation$ if $whitespace$ ( modifiers $whitespace$ == $whitespace$ this . modifiers ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . modifiers , $whitespace$ this . modifiers , $whitespace$ modifiers ) ; $newline$ $indentation$ if $whitespace$ ( this . modifiers $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . modifiers . setparentnode ( null ) ; $newline$ $indentation$ this . modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ setasparentnodeof ( modifiers ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ return $whitespace$ m_matching ( modifiers ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ this. modifiers. setparentnode ( null ) ; $newline$ $indentation$ this. modifiers $whitespace$ = $whitespace$ modifiers ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	107	119	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.8571375012397766	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleRequiresDirective setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ modulerequiresdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isModuleRequiresDirective	203	207	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.8808531165122986	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleRequiresDirective(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismodulerequiresdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismodulerequiresdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isModuleRequiresStmt	180	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleRequiresDirective.java	0.8959872722625732	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleRequiresStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismodulerequiresstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismodulerequiresstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifModuleUsesDirective	172	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.6572663187980652	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifModuleUsesDirective(Consumer<ModuleUsesDirective> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleusesdirective ( consumer < moduleusesdirective > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifmoduleusesdirective ( consumer < moduleusesdirective > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	178	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.7023842930793762	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ModuleUsesDirectiveMetaModel getMetaModel(){
		    return JavaParserMetaModel.moduleUsesDirectiveMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . moduleusesdirectivemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirectivemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. moduleusesdirectivemetamodel ; $newline$ $indentation$ }			
toModuleUsesDirective	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.7179208993911743	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleUsesDirective> toModuleUsesDirective(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleusesdirective > $whitespace$ tomoduleusesdirective ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum < moduleuse > $whitespace$ getmoduleuses ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
toModuleUsesStmt	116	120	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.7299522161483765	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ModuleUsesDirective> toModuleUsesStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < moduleusesdirective > $whitespace$ tomoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ enum < moduleuse > $whitespace$ tomoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
asModuleUsesDirective	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.8380094766616821	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ModuleUsesDirective asModuleUsesDirective(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ asmoduleusesdirective ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ getmoduleusesdirective ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
replace	141	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.8389257192611694	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((Name) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( name ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ replacementnode ; $newline$ $indentation$ }			
asModuleUsesStmt	105	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.8517841696739197	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ModuleUsesDirective asModuleUsesStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ asmoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ asmoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	127	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.8616932034492493	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ModuleUsesDirective setName(final Name name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ moduleusesdirective $whitespace$ setname ( final $whitespace$ name $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isModuleUsesDirective	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.8936936259269714	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleUsesDirective(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleusesdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleusesdirective ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isModuleUsesStmt	99	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/modules/ModuleUsesDirective.java	0.9070149064064026	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isModuleUsesStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ ismoduleusesstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
addExtendedType	56	60	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithExtends.java	0.7273072004318237	MID	"		@SuppressWarnings(""unchecked"")
		 N addExtendedType(ClassOrInterfaceType extend){
		    getExtendedTypes().add(extend);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addextendedtype ( classorinterfacetype $whitespace$ extend ) { $newline$ $indentation$ getextendedtypes ( ) . add ( extend ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addextendedtype ( classorinterfacetype $whitespace$ extend ) { $newline$ $indentation$ getextendedtypes ( ). add ( extend ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addImplementedType	50	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithImplements.java	0.6894065141677856	MID	"		@SuppressWarnings(""unchecked"")
		 N addImplementedType(ClassOrInterfaceType implement){
		    getImplementedTypes().add(implement);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addimplementedtype ( classorinterfacetype $whitespace$ implement ) { $newline$ $indentation$ getimplementedtypes ( ) . add ( implement ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addimplementedtype ( classorinterfacetype $whitespace$ implement ) { $newline$ $indentation$ getimplementedtypes ( ). add ( implement ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
setImplementedType	44	48	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithImplements.java	0.7027458548545837	MID	"		@SuppressWarnings(""unchecked"")
		 N setImplementedType(int i, ClassOrInterfaceType implement){
		    getImplementedTypes().set(i, implement);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setimplementedtype ( int $whitespace$ i , $whitespace$ classorinterfacetype $whitespace$ implement ) { $newline$ $indentation$ getimplementedtypes ( ) . set ( i , $whitespace$ implement ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setimplementedtype ( int $whitespace$ i, $whitespace$ classorinterfacetype $whitespace$ implement ) { $newline$ $indentation$ getimplementedtypes ( ). set ( i, $whitespace$ implement ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addMember	68	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithMembers.java	0.6729860901832581	MID	"		@SuppressWarnings(""unchecked"")
		 N addMember(BodyDeclaration<?> member){
		    getMembers().add(member);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addmember ( bodydeclaration < ? > $whitespace$ member ) { $newline$ $indentation$ getmembers ( ) . add ( member ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addmember ( bodydeclaration <? > $whitespace$ member ) { $newline$ $indentation$ getmembers ( ). add ( member ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
setMember	62	66	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithMembers.java	0.7141515016555786	MID	"		@SuppressWarnings(""unchecked"")
		 N setMember(int i, BodyDeclaration<?> member){
		    getMembers().set(i, member);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setmember ( int $whitespace$ i , $whitespace$ bodydeclaration < ? > $whitespace$ member ) { $newline$ $indentation$ getmembers ( ) . set ( i , $whitespace$ member ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setmember ( int $whitespace$ member ) { $newline$ $indentation$ getmembers ( ). set ( member, $whitespace$ member ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
removeModifier	64	70	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java	0.066405676305294	LOW	"		@SuppressWarnings(""unchecked"")
		 N removeModifier(Modifier.Keyword... modifiersToRemove){
		    List<Modifier.Keyword> modifiersToRemoveAsList = Arrays.asList(modifiersToRemove);
		    NodeList<Modifier> remaining = getModifiers().stream().filter(existingModifier -> !modifiersToRemoveAsList.contains(existingModifier.getKeyword())).collect(toNodeList());
		    setModifiers(remaining);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ removemodifier ( modifier . keyword . . . $whitespace$ modifierstoremove ) { $newline$ $indentation$ list < modifier . keyword > $whitespace$ modifierstoremoveaslist $whitespace$ = $whitespace$ arrays . aslist ( modifierstoremove ) ; $newline$ $indentation$ nodelist < modifier > $whitespace$ remaining $whitespace$ = $whitespace$ getmodifiers ( ) . stream ( ) . filter ( existingmodifier $whitespace$ - > $whitespace$ ! modifierstoremoveaslist . contains ( existingmodifier . getkeyword ( ) ) ) . collect ( tonodelist ( ) ) ; $newline$ $indentation$ setmodifiers ( remaining ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ removemodifier ( modifier. keyword... $whitespace$ modifierstoremove ) { $newline$ $indentation$ list < modifier. keyword > $whitespace$ modifierstoremoveaslist $whitespace$ = $whitespace$ getmodifiers ( ). stream ( ) $newline$ $indentation$. filter ( existingmodifier $whitespace$ - > $whitespace$! iscellsfromobject ( existingmodifier. getkeyword ( ) ) ) $newline$ $indentation$. collect ( tonodelist ( ) ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addModifier	51	62	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java	0.269667774438858	LOW	"		@SuppressWarnings(""unchecked"")
		 N addModifier(Modifier.Keyword... newModifiers){
		    NodeList<Modifier> existingModifiers = new NodeList<>(getModifiers());
		    for (Modifier.Keyword newModifier : newModifiers) {
		        boolean alreadyPresent = existingModifiers.stream().anyMatch(m -> m.getKeyword() == newModifier);
		        if (!alreadyPresent) {
		            existingModifiers.add(new Modifier(newModifier));
		        }
		    }
		    setModifiers(existingModifiers);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addmodifier ( modifier . keyword . . . $whitespace$ newmodifiers ) { $newline$ $indentation$ nodelist < modifier > $whitespace$ existingmodifiers $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( getmodifiers ( ) ) ; $newline$ $indentation$ for $whitespace$ ( modifier . keyword $whitespace$ newmodifier $whitespace$ : $whitespace$ newmodifiers ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ alreadypresent $whitespace$ = $whitespace$ existingmodifiers . stream ( ) . anymatch ( m $whitespace$ - > $whitespace$ m . getkeyword ( ) $whitespace$ == $whitespace$ newmodifier ) ; $newline$ $indentation$ if $whitespace$ ( ! alreadypresent ) $whitespace$ { $newline$ $indentation$ existingmodifiers . add ( new $whitespace$ modifier ( newmodifier ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ setmodifiers ( existingmodifiers ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addmodifier ( modifier. keyword... $whitespace$ newmodifiers ) { $newline$ $indentation$ nodelist < modifier > $whitespace$ existingmodifiers $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( getmodifiers ( ) ) ; $newline$ $indentation$ for $whitespace$ ( modifier. keyword $whitespace$ newmodifier $whitespace$ : $whitespace$ newmodifiers ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ alreadypresent $whitespace$ = $whitespace$ existingmodifiers. stream ( ). anymatch ( m $whitespace$ - > $whitespace$ m. getkeyword ( ) $whitespace$ == $whitespace$ newmodifier ) ; $newline$ $indentation$ boolean $whitespace$ ispresent $whitespace$ = $whitespace$! alreadypresent ) $whitespace$ { $newline$ $indentation$ existingmodifiers. add ( new $whitespace$ modifier ( newmodifier ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ setmodifiers ( existingmodifiers ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
getAccessSpecifier	103	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java	0.7161852121353149	MID	"		 AccessSpecifier getAccessSpecifier(){
		    for (Modifier modifier : getModifiers()) {
		        switch(modifier.getKeyword()) {
		            case PUBLIC:
		                return AccessSpecifier.PUBLIC;
		            case PROTECTED:
		                return AccessSpecifier.PROTECTED;
		            case PRIVATE:
		                return AccessSpecifier.PRIVATE;
		        }
		    }
		    return AccessSpecifier.NONE;
		}"	$indentation$ accessspecifier $whitespace$ getaccessspecifier ( ) { $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ modifier $whitespace$ : $whitespace$ getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ switch ( modifier . getkeyword ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ public : $newline$ $indentation$ return $whitespace$ accessspecifier . public ; $newline$ $indentation$ case $whitespace$ protected : $newline$ $indentation$ return $whitespace$ accessspecifier . protected ; $newline$ $indentation$ case $whitespace$ private : $newline$ $indentation$ return $whitespace$ accessspecifier . private ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier . none ; $newline$ $indentation$ }	$indentation$ accessspecifier $whitespace$ getaccessspecifier ( ) { $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ modifier $whitespace$ : $whitespace$ getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( modifier. getkeyword ( ) $whitespace$ == $whitespace$ commandtype. public ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. public ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ public : $whitespace$ accessspecifier. public ; $newline$ $indentation$ case $whitespace$ protected : $whitespace$ accessspecifier. protected ; $newline$ $indentation$ case $whitespace$ private : $whitespace$ accessspecifier. private ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier. none ; $newline$ $indentation$ }			
hasModifier	83	90	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java	0.8543925285339355	HIGH	"		 boolean hasModifier(Modifier.Keyword modifier){
		    for (Modifier m : getModifiers()) {
		        if (m.getKeyword() == modifier) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ boolean $whitespace$ hasmodifier ( modifier . keyword $whitespace$ modifier ) { $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ m $whitespace$ : $whitespace$ getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( m . getkeyword ( ) $whitespace$ == $whitespace$ modifier ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ hasmodifier ( modifier. keyword $whitespace$ modifier ) { $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ m $whitespace$ : $whitespace$ getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$! m. getkeyword ( ) $whitespace$ == $whitespace$ modifier ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
setModifier	72	77	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithModifiers.java	0.8616849780082703	HIGH	"		 N setModifier(Modifier.Keyword m, boolean set){
		    if (set) {
		        return addModifier(m);
		    }
		    return removeModifier(m);
		}"	$indentation$ n $whitespace$ setmodifier ( modifier . keyword $whitespace$ m , $whitespace$ boolean $whitespace$ set ) { $newline$ $indentation$ if $whitespace$ ( set ) $whitespace$ { $newline$ $indentation$ return $whitespace$ addmodifier ( m ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removemodifier ( m ) ; $newline$ $indentation$ }	$indentation$ n $whitespace$ setmodifier ( modifier. keyword $whitespace$ m, $whitespace$ boolean $whitespace$ set ) { $newline$ $indentation$ return $whitespace$ addmodifier ( m ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removemodifier ( m ) ; $newline$ $indentation$ }			
setName	42	46	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithName.java	0.722141444683075	MID	"		@SuppressWarnings(""unchecked"")
		 N setName(String name){
		    assertNonEmpty(name);
		    return setName(parseName(name));
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setname ( string $whitespace$ name ) { $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ return $whitespace$ setname ( parsename ( name ) ) ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setname ( string $whitespace$ name ) { $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ return $whitespace$ setname ( parsename ( name ) ) ; $newline$ $indentation$ }			
hasParametersOfType	164	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithParameters.java	0.0069792428985238	LOW	"		 boolean hasParametersOfType(Class<?>... paramTypes){
		    return // if p.getType() is a class or interface type, we want to consider its erasure, i.e., if the parameter
		    getParameters().stream().// is ""List<String>"", we want to consider it as ""List"", so we need to call getName()
		    map(p -> p.getType().toClassOrInterfaceType().map(NodeWithSimpleName::getNameAsString).orElseGet(() -> p.getType().asString())).collect(toList()).equals(Stream.of(paramTypes).map(Class::getSimpleName).collect(toList()));
		}"	"$indentation$ boolean $whitespace$ hasparametersoftype ( class < ? > . . . $whitespace$ paramtypes ) { $newline$ $indentation$ return $whitespace$ $//·if·p.gettype()·is·a·class·or·interface·type,·we·want·to·consider·its·erasure,·i.e.,·if·the·parameter$ $newline$ $indentation$ getparameters ( ) . stream ( ) . $//·is·""list<string>"",·we·want·to·consider·it·as·""list"",·so·we·need·to·call·getname()$ $newline$ $indentation$ map ( p $whitespace$ - > $whitespace$ p . gettype ( ) . toclassorinterfacetype ( ) . map ( nodewithsimplename : : getnameasstring ) . orelseget ( ( ) $whitespace$ - > $whitespace$ p . gettype ( ) . asstring ( ) ) ) . collect ( tolist ( ) ) . equals ( stream . of ( paramtypes ) . map ( class : : getsimplename ) . collect ( tolist ( ) ) ) ; $newline$ $indentation$ }"	$indentation$ boolean $whitespace$ hasparametersoftype ( class <? >... $whitespace$ paramtypes ) { $newline$ $indentation$ return $whitespace$ $//filterationifspace$ ( $newline$ $indentation$p. gettype() $whitespace$ == $whitespace$ $string$ ) $newline$ $indentation$. orelseget ( ( ) $whitespace$ - > $whitespace$ p. gettype ( ). toclassorinterfacetype ( ) ) $newline$ $indentation$. collect ( tolist ( ) ). equals ( stream. of ( paramtypes ). map ( class : : getsimplename ). collect ( tolist ( ) ) ) ; $newline$ $indentation$ }			
containsWithinRange	73	78	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithRange.java	0.723794162273407	MID	"		 boolean containsWithinRange(Node other){
		    if (hasRange() && other.hasRange()) {
		        return getRange().get().contains(other.getRange().get());
		    }
		    return false;
		}"	$indentation$ boolean $whitespace$ containswithinrange ( node $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( hasrange ( ) $whitespace$ && $whitespace$ other . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getrange ( ) . get ( ) . contains ( other . getrange ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ containswithinrange ( node $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( hasrange ( ) $whitespace$ && $whitespace$ other. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getrange ( ). get ( ). contains ( other. getrange ( ). get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
setName	40	44	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithSimpleName.java	0.7309646606445312	MID	"		@SuppressWarnings(""unchecked"")
		 N setName(String name){
		    assertNonEmpty(name);
		    return setName(new SimpleName(name));
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setname ( string $whitespace$ name ) { $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ return $whitespace$ setname ( new $whitespace$ simplename ( name ) ) ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setname ( string $whitespace$ name ) { $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ return $whitespace$ setname ( new $whitespace$ simplename ( name ) ) ; $newline$ $indentation$ }			
copyStatements	106	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithStatements.java	0.7013975977897644	MID	"		@SuppressWarnings(""unchecked"")
		 N copyStatements(NodeList<Statement> nodeList){
		    for (Statement n : nodeList) {
		        addStatement(n.clone());
		    }
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ copystatements ( nodelist < statement > $whitespace$ nodelist ) { $newline$ $indentation$ for $whitespace$ ( statement $whitespace$ n $whitespace$ : $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ addstatement ( n . clone ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ copystatements ( nodelist < statement > $whitespace$ nodelist ) { $newline$ $indentation$ for $whitespace$ ( statement $whitespace$ n $whitespace$ : $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ addstatement ( n. clone ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addThrownException	50	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithThrownExceptions.java	0.7146283984184265	MID	"		@SuppressWarnings(""unchecked"")
		 N addThrownException(ReferenceType throwType){
		    getThrownExceptions().add(throwType);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addthrownexception ( referencetype $whitespace$ throwtype ) { $newline$ $indentation$ getthrownexceptions ( ) . add ( throwtype ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addthrownexception ( referencetype $whitespace$ throwtype ) { $newline$ $indentation$ getthrownexceptions ( ). add ( throwtype ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addTypeParameter	51	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTypeParameters.java	0.7099998593330383	MID	"		@SuppressWarnings(""unchecked"")
		 N addTypeParameter(TypeParameter typeParameter){
		    getTypeParameters().add(typeParameter);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addtypeparameter ( typeparameter $whitespace$ typeparameter ) { $newline$ $indentation$ gettypeparameters ( ) . add ( typeparameter ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addtypeparameter ( typeparameter $whitespace$ typeparameter ) { $newline$ $indentation$ gettypeparameters ( ). add ( typeparameter ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
setTypeParameter	45	49	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithTypeParameters.java	0.7173050045967102	MID	"		@SuppressWarnings(""unchecked"")
		 N setTypeParameter(int i, TypeParameter typeParameter){
		    getTypeParameters().set(i, typeParameter);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ settypeparameter ( int $whitespace$ i , $whitespace$ typeparameter $whitespace$ typeparameter ) { $newline$ $indentation$ gettypeparameters ( ) . set ( i , $whitespace$ typeparameter ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ settypeparameter ( int $whitespace$ i, $whitespace$ typeparameter $whitespace$ typeparameter ) { $newline$ $indentation$ gettypeparameters ( ). set ( i, $whitespace$ typeparameter ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
addVariable	53	57	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java	0.6916050314903259	MID	"		@SuppressWarnings(""unchecked"")
		 N addVariable(VariableDeclarator variableDeclarator){
		    getVariables().add(variableDeclarator);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addvariable ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ getvariables ( ) . add ( variabledeclarator ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ addvariable ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ getvariables ( ). add ( variabledeclarator ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
setVariable	47	51	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java	0.6987187266349792	MID	"		@SuppressWarnings(""unchecked"")
		 N setVariable(int i, VariableDeclarator variableDeclarator){
		    getVariables().set(i, variableDeclarator);
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setvariable ( int $whitespace$ i , $whitespace$ variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ getvariables ( ) . set ( i , $whitespace$ variabledeclarator ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setvariable ( int $whitespace$ i, $whitespace$ variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ getvariables ( ). set ( i, $whitespace$ variabledeclarator ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
calculateMaximumCommonType	130	172	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java	0.7024708688259125	MID	"		 static Optional<Type> calculateMaximumCommonType(List<Type> types){
		    // we use a local class because we cannot use an helper static method in an interface
		    class Helper {
		
		        // Conceptually: given a type we start from the Element Type and get as many array levels as indicated
		        // From the implementation point of view we start from the actual type and we remove how many array
		        // levels as needed to get the target level of arrays
		        // It returns null if the type has less array levels then the desired target
		        private Optional<Type> toArrayLevel(Type type, int level) {
		            if (level > type.getArrayLevel()) {
		                return Optional.empty();
		            }
		            for (int i = type.getArrayLevel(); i > level; i--) {
		                if (!(type instanceof ArrayType)) {
		                    return Optional.empty();
		                }
		                type = ((ArrayType) type).getComponentType();
		            }
		            return Optional.of(type);
		        }
		    }
		    Helper helper = new Helper();
		    int level = 0;
		    boolean keepGoing = true;
		    // In practice we want to check for how many levels of arrays all the variables have the same type,
		    // including also the annotations
		    while (keepGoing) {
		        final int currentLevel = level;
		        // Now, given that equality on nodes consider the position the simplest way is to compare
		        // the pretty-printed string got for a node. We just check all them are the same and if they
		        // are we just just is not null
		        Object[] values = types.stream().map(v -> {
		            Optional<Type> t = helper.toArrayLevel(v, currentLevel);
		            return t.map(Node::toString).orElse(null);
		        }).distinct().toArray();
		        if (values.length == 1 && values[0] != null) {
		            level++;
		        } else {
		            keepGoing = false;
		        }
		    }
		    return helper.toArrayLevel(types.get(0), --level);
		}"	$indentation$ static $whitespace$ optional < type > $whitespace$ calculatemaximumcommontype ( list < type > $whitespace$ types ) { $newline$ $indentation$ $//·we·use·a·local·class·because·we·cannot·use·an·helper·static·method·in·an·interface$ $newline$ $indentation$ class $whitespace$ helper $whitespace$ { $newline$ $indentation$ $//·conceptually:·given·a·type·we·start·from·the·element·type·and·get·as·many·array·levels·as·indicated$ $newline$ $indentation$ $//·from·the·implementation·point·of·view·we·start·from·the·actual·type·and·we·remove·how·many·array$ $newline$ $indentation$ $//·levels·as·needed·to·get·the·target·level·of·arrays$ $newline$ $indentation$ $//·it·returns·null·if·the·type·has·less·array·levels·then·the·desired·target$ $newline$ $indentation$ private $whitespace$ optional < type > $whitespace$ toarraylevel ( type $whitespace$ type , $whitespace$ int $whitespace$ level ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( level $whitespace$ > $whitespace$ type . getarraylevel ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ type . getarraylevel ( ) ; $whitespace$ i $whitespace$ > $whitespace$ level ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! ( type $whitespace$ instanceof $whitespace$ arraytype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ type $whitespace$ = $whitespace$ ( ( arraytype ) $whitespace$ type ) . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( type ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ helper $whitespace$ helper $whitespace$ = $whitespace$ new $whitespace$ helper ( ) ; $newline$ $indentation$ int $whitespace$ level $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ keepgoing $whitespace$ = $whitespace$ true ; $newline$ $indentation$ $//·in·practice·we·want·to·check·for·how·many·levels·of·arrays·all·the·variables·have·the·same·type,$ $newline$ $indentation$ $//·including·also·the·annotations$ $newline$ $indentation$ while $whitespace$ ( keepgoing ) $whitespace$ { $newline$ $indentation$ final $whitespace$ int $whitespace$ currentlevel $whitespace$ = $whitespace$ level ; $newline$ $indentation$ $//·now,·given·that·equality·on·nodes·consider·the·position·the·simplest·way·is·to·compare$ $newline$ $indentation$ $//·the·pretty-printed·string·got·for·a·node.·we·just·check·all·them·are·the·same·and·if·they$ $newline$ $indentation$ $//·are·we·just·just·is·not·null$ $newline$ $indentation$ object [ ] $whitespace$ values $whitespace$ = $whitespace$ types . stream ( ) . map ( v $whitespace$ - > $whitespace$ { $newline$ $indentation$ optional < type > $whitespace$ t $whitespace$ = $whitespace$ helper . toarraylevel ( v , $whitespace$ currentlevel ) ; $newline$ $indentation$ return $whitespace$ t . map ( node : : tostring ) . orelse ( null ) ; $newline$ $indentation$ } ) . distinct ( ) . toarray ( ) ; $newline$ $indentation$ if $whitespace$ ( values . length $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ values [ $number$ ] $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ level ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ keepgoing $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ helper . toarraylevel ( types . get ( $number$ ) , $whitespace$ -- level ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ optional < type > $whitespace$ calculatemaximumcommontype ( list < type > $whitespace$ types ) { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ type $whitespace$ array $whitespace$ of $whitespace$ type $whitespace$ array $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ type $whitespace$ array $whitespace$ of $whitespace$ type $whitespace$ array $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ type $whitespace$ array $whitespace$ of $whitespace$ type $whitespace$ array $newline$ $indentation$ if $whitespace$ ( level $whitespace$ > $whitespace$ type			
toArrayLevel	138	149	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java	0.7117919921875	MID	"		private Optional<Type> toArrayLevel(Type type, int level){
		    if (level > type.getArrayLevel()) {
		        return Optional.empty();
		    }
		    for (int i = type.getArrayLevel(); i > level; i--) {
		        if (!(type instanceof ArrayType)) {
		            return Optional.empty();
		        }
		        type = ((ArrayType) type).getComponentType();
		    }
		    return Optional.of(type);
		}"	$indentation$ private $whitespace$ optional < type > $whitespace$ toarraylevel ( type $whitespace$ type , $whitespace$ int $whitespace$ level ) { $newline$ $indentation$ if $whitespace$ ( level $whitespace$ > $whitespace$ type . getarraylevel ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ type . getarraylevel ( ) ; $whitespace$ i $whitespace$ > $whitespace$ level ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! ( type $whitespace$ instanceof $whitespace$ arraytype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ type $whitespace$ = $whitespace$ ( ( arraytype ) $whitespace$ type ) . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( type ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < type > $whitespace$ toarraylevel ( type $whitespace$ type, $whitespace$ int $whitespace$ level ) { $newline$ $indentation$ if $whitespace$ ( level $whitespace$ > $whitespace$ type. getarraylevel ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ type. getarraylevel ( ) ; $whitespace$ i $whitespace$ > $whitespace$ level ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! ( type $whitespace$ instanceof $whitespace$ arraytype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ type $whitespace$ = $whitespace$ ( ( arraytype ) $whitespace$ type ). getcomponenttype ( ) ; $newline$ $indentation$ return $whitespace$ optional. of ( type ) ; $newline$ $indentation$ }			
setAllTypes	108	114	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/nodeTypes/NodeWithVariables.java	0.7221735119819641	MID	"		@SuppressWarnings(""unchecked"")
		 N setAllTypes(Type newType){
		    for (VariableDeclarator variable : getVariables()) {
		        variable.setType(newType);
		    }
		    return (N) this;
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setalltypes ( type $whitespace$ newtype ) { $newline$ $indentation$ for $whitespace$ ( variabledeclarator $whitespace$ variable $whitespace$ : $whitespace$ getvariables ( ) ) $whitespace$ { $newline$ $indentation$ variable . settype ( newtype ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ n $whitespace$ setalltypes ( type $whitespace$ newtype ) { $newline$ $indentation$ type. foreach ( this : : settype ) ; $newline$ $indentation$ return $whitespace$ ( n ) $whitespace$ this ; $newline$ $indentation$ }			
fromCamelCaseName	157	163	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/ObservableProperty.java	0.1637373268604278	LOW	"		public static ObservableProperty fromCamelCaseName(String camelCaseName){
		    Optional<ObservableProperty> observableProperty = Arrays.stream(values()).filter(v -> v.camelCaseName().equals(camelCaseName)).findFirst();
		    if (observableProperty.isPresent()) {
		        return observableProperty.get();
		    }
		    throw new IllegalArgumentException(""No property found with the given camel case name: "" + camelCaseName);
		}"	$indentation$ public $whitespace$ static $whitespace$ observableproperty $whitespace$ fromcamelcasename ( string $whitespace$ camelcasename ) { $newline$ $indentation$ optional < observableproperty > $whitespace$ observableproperty $whitespace$ = $whitespace$ arrays . stream ( values ( ) ) . filter ( v $whitespace$ - > $whitespace$ v . camelcasename ( ) . equals ( camelcasename ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( observableproperty . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ observableproperty . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ camelcasename ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ observableproperty $whitespace$ fromcamelcasename ( string $whitespace$ camelcasename ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( values ( ) ) $newline$ $indentation$. filter ( v $whitespace$ - > $whitespace$ v. camelcasename ( ). equals ( camelcasename ) ) $newline$ $indentation$. findfirst ( ) ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ static $whitespace$ observableproperty $whitespace$ from ( string $whitespace$ index ) $whitespace$ { $newline$ $indentation$ return $whitespace$ observableproperty. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ camelcasename ) ; $newline$ $indentation$ }			
getValueAsMultipleReference	231	248	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/ObservableProperty.java	0.1929744035005569	LOW	"		public NodeList<? extends Node> getValueAsMultipleReference(Node node){
		    Object rawValue = getRawValue(node);
		    try {
		        if (rawValue == null) {
		            return null;
		        }
		        if (rawValue instanceof NodeList) {
		            return (NodeList) rawValue;
		        }
		        Optional<NodeList> opt = (Optional<NodeList>) rawValue;
		        if (opt.isPresent()) {
		            return opt.get();
		        }
		        return null;
		    } catch (ClassCastException e) {
		        throw new RuntimeException(""Unable to get list value for "" + this.name() + "" from "" + node + "" (class: "" + node.getClass().getSimpleName() + "")"", e);
		    }
		}"	$indentation$ public $whitespace$ nodelist < ? $whitespace$ extends $whitespace$ node > $whitespace$ getvalueasmultiplereference ( node $whitespace$ node ) { $newline$ $indentation$ object $whitespace$ rawvalue $whitespace$ = $whitespace$ getrawvalue ( node ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rawvalue $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( rawvalue $whitespace$ instanceof $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( nodelist ) $whitespace$ rawvalue ; $newline$ $indentation$ } $newline$ $indentation$ optional < nodelist > $whitespace$ opt $whitespace$ = $whitespace$ ( optional < nodelist > ) $whitespace$ rawvalue ; $newline$ $indentation$ if $whitespace$ ( opt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ opt . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classcastexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ this . name ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ nodelist <? $whitespace$ extends $whitespace$ node > $whitespace$ getvalueasmultiplereference ( node $whitespace$ node ) { $newline$ $indentation$ object $whitespace$ rawvalue $whitespace$ = $whitespace$ getrawvalue ( node ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rawvalue $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( rawvalue $whitespace$ instanceof $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( nodelist ) $whitespace$ rawvalue ; $newline$ $indentation$ } $newline$ $indentation$ optional < nodelist > $whitespace$ opt $whitespace$ = $whitespace$ ( optional < nodelist > ) $whitespace$ rawvalue ; $newline$ $indentation$ if $whitespace$ ( opt. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ opt. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classcastexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ this. name ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node. getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$, $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
getRawValue	267	280	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/ObservableProperty.java	0.2546180188655853	LOW	"		public Object getRawValue(Node node){
		    String getterName = ""get"" + Utils.capitalize(camelCaseName());
		    if (!hasMethod(node, getterName)) {
		        getterName = ""is"" + Utils.capitalize(camelCaseName());
		        if (!hasMethod(node, getterName)) {
		            getterName = ""has"" + Utils.capitalize(camelCaseName());
		        }
		    }
		    try {
		        return node.getClass().getMethod(getterName).invoke(node);
		    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
		        throw new RuntimeException(""Unable to get value for "" + this.name() + "" from "" + node + "" ("" + node.getClass().getSimpleName() + "")"", e);
		    }
		}"	$indentation$ public $whitespace$ object $whitespace$ getrawvalue ( node $whitespace$ node ) { $newline$ $indentation$ string $whitespace$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils . capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ! hasmethod ( node , $whitespace$ gettername ) ) $whitespace$ { $newline$ $indentation$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils . capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ! hasmethod ( node , $whitespace$ gettername ) ) $whitespace$ { $newline$ $indentation$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils . capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ node . getclass ( ) . getmethod ( gettername ) . invoke ( node ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( nosuchmethodexception $whitespace$ | $whitespace$ illegalaccessexception $whitespace$ | $whitespace$ invocationtargetexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ this . name ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ object $whitespace$ getrawvalue ( node $whitespace$ node ) { $newline$ $indentation$ string $whitespace$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils. capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ if $whitespace$ (! hasmethod ( node, $whitespace$ gettername ) ) $whitespace$ { $newline$ $indentation$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils. capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ if $whitespace$ (! hasmethod ( node, $whitespace$ gettername ) ) $whitespace$ { $newline$ $indentation$ gettername $whitespace$ = $whitespace$ $string$ $whitespace$ + $whitespace$ utils. capitalize ( camelcasename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ object $whitespace$ getrawvalue ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node. getclass ( ). getmethod ( gettername ). invoke ( node ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( nosuchmethodexception $whitespace$ | $whitespace$ illegalaccessexception $whitespace$ | $whitespace$ invocationtargetexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ this. name ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ node. getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$, $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
hasMethod	222	229	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/ObservableProperty.java	0.850599467754364	HIGH	"		private boolean hasMethod(Node node, String name){
		    try {
		        node.getClass().getMethod(name);
		        return true;
		    } catch (NoSuchMethodException e) {
		        return false;
		    }
		}"	$indentation$ private $whitespace$ boolean $whitespace$ hasmethod ( node $whitespace$ node , $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ node . getclass ( ) . getmethod ( name ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( nosuchmethodexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ hasmethod ( node $whitespace$ node, $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node. getclass ( ). getmethod ( name ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( nosuchmethodexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ }			
considerAdding	110	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/PropagatingAstObserver.java	0.8542580604553223	HIGH	"		private void considerAdding(Object element){
		    if (element instanceof Node) {
		        ((Node) element).registerForSubtree(this);
		    } else if (element instanceof Observable) {
		        ((Observable) element).register(this);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ consideradding ( object $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ node ) $whitespace$ { $newline$ $indentation$ ( ( node ) $whitespace$ element ) . registerforsubtree ( this ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ observable ) $whitespace$ { $newline$ $indentation$ ( ( observable ) $whitespace$ element ) . register ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ consideradding ( object $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ node ) $whitespace$ { $newline$ $indentation$ ( ( node ) $whitespace$ element ). registerforsubtree ( this ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ observable ) $whitespace$ { $newline$ $indentation$ ( ( observable ) $whitespace$ element ). register ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
considerRemoving	102	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/observer/PropagatingAstObserver.java	0.8655262589454651	HIGH	"		private void considerRemoving(Object element){
		    if (element instanceof Observable) {
		        if (((Observable) element).isRegistered(this)) {
		            ((Observable) element).unregister(this);
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ considerremoving ( object $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ observable ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( observable ) $whitespace$ element ) . isregistered ( this ) ) $whitespace$ { $newline$ $indentation$ ( ( observable ) $whitespace$ element ) . unregister ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ considerremoving ( object $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ observable ) $whitespace$ { $newline$ $indentation$ this. onsend ( ( ( observable ) $whitespace$ element ). isregistered ( this ) ) $whitespace$ { $newline$ $indentation$ ( ( observable ) $whitespace$ element ). unregister ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
ifAssertStmt	196	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.7173944115638733	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifAssertStmt(Consumer<AssertStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifassertstmt ( consumer < assertstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifassertstmt ( consumer < assertstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	78	82	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setCheck	100	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.8344519734382629	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public AssertStmt setCheck(final Expression check){
		    assertNotNull(check);
		    if (check == this.check) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.CHECK, this.check, check);
		    if (this.check != null)
		        this.check.setParentNode(null);
		    this.check = check;
		    setAsParentNodeOf(check);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assertstmt $whitespace$ setcheck ( final $whitespace$ expression $whitespace$ check ) { $newline$ $indentation$ assertnotnull ( check ) ; $newline$ $indentation$ if $whitespace$ ( check $whitespace$ == $whitespace$ this . check ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . check , $whitespace$ this . check , $whitespace$ check ) ; $newline$ $indentation$ if $whitespace$ ( this . check $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . check . setparentnode ( null ) ; $newline$ $indentation$ this . check $whitespace$ = $whitespace$ check ; $newline$ $indentation$ setasparentnodeof ( check ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assertstmt $whitespace$ setcheck ( final $whitespace$ expression $whitespace$ check ) { $newline$ $indentation$ if $whitespace$ ( check $whitespace$ == $whitespace$ this. check ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. check, $whitespace$ this. check, $whitespace$ check ) ; $newline$ $indentation$ if $whitespace$ ( this. check $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. check. setparentnode ( null ) ; $newline$ $indentation$ this. check $whitespace$ = $whitespace$ check ; $newline$ $indentation$ setasparentnodeof ( check ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
remove	133	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.8371177911758423	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (message != null) {
		        if (node == message) {
		            removeMessage();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( message $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ message ) $whitespace$ { $newline$ $indentation$ removemessage ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( message $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ message ) $whitespace$ { $newline$ $indentation$ removemessage ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
asAssertStmt	190	194	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.8864132761955261	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public AssertStmt asAssertStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assertstmt $whitespace$ asassertstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ assertstmt $whitespace$ asassertstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isAssertStmt	184	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/AssertStmt.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isAssertStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassertstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassertstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifBlockStmt	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifBlockStmt(Consumer<BlockStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifblockstmt ( consumer < blockstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifblockstmt ( consumer < blockstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	69	73	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setStatements	86	98	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java	0.8704135417938232	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public BlockStmt setStatements(final NodeList<Statement> statements){
		    assertNotNull(statements);
		    if (statements == this.statements) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.STATEMENTS, this.statements, statements);
		    if (this.statements != null)
		        this.statements.setParentNode(null);
		    this.statements = statements;
		    setAsParentNodeOf(statements);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ setstatements ( final $whitespace$ nodelist < statement > $whitespace$ statements ) { $newline$ $indentation$ assertnotnull ( statements ) ; $newline$ $indentation$ if $whitespace$ ( statements $whitespace$ == $whitespace$ this . statements ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . statements , $whitespace$ this . statements , $whitespace$ statements ) ; $newline$ $indentation$ if $whitespace$ ( this . statements $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . statements . setparentnode ( null ) ; $newline$ $indentation$ this . statements $whitespace$ = $whitespace$ statements ; $newline$ $indentation$ setasparentnodeof ( statements ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ setstatements ( final $whitespace$ nodelist < statement > $whitespace$ statements ) { $newline$ $indentation$ if $whitespace$ ( statements $whitespace$ == $whitespace$ this. statements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( statements $whitespace$ == $whitespace$ null ) $newline$ $indentation$ this. statements. setparentnode ( null ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. statements, $whitespace$ this. statements, $whitespace$ statements ) ; $newline$ $indentation$ if $whitespace$ ( this. statements $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. statements. setparentnode ( null ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asBlockStmt	148	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public BlockStmt asBlockStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ blockstmt $whitespace$ asblockstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ estmt $whitespace$ asblockstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isBlockStmt	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BlockStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isBlockStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isblockstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isblockstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifBreakStmt	182	186	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java	0.7173429727554321	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifBreakStmt(Consumer<BreakStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifbreakstmt ( consumer < breakstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifbreakstmt ( consumer < breakstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	87	91	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
remove	123	136	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java	0.8483443856239319	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (label != null) {
		        if (node == label) {
		            removeLabel();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( label $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ label ) $whitespace$ { $newline$ $indentation$ removelabel ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( label $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ label ) $whitespace$ { $newline$ $indentation$ removelabel ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
asBreakStmt	176	180	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java	0.8956716060638428	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public BreakStmt asBreakStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ breakstmt $whitespace$ asbreakstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ breakstmt $whitespace$ asbreakstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isBreakStmt	170	174	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/BreakStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isBreakStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbreakstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isbreakstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getMetaModel	136	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/CatchClause.java	0.736973226070404	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public CatchClauseMetaModel getMetaModel(){
		    return JavaParserMetaModel.catchClauseMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ catchclausemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . catchclausemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ catchclausemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. catchclausemetamodel ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/CatchClause.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	116	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/CatchClause.java	0.8461236953735352	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public CatchClause setBody(final BlockStmt body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ catchclause $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ catchclause $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertthat ( body ). isinterface ( ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifContinueStmt	170	174	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java	0.6982592344284058	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifContinueStmt(Consumer<ContinueStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifcontinuestmt ( consumer < continuestmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( consumer < continuestmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	137	141	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java	0.7322882413864136	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ContinueStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.continueStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ continuestmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . continuestmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ continuestmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. continuestmtmetamodel ; $newline$ $indentation$ }			
remove	111	124	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java	0.8483443856239319	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (label != null) {
		        if (node == label) {
		            removeLabel();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( label $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ label ) $whitespace$ { $newline$ $indentation$ removelabel ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( label $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ label ) $whitespace$ { $newline$ $indentation$ removelabel ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
asContinueStmt	164	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java	0.8750500082969666	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ContinueStmt asContinueStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ continuestmt $whitespace$ ascontinuestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ continuestmt $whitespace$ ascontinuestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isContinueStmt	158	162	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ContinueStmt.java	0.9117472767829896	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isContinueStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscontinuestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscontinuestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifDoStmt	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.7364007830619812	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifDoStmt(Consumer<DoStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifdostmt ( consumer < dostmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dostmt ( consumer < dostmt > $whitespace$ action ) $whitespace$ { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
clone	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.8345121741294861	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public DoStmt clone(){
		    return (DoStmt) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( dostmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( dostmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setBody	97	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.8594857454299927	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public DoStmt setBody(final Statement body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ asserttrue ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asDoStmt	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.9128557443618774	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public DoStmt asDoStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ asdostmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ dostmt $whitespace$ asdostmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isDoStmt	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/DoStmt.java	0.9321219325065612	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isDoStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isdostmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isdostmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifEmptyStmt	91	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/EmptyStmt.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifEmptyStmt(Consumer<EmptyStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifemptystmt ( consumer < emptystmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifemptystmt ( consumer < emptystmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	55	59	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/EmptyStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asEmptyStmt	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/EmptyStmt.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public EmptyStmt asEmptyStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ emptystmt $whitespace$ asemptystmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ emptystmt $whitespace$ asemptystmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isEmptyStmt	79	83	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/EmptyStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isEmptyStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isemptystmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isemptystmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
toExplicitConstructorInvocationStmt	299	303	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.6156629323959351	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ExplicitConstructorInvocationStmt> toExplicitConstructorInvocationStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < explicitconstructorinvocationstmt > $whitespace$ toexplicitconstructorinvocationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < explicitconstructorinvocationstmt > $whitespace$ toexplicitconstructorinvocationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	229	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.666171669960022	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ExplicitConstructorInvocationStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.explicitConstructorInvocationStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ explicitconstructorinvocationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . explicitconstructorinvocationstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ explicitconstructorinvocationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. explicitconstructorinvocationstmtmetamodel ; $newline$ $indentation$ }			
clone	223	227	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.7001785635948181	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public ExplicitConstructorInvocationStmt clone(){
		    return (ExplicitConstructorInvocationStmt) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ explicitconstructorinvocationstmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( explicitconstructorinvocationstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ explicitconstructorinvocationstmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( explicitconstructorinvocationstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setExpression	142	153	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.7227382063865662	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ExplicitConstructorInvocationStmt setExpression(final Expression expression){
		    if (expression == this.expression) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.EXPRESSION, this.expression, expression);
		    if (this.expression != null)
		        this.expression.setParentNode(null);
		    this.expression = expression;
		    setAsParentNodeOf(expression);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ explicitconstructorinvocationstmt $whitespace$ setexpression ( final $whitespace$ expression $whitespace$ expression ) { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ == $whitespace$ this . expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . expression , $whitespace$ this . expression , $whitespace$ expression ) ; $newline$ $indentation$ if $whitespace$ ( this . expression $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . expression . setparentnode ( null ) ; $newline$ $indentation$ this . expression $whitespace$ = $whitespace$ expression ; $newline$ $indentation$ setasparentnodeof ( expression ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ explicitconstructorinvocationstmt $whitespace$ setexpression ( final $whitespace$ expression $whitespace$ expression ) { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ == $whitespace$ this. expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. expression, $whitespace$ this. expression, $whitespace$ expression ) ; $newline$ $indentation$ if $whitespace$ ( this. expression $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. expression. setparentnode ( null ) ; $newline$ $indentation$ this. expression $whitespace$ = $whitespace$ expression ; $newline$ $indentation$ setasparentnodeof ( expression ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
accept	95	99	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
isExplicitConstructorInvocationStmt	264	268	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExplicitConstructorInvocationStmt.java	0.8486641645431519	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isExplicitConstructorInvocationStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isexplicitconstructorinvocationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isexplicitconstructorinvocationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifExpressionStmt	138	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExpressionStmt.java	0.6836962699890137	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifExpressionStmt(Consumer<ExpressionStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifexpressionstmt ( consumer < expressionstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifexpressionstmt ( consumer < expressionstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
asExpressionStmt	132	136	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExpressionStmt.java	0.8627721071243286	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ExpressionStmt asExpressionStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ expressionstmt $whitespace$ asexpressionstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ expressionstmt $whitespace$ asexpressionstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isExpressionStmt	126	130	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ExpressionStmt.java	0.9062368273735046	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isExpressionStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isexpressionstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isexpressionstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifForEachStmt	228	232	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.7040520310401917	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifForEachStmt(Consumer<ForEachStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifforeachstmt ( consumer < foreachstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( consumer < foreachstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	234	238	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.7351876497268677	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ForEachStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.forEachStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ foreachstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . foreachstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ foreachstmtmetamodel $whitespace$ getmetamodel ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. foreachstmtmetamodel ; $newline$ $indentation$ }			
accept	85	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	112	124	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.8517835736274719	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ForEachStmt setBody(final Statement body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ foreachstmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ foreachstmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ asserttrue ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asForEachStmt	216	220	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.8808639645576477	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ForEachStmt asForEachStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ foreachstmt $whitespace$ asforeachstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ foreachstmt $whitespace$ asforeachstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isForEachStmt	210	214	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForEachStmt.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isForEachStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isforeachstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isforeachstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setInitialization	169	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.6974226236343384	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ForStmt setInitialization(final NodeList<Expression> initialization){
		    assertNotNull(initialization);
		    if (initialization == this.initialization) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.INITIALIZATION, this.initialization, initialization);
		    if (this.initialization != null)
		        this.initialization.setParentNode(null);
		    this.initialization = initialization;
		    setAsParentNodeOf(initialization);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ setinitialization ( final $whitespace$ nodelist < expression > $whitespace$ initialization ) { $newline$ $indentation$ assertnotnull ( initialization ) ; $newline$ $indentation$ if $whitespace$ ( initialization $whitespace$ == $whitespace$ this . initialization ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . initialization , $whitespace$ this . initialization , $whitespace$ initialization ) ; $newline$ $indentation$ if $whitespace$ ( this . initialization $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . initialization . setparentnode ( null ) ; $newline$ $indentation$ this . initialization $whitespace$ = $whitespace$ initialization ; $newline$ $indentation$ setasparentnodeof ( initialization ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ setinitialization ( final $whitespace$ nodelist < expression > $whitespace$ initialization ) { $newline$ $indentation$ assertnotnull ( initialization ) ; $newline$ $indentation$ if $whitespace$ ( initialization $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. initialization, $whitespace$ this. initialization, $whitespace$ initialization ) ; $newline$ $indentation$ if $whitespace$ ( this. initialization $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. initialization. setparentnode ( null ) ; $newline$ $indentation$ this. initialization $whitespace$ = $whitespace$ initialization ; $newline$ $indentation$ setasparentnodeof ( initialization ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifForStmt	284	288	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.7324832081794739	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifForStmt(Consumer<ForStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifforstmt ( consumer < forstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ dobuild ( consumer < forstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
clone	229	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.8295180201530457	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public ForStmt clone(){
		    return (ForStmt) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( forstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( forstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setBody	136	148	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.8625432252883911	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ForStmt setBody(final Statement body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ asserttrue ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asForStmt	278	282	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.9059171080589294	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ForStmt asForStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ forstmt $whitespace$ asforstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ forstmt $whitespace$ asforstmt ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isForStmt	272	276	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ForStmt.java	0.9284743070602416	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isForStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isforstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isforstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setThenStmt	141	153	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.6683446168899536	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public IfStmt setThenStmt(final Statement thenStmt){
		    assertNotNull(thenStmt);
		    if (thenStmt == this.thenStmt) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.THEN_STMT, this.thenStmt, thenStmt);
		    if (this.thenStmt != null)
		        this.thenStmt.setParentNode(null);
		    this.thenStmt = thenStmt;
		    setAsParentNodeOf(thenStmt);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ ifstmt $whitespace$ setthenstmt ( final $whitespace$ statement $whitespace$ thenstmt ) { $newline$ $indentation$ assertnotnull ( thenstmt ) ; $newline$ $indentation$ if $whitespace$ ( thenstmt $whitespace$ == $whitespace$ this . thenstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . then_stmt , $whitespace$ this . thenstmt , $whitespace$ thenstmt ) ; $newline$ $indentation$ if $whitespace$ ( this . thenstmt $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . thenstmt . setparentnode ( null ) ; $newline$ $indentation$ this . thenstmt $whitespace$ = $whitespace$ thenstmt ; $newline$ $indentation$ setasparentnodeof ( thenstmt ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanstmt $whitespace$ setthenstmt ( final $whitespace$ statement $whitespace$ thenstmt ) { $newline$ $indentation$ assertnotnull ( thenstmt ) ; $newline$ $indentation$ return $whitespace$ this. thenstmt $whitespace$ == $whitespace$ this. thenstmt ; $newline$ $indentation$ } $newline$ $indentation$ @ test $newline$ $indentation$ public $whitespace$ void $whitespace$ setthenstmt ( final $whitespace$ statement $whitespace$ thenstmt ) { $newline$ $indentation$ this. thenstmt. setparentnode ( thenstmt ) ; $newline$ $indentation$ setasparentnodeof ( thenstmt ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ setasparentnodeof ( final $whitespace$ statement $whitespace$ thenstmt ) { $newline$ $indentation$ this. thenstmt $whitespace$ = $whitespace$ thenstmt ; $newline$ $indentation$ setasparentnodeof ( thenstmt ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifIfStmt	254	258	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.7364007830619812	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifIfStmt(Consumer<IfStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ififstmt ( consumer < ifstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ififstmt ( consumer < ifstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	81	85	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
remove	155	168	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.8327826857566833	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (elseStmt != null) {
		        if (node == elseStmt) {
		            removeElseStmt();
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( elsestmt $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ elsestmt ) $whitespace$ { $newline$ $indentation$ removeelsestmt ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ removeelsestmt ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
clone	207	211	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.8345121741294861	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public IfStmt clone(){
		    return (IfStmt) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ ifstmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( ifstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ staticstmt $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ifstmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
asIfStmt	248	252	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.9128557443618774	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public IfStmt asIfStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ ifstmt $whitespace$ asifstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ booleanstmt $whitespace$ asifstmt ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isIfStmt	242	246	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/IfStmt.java	0.9321219325065612	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isIfStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isifstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isagestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLabeledStmt	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java	0.702133297920227	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLabeledStmt(Consumer<LabeledStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflabeledstmt ( consumer < labeledstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ booleanlabeledstmt ( consumer < labeledstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	131	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java	0.7351876497268677	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public LabeledStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.labeledStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ labeledstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . labeledstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ labeledstmtmetamodel $whitespace$ getmetamodel ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. labeledstmtmetamodel ; $newline$ $indentation$ }			
setLabel	111	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java	0.8360031247138977	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public LabeledStmt setLabel(final SimpleName label){
		    assertNotNull(label);
		    if (label == this.label) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.LABEL, this.label, label);
		    if (this.label != null)
		        this.label.setParentNode(null);
		    this.label = label;
		    setAsParentNodeOf(label);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ labeledstmt $whitespace$ setlabel ( final $whitespace$ simplename $whitespace$ label ) { $newline$ $indentation$ assertnotnull ( label ) ; $newline$ $indentation$ if $whitespace$ ( label $whitespace$ == $whitespace$ this . label ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . label , $whitespace$ this . label , $whitespace$ label ) ; $newline$ $indentation$ if $whitespace$ ( this . label $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . label . setparentnode ( null ) ; $newline$ $indentation$ this . label $whitespace$ = $whitespace$ label ; $newline$ $indentation$ setasparentnodeof ( label ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ labeledstmt $whitespace$ setlabel ( final $whitespace$ simplename $whitespace$ label ) { $newline$ $indentation$ return $whitespace$ label ; $newline$ $indentation$ } $newline$ $indentation$ @ test $newline$ $indentation$ public $whitespace$ labeledstmt $whitespace$ setlabel ( final $whitespace$ simplename $whitespace$ label ) { $newline$ $indentation$ if $whitespace$ ( label $whitespace$ == $whitespace$ this. label ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. label, $whitespace$ this. label, $whitespace$ label ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asLabeledStmt	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java	0.8798959851264954	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public LabeledStmt asLabeledStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ labeledstmt $whitespace$ aslabeledstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ final $whitespace$ labeledstmt $whitespace$ aslabeledstmt ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isLabeledStmt	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LabeledStmt.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLabeledStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islabeledstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islabeledstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifLocalClassDeclarationStmt	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java	0.6113665103912354	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifLocalClassDeclarationStmt(Consumer<LocalClassDeclarationStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflocalclassdeclarationstmt ( consumer < localclassdeclarationstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iflocalclassdeclarationstmt ( consumer < localclassdeclarationstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toLocalClassDeclarationStmt	148	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java	0.6840498447418213	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<LocalClassDeclarationStmt> toLocalClassDeclarationStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < localclassdeclarationstmt > $whitespace$ tolocalclassdeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < localclassdeclarationstmt > $whitespace$ tolocalclassdeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
getMetaModel	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java	0.6846005320549011	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public LocalClassDeclarationStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.localClassDeclarationStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ localclassdeclarationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . localclassdeclarationstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ localclassdeclarationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. localclassdeclarationstmtmetamodel ; $newline$ $indentation$ }			
accept	74	78	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
isLocalClassDeclarationStmt	130	134	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalClassDeclarationStmt.java	0.8750794529914856	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLocalClassDeclarationStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islocalclassdeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islocalclassdeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
getMetaModel	106	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalRecordDeclarationStmt.java	0.6812337040901184	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public LocalRecordDeclarationStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.localRecordDeclarationStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ localrecorddeclarationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . localrecorddeclarationstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ localrecorddeclarationstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. localrecorddeclarationstmtmetamodel ; $newline$ $indentation$ }			
toLocalRecordDeclarationStmt	143	147	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalRecordDeclarationStmt.java	0.6849849820137024	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<LocalRecordDeclarationStmt> toLocalRecordDeclarationStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < localrecorddeclarationstmt > $whitespace$ tolocalrecorddeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < localrecorddeclarationstmt > $whitespace$ tolocalrecorddeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	69	73	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalRecordDeclarationStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
isLocalRecordDeclarationStmt	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/LocalRecordDeclarationStmt.java	0.8714120388031006	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isLocalRecordDeclarationStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islocalrecorddeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ islocalrecorddeclarationstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setExpression	99	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java	0.6860074400901794	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ReturnStmt setExpression(final Expression expression){
		    if (expression == this.expression) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.EXPRESSION, this.expression, expression);
		    if (this.expression != null)
		        this.expression.setParentNode(null);
		    this.expression = expression;
		    setAsParentNodeOf(expression);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ returnstmt $whitespace$ setexpression ( final $whitespace$ expression $whitespace$ expression ) { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ == $whitespace$ this . expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . expression , $whitespace$ this . expression , $whitespace$ expression ) ; $newline$ $indentation$ if $whitespace$ ( this . expression $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . expression . setparentnode ( null ) ; $newline$ $indentation$ this . expression $whitespace$ = $whitespace$ expression ; $newline$ $indentation$ setasparentnodeof ( expression ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ returnstmt $whitespace$ setexpression ( final $whitespace$ expression $whitespace$ expression ) { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ == $whitespace$ this. expression ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. expression, $whitespace$ this. expression, $whitespace$ expression ) ; $newline$ $indentation$ if $whitespace$ ( this. expression $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. expression. setparentnode ( null ) ; $newline$ $indentation$ this. expression $whitespace$ = $whitespace$ expression ; $newline$ $indentation$ setasparentnodeof ( expression ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifReturnStmt	171	175	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java	0.719254195690155	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifReturnStmt(Consumer<ReturnStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifreturnstmt ( consumer < returnstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ returnstmt ( consumer < returnstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	76	80	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asReturnStmt	165	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java	0.8873354196548462	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ReturnStmt asReturnStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ returnstmt $whitespace$ asreturnstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ returnstmt $whitespace$ asreturnstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isReturnStmt	159	163	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ReturnStmt.java	0.9195840358734132	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isReturnStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isreturnstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isreturnstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
clone	57	61	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/Statement.java	0.8362693786621094	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Statement clone(){
		    return (Statement) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ statement $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( statement ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ statement $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( statement ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
replace	224	243	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.6580192446708679	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < labels.size(); i++) {
		        if (labels.get(i) == node) {
		            labels.set(i, (Expression) replacementNode);
		            return true;
		        }
		    }
		    for (int i = 0; i < statements.size(); i++) {
		        if (statements.get(i) == node) {
		            statements.set(i, (Statement) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ labels . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( labels . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ labels . set ( i , $whitespace$ ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ statements . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( statements . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ statements . set ( i , $whitespace$ ( statement ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$			
remove	175	194	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.6769472360610962	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < labels.size(); i++) {
		        if (labels.get(i) == node) {
		            labels.remove(i);
		            return true;
		        }
		    }
		    for (int i = 0; i < statements.size(); i++) {
		        if (statements.get(i) == node) {
		            statements.remove(i);
		            return true;
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ labels . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( labels . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ labels . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ statements . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( statements . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ statements . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ labels. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( labels. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ labels. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
getMetaModel	202	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.7333943247795105	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public SwitchEntryMetaModel getMetaModel(){
		    return JavaParserMetaModel.switchEntryMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentrymetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . switchentrymetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentrymetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. switchentrymetamodel ; $newline$ $indentation$ }			
accept	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setStatements	161	173	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.8639063239097595	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SwitchEntry setStatements(final NodeList<Statement> statements){
		    assertNotNull(statements);
		    if (statements == this.statements) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.STATEMENTS, this.statements, statements);
		    if (this.statements != null)
		        this.statements.setParentNode(null);
		    this.statements = statements;
		    setAsParentNodeOf(statements);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ setstatements ( final $whitespace$ nodelist < statement > $whitespace$ statements ) { $newline$ $indentation$ assertnotnull ( statements ) ; $newline$ $indentation$ if $whitespace$ ( statements $whitespace$ == $whitespace$ this . statements ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . statements , $whitespace$ this . statements , $whitespace$ statements ) ; $newline$ $indentation$ if $whitespace$ ( this . statements $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . statements . setparentnode ( null ) ; $newline$ $indentation$ this . statements $whitespace$ = $whitespace$ statements ; $newline$ $indentation$ setasparentnodeof ( statements ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ setstatements ( final $whitespace$ nodelist < statement > $whitespace$ statements ) { $newline$ $indentation$ assertnotnull ( statements ) ; $newline$ $indentation$ if $whitespace$ ( statements $whitespace$ == $whitespace$ this. statements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( statements $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. statements. setparentnode ( null ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. statements, $whitespace$ this. statements, $whitespace$ statements ) ; $newline$ $indentation$ if $whitespace$ ( this. statements $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. statements. setparentnode ( null ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setLabels	147	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.8807325959205627	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SwitchEntry setLabels(final NodeList<Expression> labels){
		    assertNotNull(labels);
		    if (labels == this.labels) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.LABELS, this.labels, labels);
		    if (this.labels != null)
		        this.labels.setParentNode(null);
		    this.labels = labels;
		    setAsParentNodeOf(labels);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ setlabels ( final $whitespace$ nodelist < expression > $whitespace$ labels ) { $newline$ $indentation$ assertnotnull ( labels ) ; $newline$ $indentation$ if $whitespace$ ( labels $whitespace$ == $whitespace$ this . labels ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . labels , $whitespace$ this . labels , $whitespace$ labels ) ; $newline$ $indentation$ if $whitespace$ ( this . labels $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . labels . setparentnode ( null ) ; $newline$ $indentation$ this . labels $whitespace$ = $whitespace$ labels ; $newline$ $indentation$ setasparentnodeof ( labels ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ setlabels ( final $whitespace$ nodelist < expression > $whitespace$ labels ) $whitespace$ { $newline$ $indentation$ assertnotnull ( labels ) ; $newline$ $indentation$ if $whitespace$ ( labels $whitespace$ == $whitespace$ this. labels ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. labels, $whitespace$ this. labels, $whitespace$ labels ) ; $newline$ $indentation$ if $whitespace$ ( this. labels $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. labels. setparentnode ( null ) ; $newline$ $indentation$ this. labels $whitespace$ = $whitespace$ labels ; $newline$ $indentation$ setasparentnodeof ( labels ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setType	213	222	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchEntry.java	0.8852975368499756	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SwitchEntry setType(final Type type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    this.type = type;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchentry $whitespace$ settype ( final $whitespace$ type $whitespace$ type ) { $newline$ $indentation$ asserttokentype ( type, $whitespace$ type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this. type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
replace	187	204	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java	0.7001101970672607	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    for (int i = 0; i < entries.size(); i++) {
		        if (entries.get(i) == node) {
		            entries.set(i, (SwitchEntry) replacementNode);
		            return true;
		        }
		    }
		    if (node == selector) {
		        setSelector((Expression) replacementNode);
		        return true;
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ entries . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entries . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ entries . set ( i , $whitespace$ ( switchentry ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ selector ) $whitespace$ { $newline$ $indentation$ setselector ( ( expression ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ entries. size ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ node. set ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. replace ( node, $whitespace$ replacementnode ) ; $newline$ $indentation$ }			
ifSwitchStmt	218	222	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java	0.7155272364616394	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifSwitchStmt(Consumer<SwitchStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifswitchstmt ( consumer < switchstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifswitchstmt ( consumer < switchstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
setEntries	132	144	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java	0.8688095211982727	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SwitchStmt setEntries(final NodeList<SwitchEntry> entries){
		    assertNotNull(entries);
		    if (entries == this.entries) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ENTRIES, this.entries, entries);
		    if (this.entries != null)
		        this.entries.setParentNode(null);
		    this.entries = entries;
		    setAsParentNodeOf(entries);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchstmt $whitespace$ setentries ( final $whitespace$ nodelist < switchentry > $whitespace$ entries ) { $newline$ $indentation$ assertnotnull ( entries ) ; $newline$ $indentation$ if $whitespace$ ( entries $whitespace$ == $whitespace$ this . entries ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . entries , $whitespace$ this . entries , $whitespace$ entries ) ; $newline$ $indentation$ if $whitespace$ ( this . entries $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . entries . setparentnode ( null ) ; $newline$ $indentation$ this . entries $whitespace$ = $whitespace$ entries ; $newline$ $indentation$ setasparentnodeof ( entries ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchstmt $whitespace$ setentries ( final $whitespace$ nodelist < switchentry > $whitespace$ entries ) { $newline$ $indentation$ return $whitespace$ entries. stream ( ) $newline$ $indentation$. filter ( this : : isnull ) $newline$ $indentation$. map ( entries $whitespace$ - > $whitespace$ this. entries. setparentnode ( null ) ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ addonlythesecomponents ( final $whitespace$ nodelist < string > $whitespace$ entries, $whitespace$ final $whitespace$ list < string > $whitespace$ entries ) { $newline$ $indentation$ if $whitespace$ ( isempty ( entries ) ) $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ return $whitespace$ entries. stream ( ) $newline$ $indentation$. map ( this : : extractjurisdiction ) $newline$ $indentation$. map ( string : : tostring ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ setattributes ( final $whitespace$ nodelist < string > $whitespace$ entries ) { $newline$ $indentation$ if $whitespace$ ( isempty ( entries ) ) $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ return $whitespace$ entries ; $newline$ $indentation$ }			
asSwitchStmt	212	216	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java	0.8873354196548462	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public SwitchStmt asSwitchStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ switchstmt $whitespace$ asswitchstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ switchstmt $whitespace$ asswitchstmt ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isSwitchStmt	206	210	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SwitchStmt.java	0.9189016819000244	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isSwitchStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isswitchstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isswitchstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifSynchronizedStmt	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.6772084832191467	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifSynchronizedStmt(Consumer<SynchronizedStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifsynchronizedstmt ( consumer < synchronizedstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ applystmt ( consumer < synchronizedstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	131	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.7258090972900391	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public SynchronizedStmtMetaModel getMetaModel(){
		    return JavaParserMetaModel.synchronizedStmtMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . synchronizedstmtmetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmtmetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. synchronizedstmtmetamodel ; $newline$ $indentation$ }			
toSynchronizedStmt	172	176	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.7331438064575195	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<SynchronizedStmt> toSynchronizedStmt(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < synchronizedstmt > $whitespace$ tosynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < synchronizedstmt > $whitespace$ tosynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	111	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.8424115777015686	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public SynchronizedStmt setBody(final BlockStmt body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmt $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmt $whitespace$ setbody ( final $whitespace$ blockstmt $whitespace$ body ) { $newline$ $indentation$ assertthat ( body ). isnull ( ) $newline$ $indentation$. map ( blockstmt : : add ) $newline$ $indentation$. orelse ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asSynchronizedStmt	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.8536978960037231	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public SynchronizedStmt asSynchronizedStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmt $whitespace$ assynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ synchronizedstmt $whitespace$ assynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isSynchronizedStmt	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/SynchronizedStmt.java	0.8998482823371887	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isSynchronizedStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ issynchronizedstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifThrowStmt	139	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ThrowStmt.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifThrowStmt(Consumer<ThrowStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifthrowstmt ( consumer < throwstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifthrowstmt ( consumer < throwstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	71	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ThrowStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asThrowStmt	133	137	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ThrowStmt.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ThrowStmt asThrowStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ throwstmt $whitespace$ asthrowstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ throwstmt $whitespace$ asthrowstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isThrowStmt	127	131	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/ThrowStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isThrowStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isthrowstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isthrowstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setTryBlock	193	205	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.6759675145149231	MID	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public TryStmt setTryBlock(final BlockStmt tryBlock){
		    assertNotNull(tryBlock);
		    if (tryBlock == this.tryBlock) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TRY_BLOCK, this.tryBlock, tryBlock);
		    if (this.tryBlock != null)
		        this.tryBlock.setParentNode(null);
		    this.tryBlock = tryBlock;
		    setAsParentNodeOf(tryBlock);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ settryblock ( final $whitespace$ blockstmt $whitespace$ tryblock ) { $newline$ $indentation$ assertnotnull ( tryblock ) ; $newline$ $indentation$ if $whitespace$ ( tryblock $whitespace$ == $whitespace$ this . tryblock ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . try_block , $whitespace$ this . tryblock , $whitespace$ tryblock ) ; $newline$ $indentation$ if $whitespace$ ( this . tryblock $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . tryblock . setparentnode ( null ) ; $newline$ $indentation$ this . tryblock $whitespace$ = $whitespace$ tryblock ; $newline$ $indentation$ setasparentnodeof ( tryblock ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ settryblock ( final $whitespace$ blockstmt $whitespace$ tryblock ) { $newline$ $indentation$ return $whitespace$ tryblock ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ list < blockstmt > $whitespace$ tryblock ( final $whitespace$ blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ final $whitespace$ blockstmt $whitespace$ x $whitespace$ = $whitespace$ this. tryblock ) ; $newline$ $indentation$ final $whitespace$ set < blockstmt > $whitespace$ newblock $whitespace$ = $whitespace$ new $whitespace$ linkedhashset < > ( tryblock ) ; $newline$ $indentation$ x. addblock ( null ) ; $newline$ $indentation$ x. addblock ( tryblock ) ; $newline$ $indentation$ return $whitespace$ x ; $newline$ $indentation$ }			
ifTryStmt	308	312	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.7342804670333862	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifTryStmt(Consumer<TryStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftrystmt ( consumer < trystmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftrystmt ( consumer < trystmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
clone	253	257	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.8308139443397522	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public TryStmt clone(){
		    return (TryStmt) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( trystmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ static $whitespace$ trystmt $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( trystmt ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
setResources	207	219	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.8597676753997803	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public TryStmt setResources(final NodeList<Expression> resources){
		    assertNotNull(resources);
		    if (resources == this.resources) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.RESOURCES, this.resources, resources);
		    if (this.resources != null)
		        this.resources.setParentNode(null);
		    this.resources = resources;
		    setAsParentNodeOf(resources);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ setresources ( final $whitespace$ nodelist < expression > $whitespace$ resources ) { $newline$ $indentation$ assertnotnull ( resources ) ; $newline$ $indentation$ if $whitespace$ ( resources $whitespace$ == $whitespace$ this . resources ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . resources , $whitespace$ this . resources , $whitespace$ resources ) ; $newline$ $indentation$ if $whitespace$ ( this . resources $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . resources . setparentnode ( null ) ; $newline$ $indentation$ this . resources $whitespace$ = $whitespace$ resources ; $newline$ $indentation$ setasparentnodeof ( resources ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ setresources ( final $whitespace$ nodelist < expression > $whitespace$ resources ) { $newline$ $indentation$ assertnotnull ( resources ) ; $newline$ $indentation$ if $whitespace$ ( resources $whitespace$ == $whitespace$ this. resources ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. resources, $whitespace$ this. resources, $whitespace$ resources ) ; $newline$ $indentation$ if $whitespace$ ( this. resources $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. resources. setparentnode ( null ) ; $newline$ $indentation$ this. resources $whitespace$ = $whitespace$ resources ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asTryStmt	302	306	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.9066975712776184	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public TryStmt asTryStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ astrystmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ trystmt $whitespace$ astrystmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isTryStmt	296	300	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/TryStmt.java	0.9284743070602416	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isTryStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istrystmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istrystmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifUnparsableStmt	98	102	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/UnparsableStmt.java	0.6896289587020874	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifUnparsableStmt(Consumer<UnparsableStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifunparsablestmt ( consumer < unparsablestmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ final $whitespace$ void $whitespace$ ifunparsablestmt ( consumer < unparsablestmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	57	61	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/UnparsableStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asUnparsableStmt	92	96	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/UnparsableStmt.java	0.8616802096366882	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public UnparsableStmt asUnparsableStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unparsablestmt $whitespace$ asunparsablestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unparsablestmt $whitespace$ asunparsablestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isUnparsableStmt	86	90	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/UnparsableStmt.java	0.9062368273735046	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isUnparsableStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunparsablestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunparsablestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifWhileStmt	166	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java	0.7173429727554321	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifWhileStmt(Consumer<WhileStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifwhilestmt ( consumer < whilestmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ do**************************stmt ( consumer < whilestmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	75	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setBody	97	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java	0.8544335961341858	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public WhileStmt setBody(final Statement body){
		    assertNotNull(body);
		    if (body == this.body) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.BODY, this.body, body);
		    if (this.body != null)
		        this.body.setParentNode(null);
		    this.body = body;
		    setAsParentNodeOf(body);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ whilestmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ assertnotnull ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this . body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . body , $whitespace$ this . body , $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this . body $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . body . setparentnode ( null ) ; $newline$ $indentation$ this . body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ setasparentnodeof ( body ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ whilestmt $whitespace$ setbody ( final $whitespace$ statement $whitespace$ body ) { $newline$ $indentation$ asserttrue ( body ) ; $newline$ $indentation$ if $whitespace$ ( body $whitespace$ == $whitespace$ this. body ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. body, $whitespace$ this. body, $whitespace$ body ) ; $newline$ $indentation$ if $whitespace$ ( this. body $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. body. setparentnode ( null ) ; $newline$ $indentation$ this. body $whitespace$ = $whitespace$ body ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asWhileStmt	160	164	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public WhileStmt asWhileStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ whilestmt $whitespace$ aswhilestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ whilestmt $whitespace$ aswhilestmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isWhileStmt	154	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/WhileStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isWhileStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iswhilestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iswhilestmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifYieldStmt	129	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/YieldStmt.java	0.7173429727554321	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifYieldStmt(Consumer<YieldStmt> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifyieldstmt ( consumer < yieldstmt > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifyieldstmt ( consumer < yieldstmt > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	99	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/YieldStmt.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asYieldStmt	117	121	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/YieldStmt.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public YieldStmt asYieldStmt(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ yieldstmt $whitespace$ asyieldstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ yieldstmt $whitespace$ toyieldstmt ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isYieldStmt	111	115	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/stmt/YieldStmt.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isYieldStmt(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isyieldstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isyieldstmt ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
unwrapArrayTypes	176	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.0968619510531425	LOW	"		public static Pair<Type, List<ArrayBracketPair>> unwrapArrayTypes(Type type){
		    final List<ArrayBracketPair> arrayBracketPairs = new ArrayList<>(0);
		    while (type instanceof ArrayType) {
		        ArrayType arrayType = (ArrayType) type;
		        arrayBracketPairs.add(new ArrayBracketPair(type.getTokenRange().orElse(null), arrayType.getOrigin(), arrayType.getAnnotations()));
		        type = arrayType.getComponentType();
		    }
		    return new Pair<>(type, arrayBracketPairs);
		}"	$indentation$ public $whitespace$ static $whitespace$ pair < type , $whitespace$ list < arraybracketpair >> $whitespace$ unwraparraytypes ( type $whitespace$ type ) { $newline$ $indentation$ final $whitespace$ list < arraybracketpair > $whitespace$ arraybracketpairs $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( $number$ ) ; $newline$ $indentation$ while $whitespace$ ( type $whitespace$ instanceof $whitespace$ arraytype ) $whitespace$ { $newline$ $indentation$ arraytype $whitespace$ arraytype $whitespace$ = $whitespace$ ( arraytype ) $whitespace$ type ; $newline$ $indentation$ arraybracketpairs . add ( new $whitespace$ arraybracketpair ( type . gettokenrange ( ) . orelse ( null ) , $whitespace$ arraytype . getorigin ( ) , $whitespace$ arraytype . getannotations ( ) ) ) ; $newline$ $indentation$ type $whitespace$ = $whitespace$ arraytype . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( type , $whitespace$ arraybracketpairs ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ pair < type, $whitespace$ list < arraybracketpair >> $whitespace$ unwraparraytypes ( type $whitespace$ type ) { $newline$ $indentation$ final $whitespace$ list < arraybracketpair > $whitespace$ arraybracketpairs $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( $number$ ) ; $newline$ $indentation$ // $whitespace$ set $whitespace$ up $whitespace$ datastore $whitespace$ array $whitespace$ with $whitespace$ datastore $newline$ $indentation$ while $whitespace$ ( type $whitespace$ instanceof $whitespace$ arraytype ) $whitespace$ { $newline$ $indentation$ arraytype $whitespace$ arraytype $whitespace$ = $whitespace$ ( arraytype ) $whitespace$ type ; $newline$ $indentation$ arraybracketpairs. add ( new $whitespace$ arraybracketpair ( type. gettokenrange ( ). orelse ( null ), $whitespace$ arraytype. getorigin ( ), $whitespace$ arraytype. getannotations ( ) ) ) ; $newline$ $indentation$ // $whitespace$ add $whitespace$ images $whitespace$ to $whitespace$ be $whitespace$ used $whitespace$ on $whitespace$ the $whitespace$ very $whitespace$ first $whitespace$ array $whitespace$ of $whitespace$ array. $newline$ $indentation$ arraybracketpairs. add ( new $whitespace$ arraybracketpair ( type. gettokenrange ( ). orelse ( null ), $whitespace$ arraytype. getorigin ( ), $whitespace$ arraytype. getannotations ( ) ) ) ; $newline$ $indentation$ // $whitespace$ add $whitespace$ images $whitespace$ to $whitespace$ be $whitespace$ used $whitespace$ on $whitespace$ the $whitespace$ user $whitespace$ to $whitespace$ be $whitespace$ on $whitespace$ a $whitespace$ power $whitespace$ ring $whitespace$ return $whitespace$ arraytype. $newline$ $indentation			
wrapInArrayTypes	135	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.1045020595192909	LOW	"		@SafeVarargs
		public static Type wrapInArrayTypes(Type type, List<ArrayBracketPair>... arrayBracketPairLists){
		    TokenRange outerMostTokenRange = null;
		    for (int i = arrayBracketPairLists.length - 1; i >= 0; i--) {
		        final List<ArrayBracketPair> arrayBracketPairList = arrayBracketPairLists[i];
		        if (arrayBracketPairList != null) {
		            for (int j = arrayBracketPairList.size() - 1; j >= 0; j--) {
		                ArrayBracketPair pair = arrayBracketPairList.get(j);
		                if (type.getTokenRange().isPresent() && pair.getTokenRange().isPresent()) {
		                    TokenRange currentTokenRange = new TokenRange(type.getTokenRange().get().getBegin(), pair.getTokenRange().get().getEnd());
		                    // The end range must be equals to the last array bracket pair in the list
		                    // in the example below:
		                    // Long[][]
		                    //        ^
		                    //        |
		                    // this is the outermost range for the ArrayType
		                    outerMostTokenRange = getOuterMostTokenRange(currentTokenRange, outerMostTokenRange);
		                }
		                type = new ArrayType(outerMostTokenRange, type, pair.getOrigin(), pair.getAnnotations());
		            }
		        }
		    }
		    return type;
		}"	$indentation$ @ safevarargs $newline$ $indentation$ public $whitespace$ static $whitespace$ type $whitespace$ wrapinarraytypes ( type $whitespace$ type , $whitespace$ list < arraybracketpair > . . . $whitespace$ arraybracketpairlists ) { $newline$ $indentation$ tokenrange $whitespace$ outermosttokenrange $whitespace$ = $whitespace$ null ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ arraybracketpairlists . length $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ final $whitespace$ list < arraybracketpair > $whitespace$ arraybracketpairlist $whitespace$ = $whitespace$ arraybracketpairlists [ i ] ; $newline$ $indentation$ if $whitespace$ ( arraybracketpairlist $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ arraybracketpairlist . size ( ) $whitespace$ - $whitespace$ $number$ ; $whitespace$ j $whitespace$ >= $whitespace$ $number$ ; $whitespace$ j -- ) $whitespace$ { $newline$ $indentation$ arraybracketpair $whitespace$ pair $whitespace$ = $whitespace$ arraybracketpairlist . get ( j ) ; $newline$ $indentation$ if $whitespace$ ( type . gettokenrange ( ) . ispresent ( ) $whitespace$ && $whitespace$ pair . gettokenrange ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ currenttokenrange $whitespace$ = $whitespace$ new $whitespace$ tokenrange ( type . gettokenrange ( ) . get ( ) . getbegin ( ) , $whitespace$ pair . gettokenrange ( ) . get ( ) . getend ( ) ) ; $newline$ $indentation$ $//·the·end·range·must·be·equals·to·the·last·array·bracket·pair·in·the·list$ $newline$ $indentation$ $//·in·the·example·below:$ $newline$ $indentation$ $//·long[][]$ $newline$ $indentation$ $//········^$ $newline$ $indentation$ $//········|$ $newline$ $indentation$ $//·this·is·the·outermost·range·for·the·arraytype$ $newline$ $indentation$ outermosttokenrange $whitespace$ = $whitespace$ getoutermosttokenrange ( currenttokenrange , $whitespace$ outermosttokenrange ) ; $newline$ $indentation$ } $newline$ $indentation$ type $whitespace$ = $whitespace$ new $whitespace$ arraytype ( outermosttokenrange , $whitespace$ type , $whitespace$ pair . getorigin ( ) , $whitespace$ pair . getannotations ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ @ safevarargs $newline$ $indentation$ public $whitespace$ static $whitespace$ type $whitespace$ wrapinarraytypes ( type $whitespace$ type, $whitespace$ list < arraybracketpair >... $whitespace$ arraybracketpairlists ) { $newline$ $indentation$ tokenrange $whitespace$ outermosttokenrange $whitespace$ = $whitespace$ null ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ arraybracketpairlists. length $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ final $whitespace$ list < arraybracketpair > $whitespace$ arraybracketpairlist $whitespace$ = $whitespace$ arraybracketpairlists [ i ] ; $newline$ $indentation$ if $whitespace$ ( arraybracketpairlist $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ arraybracketpairlist. size ( ) $whitespace$ - $whitespace$ $number$ ; $whitespace$ j $whitespace$ >= $whitespace$ $number$ ; $whitespace$ j -- ) $whitespace$ { $newline$ $indentation$ arraybracketpair $whitespace$ pair $whitespace$ = $whitespace$ arraybracketpairlist. get ( j ) ; $newline$ $indentation$ if $whitespace$ ( type. gettokenrange ( ). ispresent ( ) $whitespace$ && $whitespace$ pair. gettokenrange ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ currenttokenrange $whitespace$ = $whitespace$ new $whitespace$ tokenrange ( type. gettokenrange ( ). get ( ). getbegin ( ), $whitespace$ pair. gettokenrange ( ). get (			
getOuterMostTokenRange	163	169	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.2120673209428787	LOW	"		private static TokenRange getOuterMostTokenRange(TokenRange tokenRange1, TokenRange tokenRange2){
		    if (tokenRange2 == null)
		        return tokenRange1;
		    if (tokenRange1.getEnd().getRange().get().isAfter(tokenRange2.getEnd().getRange().get())) {
		        return tokenRange1;
		    }
		    return new TokenRange(tokenRange1.getBegin(), tokenRange2.getEnd());
		}"	$indentation$ private $whitespace$ static $whitespace$ tokenrange $whitespace$ getoutermosttokenrange ( tokenrange $whitespace$ tokenrange1 , $whitespace$ tokenrange $whitespace$ tokenrange2 ) { $newline$ $indentation$ if $whitespace$ ( tokenrange2 $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ tokenrange1 ; $newline$ $indentation$ if $whitespace$ ( tokenrange1 . getend ( ) . getrange ( ) . get ( ) . isafter ( tokenrange2 . getend ( ) . getrange ( ) . get ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokenrange1 ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ tokenrange ( tokenrange1 . getbegin ( ) , $whitespace$ tokenrange2 . getend ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ tokenrange $whitespace$ getoutermosttokenrange ( tokenrange $whitespace$ tokenrange1, $whitespace$ tokenrange $whitespace$ tokenrange2 ) { $newline$ $indentation$ if $whitespace$ ( tokenrange2 $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ tokenrange1 ; $newline$ $indentation$ return $whitespace$ tokenrange1 ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ tokenrange $whitespace$ getoutermosttokenrange ( tokenrange $whitespace$ tokenrange1, $whitespace$ tokenrange $whitespace$ tokenrange2 ) { $newline$ $indentation$ if $whitespace$ ( tokenrange1. getend ( ). getrange ( ). get ( ). isafter ( tokenrange2. getend ( ). getrange ( ). get ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokenrange1 ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ tokenrange ( tokenrange1. getbegin ( ), $whitespace$ tokenrange2. getend ( ) ) ; $newline$ $indentation$ }			
ifArrayType	303	307	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifArrayType(Consumer<ArrayType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarraytype ( consumer < arraytype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifarraytype ( consumer < byte > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
toDescriptor	258	264	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.7294408679008484	MID	"		@Override
		public String toDescriptor(){
		    StringBuffer sb = new StringBuffer();
		    sb.append(""["");
		    sb.append(componentType.toDescriptor());
		    return sb.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ todescriptor ( ) { $newline$ $indentation$ stringbuffer $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuffer ( ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ sb . append ( componenttype . todescriptor ( ) ) ; $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ todescriptor ( ) { $newline$ $indentation$ stringbuffer $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuffer ( ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ sb. append ( componenttype. todescriptor ( ) ) ; $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
accept	99	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setOrigin	242	251	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.8668793439865112	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ArrayType setOrigin(final Origin origin){
		    assertNotNull(origin);
		    if (origin == this.origin) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ORIGIN, this.origin, origin);
		    this.origin = origin;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraytype $whitespace$ setorigin ( final $whitespace$ origin $whitespace$ origin ) { $newline$ $indentation$ assertnotnull ( origin ) ; $newline$ $indentation$ if $whitespace$ ( origin $whitespace$ == $whitespace$ this . origin ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . origin , $whitespace$ this . origin , $whitespace$ origin ) ; $newline$ $indentation$ this . origin $whitespace$ = $whitespace$ origin ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraytype $whitespace$ setorigin ( final $whitespace$ origin $whitespace$ origin ) { $newline$ $indentation$ assertnotnull ( origin ) ; $newline$ $indentation$ if $whitespace$ ( origin $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. origin, $whitespace$ this. origin, $whitespace$ origin ) ; $newline$ $indentation$ this. origin $whitespace$ = $whitespace$ origin ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asArrayType	297	301	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.8948096036911011	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ArrayType asArrayType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ arraytype $whitespace$ asarraytype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ list < long > $whitespace$ asarraytype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isArrayType	291	295	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ArrayType.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isArrayType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarraytype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isarraytype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
convertToUsage	342	358	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.0529403872787952	LOW	"		@Override
		public ResolvedType convertToUsage(Context context){
		    String name = getNameWithScope();
		    SymbolReference<ResolvedTypeDeclaration> ref = context.solveType(name);
		    if (!ref.isSolved()) {
		        throw new UnsolvedSymbolException(name);
		    }
		    ResolvedTypeDeclaration typeDeclaration = ref.getCorrespondingDeclaration();
		    List<ResolvedType> typeParameters = Collections.emptyList();
		    if (getTypeArguments().isPresent()) {
		        typeParameters = getTypeArguments().get().stream().map((pt) -> pt.convertToUsage(context)).collect(Collectors.toList());
		    }
		    if (typeDeclaration.isTypeParameter()) {
		        return new ResolvedTypeVariable(typeDeclaration.asTypeParameter());
		    }
		    return new ReferenceTypeImpl((ResolvedReferenceTypeDeclaration) typeDeclaration, typeParameters);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ getnamewithscope ( ) ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ context . solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ ref . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparameters $whitespace$ = $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ if $whitespace$ ( gettypearguments ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ typeparameters $whitespace$ = $whitespace$ gettypearguments ( ) . get ( ) . stream ( ) . map ( ( pt ) $whitespace$ - > $whitespace$ pt . converttousage ( context ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typedeclaration . istypeparameter ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( typedeclaration . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ( resolvedreferencetypedeclaration ) $whitespace$ typedeclaration , $whitespace$ typeparameters ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ getnamewithscope ( ) ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ context. solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ (! ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ ref. getcorrespondingdeclaration ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparameters $whitespace$ = $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ if $whitespace$ ( gettypearguments ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ typeparameters $whitespace$ = $whitespace$ gettypearguments ( ). get ( ). stream ( ). map ( ( pt ) $whitespace$ - > $whitespace$ pt. converttousage ( context ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typedeclaration. istypeparameter ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( typedeclaration. astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ( resolvedreferencetypedeclaration ) $whitespace$ typedeclaration, $whitespace$ typeparameters ) ; $newline$ $indentation$ }			
asString	243	250	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.1908288300037384	LOW	"		@Override
		public String asString(){
		    StringBuilder str = new StringBuilder();
		    getScope().ifPresent(s -> str.append(s.asString()).append("".""));
		    str.append(name.asString());
		    getTypeArguments().ifPresent(ta -> str.append(ta.stream().map(Type::asString).collect(joining("","", ""<"", "">""))));
		    return str.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ str $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ getscope ( ) . ifpresent ( s $whitespace$ - > $whitespace$ str . append ( s . asstring ( ) ) . append ( $string$ ) ) ; $newline$ $indentation$ str . append ( name . asstring ( ) ) ; $newline$ $indentation$ gettypearguments ( ) . ifpresent ( ta $whitespace$ - > $whitespace$ str . append ( ta . stream ( ) . map ( type : : asstring ) . collect ( joining ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ) ) ) ; $newline$ $indentation$ return $whitespace$ str . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ str $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ getscope ( ). ifpresent ( s $whitespace$ - > $whitespace$ str. append ( s. asstring ( ) ). append ( $string$ ) ) ; $newline$ $indentation$ str. append ( name. asstring ( ) ) ; $newline$ $indentation$ gettypearguments ( ). ifpresent ( ta $whitespace$ - > $whitespace$ str. append ( ta. stream ( ). map ( type : : asstring ). collect ( joining ( $string$, $whitespace$ $string$, $whitespace$ $string$ ) ) ) ) ; $newline$ $indentation$ return $whitespace$ str. tostring ( ) ; $newline$ $indentation$ }			
replace	278	303	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.6291108131408691	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    if (scope != null) {
		        if (node == scope) {
		            setScope((ClassOrInterfaceType) replacementNode);
		            return true;
		        }
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.set(i, (Type) replacementNode);
		                return true;
		            }
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setscope ( ( classorinterfacetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . set ( i , $whitespace$ ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ deletednode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ deletednode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scope $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ setscope ( ( classorinterfacetype ) $whitespace$ deletednode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments. set ( i, $whitespace$ ( type ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
remove	220	241	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.6321473717689514	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.RemoveMethodGenerator"")
		public boolean remove(Node node){
		    if (node == null) {
		        return false;
		    }
		    if (scope != null) {
		        if (node == scope) {
		            removeScope();
		            return true;
		        }
		    }
		    if (typeArguments != null) {
		        for (int i = 0; i < typeArguments.size(); i++) {
		            if (typeArguments.get(i) == node) {
		                typeArguments.remove(i);
		                return true;
		            }
		        }
		    }
		    return super.remove(node);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ removescope ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments . remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . remove ( node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ remove ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scope $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ scope ) $whitespace$ { $newline$ $indentation$ removescope ( ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typearguments $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typearguments. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typearguments. get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typearguments. remove ( i ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super. remove ( node ) ; $newline$ $indentation$ }			
ifClassOrInterfaceType	317	321	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.647890031337738	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifClassOrInterfaceType(Consumer<ClassOrInterfaceType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifclassorinterfacetype ( consumer < classorinterfacetype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifclassorinterfacetype ( consumer < classorinterfacetype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	272	276	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.7031294107437134	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ClassOrInterfaceTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.classOrInterfaceTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . classorinterfacetypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. classorinterfacetypemetamodel ; $newline$ $indentation$ }			
toClassOrInterfaceType	328	332	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.7129606604576111	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<ClassOrInterfaceType> toClassOrInterfaceType(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < classorinterfacetype > $whitespace$ toclassorinterfacetype ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < classorinterfacetype > $whitespace$ getclassorinterfacetype ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	118	122	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asClassOrInterfaceType	311	315	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.8295088410377502	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ClassOrInterfaceType asClassOrInterfaceType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetype $whitespace$ asclassorinterfacetype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetype $whitespace$ asclassorinterfacetype ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setName	158	170	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.8459184765815735	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public ClassOrInterfaceType setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetype $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ classorinterfacetype $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ this. name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isClassOrInterfaceType	305	309	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ClassOrInterfaceType.java	0.8872548341751099	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isClassOrInterfaceType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassorinterfacetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isclassorinterfacetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifIntersectionType	174	178	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.6792144775390625	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifIntersectionType(Consumer<IntersectionType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifintersectiontype ( consumer < intersectiontype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifintersectiontype ( consumer < intersectiontype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	141	145	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.7239760756492615	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public IntersectionTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.intersectionTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ intersectiontypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . intersectiontypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ intersectiontypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. intersectiontypemetamodel ; $newline$ $indentation$ }			
toIntersectionType	185	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.7385038137435913	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public Optional<IntersectionType> toIntersectionType(){
		    return Optional.of(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < intersectiontype > $whitespace$ tointersectiontype ( ) { $newline$ $indentation$ return $whitespace$ optional . of ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ optional < intersectiontype > $whitespace$ getplacedintersection ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( this ) ; $newline$ $indentation$ }			
accept	79	83	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asIntersectionType	168	172	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.8513869643211365	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public IntersectionType asIntersectionType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ intersectiontype $whitespace$ asintersectiontype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ intersectiontype $whitespace$ asintersectiontype ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isIntersectionType	162	166	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/IntersectionType.java	0.8998482823371887	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isIntersectionType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isintersectiontype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isintersectiontype ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifPrimitiveType	249	253	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.692321240901947	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifPrimitiveType(Consumer<PrimitiveType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifprimitivetype ( consumer < primitivetype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifprimitivetype ( consumer < primitivetype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
byTypeName	109	116	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.7086339592933655	MID	"		public static Optional<Primitive> byTypeName(String name){
		    for (Primitive primitive : values()) {
		        if (primitive.name().toLowerCase().equals(name)) {
		            return Optional.of(primitive);
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < primitive > $whitespace$ bytypename ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( primitive $whitespace$ primitive $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( primitive . name ( ) . tolowercase ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( primitive ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < primitive > $whitespace$ bytypename ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( primitive $whitespace$ primitive $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( primitive. name ( ). tolowercase ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( primitive ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
getMetaModel	231	235	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.7284247875213623	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public PrimitiveTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.primitiveTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . primitivetypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. primitivetypemetamodel ; $newline$ $indentation$ }			
setType	204	213	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.8679290413856506	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public PrimitiveType setType(final Primitive type){
		    assertNotNull(type);
		    if (type == this.type) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.TYPE, this.type, type);
		    this.type = type;
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetype $whitespace$ settype ( final $whitespace$ primitive $whitespace$ type ) { $newline$ $indentation$ assertnotnull ( type ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ this . type ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . type , $whitespace$ this . type , $whitespace$ type ) ; $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetype $whitespace$ settype ( final $whitespace$ primitive $whitespace$ type ) { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ primitivetype $whitespace$ settype ( final $whitespace$ primitive $whitespace$ type ) { $newline$ $indentation$ asserttrue ( type $whitespace$ == $whitespace$ this. type ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. type, $whitespace$ this. type, $whitespace$ type ) ; $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asPrimitiveType	243	247	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.8732365965843201	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public PrimitiveType asPrimitiveType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetype $whitespace$ asprimitivetype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ primitivetype $whitespace$ asprimitivetype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isPrimitiveType	237	241	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/PrimitiveType.java	0.9092122316360474	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isPrimitiveType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifReferenceType	84	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ReferenceType.java	0.690359890460968	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifReferenceType(Consumer<ReferenceType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifreferencetype ( consumer < referencetype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifreferencetype ( consumer < referencetype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	66	70	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ReferenceType.java	0.73023921251297	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public ReferenceTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.referenceTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ referencetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . referencetypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ referencetypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. referencetypemetamodel ; $newline$ $indentation$ }			
asReferenceType	78	82	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ReferenceType.java	0.8722156286239624	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public ReferenceType asReferenceType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ referencetype $whitespace$ asreferencetype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ objecttype $whitespace$ asreferencetype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isReferenceType	72	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/ReferenceType.java	0.9092122316360474	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isReferenceType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isreferencetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isreferencetype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
setAnnotations	83	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/Type.java	0.8304951190948486	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public Type setAnnotations(final NodeList<AnnotationExpr> annotations){
		    assertNotNull(annotations);
		    if (annotations == this.annotations) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.ANNOTATIONS, this.annotations, annotations);
		    if (this.annotations != null)
		        this.annotations.setParentNode(null);
		    this.annotations = annotations;
		    setAsParentNodeOf(annotations);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this . annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . annotations , $whitespace$ this . annotations , $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this . annotations $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . annotations . setparentnode ( null ) ; $newline$ $indentation$ this . annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ setannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ assertnotnull ( annotations ) ; $newline$ $indentation$ if $whitespace$ ( annotations $whitespace$ == $whitespace$ this. annotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. annotations, $whitespace$ this. annotations, $whitespace$ annotations ) ; $newline$ $indentation$ if $whitespace$ ( this. annotations $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. annotations. setparentnode ( null ) ; $newline$ $indentation$ this. annotations $whitespace$ = $whitespace$ annotations ; $newline$ $indentation$ setasparentnodeof ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
clone	134	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/Type.java	0.86275714635849	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public Type clone(){
		    return (Type) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( type ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ type $whitespace$ clone ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( type ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
asString	176	181	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.2554632723331451	LOW	"		@Override
		public String asString(){
		    StringBuilder str = new StringBuilder(getNameAsString());
		    getTypeBound().ifNonEmpty(l -> str.append(l.stream().map(ClassOrInterfaceType::asString).collect(joining(""&"", "" extends "", """"))));
		    return str.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ str $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( getnameasstring ( ) ) ; $newline$ $indentation$ gettypebound ( ) . ifnonempty ( l $whitespace$ - > $whitespace$ str . append ( l . stream ( ) . map ( classorinterfacetype : : asstring ) . collect ( joining ( $string$ , $whitespace$ $string$ , $whitespace$ $string$ ) ) ) ) ; $newline$ $indentation$ return $whitespace$ str . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ asstring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ str $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( getnameasstring ( ) ) ; $newline$ $indentation$ gettypebound ( ). ifnonempty ( l $whitespace$ - > $whitespace$ str. append ( l. stream ( ). map ( classorinterfacetype : : asstring ). collect ( joining ( $string$, $whitespace$ $string$, $whitespace$ $string$ ) ) ) ; $newline$ $indentation$ return $whitespace$ str. tostring ( ) ; $newline$ $indentation$ }			
setAnnotations	155	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.6108577847480774	MID	"		@Override
		public TypeParameter setAnnotations(NodeList<AnnotationExpr> annotations){
		    super.setAnnotations(annotations);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ setannotations ( nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ super . setannotations ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ setannotations ( nodelist < annotationexpr > $whitespace$ annotations ) { $newline$ $indentation$ super. setannotations ( annotations ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
ifTypeParameter	231	235	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.6883916854858398	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifTypeParameter(Consumer<TypeParameter> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ iftypeparameter ( consumer < typeparameter > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ if_parameter ( consumer < typeparameter > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
replace	200	217	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.7178299427032471	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.ReplaceMethodGenerator"")
		public boolean replace(Node node, Node replacementNode){
		    if (node == null) {
		        return false;
		    }
		    if (node == name) {
		        setName((SimpleName) replacementNode);
		        return true;
		    }
		    for (int i = 0; i < typeBound.size(); i++) {
		        if (typeBound.get(i) == node) {
		            typeBound.set(i, (ClassOrInterfaceType) replacementNode);
		            return true;
		        }
		    }
		    return super.replace(node, replacementNode);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node , $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ name ) $whitespace$ { $newline$ $indentation$ setname ( ( simplename ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typebound . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typebound . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ typebound . set ( i , $whitespace$ ( classorinterfacetype ) $whitespace$ replacementnode ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ super . replace ( node , $whitespace$ replacementnode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ false $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ name $whitespace$? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ replace ( node $whitespace$ node, $whitespace$ node $whitespace$ replacementnode ) $whitespace$ { $newline$ $indentation$ return $whitespace$ node $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ node $whitespace$ == $whitespace$ name. equals ( node ) ; $newline$ $indentation$ } $newline$ $indentation$			
getMetaModel	194	198	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.7338451147079468	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public TypeParameterMetaModel getMetaModel(){
		    return JavaParserMetaModel.typeParameterMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparametermetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . typeparametermetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparametermetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. typeparametermetamodel ; $newline$ $indentation$ }			
accept	94	98	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
setName	127	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.8436498641967773	HIGH	"		@Generated(""com.github.javaparser.generator.core.node.PropertyGenerator"")
		public TypeParameter setName(final SimpleName name){
		    assertNotNull(name);
		    if (name == this.name) {
		        return this;
		    }
		    notifyPropertyChange(ObservableProperty.NAME, this.name, name);
		    if (this.name != null)
		        this.name.setParentNode(null);
		    this.name = name;
		    setAsParentNodeOf(name);
		    return this;
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnotnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this . name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty . name , $whitespace$ this . name , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this . name $whitespace$ != $whitespace$ null ) $newline$ $indentation$ this . name . setparentnode ( null ) ; $newline$ $indentation$ this . name $whitespace$ = $whitespace$ name ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ setname ( final $whitespace$ simplename $whitespace$ name ) { $newline$ $indentation$ assertnull ( name ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ this. name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ notifypropertychange ( observableproperty. name, $whitespace$ this. name, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( this. name $whitespace$!= $whitespace$ null ) $newline$ $indentation$ this. name. setparentnode ( null ) ; $newline$ $indentation$ setasparentnodeof ( name ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
asTypeParameter	225	229	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.871187686920166	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public TypeParameter asTypeParameter(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ astypeparameter ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ typeparameter $whitespace$ astypeparameter ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isTypeParameter	219	223	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/TypeParameter.java	0.9107182621955872	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isTypeParameter(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ istypeparameter ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isanparameter ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
convertToUsage	202	208	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnionType.java	0.1462331861257553	LOW	"		@Override
		public ResolvedType convertToUsage(Context context){
		    List<ResolvedType> resolvedElements = getElements().stream().map(el -> el.convertToUsage(context)).collect(Collectors.toList());
		    return new ResolvedUnionType(resolvedElements);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ resolvedelements $whitespace$ = $whitespace$ getelements ( ) . stream ( ) . map ( el $whitespace$ - > $whitespace$ el . converttousage ( context ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolveduniontype ( resolvedelements ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ resolvedelements $whitespace$ = $whitespace$ getelements ( ). stream ( ) $newline$ $indentation$. map ( el $whitespace$ - > $whitespace$ el. converttousage ( context ) ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolveduniontype ( resolvedelements ) ; $newline$ $indentation$ }			
ifUnionType	185	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnionType.java	0.7154755592346191	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifUnionType(Consumer<UnionType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifuniontype ( consumer < uniontype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifuniontype ( consumer < uniontype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
asUnionType	179	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnionType.java	0.8939412832260132	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public UnionType asUnionType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ uniontype $whitespace$ asuniontype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ uniontype $whitespace$ asuniontype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isUnionType	173	177	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnionType.java	0.9232313632965088	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isUnionType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isuniontype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isuniontype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifUnknownType	114	118	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnknownType.java	0.7040520310401917	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifUnknownType(Consumer<UnknownType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifunknowntype ( consumer < unknowntype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifunknowntype ( consumer < isunknowntype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	96	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnknownType.java	0.7333943247795105	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public UnknownTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.unknownTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unknowntypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . unknowntypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unknowntypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. unknowntypemetamodel ; $newline$ $indentation$ }			
asUnknownType	108	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnknownType.java	0.8808639645576477	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public UnknownType asUnknownType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unknowntype $whitespace$ asunknowntype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ unknowntype $whitespace$ asunknowntype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isUnknownType	102	106	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/UnknownType.java	0.9155550003051758	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isUnknownType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunknowntype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isunknowntype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
convertToUsage	137	175	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.0226838495582342	LOW	"		@Override
		public ResolvedType convertToUsage(Context context){
		    Node parent = getParentNode().get();
		    if (!(parent instanceof VariableDeclarator)) {
		        throw new IllegalStateException(""Trying to resolve a `var` which is not in a variable declaration."");
		    }
		    final VariableDeclarator variableDeclarator = (VariableDeclarator) parent;
		    Optional<Expression> initializer = variableDeclarator.getInitializer();
		    if (!initializer.isPresent()) {
		        // When a `var` type decl has no initializer it may be part of a
		        // for-each statement (e.g. `for(var i : expr)`).
		        Optional<ForEachStmt> forEachStmt = forEachStmtWithVariableDeclarator(variableDeclarator);
		        if (forEachStmt.isPresent()) {
		            Expression iterable = forEachStmt.get().getIterable();
		            ResolvedType iterType = iterable.calculateResolvedType();
		            if (iterType instanceof ResolvedArrayType) {
		                // The type of a variable in a for-each loop with an array
		                // is the component type of the array.
		                return ((ResolvedArrayType) iterType).getComponentType();
		            }
		            if (iterType.isReferenceType()) {
		                // The type of a variable in a for-each loop with an
		                // Iterable with parameter type
		                List<ResolvedType> parametersType = iterType.asReferenceType().typeParametersMap().getTypes();
		                if (parametersType.isEmpty()) {
		                    Optional<ResolvedTypeDeclaration> oObjectDeclaration = context.solveType(JAVA_LANG_OBJECT).getDeclaration();
		                    return oObjectDeclaration.map(decl -> ReferenceTypeImpl.undeterminedParameters(decl.asReferenceType())).orElseThrow(() -> new UnsupportedOperationException());
		                }
		                return parametersType.get(0);
		            }
		        }
		    }
		    return initializer.map(Expression::calculateResolvedType).orElseThrow(() -> new IllegalStateException(""Cannot resolve `var` which has no initializer.""));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parent $whitespace$ instanceof $whitespace$ variabledeclarator ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ ( variabledeclarator ) $whitespace$ parent ; $newline$ $indentation$ optional < expression > $whitespace$ initializer $whitespace$ = $whitespace$ variabledeclarator . getinitializer ( ) ; $newline$ $indentation$ if $whitespace$ ( ! initializer . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·when·a·`var`·type·decl·has·no·initializer·it·may·be·part·of·a$ $newline$ $indentation$ $//·for-each·statement·(e.g.·`for(var·i·:·expr)`).$ $newline$ $indentation$ optional < foreachstmt > $whitespace$ foreachstmt $whitespace$ = $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator ) ; $newline$ $indentation$ if $whitespace$ ( foreachstmt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ iterable $whitespace$ = $whitespace$ foreachstmt . get ( ) . getiterable ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ itertype $whitespace$ = $whitespace$ iterable . calculateresolvedtype ( ) ; $newline$ $indentation$ if $whitespace$ ( itertype $whitespace$ instanceof $whitespace$ resolvedarraytype ) $whitespace$ { $newline$ $indentation$ $//·the·type·of·a·variable·in·a·for-each·loop·with·an·array$ $newline$ $indentation$ $//·is·the·component·type·of·the·array.$ $newline$ $indentation$ return $whitespace$ ( ( resolvedarraytype ) $whitespace$ itertype ) . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( itertype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ $//·the·type·of·a·variable·in·a·for-each·loop·with·an$ $newline$ $indentation$ $//·iterable·with·parameter·type$ $newline$ $indentation$ list < resolvedtype > $whitespace$ parameterstype $whitespace$ = $whitespace$ itertype . asreferencetype ( ) . typeparametersmap ( ) . gettypes ( ) ; $newline$ $indentation$ if $whitespace$ ( parameterstype . isempty ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedtypedeclaration > $whitespace$ oobjectdeclaration $whitespace$ = $whitespace$ context . solvetype ( java_lang_object ) . getdeclaration ( ) ; $newline$ $indentation$ return $whitespace$ oobjectdeclaration . map ( decl $whitespace$ - > $whitespace$ referencetypeimpl . undeterminedparameters ( decl . asreferencetype ( ) ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ parameterstype . get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ initializer . map ( expression : : calculateresolvedtype ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ converttousage ( context $whitespace$ context ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ getparentnode ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parent $whitespace$ instanceof $whitespace$ variabledeclarator ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ ( variabledeclarator ) $whitespace$ parent ; $newline$ $indentation$ final $whitespace$ optional < expression > $whitespace$ initializer $whitespace$ = $whitespace$ variabledeclarator. getinitializer ( ) ; $newline$ $indentation$ if $whitespace$ (! initializer. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ therep $whitespace$ = $whitespace$ getrepetition ( ) ; $newline$ $indentation$ ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < p > $whitespace$ cachedblue $whitespace$ = $whitespace$ $whitespace$ getrepetition ( ) ; $newline$ $indentation$ if $whitespace$ (! cachedblue. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ cachedblue. get ( ). getiterable ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ itertype $whitespace$ = $whitespace$ iterable. calculateresolvedtype ( ) ; $newline$ $indentation$ if $whitespace$ ( foreachstmt > $whitespace$ foreachstmt $whitespace$ = $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator ) ; $newline$ $indentation$ if $whitespace$ ( foreachstmt. ispresent ( ) ) $whitespace$ { $new			
forEachStmtWithVariableDeclarator	177	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.2712447941303253	LOW	"		private Optional<ForEachStmt> forEachStmtWithVariableDeclarator(VariableDeclarator variableDeclarator){
		    Optional<Node> node = variableDeclarator.getParentNode();
		    if (!node.isPresent() || !(node.get() instanceof VariableDeclarationExpr)) {
		        return Optional.empty();
		    }
		    node = node.get().getParentNode();
		    if (!node.isPresent() || !(node.get() instanceof ForEachStmt)) {
		        return Optional.empty();
		    }
		    return Optional.of((ForEachStmt) node.get());
		}"	$indentation$ private $whitespace$ optional < foreachstmt > $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ optional < node > $whitespace$ node $whitespace$ = $whitespace$ variabledeclarator . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! node . ispresent ( ) $whitespace$ || $whitespace$ ! ( node . get ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ = $whitespace$ node . get ( ) . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! node . ispresent ( ) $whitespace$ || $whitespace$ ! ( node . get ( ) $whitespace$ instanceof $whitespace$ foreachstmt ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( ( foreachstmt ) $whitespace$ node . get ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < foreachstmt > $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ optional < node > $whitespace$ node $whitespace$ = $whitespace$ variabledeclarator. getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! node. ispresent ( ) $whitespace$ || $whitespace$! ( node. get ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ = $whitespace$ node. get ( ). getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! node. ispresent ( ) $whitespace$ || $whitespace$! ( node. get ( ) $whitespace$ instanceof $whitespace$ foreachstmt ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( ( foreachstmt ) $whitespace$ node. get ( ) ) ; $newline$ $indentation$ }			
ifVarType	131	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.7324832081794739	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifVarType(Consumer<VarType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvartype ( consumer < vartype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvartype ( consumer < vartype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	101	105	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
clone	84	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.8295180201530457	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.CloneGenerator"")
		public VarType clone(){
		    return (VarType) accept(new CloneVisitor(), null);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ vartype $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( vartype ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ) , $whitespace$ null ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ vartype $whitespace$ clone ( ) { $newline$ $indentation$ return $whitespace$ ( vartype ) $whitespace$ accept ( new $whitespace$ clonevisitor ( ), $whitespace$ null ) ; $newline$ $indentation$ }			
asVarType	119	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.9051307439804076	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public VarType asVarType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ vartype $whitespace$ asvartype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ list < var > $whitespace$ asvartype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isVarType	113	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VarType.java	0.9284743070602416	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isVarType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvartype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvartype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifVoidType	115	119	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VoidType.java	0.7221471667289734	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifVoidType(Consumer<VoidType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvoidtype ( consumer < voidtype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifvoidtype ( consumer < voidtype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
accept	64	68	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VoidType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asVoidType	109	113	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VoidType.java	0.8982763886451721	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public VoidType asVoidType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ voidtype $whitespace$ asvoidtype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ asvoidtype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isVoidType	103	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/VoidType.java	0.925080955028534	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isVoidType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvoidtype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isvoidtype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
ifWildcardType	244	248	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java	0.7001922726631165	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public void ifWildcardType(Consumer<WildcardType> action){
		    action.accept(this);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ ifwildcardtype ( consumer < wildcardtype > $whitespace$ action ) { $newline$ $indentation$ action . accept ( this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ void $whitespace$ booleanwildcardtype ( consumer < wildcardtype > $whitespace$ action ) { $newline$ $indentation$ action. accept ( this ) ; $newline$ $indentation$ }			
getMetaModel	194	198	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java	0.7304824590682983	MID	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.GetMetaModelGenerator"")
		public WildcardTypeMetaModel getMetaModel(){
		    return JavaParserMetaModel.wildcardTypeMetaModel;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ wildcardtypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel . wildcardtypemetamodel ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ wildcardtypemetamodel $whitespace$ getmetamodel ( ) { $newline$ $indentation$ return $whitespace$ javaparsermetamodel. wildcardtypemetamodel ; $newline$ $indentation$ }			
accept	84	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java	0.8290517330169678	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.AcceptGenerator"")
		public R accept(final GenericVisitor<R, A> v, final A arg){
		    return v.visit(this, arg);
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r , $whitespace$ a > $whitespace$ v , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v . visit ( this , $whitespace$ arg ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ r $whitespace$ accept ( final $whitespace$ genericvisitor < r, $whitespace$ a > $whitespace$ v, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ return $whitespace$ v. visit ( this, $whitespace$ arg ) ; $newline$ $indentation$ }			
asWildcardType	238	242	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java	0.8730261325836182	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public WildcardType asWildcardType(){
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ wildcardtype $whitespace$ aswildcardtype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ wildcardtype $whitespace$ aswildcardtype ( ) { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isWildcardType	232	236	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/type/WildcardType.java	0.912484049797058	HIGH	"		@Override
		@Generated(""com.github.javaparser.generator.core.node.TypeCastingGenerator"")
		public boolean isWildcardType(){
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iswildcardtype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iswildcardtype ( ) { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
processor	41	50	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/TypedValidator.java	0.2041351646184921	LOW	"		@SuppressWarnings(""unchecked"")
		 Processor processor(){
		    return new Processor() {
		
		        @Override
		        public void postProcess(ParseResult<? extends Node> result, ParserConfiguration configuration) {
		            result.getResult().ifPresent(node -> accept((N) node, new ProblemReporter(problem -> result.getProblems().add(problem))));
		        }
		    };
		}"	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ processor $whitespace$ processor ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ processor ( ) $whitespace$ { $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ postprocess ( parseresult < ? $whitespace$ extends $whitespace$ node > $whitespace$ result , $whitespace$ parserconfiguration $whitespace$ configuration ) $whitespace$ { $newline$ $indentation$ result . getresult ( ) . ifpresent ( node $whitespace$ - > $whitespace$ accept ( ( n ) $whitespace$ node , $whitespace$ new $whitespace$ problemreporter ( problem $whitespace$ - > $whitespace$ result . getproblems ( ) . add ( problem ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ processor $whitespace$ processor ( ) { $newline$ $indentation$ return $whitespace$ ( upconfiguration $whitespace$ - > $whitespace$ { $newline$ $indentation$ result. getresult ( ). ifpresent ( node $whitespace$ - > $whitespace$ accept ( ( n ) $whitespace$ node, $whitespace$ new $whitespace$ problemreporter ( problem $whitespace$ - > $whitespace$ result. getproblems ( ). add ( problem ) ) ) ; $newline$ $indentation$ } ; $newline$ $indentation$ }			
toString	57	64	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/UpgradeJavaMessage.java	0.2455917745828628	LOW	"		@Override
		public String toString(){
		    return String.format(""%s Pay attention that this feature is supported starting from '%s' language level. If you need that feature the language level must be configured in the configuration before parsing the source files."", this.reason, this.level.toString());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ string . format ( $string$ , $whitespace$ this . reason , $whitespace$ this . level . tostring ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ string. format ( $string$, $whitespace$ this. reason, $whitespace$ this. level. tostring ( ) ) ; $newline$ $indentation$ }			
removeModifierFromArray	203	208	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/ModifierValidator.java	0.2460242062807083	LOW	"		private Modifier.Keyword[] removeModifierFromArray(Modifier.Keyword m, Modifier.Keyword[] allowedModifiers){
		    final List<Modifier.Keyword> newModifiers = new ArrayList<>(asList(allowedModifiers));
		    newModifiers.remove(m);
		    allowedModifiers = newModifiers.toArray(new Modifier.Keyword[0]);
		    return allowedModifiers;
		}"	$indentation$ private $whitespace$ modifier . keyword [ ] $whitespace$ removemodifierfromarray ( modifier . keyword $whitespace$ m , $whitespace$ modifier . keyword [ ] $whitespace$ allowedmodifiers ) { $newline$ $indentation$ final $whitespace$ list < modifier . keyword > $whitespace$ newmodifiers $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( aslist ( allowedmodifiers ) ) ; $newline$ $indentation$ newmodifiers . remove ( m ) ; $newline$ $indentation$ allowedmodifiers $whitespace$ = $whitespace$ newmodifiers . toarray ( new $whitespace$ modifier . keyword [ $number$ ] ) ; $newline$ $indentation$ return $whitespace$ allowedmodifiers ; $newline$ $indentation$ }	$indentation$ private $whitespace$ modifier. keyword [ ] $whitespace$ removemodifierfromarray ( modifier. keyword $whitespace$ m, $whitespace$ modifier. keyword [ ] $whitespace$ allowedmodifiers ) { $newline$ $indentation$ final $whitespace$ list < modifier. keyword > $whitespace$ newmodifiers $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( aslist ( allowedmodifiers ) ) ; $newline$ $indentation$ newmodifiers. remove ( m ) ; $newline$ $indentation$ allowedmodifiers $whitespace$ = $whitespace$ newmodifiers. toarray ( new $whitespace$ modifier. keyword [ $number$ ] ) ; $newline$ $indentation$ return $whitespace$ allowedmodifiers ; $newline$ $indentation$ }			
validateModifiers	188	201	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/ModifierValidator.java	0.2669687569141388	LOW	"		private void validateModifiers(T n, ProblemReporter reporter, Modifier.Keyword... allowedModifiers){
		    validateAtMostOneOf(n, reporter, PUBLIC, PROTECTED, PRIVATE);
		    validateAtMostOneOf(n, reporter, FINAL, ABSTRACT);
		    if (hasStrictfp) {
		        validateAtMostOneOf(n, reporter, NATIVE, STRICTFP);
		    } else {
		        allowedModifiers = removeModifierFromArray(STRICTFP, allowedModifiers);
		    }
		    for (Modifier m : n.getModifiers()) {
		        if (!arrayContains(allowedModifiers, m.getKeyword())) {
		            reporter.report(n, ""'%s' is not allowed here."", m.getKeyword().asString());
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ validatemodifiers ( t $whitespace$ n , $whitespace$ problemreporter $whitespace$ reporter , $whitespace$ modifier . keyword . . . $whitespace$ allowedmodifiers ) { $newline$ $indentation$ validateatmostoneof ( n , $whitespace$ reporter , $whitespace$ public , $whitespace$ protected , $whitespace$ private ) ; $newline$ $indentation$ validateatmostoneof ( n , $whitespace$ reporter , $whitespace$ final , $whitespace$ abstract ) ; $newline$ $indentation$ if $whitespace$ ( hasstrictfp ) $whitespace$ { $newline$ $indentation$ validateatmostoneof ( n , $whitespace$ reporter , $whitespace$ native , $whitespace$ strictfp ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ allowedmodifiers $whitespace$ = $whitespace$ removemodifierfromarray ( strictfp , $whitespace$ allowedmodifiers ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ m $whitespace$ : $whitespace$ n . getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! arraycontains ( allowedmodifiers , $whitespace$ m . getkeyword ( ) ) ) $whitespace$ { $newline$ $indentation$ reporter . report ( n , $whitespace$ $string$ , $whitespace$ m . getkeyword ( ) . asstring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ validatemodifiers ( t $whitespace$ n, $whitespace$ problemreporter $whitespace$ reporter, $whitespace$ modifier. keyword... $whitespace$ allowedmodifiers ) { $newline$ $indentation$ validateatmostoneof ( n, $whitespace$ reporter, $whitespace$ public, $whitespace$ protected, $whitespace$ private ) ; $newline$ $indentation$ validateatmostoneof ( n, $whitespace$ reporter, $whitespace$ final, $whitespace$ abstract ) ; $newline$ $indentation$ if $whitespace$ ( hasstrictfp ) $whitespace$ { $newline$ $indentation$ validateatmostoneof ( n, $whitespace$ reporter, $whitespace$ native, $whitespace$ strictfp ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( modifier $whitespace$ m $whitespace$ : $whitespace$ n. getmodifiers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! arraycontains ( allowedmodifiers, $whitespace$ m. getkeyword ( ) ) ) $whitespace$ { $newline$ $indentation$ reporter. report ( n, $whitespace$ $string$, $whitespace$ m. getkeyword ( ). asstring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
visit	64	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/ModifierValidator.java	0.6649349331855774	MID	"		@Override
		public void visit(ClassOrInterfaceDeclaration n, ProblemReporter reporter){
		    if (n.isInterface()) {
		        validateInterfaceModifiers(n, reporter);
		    } else {
		        validateClassModifiers(n, reporter);
		    }
		    super.visit(n, reporter);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( classorinterfacedeclaration $whitespace$ n , $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ if $whitespace$ ( n . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ validateinterfacemodifiers ( n , $whitespace$ reporter ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ validateclassmodifiers ( n , $whitespace$ reporter ) ; $newline$ $indentation$ } $newline$ $indentation$ super . visit ( n , $whitespace$ reporter ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( classorinterfacedeclaration $whitespace$ n, $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ if $whitespace$ ( n. isinterface ( ) ) $whitespace$ { $newline$ $indentation$ validateinterfacemodifiers ( n, $whitespace$ reporter ) ; $newline$ $indentation$ } $newline$ $indentation$ else $whitespace$ { $newline$ $indentation$ validateclassmodifiers ( n, $whitespace$ reporter ) ; $newline$ $indentation$ } $newline$ $indentation$ super. visit ( n, $whitespace$ reporter ) ; $newline$ $indentation$ }			
arrayContains	210	217	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/ModifierValidator.java	0.8645015954971313	HIGH	"		private boolean arrayContains(Object[] items, Object searchItem){
		    for (Object o : items) {
		        if (o == searchItem) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ arraycontains ( object [ ] $whitespace$ items , $whitespace$ object $whitespace$ searchitem ) { $newline$ $indentation$ for $whitespace$ ( object $whitespace$ o $whitespace$ : $whitespace$ items ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ searchitem ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ arraycontains ( object [ ] $whitespace$ items, $whitespace$ object $whitespace$ searchitem ) { $newline$ $indentation$ for $whitespace$ ( object $whitespace$ o $whitespace$ : $whitespace$ items ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
validate	43	47	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/NoBinaryIntegerLiteralsValidator.java	0.7214935421943665	MID	"		private static void validate(LiteralStringValueExpr n, ProblemReporter arg){
		    if (n.getValue().toUpperCase().startsWith(""0B"")) {
		        arg.report(n, ""Binary literal values are not supported."");
		    }
		}"	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ validate ( literalstringvalueexpr $whitespace$ n , $whitespace$ problemreporter $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( n . getvalue ( ) . touppercase ( ) . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ arg . report ( n , $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ validate ( literalstringvalueexpr $whitespace$ n, $whitespace$ problemreporter $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( n. getvalue ( ). touppercase ( ). startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ arg. report ( n, $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
validateRecordComponentAccessorMethods	77	85	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/RecordDeclarationValidator.java	0.0720408782362937	LOW	"		private void validateRecordComponentAccessorMethods(RecordDeclaration n, ProblemReporter reporter){
		    n.getParameters().forEach(parameter -> {
		        n.getMethodsByName(parameter.getNameAsString()).stream().filter(methodDeclaration -> methodDeclaration.getParameters().isEmpty()).forEach(methodDeclaration -> {
		            if (!methodDeclaration.getType().equals(parameter.getType())) {
		                reporter.report(n, String.format(""Incorrect component accessor return type. Expected: '%s', found: '%s'."", parameter.getTypeAsString(), methodDeclaration.getTypeAsString()));
		            }
		        });
		    });
		}"	$indentation$ private $whitespace$ void $whitespace$ validaterecordcomponentaccessormethods ( recorddeclaration $whitespace$ n , $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ n . getparameters ( ) . foreach ( parameter $whitespace$ - > $whitespace$ { $newline$ $indentation$ n . getmethodsbyname ( parameter . getnameasstring ( ) ) . stream ( ) . filter ( methoddeclaration $whitespace$ - > $whitespace$ methoddeclaration . getparameters ( ) . isempty ( ) ) . foreach ( methoddeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! methoddeclaration . gettype ( ) . equals ( parameter . gettype ( ) ) ) $whitespace$ { $newline$ $indentation$ reporter . report ( n , $whitespace$ string . format ( $string$ , $whitespace$ parameter . gettypeasstring ( ) , $whitespace$ methoddeclaration . gettypeasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ validaterecordcomponentaccessormethods ( recorddeclaration $whitespace$ n, $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ n. getparameters ( ). foreach ( parameter $whitespace$ - > $whitespace$ { $newline$ $indentation$ n. getmethodsbyname ( parameter. getnameasstring ( ) ). stream ( ) $newline$ $indentation$. filter ( methoddeclaration $whitespace$ - > $whitespace$ methoddeclaration. getparameters ( ). isempty ( ) $newline$ $indentation$. foreach ( methoddeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ (! methoddeclaration. gettype ( ). equals ( parameter. gettype ( ) ) ) $whitespace$ { $newline$ $indentation$ reporter. report ( n, $whitespace$ string. format ( $string$, $whitespace$ parameter. gettypeasstring ( ), $whitespace$ methoddeclaration. gettypeasstring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ }			
forbidAbstractModifier	37	41	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/language_level_validations/chunks/RecordDeclarationValidator.java	0.6225152015686035	MID	"		private void forbidAbstractModifier(RecordDeclaration n, ProblemReporter reporter){
		    if (n.getModifiers().contains(Modifier.abstractModifier())) {
		        reporter.report(n, ""Record Declarations must not be declared as abstract."");
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ forbidabstractmodifier ( recorddeclaration $whitespace$ n , $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ if $whitespace$ ( n . getmodifiers ( ) . contains ( modifier . abstractmodifier ( ) ) ) $whitespace$ { $newline$ $indentation$ reporter . report ( n , $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ forbidabstractmodifier ( recorddeclaration $whitespace$ n, $whitespace$ problemreporter $whitespace$ reporter ) { $newline$ $indentation$ if $whitespace$ ( n. getmodifiers ( ). contains ( modifier. abstractmodifier ( ) ) ) $whitespace$ { $newline$ $indentation$ adddelay ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
replace	54	58	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/validator/postprocessors/PostProcessors.java	0.6288999319076538	MID	"		public PostProcessors replace(Processor oldProcessor, Processor newProcessor){
		    remove(oldProcessor);
		    add(newProcessor);
		    return this;
		}"	$indentation$ public $whitespace$ postprocessors $whitespace$ replace ( processor $whitespace$ oldprocessor , $whitespace$ processor $whitespace$ newprocessor ) { $newline$ $indentation$ remove ( oldprocessor ) ; $newline$ $indentation$ add ( newprocessor ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ postprocessors $whitespace$ replace ( processor $whitespace$ oldprocessor, $whitespace$ processor $whitespace$ newprocessor ) { $newline$ $indentation$ remove ( oldprocessor ) ; $newline$ $indentation$ add ( newprocessor ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
visit	41	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/CloneVisitor.java	0.0730886459350586	LOW	"		@Override
		@Generated(""com.github.javaparser.generator.core.visitor.CloneVisitorGenerator"")
		public Visitable visit(final CompilationUnit n, final Object arg){
		    NodeList<ImportDeclaration> imports = cloneList(n.getImports(), arg);
		    ModuleDeclaration module = cloneNode(n.getModule(), arg);
		    PackageDeclaration packageDeclaration = cloneNode(n.getPackageDeclaration(), arg);
		    NodeList<TypeDeclaration<?>> types = cloneList(n.getTypes(), arg);
		    Comment comment = cloneNode(n.getComment(), arg);
		    CompilationUnit r = new CompilationUnit(n.getTokenRange().orElse(null), packageDeclaration, imports, types, module);
		    n.getStorage().ifPresent(s -> r.setStorage(s.getPath(), s.getEncoding()));
		    r.setComment(comment);
		    n.getOrphanComments().stream().map(Comment::clone).forEach(r::addOrphanComment);
		    copyData(n, r);
		    return r;
		}"	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ visitable $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n , $whitespace$ final $whitespace$ object $whitespace$ arg ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ imports $whitespace$ = $whitespace$ clonelist ( n . getimports ( ) , $whitespace$ arg ) ; $newline$ $indentation$ moduledeclaration $whitespace$ module $whitespace$ = $whitespace$ clonenode ( n . getmodule ( ) , $whitespace$ arg ) ; $newline$ $indentation$ packagedeclaration $whitespace$ packagedeclaration $whitespace$ = $whitespace$ clonenode ( n . getpackagedeclaration ( ) , $whitespace$ arg ) ; $newline$ $indentation$ nodelist < typedeclaration < ? >> $whitespace$ types $whitespace$ = $whitespace$ clonelist ( n . gettypes ( ) , $whitespace$ arg ) ; $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ clonenode ( n . getcomment ( ) , $whitespace$ arg ) ; $newline$ $indentation$ compilationunit $whitespace$ r $whitespace$ = $whitespace$ new $whitespace$ compilationunit ( n . gettokenrange ( ) . orelse ( null ) , $whitespace$ packagedeclaration , $whitespace$ imports , $whitespace$ types , $whitespace$ module ) ; $newline$ $indentation$ n . getstorage ( ) . ifpresent ( s $whitespace$ - > $whitespace$ r . setstorage ( s . getpath ( ) , $whitespace$ s . getencoding ( ) ) ) ; $newline$ $indentation$ r . setcomment ( comment ) ; $newline$ $indentation$ n . getorphancomments ( ) . stream ( ) . map ( comment : : clone ) . foreach ( r : : addorphancomment ) ; $newline$ $indentation$ copydata ( n , $whitespace$ r ) ; $newline$ $indentation$ return $whitespace$ r ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ generated ( $string$ ) $newline$ $indentation$ public $whitespace$ visitable $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n, $whitespace$ final $whitespace$ object $whitespace$ arg ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ imports $whitespace$ = $whitespace$ clonelist ( n. getimports ( ), $whitespace$ arg ) ; $newline$ $indentation$ moduledeclaration $whitespace$ module $whitespace$ = $whitespace$ clonenode ( n. getmodule ( ), $whitespace$ arg ) ; $newline$ $indentation$ packagedeclaration $whitespace$ packagedeclaration $whitespace$ = $whitespace$ clonenode ( n. getpackagedeclaration ( ), $whitespace$ arg ) ; $newline$ $indentation$ nodelist < typedeclaration <? >> $whitespace$ types $whitespace$ = $whitespace$ clonelist ( n. gettypes ( ), $whitespace$ arg ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ compilationunit ( n. gettokenrange ( ). orelse ( null ), $whitespace$ packagedeclaration, $whitespace$ imports, $whitespace$ types, $whitespace$ module ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ visitable $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n, $whitespace$ final $whitespace$ object $whitespace$ arg ) { $newline$ $indentation$ final $whitespace$ string $whitespace$ value $whitespace$ = $whitespace$ clonenode ( n. getcomment ( ), $whitespace$ s. getencoding ( ) ) ; $newline$ $indentation$ final $whitespace$ list < comment > $whitespace$ comments $whitespace$ = $whitespace$ clonelist ( n. gettypes ( ), $whitespace$ s. getencoding ( ) ) ; $newline$ $indentation$ final $whitespace$			
copyData	1217	1221	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/CloneVisitor.java	0.7168551683425903	MID	"		private void copyData(Node source, Node destination){
		    for (DataKey dataKey : source.getDataKeys()) {
		        destination.setData(dataKey, source.getData(dataKey));
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ copydata ( node $whitespace$ source , $whitespace$ node $whitespace$ destination ) { $newline$ $indentation$ for $whitespace$ ( datakey $whitespace$ datakey $whitespace$ : $whitespace$ source . getdatakeys ( ) ) $whitespace$ { $newline$ $indentation$ destination . setdata ( datakey , $whitespace$ source . getdata ( datakey ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ copydata ( node $whitespace$ source, $whitespace$ node $whitespace$ destination ) { $newline$ $indentation$ for $whitespace$ ( datakey $whitespace$ datakey $whitespace$ : $whitespace$ source. getdatakeys ( ) ) $whitespace$ { $newline$ $indentation$ destination. setdata ( datakey, $whitespace$ source. getdata ( datakey ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
commonNodeEquality	57	62	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/EqualsVisitor.java	0.6433219909667969	MID	"		private boolean commonNodeEquality(Node n, Node n2){
		    if (!nodeEquals(n.getComment(), n2.getComment())) {
		        return false;
		    }
		    return nodesEquals(n.getOrphanComments(), n2.getOrphanComments());
		}"	$indentation$ private $whitespace$ boolean $whitespace$ commonnodeequality ( node $whitespace$ n , $whitespace$ node $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( ! nodeequals ( n . getcomment ( ) , $whitespace$ n2 . getcomment ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nodesequals ( n . getorphancomments ( ) , $whitespace$ n2 . getorphancomments ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ commonnodeequality ( node $whitespace$ n, $whitespace$ node $whitespace$ n2 ) { $newline$ $indentation$ return $whitespace$! nodeequals ( n. getcomment ( ), $whitespace$ n2. getcomment ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isimported ( node $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$! nodesequals ( n. getorphancomments ( ), $whitespace$ n2. getorphancomments ( ) ) ; $newline$ $indentation$ }			
nodesEquals	64	80	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/EqualsVisitor.java	0.6779707074165344	MID	"		private boolean nodesEquals(final List<T> nodes1, final List<T> nodes2){
		    if (nodes1 == null) {
		        return nodes2 == null;
		    }
		    if (nodes2 == null) {
		        return false;
		    }
		    if (nodes1.size() != nodes2.size()) {
		        return false;
		    }
		    for (int i = 0; i < nodes1.size(); i++) {
		        if (!nodeEquals(nodes1.get(i), nodes2.get(i))) {
		            return false;
		        }
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ nodesequals ( final $whitespace$ list < t > $whitespace$ nodes1 , $whitespace$ final $whitespace$ list < t > $whitespace$ nodes2 ) { $newline$ $indentation$ if $whitespace$ ( nodes1 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nodes2 $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodes2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodes1 . size ( ) $whitespace$ != $whitespace$ nodes2 . size ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodes1 . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! nodeequals ( nodes1 . get ( i ) , $whitespace$ nodes2 . get ( i ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ nodesequals ( final $whitespace$ list < t > $whitespace$ nodes1, $whitespace$ final $whitespace$ list < t > $whitespace$ nodes2 ) { $newline$ $indentation$ if $whitespace$ ( nodes1 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nodes2 $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodes2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodes1. size ( ) $whitespace$!= $whitespace$ nodes2. size ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodes1. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! nodeequals ( nodes1. get ( i ), $whitespace$ nodes2. get ( i ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
nodeEquals	100	114	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/EqualsVisitor.java	0.8590565323829651	HIGH	"		private boolean nodeEquals(final T n, final T n2){
		    if (n == n2) {
		        return true;
		    }
		    if (n == null || n2 == null) {
		        return false;
		    }
		    if (n.getClass() != n2.getClass()) {
		        return false;
		    }
		    if (!commonNodeEquality(n, n2)) {
		        return false;
		    }
		    return n.accept(this, n2);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ nodeequals ( final $whitespace$ t $whitespace$ n , $whitespace$ final $whitespace$ t $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getclass ( ) $whitespace$ != $whitespace$ n2 . getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! commonnodeequality ( n , $whitespace$ n2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n . accept ( this , $whitespace$ n2 ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ nodeequals ( final $whitespace$ t $whitespace$ n, $whitespace$ final $whitespace$ t $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n. getclass ( ) $whitespace$!= $whitespace$ n2. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! commonnodeequality ( n, $whitespace$ n2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n. accept ( this, $whitespace$ n2 ) ; $newline$ $indentation$ }			
objEquals	124	132	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/EqualsVisitor.java	0.90683776140213	HIGH	"		private boolean objEquals(final Object n, final Object n2){
		    if (n == n2) {
		        return true;
		    }
		    if (n == null || n2 == null) {
		        return false;
		    }
		    return n.equals(n2);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ objequals ( final $whitespace$ object $whitespace$ n , $whitespace$ final $whitespace$ object $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n . equals ( n2 ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ objequals ( final $whitespace$ object $whitespace$ n, $whitespace$ final $whitespace$ object $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n. equals ( n2 ) ; $newline$ $indentation$ }			
visit	42	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/GenericVisitorAdapter.java	0.734044075012207	MID	"		@Override
		public R visit(final AnnotationDeclaration n, final A arg){
		    R result;
		    {
		        result = n.getMembers().accept(this, arg);
		        if (result != null)
		            return result;
		    }
		    {
		        result = n.getModifiers().accept(this, arg);
		        if (result != null)
		            return result;
		    }
		    {
		        result = n.getName().accept(this, arg);
		        if (result != null)
		            return result;
		    }
		    {
		        result = n.getAnnotations().accept(this, arg);
		        if (result != null)
		            return result;
		    }
		    if (n.getComment().isPresent()) {
		        result = n.getComment().get().accept(this, arg);
		        if (result != null)
		            return result;
		    }
		    return null;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ r $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ n , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ r $whitespace$ result ; $newline$ $indentation$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n . getmembers ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n . getmodifiers ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n . getname ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n . getannotations ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getcomment ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n . getcomment ( ) . get ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ r $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ n, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ r $whitespace$ result $whitespace$ = $whitespace$ n. getmembers ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$!= $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ else $newline$ $indentation$ return $whitespace$ n. getmodifiers ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ r $whitespace$ = $whitespace$ n. getname ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( result $whitespace$!= $whitespace$ null ) $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ else $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n. getcomment ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ n. getcomment			
visit	55	70	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/ModifierVisitor.java	0.1946746557950973	LOW	"		@Override
		public Visitable visit(final AnnotationDeclaration n, final A arg){
		    NodeList<AnnotationExpr> annotations = modifyList(n.getAnnotations(), arg);
		    NodeList<Modifier> modifiers = modifyList(n.getModifiers(), arg);
		    NodeList<BodyDeclaration<?>> members = modifyList(n.getMembers(), arg);
		    SimpleName name = (SimpleName) n.getName().accept(this, arg);
		    Comment comment = n.getComment().map(s -> (Comment) s.accept(this, arg)).orElse(null);
		    if (name == null)
		        return null;
		    n.setAnnotations(annotations);
		    n.setModifiers(modifiers);
		    n.setMembers(members);
		    n.setName(name);
		    n.setComment(comment);
		    return n;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ visitable $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ n , $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ nodelist < annotationexpr > $whitespace$ annotations $whitespace$ = $whitespace$ modifylist ( n . getannotations ( ) , $whitespace$ arg ) ; $newline$ $indentation$ nodelist < modifier > $whitespace$ modifiers $whitespace$ = $whitespace$ modifylist ( n . getmodifiers ( ) , $whitespace$ arg ) ; $newline$ $indentation$ nodelist < bodydeclaration < ? >> $whitespace$ members $whitespace$ = $whitespace$ modifylist ( n . getmembers ( ) , $whitespace$ arg ) ; $newline$ $indentation$ simplename $whitespace$ name $whitespace$ = $whitespace$ ( simplename ) $whitespace$ n . getname ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ n . getcomment ( ) . map ( s $whitespace$ - > $whitespace$ ( comment ) $whitespace$ s . accept ( this , $whitespace$ arg ) ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ n . setannotations ( annotations ) ; $newline$ $indentation$ n . setmodifiers ( modifiers ) ; $newline$ $indentation$ n . setmembers ( members ) ; $newline$ $indentation$ n . setname ( name ) ; $newline$ $indentation$ n . setcomment ( comment ) ; $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ visitable $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ n, $whitespace$ final $whitespace$ a $whitespace$ arg ) { $newline$ $indentation$ nodelist < annotationexpr > $whitespace$ annotations $whitespace$ = $whitespace$ modifylist ( n. getannotations ( ), $whitespace$ arg ) ; $newline$ $indentation$ nodelist < modifier > $whitespace$ modifiers $whitespace$ = $whitespace$ modifylist ( n. getmodifiers ( ), $whitespace$ arg ) ; $newline$ $indentation$ nodelist < bodydeclaration <? >> $whitespace$ members $whitespace$ = $whitespace$ modifylist ( n. getmembers ( ), $whitespace$ arg ) ; $newline$ $indentation$ simplename $whitespace$ name $whitespace$ = $whitespace$ ( simplename ) $whitespace$ n. getname ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ n. getcomment ( ). map ( s $whitespace$ - > $whitespace$ ( comment ) $whitespace$ s. accept ( this, $whitespace$ arg ) ). orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( name $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ n. setannotations ( annotations ) ; $newline$ $indentation$ n. setmodifiers ( modifiers ) ; $newline$ $indentation$ n. setname ( name ) ; $newline$ $indentation$ n. setcomment ( comment ) ; $newline$ $indentation$ return $whitespace$ n ; $newline$ $indentation$ }			
nodesEquals	43	59	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitor.java	0.6868765354156494	MID	"		private boolean nodesEquals(NodeList<N> n, NodeList<N> n2){
		    if (n == n2) {
		        return true;
		    }
		    if (n == null || n2 == null) {
		        return false;
		    }
		    if (n.size() != n2.size()) {
		        return false;
		    }
		    for (int i = 0; i < n.size(); i++) {
		        if (!nodeEquals(n.get(i), n2.get(i))) {
		            return false;
		        }
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ nodesequals ( nodelist < n > $whitespace$ n , $whitespace$ nodelist < n > $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . size ( ) $whitespace$ != $whitespace$ n2 . size ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ n . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! nodeequals ( n . get ( i ) , $whitespace$ n2 . get ( i ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ nodesequals ( nodelist < n > $whitespace$ n, $whitespace$ nodelist < n > $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ n. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! nodeequals ( n. get ( i ), $whitespace$ n2. get ( i ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
nodeEquals	61	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitor.java	0.8940281271934509	HIGH	"		private boolean nodeEquals(final T n, final T n2){
		    if (n == n2) {
		        return true;
		    }
		    if (n == null || n2 == null) {
		        return false;
		    }
		    if (n.getClass() != n2.getClass()) {
		        return false;
		    }
		    return n.accept(this, n2);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ nodeequals ( final $whitespace$ t $whitespace$ n , $whitespace$ final $whitespace$ t $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getclass ( ) $whitespace$ != $whitespace$ n2 . getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n . accept ( this , $whitespace$ n2 ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ nodeequals ( final $whitespace$ t $whitespace$ n, $whitespace$ final $whitespace$ t $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n. getclass ( ) $whitespace$!= $whitespace$ n2. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n. accept ( this, $whitespace$ n2 ) ; $newline$ $indentation$ }			
objEquals	82	90	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NoCommentEqualsVisitor.java	0.90683776140213	HIGH	"		private boolean objEquals(final Object n, final Object n2){
		    if (n == n2) {
		        return true;
		    }
		    if (n == null || n2 == null) {
		        return false;
		    }
		    return n.equals(n2);
		}"	$indentation$ private $whitespace$ boolean $whitespace$ objequals ( final $whitespace$ object $whitespace$ n , $whitespace$ final $whitespace$ object $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n . equals ( n2 ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ objequals ( final $whitespace$ object $whitespace$ n, $whitespace$ final $whitespace$ object $whitespace$ n2 ) { $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ n2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ n2 $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ n. equals ( n2 ) ; $newline$ $indentation$ }			
visit	161	193	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/NodeFinderVisitor.java	0.6849066615104675	MID	"		@Override
		public void visit(final AnnotationDeclaration n, final Range arg){
		    {
		        n.getMembers().accept(this, arg);
		        if (selectedNode != null)
		            return;
		    }
		    {
		        n.getModifiers().accept(this, arg);
		        if (selectedNode != null)
		            return;
		    }
		    {
		        n.getName().accept(this, arg);
		        if (selectedNode != null)
		            return;
		    }
		    {
		        n.getAnnotations().accept(this, arg);
		        if (selectedNode != null)
		            return;
		    }
		    if (n.getComment().isPresent()) {
		        n.getComment().get().accept(this, arg);
		        if (selectedNode != null)
		            return;
		    }
		    if (fn.apply(n, arg)) {
		        selectedNode = n;
		    }
		    return;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ n , $whitespace$ final $whitespace$ range $whitespace$ arg ) { $newline$ $indentation$ { $newline$ $indentation$ n . getmembers ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ n . getmodifiers ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ n . getname ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ n . getannotations ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getcomment ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n . getcomment ( ) . get ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( fn . apply ( n , $whitespace$ arg ) ) $whitespace$ { $newline$ $indentation$ selectednode $whitespace$ = $whitespace$ n ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ annotationdeclaration $whitespace$ arg, $whitespace$ final $whitespace$ range $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( isnode ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ else $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ { $newline$ $indentation$ if $whitespace$ ( isnode ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ else $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isnode ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ if $whitespace$ ( selectednode $whitespace$!= $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ else $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( fn. apply			
visitBreadthFirst	72	82	javaparser/javaparser-core/src/main/java/com/github/javaparser/ast/visitor/TreeVisitor.java	0.6184343099594116	MID	"		public void visitBreadthFirst(Node node){
		    final Queue<Node> queue = new LinkedList<>();
		    queue.offer(node);
		    while (queue.size() > 0) {
		        final Node head = queue.peek();
		        for (Node child : head.getChildNodes()) {
		            queue.offer(child);
		        }
		        process(queue.poll());
		    }
		}"	$indentation$ public $whitespace$ void $whitespace$ visitbreadthfirst ( node $whitespace$ node ) { $newline$ $indentation$ final $whitespace$ queue < node > $whitespace$ queue $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ queue . offer ( node ) ; $newline$ $indentation$ while $whitespace$ ( queue . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ node $whitespace$ head $whitespace$ = $whitespace$ queue . peek ( ) ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ child $whitespace$ : $whitespace$ head . getchildnodes ( ) ) $whitespace$ { $newline$ $indentation$ queue . offer ( child ) ; $newline$ $indentation$ } $newline$ $indentation$ process ( queue . poll ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ visitbreadthfirst ( node $whitespace$ node ) { $newline$ $indentation$ final $whitespace$ queue < node > $whitespace$ queue $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ queue. offer ( node ) ; $newline$ $indentation$ while $whitespace$ ( queue. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ node $whitespace$ head $whitespace$ = $whitespace$ queue. peek ( ) ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ child $whitespace$ : $whitespace$ head. getchildnodes ( ) ) $whitespace$ { $newline$ $indentation$ queue. offer ( child ) ; $newline$ $indentation$ } $newline$ $indentation$ process ( queue ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
toComment	108	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/Javadoc.java	0.2525136172771454	LOW	"		public JavadocComment toComment(String indentation){
		    for (char c : indentation.toCharArray()) {
		        if (!Character.isWhitespace(c)) {
		            throw new IllegalArgumentException(""The indentation string should be composed only by whitespace characters"");
		        }
		    }
		    StringBuilder sb = new StringBuilder();
		    sb.append(SYSTEM_EOL);
		    final String text = toText();
		    if (!text.isEmpty()) {
		        for (String line : text.split(SYSTEM_EOL)) {
		            sb.append(indentation);
		            sb.append("" * "");
		            sb.append(line);
		            sb.append(SYSTEM_EOL);
		        }
		    }
		    sb.append(indentation);
		    sb.append("" "");
		    return new JavadocComment(sb.toString());
		}"	$indentation$ public $whitespace$ javadoccomment $whitespace$ tocomment ( string $whitespace$ indentation ) { $newline$ $indentation$ for $whitespace$ ( char $whitespace$ c $whitespace$ : $whitespace$ indentation . tochararray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! character . iswhitespace ( c ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ sb . append ( system_eol ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ text $whitespace$ = $whitespace$ totext ( ) ; $newline$ $indentation$ if $whitespace$ ( ! text . isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( string $whitespace$ line $whitespace$ : $whitespace$ text . split ( system_eol ) ) $whitespace$ { $newline$ $indentation$ sb . append ( indentation ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ sb . append ( line ) ; $newline$ $indentation$ sb . append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ sb . append ( indentation ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javadoccomment ( sb . tostring ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ javadoccomment $whitespace$ tocomment ( string $whitespace$ indentation ) { $newline$ $indentation$ for $whitespace$ ( char $whitespace$ c $whitespace$ : $whitespace$ indentation. tochararray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! character. iswhitespace ( c ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ text $whitespace$ = $whitespace$ totext ( ) ; $newline$ $indentation$ if $whitespace$ (! text. isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( string $whitespace$ line $whitespace$ : $whitespace$ text. split ( system_eol ) ) $whitespace$ { $newline$ $indentation$ sb. append ( indentation ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ sb. append ( line ) ; $newline$ $indentation$ sb. append ( system_eol ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ sb. append ( indentation ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javadoccomment ( sb. tostring ( ) ) ; $newline$ $indentation$ }			
equals	137	149	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/JavadocBlockTag.java	0.6319084763526917	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavadocBlockTag that = (JavadocBlockTag) o;
		    if (type != that.type)
		        return false;
		    if (!content.equals(that.content))
		        return false;
		    return name.equals(that.name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javadocblocktag $whitespace$ that $whitespace$ = $whitespace$ ( javadocblocktag ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ != $whitespace$ that . type ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! content . equals ( that . content ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ name . equals ( that . name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ other ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! content. equals ( that. content ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ name. equals ( that. name ) ; $newline$ $indentation$ }			
fromName	72	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/JavadocBlockTag.java	0.8873066902160645	HIGH	"		 static Type fromName(String tagName){
		    for (Type t : Type.values()) {
		        if (t.keyword.equals(tagName)) {
		            return t;
		        }
		    }
		    return UNKNOWN;
		}"	$indentation$ static $whitespace$ type $whitespace$ fromname ( string $whitespace$ tagname ) { $newline$ $indentation$ for $whitespace$ ( type $whitespace$ t $whitespace$ : $whitespace$ type . values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( t . keyword . equals ( tagname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ t ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ unknown ; $newline$ $indentation$ }	$indentation$ static $whitespace$ type $whitespace$ fromname ( string $whitespace$ tagname ) { $newline$ $indentation$ for $whitespace$ ( type $whitespace$ t $whitespace$ : $whitespace$ type. values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( t. keyword. equals ( tagname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ t ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ unknown ; $newline$ $indentation$ }			
parseText	37	52	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescription.java	0.1884316504001617	LOW	"		public static JavadocDescription parseText(String text){
		    JavadocDescription instance = new JavadocDescription();
		    int index = 0;
		    Pair<Integer, Integer> nextInlineTagPos;
		    while ((nextInlineTagPos = indexOfNextInlineTag(text, index)) != null) {
		        if (nextInlineTagPos.a != index) {
		            instance.addElement(new JavadocSnippet(text.substring(index, nextInlineTagPos.a)));
		        }
		        instance.addElement(JavadocInlineTag.fromText(text.substring(nextInlineTagPos.a, nextInlineTagPos.b + 1)));
		        index = nextInlineTagPos.b + 1;
		    }
		    if (index < text.length()) {
		        instance.addElement(new JavadocSnippet(text.substring(index)));
		    }
		    return instance;
		}"	$indentation$ public $whitespace$ static $whitespace$ javadocdescription $whitespace$ parsetext ( string $whitespace$ text ) { $newline$ $indentation$ javadocdescription $whitespace$ instance $whitespace$ = $whitespace$ new $whitespace$ javadocdescription ( ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ pair < integer , $whitespace$ integer > $whitespace$ nextinlinetagpos ; $newline$ $indentation$ while $whitespace$ ( ( nextinlinetagpos $whitespace$ = $whitespace$ indexofnextinlinetag ( text , $whitespace$ index ) ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nextinlinetagpos . a $whitespace$ != $whitespace$ index ) $whitespace$ { $newline$ $indentation$ instance . addelement ( new $whitespace$ javadocsnippet ( text . substring ( index , $whitespace$ nextinlinetagpos . a ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ instance . addelement ( javadocinlinetag . fromtext ( text . substring ( nextinlinetagpos . a , $whitespace$ nextinlinetagpos . b $whitespace$ + $whitespace$ $number$ ) ) ) ; $newline$ $indentation$ index $whitespace$ = $whitespace$ nextinlinetagpos . b $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ text . length ( ) ) $whitespace$ { $newline$ $indentation$ instance . addelement ( new $whitespace$ javadocsnippet ( text . substring ( index ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ instance ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ javadocdescription $whitespace$ parsetext ( string $whitespace$ text ) { $newline$ $indentation$ javadocdescription $whitespace$ instance $whitespace$ = $whitespace$ new $whitespace$ javadocdescription ( ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ pair < integer, $whitespace$ integer > $whitespace$ nextinlinetagpos ; $newline$ $indentation$ while $whitespace$ ( ( nextinlinetagpos $whitespace$ = $whitespace$ indexofnextinlinetag ( text, $whitespace$ index ) ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nextinlinetagpos. a $whitespace$!= $whitespace$ index ) $whitespace$ { $newline$ $indentation$ instance. addelement ( new $whitespace$ javadocsnippet ( text. substring ( index, $whitespace$ nextinlinetagpos. a ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ instance. addelement ( javadocinlinetag. fromtext ( text. substring ( nextinlinetagpos. a, $whitespace$ nextinlinetagpos. b $whitespace$ + $whitespace$ $number$ ) ) ) ; $newline$ $indentation$ index $whitespace$ = $whitespace$ nextinlinetagpos. b $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ text. length ( ) ) $whitespace$ { $newline$ $indentation$ instance. addelement ( new $whitespace$ javadocsnippet ( text. substring ( index ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ instance ; $newline$ $indentation$ }			
toText	84	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescription.java	0.6776805520057678	MID	"		public String toText(){
		    StringBuilder sb = new StringBuilder();
		    elements.forEach(e -> sb.append(e.toText()));
		    return sb.toString();
		}"	$indentation$ public $whitespace$ string $whitespace$ totext ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ elements . foreach ( e $whitespace$ - > $whitespace$ sb . append ( e . totext ( ) ) ) ; $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ string $whitespace$ totext ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ elements. foreach ( e $whitespace$ - > $whitespace$ sb. append ( e. totext ( ) ) ) ; $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
indexOfNextInlineTag	54	65	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescription.java	0.6889532208442688	MID	"		private static Pair<Integer, Integer> indexOfNextInlineTag(String text, int start){
		    int index = text.indexOf(""{@"", start);
		    if (index == -1) {
		        return null;
		    }
		    // we are interested only in complete inline tags
		    int closeIndex = text.indexOf(""}"", index);
		    if (closeIndex == -1) {
		        return null;
		    }
		    return new Pair<>(index, closeIndex);
		}"	$indentation$ private $whitespace$ static $whitespace$ pair < integer , $whitespace$ integer > $whitespace$ indexofnextinlinetag ( string $whitespace$ text , $whitespace$ int $whitespace$ start ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ text . indexof ( $string$ , $whitespace$ start ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ $//·we·are·interested·only·in·complete·inline·tags$ $newline$ $indentation$ int $whitespace$ closeindex $whitespace$ = $whitespace$ text . indexof ( $string$ , $whitespace$ index ) ; $newline$ $indentation$ if $whitespace$ ( closeindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( index , $whitespace$ closeindex ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ pair < integer, $whitespace$ integer > $whitespace$ indexofnextinlinetag ( string $whitespace$ text, $whitespace$ int $whitespace$ start ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ text. indexof ( $string$, $whitespace$ start ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////we $newline$ $indentation$ // $whitespace$ the $whitespace$ current $whitespace$ state $whitespace$ of $whitespace$ the $whitespace$ fragment $newline$ $indentation$ // $whitespace$ that $whitespace$ would $whitespace$ enlarge $whitespace$ journal $whitespace$ of $whitespace$ several $whitespace$ bytes $newline$ $indentation$ int $whitespace$ closeindex $whitespace$ = $whitespace$ text. indexof ( $string$, $whitespace$ index ) ; $newline$ $indentation$ if $whitespace$ ( closeindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( index, $whitespace$ closeindex ) ; $newline$ $indentation$ }			
equals	94	102	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocDescription.java	0.7075790762901306	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavadocDescription that = (JavadocDescription) o;
		    return elements.equals(that.elements);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javadocdescription $whitespace$ that $whitespace$ = $whitespace$ ( javadocdescription ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ elements . equals ( that . elements ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ other ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ other. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javadocdescription $whitespace$ that $whitespace$ = $whitespace$ ( javadocdescription ) $whitespace$ other ; $newline$ $indentation$ return $whitespace$ elements. equals ( that. elements ) ; $newline$ $indentation$ }			
equals	108	120	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocInlineTag.java	0.2695067524909973	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavadocInlineTag that = (JavadocInlineTag) o;
		    if (tagName != null ? !tagName.equals(that.tagName) : that.tagName != null)
		        return false;
		    if (type != that.type)
		        return false;
		    return content != null ? content.equals(that.content) : that.content == null;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javadocinlinetag $whitespace$ that $whitespace$ = $whitespace$ ( javadocinlinetag ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( tagname $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ ! tagname . equals ( that . tagname ) $whitespace$ : $whitespace$ that . tagname $whitespace$ != $whitespace$ null ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ != $whitespace$ that . type ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ content $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ content . equals ( that . content ) $whitespace$ : $whitespace$ that . content $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ other ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! tagname $whitespace$!= $whitespace$ null $whitespace$? $whitespace$! tagname. equals ( that. tagname ) $whitespace$ : $whitespace$ that. tagname $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ content $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ content. equals ( that. content ) $whitespace$ : $whitespace$ that. content $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }			
fromName	69	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocInlineTag.java	0.7347934246063232	MID	"		 static JavadocInlineTag.Type fromName(String tagName){
		    for (JavadocInlineTag.Type t : JavadocInlineTag.Type.values()) {
		        if (t.keyword.equals(tagName)) {
		            return t;
		        }
		    }
		    return UNKNOWN;
		}"	$indentation$ static $whitespace$ javadocinlinetag . type $whitespace$ fromname ( string $whitespace$ tagname ) { $newline$ $indentation$ for $whitespace$ ( javadocinlinetag . type $whitespace$ t $whitespace$ : $whitespace$ javadocinlinetag . type . values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( t . keyword . equals ( tagname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ t ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ unknown ; $newline$ $indentation$ }	$indentation$ static $whitespace$ javadocinlinetag. type $whitespace$ fromname ( string $whitespace$ tagname ) { $newline$ $indentation$ javadocinlinetag. type. values ( ). stream ( ) $newline$ $indentation$. filter ( t $whitespace$ - > $whitespace$ t. keyword. equals ( tagname ) ) $newline$ $indentation$. findfirst ( ) $newline$ $indentation$. orelse ( null ) ; $newline$ $indentation$ return $whitespace$ unknown ; $newline$ $indentation$ }			
equals	45	53	javaparser/javaparser-core/src/main/java/com/github/javaparser/javadoc/description/JavadocSnippet.java	0.7314582467079163	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavadocSnippet that = (JavadocSnippet) o;
		    return text.equals(that.text);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javadocsnippet $whitespace$ that $whitespace$ = $whitespace$ ( javadocsnippet ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ text . equals ( that . text ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javadocsnippet $whitespace$ that $whitespace$ = $whitespace$ ( javadocsnippet ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ text. equals ( that. text ) ; $newline$ $indentation$ }			
getAllPropertyMetaModels	114	122	javaparser/javaparser-core/src/main/java/com/github/javaparser/metamodel/BaseNodeMetaModel.java	0.199982687830925	LOW	"		public List<PropertyMetaModel> getAllPropertyMetaModels(){
		    List<PropertyMetaModel> allPropertyMetaModels = new ArrayList<>(getDeclaredPropertyMetaModels());
		    BaseNodeMetaModel walkNode = this;
		    while (walkNode.getSuperNodeMetaModel().isPresent()) {
		        walkNode = walkNode.getSuperNodeMetaModel().get();
		        allPropertyMetaModels.addAll(walkNode.getDeclaredPropertyMetaModels());
		    }
		    return allPropertyMetaModels;
		}"	$indentation$ public $whitespace$ list < propertymetamodel > $whitespace$ getallpropertymetamodels ( ) { $newline$ $indentation$ list < propertymetamodel > $whitespace$ allpropertymetamodels $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( getdeclaredpropertymetamodels ( ) ) ; $newline$ $indentation$ basenodemetamodel $whitespace$ walknode $whitespace$ = $whitespace$ this ; $newline$ $indentation$ while $whitespace$ ( walknode . getsupernodemetamodel ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ walknode $whitespace$ = $whitespace$ walknode . getsupernodemetamodel ( ) . get ( ) ; $newline$ $indentation$ allpropertymetamodels . addall ( walknode . getdeclaredpropertymetamodels ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ allpropertymetamodels ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < propertymetamodel > $whitespace$ getallpropertymetamodels ( ) { $newline$ $indentation$ list < propertymetamodel > $whitespace$ allpropertymetamodels $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( getdeclaredpropertymetamodels ( ) ) ; $newline$ $indentation$ basenodemetamodel $whitespace$ walknode $whitespace$ = $whitespace$ this ; $newline$ $indentation$ while $whitespace$ ( walknode. getsupernodemetamodel ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ walknode $whitespace$ = $whitespace$ walknode. getsupernodemetamodel ( ). get ( ) ; $newline$ $indentation$ allpropertymetamodels. addall ( walknode. getdeclaredpropertymetamodels ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ allpropertymetamodels ; $newline$ $indentation$ }			
equals	169	179	javaparser/javaparser-core/src/main/java/com/github/javaparser/metamodel/BaseNodeMetaModel.java	0.7259641289710999	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    BaseNodeMetaModel classMetaModel = (BaseNodeMetaModel) o;
		    if (!type.equals(classMetaModel.type))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ basenodemetamodel $whitespace$ classmetamodel $whitespace$ = $whitespace$ ( basenodemetamodel ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! type . equals ( classmetamodel . type ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! type. equals ( classmetamodel. type ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
initializeNodeMetaModels	300	414	javaparser/javaparser-core/src/main/java/com/github/javaparser/metamodel/JavaParserMetaModel.java	9.117484296439216e-05	LOW	"		@Generated(""com.github.javaparser.generator.metamodel.MetaModelGenerator"")
		private static void initializeNodeMetaModels(){
		    nodeMetaModels.add(annotationDeclarationMetaModel);
		    nodeMetaModels.add(annotationExprMetaModel);
		    nodeMetaModels.add(annotationMemberDeclarationMetaModel);
		    nodeMetaModels.add(arrayAccessExprMetaModel);
		    nodeMetaModels.add(arrayCreationExprMetaModel);
		    nodeMetaModels.add(arrayCreationLevelMetaModel);
		    nodeMetaModels.add(arrayInitializerExprMetaModel);
		    nodeMetaModels.add(arrayTypeMetaModel);
		    nodeMetaModels.add(assertStmtMetaModel);
		    nodeMetaModels.add(assignExprMetaModel);
		    nodeMetaModels.add(binaryExprMetaModel);
		    nodeMetaModels.add(blockCommentMetaModel);
		    nodeMetaModels.add(blockStmtMetaModel);
		    nodeMetaModels.add(bodyDeclarationMetaModel);
		    nodeMetaModels.add(booleanLiteralExprMetaModel);
		    nodeMetaModels.add(breakStmtMetaModel);
		    nodeMetaModels.add(callableDeclarationMetaModel);
		    nodeMetaModels.add(castExprMetaModel);
		    nodeMetaModels.add(catchClauseMetaModel);
		    nodeMetaModels.add(charLiteralExprMetaModel);
		    nodeMetaModels.add(classExprMetaModel);
		    nodeMetaModels.add(classOrInterfaceDeclarationMetaModel);
		    nodeMetaModels.add(classOrInterfaceTypeMetaModel);
		    nodeMetaModels.add(commentMetaModel);
		    nodeMetaModels.add(compactConstructorDeclarationMetaModel);
		    nodeMetaModels.add(compilationUnitMetaModel);
		    nodeMetaModels.add(conditionalExprMetaModel);
		    nodeMetaModels.add(constructorDeclarationMetaModel);
		    nodeMetaModels.add(continueStmtMetaModel);
		    nodeMetaModels.add(doStmtMetaModel);
		    nodeMetaModels.add(doubleLiteralExprMetaModel);
		    nodeMetaModels.add(emptyStmtMetaModel);
		    nodeMetaModels.add(enclosedExprMetaModel);
		    nodeMetaModels.add(enumConstantDeclarationMetaModel);
		    nodeMetaModels.add(enumDeclarationMetaModel);
		    nodeMetaModels.add(explicitConstructorInvocationStmtMetaModel);
		    nodeMetaModels.add(expressionMetaModel);
		    nodeMetaModels.add(expressionStmtMetaModel);
		    nodeMetaModels.add(fieldAccessExprMetaModel);
		    nodeMetaModels.add(fieldDeclarationMetaModel);
		    nodeMetaModels.add(forEachStmtMetaModel);
		    nodeMetaModels.add(forStmtMetaModel);
		    nodeMetaModels.add(ifStmtMetaModel);
		    nodeMetaModels.add(importDeclarationMetaModel);
		    nodeMetaModels.add(initializerDeclarationMetaModel);
		    nodeMetaModels.add(instanceOfExprMetaModel);
		    nodeMetaModels.add(integerLiteralExprMetaModel);
		    nodeMetaModels.add(intersectionTypeMetaModel);
		    nodeMetaModels.add(javadocCommentMetaModel);
		    nodeMetaModels.add(labeledStmtMetaModel);
		    nodeMetaModels.add(lambdaExprMetaModel);
		    nodeMetaModels.add(lineCommentMetaModel);
		    nodeMetaModels.add(literalExprMetaModel);
		    nodeMetaModels.add(literalStringValueExprMetaModel);
		    nodeMetaModels.add(localClassDeclarationStmtMetaModel);
		    nodeMetaModels.add(localRecordDeclarationStmtMetaModel);
		    nodeMetaModels.add(longLiteralExprMetaModel);
		    nodeMetaModels.add(markerAnnotationExprMetaModel);
		    nodeMetaModels.add(memberValuePairMetaModel);
		    nodeMetaModels.add(methodCallExprMetaModel);
		    nodeMetaModels.add(methodDeclarationMetaModel);
		    nodeMetaModels.add(methodReferenceExprMetaModel);
		    nodeMetaModels.add(modifierMetaModel);
		    nodeMetaModels.add(moduleDeclarationMetaModel);
		    nodeMetaModels.add(moduleDirectiveMetaModel);
		    nodeMetaModels.add(moduleExportsDirectiveMetaModel);
		    nodeMetaModels.add(moduleOpensDirectiveMetaModel);
		    nodeMetaModels.add(moduleProvidesDirectiveMetaModel);
		    nodeMetaModels.add(moduleRequiresDirectiveMetaModel);
		    nodeMetaModels.add(moduleUsesDirectiveMetaModel);
		    nodeMetaModels.add(nameExprMetaModel);
		    nodeMetaModels.add(nameMetaModel);
		    nodeMetaModels.add(nodeMetaModel);
		    nodeMetaModels.add(normalAnnotationExprMetaModel);
		    nodeMetaModels.add(nullLiteralExprMetaModel);
		    nodeMetaModels.add(objectCreationExprMetaModel);
		    nodeMetaModels.add(packageDeclarationMetaModel);
		    nodeMetaModels.add(parameterMetaModel);
		    nodeMetaModels.add(patternExprMetaModel);
		    nodeMetaModels.add(primitiveTypeMetaModel);
		    nodeMetaModels.add(receiverParameterMetaModel);
		    nodeMetaModels.add(recordDeclarationMetaModel);
		    nodeMetaModels.add(referenceTypeMetaModel);
		    nodeMetaModels.add(returnStmtMetaModel);
		    nodeMetaModels.add(simpleNameMetaModel);
		    nodeMetaModels.add(singleMemberAnnotationExprMetaModel);
		    nodeMetaModels.add(statementMetaModel);
		    nodeMetaModels.add(stringLiteralExprMetaModel);
		    nodeMetaModels.add(superExprMetaModel);
		    nodeMetaModels.add(switchEntryMetaModel);
		    nodeMetaModels.add(switchExprMetaModel);
		    nodeMetaModels.add(switchStmtMetaModel);
		    nodeMetaModels.add(synchronizedStmtMetaModel);
		    nodeMetaModels.add(textBlockLiteralExprMetaModel);
		    nodeMetaModels.add(thisExprMetaModel);
		    nodeMetaModels.add(throwStmtMetaModel);
		    nodeMetaModels.add(tryStmtMetaModel);
		    nodeMetaModels.add(typeDeclarationMetaModel);
		    nodeMetaModels.add(typeExprMetaModel);
		    nodeMetaModels.add(typeMetaModel);
		    nodeMetaModels.add(typeParameterMetaModel);
		    nodeMetaModels.add(unaryExprMetaModel);
		    nodeMetaModels.add(unionTypeMetaModel);
		    nodeMetaModels.add(unknownTypeMetaModel);
		    nodeMetaModels.add(unparsableStmtMetaModel);
		    nodeMetaModels.add(varTypeMetaModel);
		    nodeMetaModels.add(variableDeclarationExprMetaModel);
		    nodeMetaModels.add(variableDeclaratorMetaModel);
		    nodeMetaModels.add(voidTypeMetaModel);
		    nodeMetaModels.add(whileStmtMetaModel);
		    nodeMetaModels.add(wildcardTypeMetaModel);
		    nodeMetaModels.add(yieldStmtMetaModel);
		}"	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ initializenodemetamodels ( ) { $newline$ $indentation$ nodemetamodels . add ( annotationdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( annotationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( annotationmemberdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( arrayaccessexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( arraycreationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( arraycreationlevelmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( arrayinitializerexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( arraytypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( assertstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( assignexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( binaryexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( blockcommentmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( blockstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( bodydeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( booleanliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( breakstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( callabledeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( castexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( catchclausemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( charliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( classexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( classorinterfacedeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( classorinterfacetypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( commentmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( compactconstructordeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( compilationunitmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( conditionalexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( constructordeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( continuestmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( dostmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( doubleliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( emptystmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( enclosedexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( enumconstantdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( enumdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( explicitconstructorinvocationstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( expressionmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( expressionstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( fieldaccessexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( fielddeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( foreachstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( forstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( ifstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( importdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( initializerdeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( instanceofexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( integerliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( intersectiontypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( javadoccommentmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( labeledstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( lambdaexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( linecommentmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( literalexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( literalstringvalueexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( localclassdeclarationstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( localrecorddeclarationstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( longliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( markerannotationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( membervaluepairmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( methodcallexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( methoddeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( methodreferenceexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( modifiermetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduledeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduledirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduleexportsdirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduleopensdirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduleprovidesdirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( modulerequiresdirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( moduleusesdirectivemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( nameexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( namemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( nodemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( normalannotationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( nullliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( objectcreationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( packagedeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( parametermetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( patternexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( primitivetypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( receiverparametermetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( recorddeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( referencetypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( returnstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( simplenamemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( singlememberannotationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( statementmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( stringliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( superexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( switchentrymetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( switchexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( switchstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( synchronizedstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( textblockliteralexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( thisexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( throwstmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( trystmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( typedeclarationmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( typeexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( typemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( typeparametermetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( unaryexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( uniontypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( unknowntypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( unparsablestmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( vartypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( variabledeclarationexprmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( variabledeclaratormetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( voidtypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( whilestmtmetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( wildcardtypemetamodel ) ; $newline$ $indentation$ nodemetamodels . add ( yieldstmtmetamodel ) ; $newline$ $indentation$ }	$indentation$ @ generated ( $string$ ) $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ initializenodemetamodels ( ) $whitespace$ { $newline$ $indentation$ // $whitespace$ initialize $whitespace$ all $whitespace$ registers $whitespace$ and $whitespace$ clear $whitespace$ skins $newline$ $indentation$. and ( annotation annotation annotationarationmetamodel ) $newline$ $indentation$. add ( annotationmemberdeclarationmetamodel ) $newline$ $indentation$. and ( arrayaccessexprmetamodel ) $newline$ $indentation$. add ( arraycreationexprmetamodel ) $newline$ $indentation$. add ( arrayvalidateexprmetamodel ) $newline$ $indentation$. add ( arraytypemetamodel ) $newline$ $indentation$. add ( booleanliteralexprmetamodel ) $newline$ $indentation$. add ( breakstmtmetamodel ) $newline$ $indentation$. add ( returnstmtmetamodel ) ; $newline$ $indentation$ // $whitespace$ add $whitespace$ all $whitespace$ registers $whitespace$ and $whitespace$ clear $whitespace$ skins $newline$ $indentation$. and ( $string$ ) $newline$ $indentation$. add ( isliteralexprmetamodel ) $newline$ $indentation$. add ( nodemetamodel ) ; $newline$ $indentation$ nodemetamodels. add ( graphexprmetamodel ) ; $newline$ $indentation$ // $whitespace$ add $whitespace$ all $whitespace$ registers $whitespace$ based $whitespace$ on $whitespace$ art $whitespace$ for $whitespace$ at $whitespace$ least $whitespace$ 12 $whitespace$ months $newline$ $indentation$. and ( $string$ ) $newline$ $indentation$. add ( blockcommentmetamodel ) ; $newline$ $indentation$ nodemetamodels. add ( cost costmodel ) ; $newline$ $indentation$ // $whitespace$ add $whitespace$ all $whitespace$ registers $whitespace$ and $whitespace$ clear $whitespace$ skins $			
equals	166	178	javaparser/javaparser-core/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java	0.6808096170425415	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    PropertyMetaModel that = (PropertyMetaModel) o;
		    if (!name.equals(that.name))
		        return false;
		    if (!type.equals(that.type))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ propertymetamodel $whitespace$ that $whitespace$ = $whitespace$ ( propertymetamodel ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! name . equals ( that . name ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! type . equals ( that . type ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! name. equals ( that. name ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isvalid ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! name. equals ( that. type ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isvalid ; $newline$ $indentation$ }			
hashCode	180	185	javaparser/javaparser-core/src/main/java/com/github/javaparser/metamodel/PropertyMetaModel.java	0.8568910360336304	HIGH	"		@Override
		public int hashCode(){
		    int result = name.hashCode();
		    result = 31 * result + type.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ name . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ type . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ name. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ objects. hashcode ( type ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
genericPrettyPrint	214	218	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/ConcreteSyntaxModel.java	0.6425769329071045	MID	"		public static String genericPrettyPrint(Node node){
		    SourcePrinter sourcePrinter = new SourcePrinter();
		    forClass(node.getClass()).prettyPrint(node, sourcePrinter);
		    return sourcePrinter.toString();
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ genericprettyprint ( node $whitespace$ node ) { $newline$ $indentation$ sourceprinter $whitespace$ sourceprinter $whitespace$ = $whitespace$ new $whitespace$ sourceprinter ( ) ; $newline$ $indentation$ forclass ( node . getclass ( ) ) . prettyprint ( node , $whitespace$ sourceprinter ) ; $newline$ $indentation$ return $whitespace$ sourceprinter . tostring ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ genericprettyprint ( node $whitespace$ node ) { $newline$ $indentation$ sourceprinter $whitespace$ sourceprinter $whitespace$ = $whitespace$ new $whitespace$ sourceprinter ( ) ; $newline$ $indentation$ forclass ( node. getclass ( ) ). prettyprint ( sourceprinter ) ; $newline$ $indentation$ return $whitespace$ sourceprinter. tostring ( ) ; $newline$ $indentation$ }			
print	91	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinter.java	0.7382704615592957	MID	"		@Override
		public String print(Node node){
		    // lazy initialization of visitor which can have a state (like a buffer)
		    VoidVisitor<Void> visitor = visitorFactory.apply(configuration);
		    node.accept(visitor, null);
		    return visitor.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ print ( node $whitespace$ node ) { $newline$ $indentation$ $//·lazy·initialization·of·visitor·which·can·have·a·state·(like·a·buffer)$ $newline$ $indentation$ voidvisitor < void > $whitespace$ visitor $whitespace$ = $whitespace$ visitorfactory . apply ( configuration ) ; $newline$ $indentation$ node . accept ( visitor , $whitespace$ null ) ; $newline$ $indentation$ return $whitespace$ visitor . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ print ( node $whitespace$ node ) { $newline$ $indentation$ $number$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ node. accept ( visitor ) ; $newline$ $indentation$ return $whitespace$ visitor. tostring ( ) ; $newline$ $indentation$ }			
printOrphanCommentsBeforeThisChildNode	1813	1845	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.1548053622245788	LOW	"		private void printOrphanCommentsBeforeThisChildNode(final Node node){
		    if (!getOption(ConfigOption.PRINT_COMMENTS).isPresent())
		        return;
		    if (node instanceof Comment)
		        return;
		    Node parent = node.getParentNode().orElse(null);
		    if (parent == null)
		        return;
		    List<Node> everything = new ArrayList<>(parent.getChildNodes());
		    sortByBeginPosition(everything);
		    int positionOfTheChild = -1;
		    for (int i = 0; i < everything.size(); ++i) {
		        // indexOf is by equality, so this is used to index by identity
		        if (everything.get(i) == node) {
		            positionOfTheChild = i;
		            break;
		        }
		    }
		    if (positionOfTheChild == -1) {
		        throw new AssertionError(""I am not a child of my parent."");
		    }
		    int positionOfPreviousChild = -1;
		    for (int i = positionOfTheChild - 1; i >= 0 && positionOfPreviousChild == -1; i--) {
		        if (!(everything.get(i) instanceof Comment))
		            positionOfPreviousChild = i;
		    }
		    for (int i = positionOfPreviousChild + 1; i < positionOfTheChild; i++) {
		        Node nodeToPrint = everything.get(i);
		        if (!(nodeToPrint instanceof Comment))
		            throw new RuntimeException(""Expected comment, instead "" + nodeToPrint.getClass() + "". Position of previous child: "" + positionOfPreviousChild + "", position of child "" + positionOfTheChild);
		        nodeToPrint.accept(this, null);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsbeforethischildnode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ! getoption ( configoption . print_comments ) . ispresent ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ comment ) $newline$ $indentation$ return ; $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node . getparentnode ( ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( parent . getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ int $whitespace$ positionofthechild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ everything . size ( ) ; $whitespace$ ++ i ) $whitespace$ { $newline$ $indentation$ $//·indexof·is·by·equality,·so·this·is·used·to·index·by·identity$ $newline$ $indentation$ if $whitespace$ ( everything . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ positionofthechild $whitespace$ = $whitespace$ i ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( positionofthechild $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ positionofpreviouschild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ positionofthechild $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ positionofpreviouschild $whitespace$ == $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! ( everything . get ( i ) $whitespace$ instanceof $whitespace$ comment ) ) $newline$ $indentation$ positionofpreviouschild $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ positionofpreviouschild $whitespace$ + $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ positionofthechild ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ node $whitespace$ nodetoprint $whitespace$ = $whitespace$ everything . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ! ( nodetoprint $whitespace$ instanceof $whitespace$ comment ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ nodetoprint . getclass ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ positionofpreviouschild $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ positionofthechild ) ; $newline$ $indentation$ nodetoprint . accept ( this , $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsbeforethischildnode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ismainroute ( configoption. print_comments ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ instanceof $whitespace$ comment ) $newline$ $indentation$ return ; $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node. getparentnode ( ). orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( parent. getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ int $whitespace$ positionofthechild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ everything. size ( ) ; $whitespace$ ++ i ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////indexof$ =isententandaddordinalchild ( node ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( positionofthechild $whitespace$ == $whitespace$ null )			
visit	203	226	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.1701490581035614	LOW	"		@Override
		public void visit(final CompilationUnit n, final Void arg){
		    printOrphanCommentsBeforeThisChildNode(n);
		    printComment(n.getComment(), arg);
		    if (n.getParsed() == UNPARSABLE) {
		        printer.println(""???"");
		        return;
		    }
		    if (n.getPackageDeclaration().isPresent()) {
		        n.getPackageDeclaration().get().accept(this, arg);
		    }
		    printImports(n.getImports(), arg);
		    for (final Iterator<TypeDeclaration<?>> i = n.getTypes().iterator(); i.hasNext(); ) {
		        i.next().accept(this, arg);
		        printer.println();
		        if (i.hasNext()) {
		            printer.println();
		        }
		    }
		    n.getModule().ifPresent(m -> m.accept(this, arg));
		    printOrphanCommentsEnding(n);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n , $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ printorphancommentsbeforethischildnode ( n ) ; $newline$ $indentation$ printcomment ( n . getcomment ( ) , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( n . getparsed ( ) $whitespace$ == $whitespace$ unparsable ) $whitespace$ { $newline$ $indentation$ printer . println ( $string$ ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getpackagedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n . getpackagedeclaration ( ) . get ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ printimports ( n . getimports ( ) , $whitespace$ arg ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < typedeclaration < ? >> $whitespace$ i $whitespace$ = $whitespace$ n . gettypes ( ) . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ i . next ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ n . getmodule ( ) . ifpresent ( m $whitespace$ - > $whitespace$ m . accept ( this , $whitespace$ arg ) ) ; $newline$ $indentation$ printorphancommentsending ( n ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n, $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( n. getparsed ( ) $whitespace$ == $whitespace$ unparsable ) $whitespace$ { $newline$ $indentation$ printorphancommentsbeforethischildnode ( n ) ; $newline$ $indentation$ printcomment ( n. getcomment ( ), $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ printimports ( n. getimports ( ), $whitespace$ arg ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < typedeclaration <? >> $whitespace$ i $whitespace$ = $whitespace$ n. gettypes ( ). iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ i. next ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ if $whitespace$ ( i. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ n. getmodule ( ). ifpresent ( m $whitespace$ - > $whitespace$ m. accept ( this, $whitespace$ arg ) ) ; $newline$ $indentation$ printorphan			
printOrphanCommentsEnding	1847	1867	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.1770800501108169	LOW	"		private void printOrphanCommentsEnding(final Node node){
		    if (!getOption(ConfigOption.PRINT_COMMENTS).isPresent())
		        return;
		    List<Node> everything = new ArrayList<>(node.getChildNodes());
		    sortByBeginPosition(everything);
		    if (everything.isEmpty()) {
		        return;
		    }
		    int commentsAtEnd = 0;
		    boolean findingComments = true;
		    while (findingComments && commentsAtEnd < everything.size()) {
		        Node last = everything.get(everything.size() - 1 - commentsAtEnd);
		        findingComments = (last instanceof Comment);
		        if (findingComments) {
		            commentsAtEnd++;
		        }
		    }
		    for (int i = 0; i < commentsAtEnd; i++) {
		        everything.get(everything.size() - commentsAtEnd + i).accept(this, null);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsending ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ! getoption ( configoption . print_comments ) . ispresent ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( node . getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything . size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace$ { $newline$ $indentation$ commentsatend ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ commentsatend ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ commentsatend $whitespace$ + $whitespace$ i ) . accept ( this , $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsending ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ (! getoption ( configoption. print_comments ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( node. getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything. size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything. get ( everything. size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace$ { $newline$ $indentation$ commentsatend ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ commentsatend ; $white			
printModifiers	79	83	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.2592527270317077	LOW	"		protected void printModifiers(final NodeList<Modifier> modifiers){
		    if (modifiers.size() > 0) {
		        printer.print(modifiers.stream().map(Modifier::getKeyword).map(Modifier.Keyword::asString).collect(joining("" "")) + "" "");
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ printer . print ( modifiers . stream ( ) . map ( modifier : : getkeyword ) . map ( modifier . keyword : : asstring ) . collect ( joining ( $string$ ) ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ printer. print ( modifiers. stream ( ). map ( modifier : : getkeyword ). map ( modifier. keyword : : asstring ). collect ( joining ( $string$ ) ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
printImports	1784	1811	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.2796671092510223	LOW	"		private void printImports(NodeList<ImportDeclaration> imports, Void arg){
		    ImportOrderingStrategy strategy = new DefaultImportOrderingStrategy();
		    // Get Import strategy from configuration
		    Optional<ConfigurationOption> optionalStrategy = getOption(ConfigOption.SORT_IMPORTS_STRATEGY);
		    if (optionalStrategy.isPresent()) {
		        ConfigurationOption strategyOption = optionalStrategy.get();
		        if (strategyOption.hasValue()) {
		            strategy = strategyOption.asValue();
		        }
		    }
		    // Keep retro-compatibility with option ORDER_IMPORTS.
		    Optional<ConfigurationOption> orderImportsOption = getOption(ConfigOption.ORDER_IMPORTS);
		    if (orderImportsOption.isPresent()) {
		        strategy.setSortImportsAlphabetically(true);
		    }
		    // Sort the imports according to the strategy
		    List<NodeList<ImportDeclaration>> groupOrderedImports = strategy.sortImports(imports);
		    for (NodeList<ImportDeclaration> importGroup : groupOrderedImports) {
		        importGroup.accept(this, arg);
		        if (!importGroup.isEmpty()) {
		            printer.println();
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ printimports ( nodelist < importdeclaration > $whitespace$ imports , $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ importorderingstrategy $whitespace$ strategy $whitespace$ = $whitespace$ new $whitespace$ defaultimportorderingstrategy ( ) ; $newline$ $indentation$ $//·get·import·strategy·from·configuration$ $newline$ $indentation$ optional < configurationoption > $whitespace$ optionalstrategy $whitespace$ = $whitespace$ getoption ( configoption . sort_imports_strategy ) ; $newline$ $indentation$ if $whitespace$ ( optionalstrategy . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ configurationoption $whitespace$ strategyoption $whitespace$ = $whitespace$ optionalstrategy . get ( ) ; $newline$ $indentation$ if $whitespace$ ( strategyoption . hasvalue ( ) ) $whitespace$ { $newline$ $indentation$ strategy $whitespace$ = $whitespace$ strategyoption . asvalue ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·keep·retro-compatibility·with·option·order_imports.$ $newline$ $indentation$ optional < configurationoption > $whitespace$ orderimportsoption $whitespace$ = $whitespace$ getoption ( configoption . order_imports ) ; $newline$ $indentation$ if $whitespace$ ( orderimportsoption . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ strategy . setsortimportsalphabetically ( true ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·sort·the·imports·according·to·the·strategy$ $newline$ $indentation$ list < nodelist < importdeclaration >> $whitespace$ grouporderedimports $whitespace$ = $whitespace$ strategy . sortimports ( imports ) ; $newline$ $indentation$ for $whitespace$ ( nodelist < importdeclaration > $whitespace$ importgroup $whitespace$ : $whitespace$ grouporderedimports ) $whitespace$ { $newline$ $indentation$ importgroup . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( ! importgroup . isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ printimports ( nodelist < importdeclaration > $whitespace$ imports, $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ importorderingstrategy $whitespace$ strategy $whitespace$ = $whitespace$ new $whitespace$ defaultimportorderingstrategy ( ) ; $newline$ $indentation$ if $whitespace$ (! ispresent ( ) ) $whitespace$ { $newline$ $indentation$ configurationoption $whitespace$ strategyoption $whitespace$ = $whitespace$ optionalstrategy. get ( ) ; $newline$ $indentation$ if $whitespace$ ( strategyoption. hasvalue ( ) ) $whitespace$ { $newline$ $indentation$ strategy $whitespace$ = $whitespace$ strategyoption. asvalue ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ ( ( configurationoption ) $whitespace$ strategyoption. hasvalue ( ) ) $whitespace$ { $newline$ $indentation$ strategy $whitespace$ = $whitespace$ strategyoption. asvalue ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < nodelist < importdeclaration >> $whitespace$ grouporderedimports $whitespace$ = $whitespace$ strategy. sortimports ( imports ) ; $newline$ $indentation$ for			
printPrePostFixRequiredList	185	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.2949201166629791	LOW	"		protected void printPrePostFixRequiredList(final NodeList<? extends Visitable> args, final Void arg, String prefix, String separator, String postfix){
		    printer.print(prefix);
		    if (!args.isEmpty()) {
		        for (final Iterator<? extends Visitable> i = args.iterator(); i.hasNext(); ) {
		            final Visitable v = i.next();
		            v.accept(this, arg);
		            if (i.hasNext()) {
		                printer.print(separator);
		            }
		        }
		    }
		    printer.print(postfix);
		}"	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixrequiredlist ( final $whitespace$ nodelist < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ args , $whitespace$ final $whitespace$ void $whitespace$ arg , $whitespace$ string $whitespace$ prefix , $whitespace$ string $whitespace$ separator , $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ printer . print ( prefix ) ; $newline$ $indentation$ if $whitespace$ ( ! args . isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i . next ( ) ; $newline$ $indentation$ v . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( separator ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer . print ( postfix ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixrequiredlist ( final $whitespace$ nodelist <? $whitespace$ extends $whitespace$ visitable > $whitespace$ args, $whitespace$ final $whitespace$ void $whitespace$ arg, $whitespace$ string $whitespace$ prefix, $whitespace$ string $whitespace$ separator, $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ printer. print ( prefix ) ; $newline$ $indentation$ if $whitespace$ ( args. isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator <? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args. iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i. next ( ) ; $newline$ $indentation$ v. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer. print ( postfix ) ; $newline$ $indentation$ }			
printPrePostFixOptionalList	171	183	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.2970215678215027	LOW	"		protected void printPrePostFixOptionalList(final NodeList<? extends Visitable> args, final Void arg, String prefix, String separator, String postfix){
		    if (!args.isEmpty()) {
		        printer.print(prefix);
		        for (final Iterator<? extends Visitable> i = args.iterator(); i.hasNext(); ) {
		            final Visitable v = i.next();
		            v.accept(this, arg);
		            if (i.hasNext()) {
		                printer.print(separator);
		            }
		        }
		        printer.print(postfix);
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixoptionallist ( final $whitespace$ nodelist < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ args , $whitespace$ final $whitespace$ void $whitespace$ arg , $whitespace$ string $whitespace$ prefix , $whitespace$ string $whitespace$ separator , $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ if $whitespace$ ( ! args . isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( prefix ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i . next ( ) ; $newline$ $indentation$ v . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( separator ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer . print ( postfix ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixoptionallist ( final $whitespace$ nodelist <? $whitespace$ extends $whitespace$ visitable > $whitespace$ args, $whitespace$ final $whitespace$ void $whitespace$ arg, $whitespace$ string $whitespace$ prefix, $whitespace$ string $whitespace$ separator, $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ if $whitespace$ ( args. isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer. print ( prefix ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator <? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args. iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i. next ( ) ; $newline$ $indentation$ v. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer. print ( postfix ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
printMemberAnnotations	93	101	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DefaultPrettyPrinterVisitor.java	0.6312976479530334	MID	"		protected void printMemberAnnotations(final NodeList<AnnotationExpr> annotations, final Void arg){
		    if (annotations.isEmpty()) {
		        return;
		    }
		    for (final AnnotationExpr a : annotations) {
		        a.accept(this, arg);
		        printer.println();
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printmemberannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations , $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( annotations . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ annotationexpr $whitespace$ a $whitespace$ : $whitespace$ annotations ) $whitespace$ { $newline$ $indentation$ a . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printmemberannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations, $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( annotations. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ annotationexpr $whitespace$ a $whitespace$ : $whitespace$ annotations ) $whitespace$ { $newline$ $indentation$ a. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
output	47	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/DotPrinter.java	0.7017338275909424	MID	"		public String output(Node node){
		    nodeCount = 0;
		    StringBuilder output = new StringBuilder();
		    output.append(""digraph {"");
		    output(node, null, ""root"", output);
		    output.append(SYSTEM_EOL + ""}"");
		    return output.toString();
		}"	$indentation$ public $whitespace$ string $whitespace$ output ( node $whitespace$ node ) { $newline$ $indentation$ nodecount $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ stringbuilder $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ output . append ( $string$ ) ; $newline$ $indentation$ output ( node , $whitespace$ null , $whitespace$ $string$ , $whitespace$ output ) ; $newline$ $indentation$ output . append ( system_eol $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ output . tostring ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ string $whitespace$ output ( node $whitespace$ node ) { $newline$ $indentation$ nodecount $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ nodecount $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ stringbuilder $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ output. append ( $string$ ) ; $newline$ $indentation$ output ( node, $whitespace$ null, $whitespace$ $string$, $whitespace$ output ) ; $newline$ $indentation$ output. append ( system_eol $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ output. tostring ( ) ; $newline$ $indentation$ }			
printOrphanCommentsBeforeThisChildNode	1795	1827	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.1710700392723083	LOW	"		private void printOrphanCommentsBeforeThisChildNode(final Node node){
		    if (configuration.isIgnoreComments())
		        return;
		    if (node instanceof Comment)
		        return;
		    Node parent = node.getParentNode().orElse(null);
		    if (parent == null)
		        return;
		    List<Node> everything = new ArrayList<>(parent.getChildNodes());
		    sortByBeginPosition(everything);
		    int positionOfTheChild = -1;
		    for (int i = 0; i < everything.size(); ++i) {
		        // indexOf is by equality, so this is used to index by identity
		        if (everything.get(i) == node) {
		            positionOfTheChild = i;
		            break;
		        }
		    }
		    if (positionOfTheChild == -1) {
		        throw new AssertionError(""I am not a child of my parent."");
		    }
		    int positionOfPreviousChild = -1;
		    for (int i = positionOfTheChild - 1; i >= 0 && positionOfPreviousChild == -1; i--) {
		        if (!(everything.get(i) instanceof Comment))
		            positionOfPreviousChild = i;
		    }
		    for (int i = positionOfPreviousChild + 1; i < positionOfTheChild; i++) {
		        Node nodeToPrint = everything.get(i);
		        if (!(nodeToPrint instanceof Comment))
		            throw new RuntimeException(""Expected comment, instead "" + nodeToPrint.getClass() + "". Position of previous child: "" + positionOfPreviousChild + "", position of child "" + positionOfTheChild);
		        nodeToPrint.accept(this, null);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsbeforethischildnode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( configuration . isignorecomments ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ comment ) $newline$ $indentation$ return ; $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node . getparentnode ( ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( parent . getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ int $whitespace$ positionofthechild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ everything . size ( ) ; $whitespace$ ++ i ) $whitespace$ { $newline$ $indentation$ $//·indexof·is·by·equality,·so·this·is·used·to·index·by·identity$ $newline$ $indentation$ if $whitespace$ ( everything . get ( i ) $whitespace$ == $whitespace$ node ) $whitespace$ { $newline$ $indentation$ positionofthechild $whitespace$ = $whitespace$ i ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( positionofthechild $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ positionofpreviouschild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ positionofthechild $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ positionofpreviouschild $whitespace$ == $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! ( everything . get ( i ) $whitespace$ instanceof $whitespace$ comment ) ) $newline$ $indentation$ positionofpreviouschild $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ positionofpreviouschild $whitespace$ + $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ positionofthechild ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ node $whitespace$ nodetoprint $whitespace$ = $whitespace$ everything . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ! ( nodetoprint $whitespace$ instanceof $whitespace$ comment ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ nodetoprint . getclass ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ positionofpreviouschild $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ positionofthechild ) ; $newline$ $indentation$ nodetoprint . accept ( this , $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsbeforethischildnode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( configuration. isignorecomments ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ comment ) $newline$ $indentation$ return ; $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node. getparentnode ( ). orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return ; $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( parent. getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ int $whitespace$ positionofthechild $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ everything. size ( ) ; $whitespace$ ++ i ) $whitespace$ { $newline$ $indentation$ $////g$indexof$ = $whitespace$ node. getchildnodes ( ). orelse ( null ) ; $newline$ $indentation$ positionofthechild $whitespace$ = $whitespace$ i ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( positionofthechild $whitespace$ == $whitespace$ $number$ ) $whitespace$			
printOrphanCommentsEnding	1829	1850	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.2096533328294754	LOW	"		private void printOrphanCommentsEnding(final Node node){
		    if (configuration.isIgnoreComments())
		        return;
		    // extract all nodes for which the position/range is indicated to avoid to skip orphan comments
		    List<Node> everything = node.getChildNodes().stream().filter(n -> n.hasRange()).collect(Collectors.toList());
		    sortByBeginPosition(everything);
		    if (everything.isEmpty()) {
		        return;
		    }
		    int commentsAtEnd = 0;
		    boolean findingComments = true;
		    while (findingComments && commentsAtEnd < everything.size()) {
		        Node last = everything.get(everything.size() - 1 - commentsAtEnd);
		        findingComments = (last instanceof Comment);
		        if (findingComments) {
		            commentsAtEnd++;
		        }
		    }
		    for (int i = 0; i < commentsAtEnd; i++) {
		        everything.get(everything.size() - commentsAtEnd + i).accept(this, null);
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsending ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( configuration . isignorecomments ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ $//·extract·all·nodes·for·which·the·position/range·is·indicated·to·avoid·to·skip·orphan·comments$ $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ node . getchildnodes ( ) . stream ( ) . filter ( n $whitespace$ - > $whitespace$ n . hasrange ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything . size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace$ { $newline$ $indentation$ commentsatend ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ commentsatend ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ commentsatend $whitespace$ + $whitespace$ i ) . accept ( this , $whitespace$ null ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ printorphancommentsending ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( configuration. isignorecomments ( ) ) $newline$ $indentation$ return ; $newline$ $indentation$ $whitespace$//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ method $whitespace$ to $whitespace$ setup $whitespace$ the $whitespace$ws $whitespace$ and $whitespace$ condition $whitespace$ master $whitespace$ definitions $whitespace$ from $whitespace$ the $whitespace$ given $whitespace$ list $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ node. getchildnodes ( ). stream ( ). filter ( n $whitespace$ - > $whitespace$ n. hasrange ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything. size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything. get ( everything. size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace			
printModifiers	88	92	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.2592527270317077	LOW	"		protected void printModifiers(final NodeList<Modifier> modifiers){
		    if (modifiers.size() > 0) {
		        printer.print(modifiers.stream().map(Modifier::getKeyword).map(Modifier.Keyword::asString).collect(joining("" "")) + "" "");
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ printer . print ( modifiers . stream ( ) . map ( modifier : : getkeyword ) . map ( modifier . keyword : : asstring ) . collect ( joining ( $string$ ) ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printmodifiers ( final $whitespace$ nodelist < modifier > $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifiers. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ printer. print ( modifiers. stream ( ). map ( modifier : : getkeyword ). map ( modifier. keyword : : asstring ). collect ( joining ( $string$ ) ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
visit	212	236	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.2781770527362823	LOW	"		@Override
		public void visit(final CompilationUnit n, final Void arg){
		    printOrphanCommentsBeforeThisChildNode(n);
		    printComment(n.getComment(), arg);
		    if (n.getParsed() == UNPARSABLE) {
		        printer.println(""???"");
		        return;
		    }
		    if (n.getPackageDeclaration().isPresent()) {
		        n.getPackageDeclaration().get().accept(this, arg);
		    }
		    n.getImports().accept(this, arg);
		    if (!n.getImports().isEmpty()) {
		        printer.println();
		    }
		    for (final Iterator<TypeDeclaration<?>> i = n.getTypes().iterator(); i.hasNext(); ) {
		        i.next().accept(this, arg);
		        printer.println();
		        if (i.hasNext()) {
		            printer.println();
		        }
		    }
		    n.getModule().ifPresent(m -> m.accept(this, arg));
		    printOrphanCommentsEnding(n);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n , $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ printorphancommentsbeforethischildnode ( n ) ; $newline$ $indentation$ printcomment ( n . getcomment ( ) , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( n . getparsed ( ) $whitespace$ == $whitespace$ unparsable ) $whitespace$ { $newline$ $indentation$ printer . println ( $string$ ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( n . getpackagedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ n . getpackagedeclaration ( ) . get ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ n . getimports ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( ! n . getimports ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < typedeclaration < ? >> $whitespace$ i $whitespace$ = $whitespace$ n . gettypes ( ) . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ i . next ( ) . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ n . getmodule ( ) . ifpresent ( m $whitespace$ - > $whitespace$ m . accept ( this , $whitespace$ arg ) ) ; $newline$ $indentation$ printorphancommentsending ( n ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ visit ( final $whitespace$ compilationunit $whitespace$ n, $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ final $whitespace$ string $whitespace$ value $whitespace$ = $whitespace$ n. getcomment ( ) ; $newline$ $indentation$ if $whitespace$ ( value. getparsed ( ) $whitespace$ == $whitespace$ unparsable ) $whitespace$ { $newline$ $indentation$ printorphancommentsbeforethischildnode ( n ) ; $newline$ $indentation$ printcomment ( n. getcomment ( ), $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ printorphancommentsbeforethischildnode ( n ) ; $newline$ $indentation$ printcomment ( n. getimports ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ (! n. getimports ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < typedeclaration <? >> $whitespace$ i $whitespace$ = $whitespace$ n. gettypes ( ). iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ i. next ( ). accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ if $whitespace$ ( i. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ } $newline$ $indentation$			
printPrePostFixRequiredList	194	206	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.2949201166629791	LOW	"		protected void printPrePostFixRequiredList(final NodeList<? extends Visitable> args, final Void arg, String prefix, String separator, String postfix){
		    printer.print(prefix);
		    if (!args.isEmpty()) {
		        for (final Iterator<? extends Visitable> i = args.iterator(); i.hasNext(); ) {
		            final Visitable v = i.next();
		            v.accept(this, arg);
		            if (i.hasNext()) {
		                printer.print(separator);
		            }
		        }
		    }
		    printer.print(postfix);
		}"	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixrequiredlist ( final $whitespace$ nodelist < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ args , $whitespace$ final $whitespace$ void $whitespace$ arg , $whitespace$ string $whitespace$ prefix , $whitespace$ string $whitespace$ separator , $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ printer . print ( prefix ) ; $newline$ $indentation$ if $whitespace$ ( ! args . isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i . next ( ) ; $newline$ $indentation$ v . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( separator ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer . print ( postfix ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixrequiredlist ( final $whitespace$ nodelist <? $whitespace$ extends $whitespace$ visitable > $whitespace$ args, $whitespace$ final $whitespace$ void $whitespace$ arg, $whitespace$ string $whitespace$ prefix, $whitespace$ string $whitespace$ separator, $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ printer. print ( prefix ) ; $newline$ $indentation$ if $whitespace$ ( args. isempty ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator <? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args. iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i. next ( ) ; $newline$ $indentation$ v. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer. print ( postfix ) ; $newline$ $indentation$ }			
printPrePostFixOptionalList	180	192	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.2970215678215027	LOW	"		protected void printPrePostFixOptionalList(final NodeList<? extends Visitable> args, final Void arg, String prefix, String separator, String postfix){
		    if (!args.isEmpty()) {
		        printer.print(prefix);
		        for (final Iterator<? extends Visitable> i = args.iterator(); i.hasNext(); ) {
		            final Visitable v = i.next();
		            v.accept(this, arg);
		            if (i.hasNext()) {
		                printer.print(separator);
		            }
		        }
		        printer.print(postfix);
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixoptionallist ( final $whitespace$ nodelist < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ args , $whitespace$ final $whitespace$ void $whitespace$ arg , $whitespace$ string $whitespace$ prefix , $whitespace$ string $whitespace$ separator , $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ if $whitespace$ ( ! args . isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( prefix ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator < ? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args . iterator ( ) ; $whitespace$ i . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i . next ( ) ; $newline$ $indentation$ v . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ if $whitespace$ ( i . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ printer . print ( separator ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer . print ( postfix ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printprepostfixoptionallist ( final $whitespace$ nodelist <? $whitespace$ extends $whitespace$ visitable > $whitespace$ args, $whitespace$ final $whitespace$ void $whitespace$ arg, $whitespace$ string $whitespace$ prefix, $whitespace$ string $whitespace$ separator, $whitespace$ string $whitespace$ postfix ) { $newline$ $indentation$ if $whitespace$ ( args. isempty ( ) ) $whitespace$ { $newline$ $indentation$ printer. print ( prefix ) ; $newline$ $indentation$ for $whitespace$ ( final $whitespace$ iterator <? $whitespace$ extends $whitespace$ visitable > $whitespace$ i $whitespace$ = $whitespace$ args. iterator ( ) ; $whitespace$ i. hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ final $whitespace$ visitable $whitespace$ v $whitespace$ = $whitespace$ i. next ( ) ; $newline$ $indentation$ v. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ printer. print ( postfix ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
printMemberAnnotations	102	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrintVisitor.java	0.6312976479530334	MID	"		protected void printMemberAnnotations(final NodeList<AnnotationExpr> annotations, final Void arg){
		    if (annotations.isEmpty()) {
		        return;
		    }
		    for (final AnnotationExpr a : annotations) {
		        a.accept(this, arg);
		        printer.println();
		    }
		}"	$indentation$ protected $whitespace$ void $whitespace$ printmemberannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations , $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( annotations . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ annotationexpr $whitespace$ a $whitespace$ : $whitespace$ annotations ) $whitespace$ { $newline$ $indentation$ a . accept ( this , $whitespace$ arg ) ; $newline$ $indentation$ printer . println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ void $whitespace$ printmemberannotations ( final $whitespace$ nodelist < annotationexpr > $whitespace$ annotations, $whitespace$ final $whitespace$ void $whitespace$ arg ) { $newline$ $indentation$ if $whitespace$ ( annotations. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( final $whitespace$ annotationexpr $whitespace$ a $whitespace$ : $whitespace$ annotations ) $whitespace$ { $newline$ $indentation$ a. accept ( this, $whitespace$ arg ) ; $newline$ $indentation$ printer. println ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
setConfiguration	66	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/PrettyPrinter.java	0.678968608379364	MID	"		public Printer setConfiguration(PrinterConfiguration configuration){
		    if (!(configuration instanceof PrettyPrinterConfiguration))
		        throw new IllegalArgumentException(""PrettyPrinter must be configured with a PrettyPrinterConfiguration class"");
		    this.configuration = configuration;
		    return this;
		}"	$indentation$ public $whitespace$ printer $whitespace$ setconfiguration ( printerconfiguration $whitespace$ configuration ) { $newline$ $indentation$ if $whitespace$ ( ! ( configuration $whitespace$ instanceof $whitespace$ prettyprinterconfiguration ) ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ this . configuration $whitespace$ = $whitespace$ configuration ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ printer $whitespace$ setconfiguration ( printerconfiguration $whitespace$ configuration ) { $newline$ $indentation$ if $whitespace$ (! configuration $whitespace$ instanceof $whitespace$ prettyprinterconfiguration ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ this. configuration $whitespace$ = $whitespace$ configuration ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
calculateIndentWithAlignTo	101	138	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java	0.0255698356777429	LOW	"		private String calculateIndentWithAlignTo(int column){
		    if (column < lastPrintedIndent.length()) {
		        throw new IllegalStateException(""Attempt to indent less than the previous indent."");
		    }
		    StringBuilder newIndent = new StringBuilder(lastPrintedIndent);
		    switch(indentation.getType()) {
		        case SPACES:
		        case TABS_WITH_SPACE_ALIGN:
		            while (newIndent.length() < column) {
		                newIndent.append(IndentType.SPACES.getCar());
		            }
		            break;
		        case TABS:
		            IndentType currentIndentType = indentation.getType();
		            int logicalIndentLength = newIndent.length();
		            while ((logicalIndentLength + currentIndentType.getWidth()) <= column) {
		                newIndent.insert(0, currentIndentType.getCar());
		                logicalIndentLength += currentIndentType.getWidth();
		            }
		            while (logicalIndentLength < column) {
		                newIndent.append(IndentType.SPACES.getCar());
		                logicalIndentLength++;
		            }
		            StringBuilder fullTab = new StringBuilder();
		            for (int i = 0; i < currentIndentType.getWidth(); i++) {
		                fullTab.append(IndentType.SPACES.getCar());
		            }
		            String fullTabString = fullTab.toString();
		            if ((newIndent.length() >= currentIndentType.getWidth()) && newIndent.substring(newIndent.length() - currentIndentType.getWidth()).equals(fullTabString)) {
		                int i = newIndent.indexOf(fullTabString);
		                newIndent.replace(i, i + currentIndentType.getWidth(), currentIndentType.getCar().toString());
		            }
		            break;
		        default:
		            throw new AssertionError(""Unhandled indent type"");
		    }
		    return newIndent.toString();
		}"	$indentation$ private $whitespace$ string $whitespace$ calculateindentwithalignto ( int $whitespace$ column ) { $newline$ $indentation$ if $whitespace$ ( column $whitespace$ < $whitespace$ lastprintedindent . length ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ newindent $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( lastprintedindent ) ; $newline$ $indentation$ switch ( indentation . gettype ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ spaces : $newline$ $indentation$ case $whitespace$ tabs_with_space_align : $newline$ $indentation$ while $whitespace$ ( newindent . length ( ) $whitespace$ < $whitespace$ column ) $whitespace$ { $newline$ $indentation$ newindent . append ( indenttype . spaces . getcar ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ tabs : $newline$ $indentation$ indenttype $whitespace$ currentindenttype $whitespace$ = $whitespace$ indentation . gettype ( ) ; $newline$ $indentation$ int $whitespace$ logicalindentlength $whitespace$ = $whitespace$ newindent . length ( ) ; $newline$ $indentation$ while $whitespace$ ( ( logicalindentlength $whitespace$ + $whitespace$ currentindenttype . getwidth ( ) ) $whitespace$ <= $whitespace$ column ) $whitespace$ { $newline$ $indentation$ newindent . insert ( $number$ , $whitespace$ currentindenttype . getcar ( ) ) ; $newline$ $indentation$ logicalindentlength $whitespace$ += $whitespace$ currentindenttype . getwidth ( ) ; $newline$ $indentation$ } $newline$ $indentation$ while $whitespace$ ( logicalindentlength $whitespace$ < $whitespace$ column ) $whitespace$ { $newline$ $indentation$ newindent . append ( indenttype . spaces . getcar ( ) ) ; $newline$ $indentation$ logicalindentlength ++ ; $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ fulltab $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ currentindenttype . getwidth ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ fulltab . append ( indenttype . spaces . getcar ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ fulltabstring $whitespace$ = $whitespace$ fulltab . tostring ( ) ; $newline$ $indentation$ if $whitespace$ ( ( newindent . length ( ) $whitespace$ >= $whitespace$ currentindenttype . getwidth ( ) ) $whitespace$ && $whitespace$ newindent . substring ( newindent . length ( ) $whitespace$ - $whitespace$ currentindenttype . getwidth ( ) ) . equals ( fulltabstring ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ newindent . indexof ( fulltabstring ) ; $newline$ $indentation$ newindent . replace ( i , $whitespace$ i $whitespace$ + $whitespace$ currentindenttype . getwidth ( ) , $whitespace$ currentindenttype . getcar ( ) . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ newindent . tostring ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ calculatenewwithalignto ( int $whitespace$ column ) { $newline$ $indentation$ if $whitespace$ ( column $whitespace$ < $whitespace$ lastprintednew. length ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ stringbuilder $whitespace$ newnew $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( lastprintednew ) ; $newline$ $indentation$ switch ( indentation. gettype ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ spaces : $newline$ $indentation$ case $whitespace$ tabs_with_space_align : $newline$ $indentation$ while $whitespace$ ( newnew. length ( ) $whitespace$ < $whitespace$ column ) $whitespace$ { $newline$ $indentation$ newnew. append ( indenttype. spaces. getcar ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ tabs : $newline$ $indentation$ indenttype $whitespace$ currentnewtype $whitespace$ = $whitespace$ indentation. gettype ( ) ; $newline$ $indentation$ int $whitespace$ logicalnewlength $whitespace$ = $whitespace$ newnew. length ( ) ; $newline$ $indentation$ while $whitespace$ ( ( logicalnewlength $whitespace$ + $whitespace$ currentnewtype. getwidth ( ) ) $whitespace$ <= $whitespace$ column ) $whitespace$ { $newline$ $indentation$ newnew. insert ( $number$, $whitespace$ currentnewtype. getcar ( ) ) ; $newline$ $indentation$ logicalnewlength $whitespace$ += $whitespace$ currentnewtype. getwidth ( ) ; $newline$ $indentation$ } $newline$ $indentation$ while $whitespace$ ( logicalnewlength $whitespace$ < $whitespace$ column )			
reindentWithAlignToCursor	254	258	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java	0.6039785146713257	MID	"		public void reindentWithAlignToCursor(){
		    String newIndent = calculateIndentWithAlignTo(cursor.column);
		    reindentedIndents.push(indents.pop());
		    indents.push(newIndent);
		}"	$indentation$ public $whitespace$ void $whitespace$ reindentwithaligntocursor ( ) { $newline$ $indentation$ string $whitespace$ newindent $whitespace$ = $whitespace$ calculateindentwithalignto ( cursor . column ) ; $newline$ $indentation$ reindentedindents . push ( indents . pop ( ) ) ; $newline$ $indentation$ indents . push ( newindent ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ renewwithaligntocursor ( ) { $newline$ $indentation$ string $whitespace$ newnew $whitespace$ = $whitespace$ calculatenewwithalignto ( cursor. column ) ; $newline$ $indentation$ renewedindentations. push ( indents. pop ( ) ) ; $newline$ $indentation$ indents. push ( newnew ) ; $newline$ $indentation$ }			
reindentToPreviousLevel	264	270	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java	0.7263520956039429	MID	"		public void reindentToPreviousLevel(){
		    if (reindentedIndents.isEmpty()) {
		        throw new IllegalStateException(""Reindent calls are not well-balanced."");
		    }
		    indents.pop();
		    indents.push(reindentedIndents.pop());
		}"	$indentation$ public $whitespace$ void $whitespace$ reindenttopreviouslevel ( ) { $newline$ $indentation$ if $whitespace$ ( reindentedindents . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ indents . pop ( ) ; $newline$ $indentation$ indents . push ( reindentedindents . pop ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ renewtopreviouslevel ( ) { $newline$ $indentation$ if $whitespace$ ( renewed ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ indents. pop ( ) ; $newline$ $indentation$ indents. push ( renewed ( ) ) ; $newline$ $indentation$ }			
println	193	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java	0.8666052222251892	HIGH	"		public SourcePrinter println(final String arg){
		    print(arg);
		    println();
		    return this;
		}"	$indentation$ public $whitespace$ sourceprinter $whitespace$ println ( final $whitespace$ string $whitespace$ arg ) { $newline$ $indentation$ print ( arg ) ; $newline$ $indentation$ println ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ sourceprinter $whitespace$ println ( final $whitespace$ string $whitespace$ arg ) { $newline$ $indentation$ print ( arg ) ; $newline$ $indentation$ println ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
unindent	144	152	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/SourcePrinter.java	0.9074339866638184	HIGH	"		public SourcePrinter unindent(){
		    if (indents.isEmpty()) {
		        // Since we start out with an empty indent on the stack, this will only occur
		        // the second time we over-unindent.
		        throw new IllegalStateException(""Indent/unindent calls are not well-balanced."");
		    }
		    indents.pop();
		    return this;
		}"	$indentation$ public $whitespace$ sourceprinter $whitespace$ unindent ( ) { $newline$ $indentation$ if $whitespace$ ( indents . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·since·we·start·out·with·an·empty·indent·on·the·stack,·this·will·only·occur$ $newline$ $indentation$ $//·the·second·time·we·over-unindent.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ indents . pop ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ sourceprinter $whitespace$ unnew ( ) { $newline$ $indentation$ if $whitespace$ ( indents. isempty ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ the $whitespace$ classes $whitespace$ as $whitespace$ used $whitespace$ to $whitespace$ determine $whitespace$ a $whitespace$ generic $whitespace$ exception $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ immediately $whitespace$ every $whitespace$ 3 $whitespace$ seconds $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ indents. pop ( ) ; $			
outputNode	172	247	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/XmlPrinter.java	0.0361410528421402	LOW	"		public void outputNode(Node node, String name, XMLStreamWriter xmlWriter) throws XMLStreamException{
		    assertNotNull(node);
		    assertNonEmpty(name);
		    assertNotNull(xmlWriter);
		    NodeMetaModel metaModel = node.getMetaModel();
		    List<PropertyMetaModel> allPropertyMetaModels = metaModel.getAllPropertyMetaModels();
		    Predicate<PropertyMetaModel> nonNullNode = propertyMetaModel -> propertyMetaModel.getValue(node) != null;
		    Predicate<PropertyMetaModel> nonEmptyList = propertyMetaModel -> ((NodeList) propertyMetaModel.getValue(node)).isNonEmpty();
		    Predicate<PropertyMetaModel> typeList = propertyMetaModel -> TYPE_CLASS == propertyMetaModel.getType();
		    xmlWriter.writeStartElement(name);
		    // Output node type attribute
		    if (outputNodeType) {
		        xmlWriter.writeAttribute(""type"", metaModel.getTypeName());
		    }
		    try {
		        // Output attributes
		        allPropertyMetaModels.stream().filter(PropertyMetaModel::isAttribute).filter(PropertyMetaModel::isSingular).forEach(attributeMetaModel -> {
		            try {
		                final String attributeName = attributeMetaModel.getName();
		                final String attributeValue = attributeMetaModel.getValue(node).toString();
		                xmlWriter.writeAttribute(attributeName, attributeValue);
		            } catch (XMLStreamException ex) {
		                throw new RuntimeXMLStreamException(ex);
		            }
		        });
		        // Output singular subNodes
		        allPropertyMetaModels.stream().filter(PropertyMetaModel::isNode).filter(PropertyMetaModel::isSingular).filter(nonNullNode).forEach(subNodeMetaModel -> {
		            try {
		                final Node subNode = (Node) subNodeMetaModel.getValue(node);
		                final String subNodeName = subNodeMetaModel.getName();
		                outputNode(subNode, subNodeName, xmlWriter);
		            } catch (XMLStreamException ex) {
		                throw new RuntimeXMLStreamException(ex);
		            }
		        });
		        // Output list subNodes
		        allPropertyMetaModels.stream().filter(PropertyMetaModel::isNodeList).filter(nonNullNode).filter(nonEmptyList.or(typeList)).forEach(listMetaModel -> {
		            try {
		                String listName = listMetaModel.getName();
		                String singular = listName.substring(0, listName.length() - 1);
		                NodeList<? extends Node> nodeList = (NodeList) listMetaModel.getValue(node);
		                xmlWriter.writeStartElement(listName);
		                for (Node subNode : nodeList) {
		                    outputNode(subNode, singular, xmlWriter);
		                }
		                xmlWriter.writeEndElement();
		            } catch (XMLStreamException ex) {
		                throw new RuntimeXMLStreamException(ex);
		            }
		        });
		    } catch (RuntimeXMLStreamException ex) {
		        throw ex.getXMLStreamCause();
		    }
		    xmlWriter.writeEndElement();
		}"	$indentation$ public $whitespace$ void $whitespace$ outputnode ( node $whitespace$ node , $whitespace$ string $whitespace$ name , $whitespace$ xmlstreamwriter $whitespace$ xmlwriter ) $whitespace$ throws $whitespace$ xmlstreamexception { $newline$ $indentation$ assertnotnull ( node ) ; $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ assertnotnull ( xmlwriter ) ; $newline$ $indentation$ nodemetamodel $whitespace$ metamodel $whitespace$ = $whitespace$ node . getmetamodel ( ) ; $newline$ $indentation$ list < propertymetamodel > $whitespace$ allpropertymetamodels $whitespace$ = $whitespace$ metamodel . getallpropertymetamodels ( ) ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ nonnullnode $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ propertymetamodel . getvalue ( node ) $whitespace$ != $whitespace$ null ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ nonemptylist $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ ( ( nodelist ) $whitespace$ propertymetamodel . getvalue ( node ) ) . isnonempty ( ) ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ typelist $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ type_class $whitespace$ == $whitespace$ propertymetamodel . gettype ( ) ; $newline$ $indentation$ xmlwriter . writestartelement ( name ) ; $newline$ $indentation$ $//·output·node·type·attribute$ $newline$ $indentation$ if $whitespace$ ( outputnodetype ) $whitespace$ { $newline$ $indentation$ xmlwriter . writeattribute ( $string$ , $whitespace$ metamodel . gettypename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $//·output·attributes$ $newline$ $indentation$ allpropertymetamodels . stream ( ) . filter ( propertymetamodel : : isattribute ) . filter ( propertymetamodel : : issingular ) . foreach ( attributemetamodel $whitespace$ - > $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ string $whitespace$ attributename $whitespace$ = $whitespace$ attributemetamodel . getname ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ attributevalue $whitespace$ = $whitespace$ attributemetamodel . getvalue ( node ) . tostring ( ) ; $newline$ $indentation$ xmlwriter . writeattribute ( attributename , $whitespace$ attributevalue ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( xmlstreamexception $whitespace$ ex ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimexmlstreamexception ( ex ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ $//·output·singular·subnodes$ $newline$ $indentation$ allpropertymetamodels . stream ( ) . filter ( propertymetamodel : : isnode ) . filter ( propertymetamodel : : issingular ) . filter ( nonnullnode ) . foreach ( subnodemetamodel $whitespace$ - > $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ node $whitespace$ subnode $whitespace$ = $whitespace$ ( node ) $whitespace$ subnodemetamodel . getvalue ( node ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ subnodename $whitespace$ = $whitespace$ subnodemetamodel . getname ( ) ; $newline$ $indentation$ outputnode ( subnode , $whitespace$ subnodename , $whitespace$ xmlwriter ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( xmlstreamexception $whitespace$ ex ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimexmlstreamexception ( ex ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ $//·output·list·subnodes$ $newline$ $indentation$ allpropertymetamodels . stream ( ) . filter ( propertymetamodel : : isnodelist ) . filter ( nonnullnode ) . filter ( nonemptylist . or ( typelist ) ) . foreach ( listmetamodel $whitespace$ - > $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ string $whitespace$ listname $whitespace$ = $whitespace$ listmetamodel . getname ( ) ; $newline$ $indentation$ string $whitespace$ singular $whitespace$ = $whitespace$ listname . substring ( $number$ , $whitespace$ listname . length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ nodelist < ? $whitespace$ extends $whitespace$ node > $whitespace$ nodelist $whitespace$ = $whitespace$ ( nodelist ) $whitespace$ listmetamodel . getvalue ( node ) ; $newline$ $indentation$ xmlwriter . writestartelement ( listname ) ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ subnode $whitespace$ : $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ outputnode ( subnode , $whitespace$ singular , $whitespace$ xmlwriter ) ; $newline$ $indentation$ } $newline$ $indentation$ xmlwriter . writeendelement ( ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( xmlstreamexception $whitespace$ ex ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimexmlstreamexception ( ex ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( runtimexmlstreamexception $whitespace$ ex ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ ex . getxmlstreamcause ( ) ; $newline$ $indentation$ } $newline$ $indentation$ xmlwriter . writeendelement ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ outputnode ( node $whitespace$ node, $whitespace$ string $whitespace$ name, $whitespace$ xmlstreamwriter $whitespace$ xmlwriter ) $whitespace$ throws $whitespace$ xmlstreamexception { $newline$ $indentation$ assertnotnull ( node ) ; $newline$ $indentation$ assertnonempty ( name ) ; $newline$ $indentation$ assertnotnull ( xmlwriter ) ; $newline$ $indentation$ nodemetamodel $whitespace$ metamodel $whitespace$ = $whitespace$ node. getmetamodel ( ) ; $newline$ $indentation$ list < propertymetamodel > $whitespace$ allpropertymetamodels $whitespace$ = $whitespace$ metamodel. getallpropertymetamodels ( ) ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ nonnullnode $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ propertymetamodel. getvalue ( node ) $whitespace$!= $whitespace$ null ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ nonemptylist $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ ( ( nodelist ) $whitespace$ propertymetamodel. getvalue ( node ) ). isnonempty ( ) ; $newline$ $indentation$ predicate < propertymetamodel > $whitespace$ typelist $whitespace$ = $whitespace$ propertymetamodel $whitespace$ - > $whitespace$ type_class $whitespace$ == $whitespace$ propertymetamodel. gettype ( ) ; $newline$ $indentation$ xmlwriter. writestartelement ( name ) ; $newline$ $indentation$ $////g_output_			
output	46	52	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/YamlPrinter.java	0.7036591172218323	MID	"		public String output(Node node){
		    StringBuilder output = new StringBuilder();
		    output.append(""---"");
		    output(node, ""root"", 0, output);
		    output.append(System.lineSeparator() + ""..."");
		    return output.toString();
		}"	$indentation$ public $whitespace$ string $whitespace$ output ( node $whitespace$ node ) { $newline$ $indentation$ stringbuilder $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ output . append ( $string$ ) ; $newline$ $indentation$ output ( node , $whitespace$ $string$ , $whitespace$ $number$ , $whitespace$ output ) ; $newline$ $indentation$ output . append ( system . lineseparator ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ output . tostring ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ string $whitespace$ output ( node $whitespace$ node ) { $newline$ $indentation$ stringbuilder $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ output. append ( $string$ ) ; $newline$ $indentation$ output ( node, $whitespace$ $string$, $whitespace$ $number$, $whitespace$ output ) ; $newline$ $indentation$ output. append ( system. lineseparator ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ return $whitespace$ output. tostring ( ) ; $newline$ $indentation$ }			
getTokenType	55	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmAttribute.java	0.1469925045967102	LOW	"		public int getTokenType(Node node, String text, String tokenText){
		    switch(property) {
		        case IDENTIFIER:
		            return GeneratedJavaParserConstants.IDENTIFIER;
		        case TYPE:
		            {
		                String expectedImage = ""\"""" + text.toLowerCase() + ""\"""";
		                for (int i = 0; i < GeneratedJavaParserConstants.tokenImage.length; i++) {
		                    if (GeneratedJavaParserConstants.tokenImage[i].equals(expectedImage)) {
		                        return i;
		                    }
		                }
		                throw new RuntimeException(f(""Attribute '%s' does not corresponding to any expected value. Text: %s"", property.camelCaseName(), text));
		            }
		        case KEYWORD:
		        case OPERATOR:
		            {
		                String expectedImage = ""\"""" + tokenText.toLowerCase() + ""\"""";
		                for (int i = 0; i < GeneratedJavaParserConstants.tokenImage.length; i++) {
		                    if (GeneratedJavaParserConstants.tokenImage[i].equals(expectedImage)) {
		                        return i;
		                    }
		                }
		                throw new RuntimeException(f(""Attribute '%s' does not corresponding to any expected value. Text: %s"", property.camelCaseName(), tokenText));
		            }
		        case VALUE:
		            if (node instanceof IntegerLiteralExpr) {
		                return GeneratedJavaParserConstants.INTEGER_LITERAL;
		            }
		        case NAME:
		            return GeneratedJavaParserConstants.IDENTIFIER;
		    }
		    throw new UnsupportedOperationException(""getTokenType does not know how to handle property "" + property + "" with text: "" + text);
		}"	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( node $whitespace$ node , $whitespace$ string $whitespace$ text , $whitespace$ string $whitespace$ tokentext ) { $newline$ $indentation$ switch ( property ) $whitespace$ { $newline$ $indentation$ case $whitespace$ identifier : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . identifier ; $newline$ $indentation$ case $whitespace$ type : $newline$ $indentation$ { $newline$ $indentation$ string $whitespace$ expectedimage $whitespace$ = $whitespace$ $string$ $string$ \ $string$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ generatedjavaparserconstants . tokenimage . length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( generatedjavaparserconstants . tokenimage [ i ] . equals ( expectedimage ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( f ( $string$ , $whitespace$ property . camelcasename ( ) , $whitespace$ text ) ) ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ keyword : $newline$ $indentation$ case $whitespace$ operator : $newline$ $indentation$ { $newline$ $indentation$ string $whitespace$ expectedimage $whitespace$ = $whitespace$ $string$ $string$ \ $string$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ generatedjavaparserconstants . tokenimage . length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( generatedjavaparserconstants . tokenimage [ i ] . equals ( expectedimage ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( f ( $string$ , $whitespace$ property . camelcasename ( ) , $whitespace$ tokentext ) ) ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ value : $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ integerliteralexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . integer_literal ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ name : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . identifier ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ property $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ text ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( node $whitespace$ node, $whitespace$ string $whitespace$ text, $whitespace$ string $whitespace$ tokentext ) { $newline$ $indentation$ switch ( property ) $whitespace$ { $newline$ $indentation$ case $whitespace$ identifier : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. identifier ; $newline$ $indentation$ case $whitespace$ type : $newline$ $indentation$ { $newline$ $indentation$ string $whitespace$ expectedimage $whitespace$ = $whitespace$ $string$ $string$ \ $string$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ generatedjavaparserconstants. tokenimage. length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( generatedjavaparserconstants. tokenimage [ i ]. equals ( expectedimage ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( f ( $string$, $whitespace$ property. camelcasename ( ), $whitespace$ text ) ) ; $newline$ $indentation$ } $newline$ $indentation$ case $whitespace$ keyword : $newline$ $indentation$ case $whitespace$ operator : $newline$ $indentation$ { $newline$ $indentation$ string $whitespace$ expectedimage $whitespace$ = $whitespace$ $string$ $string$ \ $string$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ generatedjavaparserconstants. tokenimage. length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$			
prettyPrint	43	47	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmAttribute.java	0.6370891332626343	MID	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    Object value = property.getRawValue(node);
		    printer.print(PrintingHelper.printToString(value));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ object $whitespace$ value $whitespace$ = $whitespace$ property . getrawvalue ( node ) ; $newline$ $indentation$ printer . print ( printinghelper . printtostring ( value ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ object $whitespace$ value $whitespace$ = $whitespace$ property. getrawvalue ( node ) ; $newline$ $indentation$ printer. print ( printinghelper. printtostring ( value ) ) ; $newline$ $indentation$ }			
prettyPrint	39	44	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmChar.java	0.693788468837738	MID	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    printer.print(""'"");
		    printer.print(property.getValueAsStringAttribute(node));
		    printer.print(""'"");
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer . print ( $string$ ) ; $newline$ $indentation$ printer . print ( property . getvalueasstringattribute ( node ) ) ; $newline$ $indentation$ printer . print ( $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer. print ( $string$ ) ; $newline$ $indentation$ printer. print ( property. getvalueasstringattribute ( node ) ) ; $newline$ $indentation$ printer. print ( $string$ ) ; $newline$ $indentation$ }			
prettyPrint	122	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmConditional.java	0.6983214020729065	MID	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    boolean test = false;
		    for (ObservableProperty prop : properties) {
		        test = test || condition.evaluate(node, prop);
		    }
		    if (test) {
		        thenElement.prettyPrint(node, printer);
		    } else {
		        elseElement.prettyPrint(node, printer);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ boolean $whitespace$ test $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( observableproperty $whitespace$ prop $whitespace$ : $whitespace$ properties ) $whitespace$ { $newline$ $indentation$ test $whitespace$ = $whitespace$ test $whitespace$ || $whitespace$ condition . evaluate ( node , $whitespace$ prop ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( test ) $whitespace$ { $newline$ $indentation$ thenelement . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ elseelement . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ boolean $whitespace$ test ; $newline$ $indentation$ for $whitespace$ ( observableproperty $whitespace$ prop $whitespace$ : $whitespace$ properties ) $whitespace$ { $newline$ $indentation$ test $whitespace$ = $whitespace$ test $whitespace$ || $whitespace$ condition. evaluate ( node, $whitespace$ prop ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( test ) $whitespace$ { $newline$ $indentation$ thenelement. prettyprint ( node, $whitespace$ printer ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ elseelement. prettyprint ( node, $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
prettyPrint	80	123	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmList.java	0.0650518909096717	LOW	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    if (property.isAboutNodes()) {
		        NodeList<? extends Node> nodeList = property.getValueAsMultipleReference(node);
		        if (nodeList == null) {
		            return;
		        }
		        if (!nodeList.isEmpty() && preceeding != null) {
		            preceeding.prettyPrint(node, printer);
		        }
		        for (int i = 0; i < nodeList.size(); i++) {
		            if (separatorPre != null && i != 0) {
		                separatorPre.prettyPrint(node, printer);
		            }
		            ConcreteSyntaxModel.genericPrettyPrint(nodeList.get(i), printer);
		            if (separatorPost != null && i != (nodeList.size() - 1)) {
		                separatorPost.prettyPrint(node, printer);
		            }
		        }
		        if (!nodeList.isEmpty() && following != null) {
		            following.prettyPrint(node, printer);
		        }
		    } else {
		        Collection<?> values = property.getValueAsCollection(node);
		        if (values == null) {
		            return;
		        }
		        if (!values.isEmpty() && preceeding != null) {
		            preceeding.prettyPrint(node, printer);
		        }
		        for (Iterator<?> it = values.iterator(); it.hasNext(); ) {
		            if (separatorPre != null && it.hasNext()) {
		                separatorPre.prettyPrint(node, printer);
		            }
		            printer.print(PrintingHelper.printToString(it.next()));
		            if (separatorPost != null && it.hasNext()) {
		                separatorPost.prettyPrint(node, printer);
		            }
		        }
		        if (!values.isEmpty() && following != null) {
		            following.prettyPrint(node, printer);
		        }
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ if $whitespace$ ( property . isaboutnodes ( ) ) $whitespace$ { $newline$ $indentation$ nodelist < ? $whitespace$ extends $whitespace$ node > $whitespace$ nodelist $whitespace$ = $whitespace$ property . getvalueasmultiplereference ( node ) ; $newline$ $indentation$ if $whitespace$ ( nodelist $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! nodelist . isempty ( ) $whitespace$ && $whitespace$ preceeding $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ preceeding . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodelist . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( separatorpre $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ i $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ separatorpre . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ concretesyntaxmodel . genericprettyprint ( nodelist . get ( i ) , $whitespace$ printer ) ; $newline$ $indentation$ if $whitespace$ ( separatorpost $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ i $whitespace$ != $whitespace$ ( nodelist . size ( ) $whitespace$ - $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ separatorpost . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! nodelist . isempty ( ) $whitespace$ && $whitespace$ following $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ following . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ collection < ? > $whitespace$ values $whitespace$ = $whitespace$ property . getvalueascollection ( node ) ; $newline$ $indentation$ if $whitespace$ ( values $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! values . isempty ( ) $whitespace$ && $whitespace$ preceeding $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ preceeding . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( iterator < ? > $whitespace$ it $whitespace$ = $whitespace$ values . iterator ( ) ; $whitespace$ it . hasnext ( ) ; $whitespace$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( separatorpre $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ it . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ separatorpre . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ printer . print ( printinghelper . printtostring ( it . next ( ) ) ) ; $newline$ $indentation$ if $whitespace$ ( separatorpost $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ it . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ separatorpost . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! values . isempty ( ) $whitespace$ && $whitespace$ following $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ following . prettyprint ( node , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ if $whitespace$ ( property. isaboutnodes ( ) ) $whitespace$ { $newline$ $indentation$ nodelist <? $whitespace$ extends $whitespace$ node > $whitespace$ nodelist $whitespace$ = $whitespace$ property. getvalueasmultiplereference ( node ) ; $newline$ $indentation$ if $whitespace$ ( nodelist $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! nodelist. isempty ( ) $whitespace$ && $whitespace$ preceeding $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ preceeding. prettyprint ( node, $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ concretesyntaxmodel. genericprettyprint ( nodelist. get ( i ), $whitespace$ printer ) ; $newline$ $indentation$ if $whitespace$ ( separatorpost $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ i $whitespace$!= $whitespace$ ( nodelist. size ( ) $whitespace$ - $whitespace$ $number$ )			
prettyPrint	34	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmOrphanCommentsEnding.java	0.266807496547699	LOW	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    List<Node> everything = new LinkedList<>();
		    everything.addAll(node.getChildNodes());
		    sortByBeginPosition(everything);
		    if (everything.isEmpty()) {
		        return;
		    }
		    int commentsAtEnd = 0;
		    boolean findingComments = true;
		    while (findingComments && commentsAtEnd < everything.size()) {
		        Node last = everything.get(everything.size() - 1 - commentsAtEnd);
		        findingComments = (last instanceof Comment);
		        if (findingComments) {
		            commentsAtEnd++;
		        }
		    }
		    for (int i = 0; i < commentsAtEnd; i++) {
		        Comment c = (Comment) everything.get(everything.size() - commentsAtEnd + i);
		        CsmComment.process(c, printer);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ everything . addall ( node . getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything . size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace$ { $newline$ $indentation$ commentsatend ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ commentsatend ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ comment $whitespace$ c $whitespace$ = $whitespace$ ( comment ) $whitespace$ everything . get ( everything . size ( ) $whitespace$ - $whitespace$ commentsatend $whitespace$ + $whitespace$ i ) ; $newline$ $indentation$ csmcomment . process ( c , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ list < node > $whitespace$ everything $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ everything. addall ( node. getchildnodes ( ) ) ; $newline$ $indentation$ sortbybeginposition ( everything ) ; $newline$ $indentation$ if $whitespace$ ( everything. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ commentsatend $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ findingcomments $whitespace$ = $whitespace$ true ; $newline$ $indentation$ while $whitespace$ ( findingcomments $whitespace$ && $whitespace$ commentsatend $whitespace$ < $whitespace$ everything. size ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ last $whitespace$ = $whitespace$ everything. get ( everything. size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ - $whitespace$ commentsatend ) ; $newline$ $indentation$ findingcomments $whitespace$ = $whitespace$ ( last $whitespace$ instanceof $whitespace$ comment ) ; $newline$ $indentation$ if $whitespace$ ( findingcomments ) $whitespace$ { $newline$ $indentation$ commentsatend ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ //find $whitespace$ the $whitespace$**************************************** $whitespace$ end $whitespace$ of $whitespace$ file $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ commentsatend ; $whitespace			
prettyPrint	40	46	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmSingleReference.java	0.6442071795463562	MID	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    Node child = property.getValueAsSingleReference(node);
		    if (child != null) {
		        ConcreteSyntaxModel.genericPrettyPrint(child, printer);
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ node $whitespace$ child $whitespace$ = $whitespace$ property . getvalueassinglereference ( node ) ; $newline$ $indentation$ if $whitespace$ ( child $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ concretesyntaxmodel . genericprettyprint ( child , $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ node $whitespace$ child $whitespace$ = $whitespace$ property. getvalueassinglereference ( node ) ; $newline$ $indentation$ if $whitespace$ ( child $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ concretesyntaxmodel. genericprettyprint ( child, $whitespace$ printer ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
prettyPrint	39	44	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmString.java	0.698462724685669	MID	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    printer.print(""\"""");
		    printer.print(property.getValueAsStringAttribute(node));
		    printer.print(""\"""");
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer . print ( $string$ $string$ \ $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer. print ( $string$ $string$ \ $string$ ) ; $newline$ $indentation$ }			
prettyPrint	39	47	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmTextBlock.java	0.9051125645637512	HIGH	"		@Override
		public void prettyPrint(Node node, SourcePrinter printer){
		    printer.print(""\""\""\"""");
		    // Per https://openjdk.java.net/jeps/378#1--Line-terminators, any 'CRLF' and 'CR' are turned into 'LF' before interpreting the text
		    printer.println();
		    // TODO: Confirm if we need to force this to use {@code \n} separators
		    printer.print(property.getValueAsStringAttribute(node));
		    printer.print(""\""\""\"""");
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ prettyprint ( node $whitespace$ node , $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer . print ( $string$ \ $string$ $string$ \ $string$ \ $string$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ void $whitespace$ prettyprint ( node $whitespace$ node, $whitespace$ sourceprinter $whitespace$ printer ) { $newline$ $indentation$ printer. print ( $string$ \ $string$ $string$ \ $string$ \ $string$ ) ; $newline$ $indentation$ }			
isCorrespondingElement	119	124	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmToken.java	0.1369354277849197	LOW	"		@Override
		public boolean isCorrespondingElement(TextElement textElement){
		    return (textElement instanceof TokenTextElement) && ((TokenTextElement) textElement).getTokenKind() == getTokenType() && ((TokenTextElement) textElement).getText().equals(getContent());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscorrespondingelement ( textelement $whitespace$ textelement ) { $newline$ $indentation$ return $whitespace$ ( textelement $whitespace$ instanceof $whitespace$ tokentextelement ) $whitespace$ && $whitespace$ ( ( tokentextelement ) $whitespace$ textelement ) . gettokenkind ( ) $whitespace$ == $whitespace$ gettokentype ( ) $whitespace$ && $whitespace$ ( ( tokentextelement ) $whitespace$ textelement ) . gettext ( ) . equals ( getcontent ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ iscorrespondingelement ( textelement $whitespace$ textelement ) { $newline$ $indentation$ return $whitespace$ ( textelement $whitespace$ instanceof $whitespace$ tokentextelement ) $whitespace$ && $whitespace$ ( ( tokentextelement ) $whitespace$ textelement ). gettokenkind ( ) $whitespace$ == $whitespace$ gettokentype ( ) $whitespace$ && $whitespace$ ( ( tokentextelement ) $whitespace$ textelement ). gettext ( ). equals ( getcontent ( ) ) ; $newline$ $indentation$ }			
hashCode	97	102	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/concretesyntaxmodel/CsmToken.java	0.7336499094963074	MID	"		@Override
		public int hashCode(){
		    int result = tokenType;
		    result = 31 * result + (content != null ? content.hashCode() : 0);
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ tokentype ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ ( content $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ content . hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ to_do ; $newline$ $indentation$ result $whitespace$ += $whitespace$ ( content $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ content. hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
equals	44	50	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/DefaultConfigurationOption.java	0.6924909353256226	MID	"		@Override
		public boolean equals(Object o){
		    if (o == null || !(o instanceof DefaultConfigurationOption))
		        return false;
		    DefaultConfigurationOption other = (DefaultConfigurationOption) o;
		    return configOption.equals(other.configOption);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ( o $whitespace$ instanceof $whitespace$ defaultconfigurationoption ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ defaultconfigurationoption $whitespace$ other $whitespace$ = $whitespace$ ( defaultconfigurationoption ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ configoption . equals ( other . configoption ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$! ( o $whitespace$ instanceof $whitespace$ defaultconfigurationoption ) ; $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$! ( o $whitespace$ instanceof $whitespace$ defaultconfigurationoption ) ; $newline$ $indentation$ if $whitespace$ ( isequals $whitespace$ || $whitespace$! isequals ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ defaultconfigurationoption $whitespace$ other $whitespace$ = $whitespace$ ( defaultconfigurationoption ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ configoption. equals ( other. configoption ) ; $newline$ $indentation$ }			
removeOption	138	142	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/DefaultPrinterConfiguration.java	0.6785145998001099	MID	"		@Override
		public PrinterConfiguration removeOption(ConfigurationOption option){
		    defaultOptions.remove(option);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ printerconfiguration $whitespace$ removeoption ( configurationoption $whitespace$ option ) { $newline$ $indentation$ defaultoptions . remove ( option ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ printerconfiguration $whitespace$ removeoption ( configurationoption $whitespace$ option ) { $newline$ $indentation$ defaultoptions. remove ( option ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
addOption	128	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/DefaultPrinterConfiguration.java	0.6852333545684814	MID	"		@Override
		public PrinterConfiguration addOption(ConfigurationOption option){
		    removeOption(option);
		    defaultOptions.add(option);
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ printerconfiguration $whitespace$ addoption ( configurationoption $whitespace$ option ) { $newline$ $indentation$ removeoption ( option ) ; $newline$ $indentation$ defaultoptions . add ( option ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ printerconfiguration $whitespace$ addoption ( configurationoption $whitespace$ option ) { $newline$ $indentation$ removeoption ( option ) ; $newline$ $indentation$ defaultoptions. add ( option ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
format	141	148	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/Indentation.java	0.6588974595069885	MID	"		private void format(){
		    StringBuilder indentString = new StringBuilder();
		    char indentChar = type.car;
		    for (int i = 0; i < size; i++) {
		        indentString.append(indentChar);
		    }
		    formattedIndentation = indentString.toString();
		}"	$indentation$ private $whitespace$ void $whitespace$ format ( ) { $newline$ $indentation$ stringbuilder $whitespace$ indentstring $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ char $whitespace$ indentchar $whitespace$ = $whitespace$ type . car ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ size ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentstring . append ( indentchar ) ; $newline$ $indentation$ } $newline$ $indentation$ formattedindentation $whitespace$ = $whitespace$ indentstring . tostring ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ format ( ) { $newline$ $indentation$ stringbuilder $whitespace$ indentstring $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ size ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentstring. append ( indentchar ) ; $newline$ $indentation$ } $newline$ $indentation$ formatted ( $string$ ) ; $newline$ $indentation$ }			
setType	123	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/Indentation.java	0.878553032875061	HIGH	"		public Indentation setType(IndentType type){
		    this.type = type;
		    format();
		    return this;
		}"	$indentation$ public $whitespace$ indentation $whitespace$ settype ( indenttype $whitespace$ type ) { $newline$ $indentation$ this . type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ format ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ indentation $whitespace$ settype ( indenttype $whitespace$ type ) { $newline$ $indentation$ this. type $whitespace$ = $whitespace$ type ; $newline$ $indentation$ format ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setSize	110	114	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/Indentation.java	0.9259000420570374	HIGH	"		public Indentation setSize(int size){
		    this.size = size;
		    format();
		    return this;
		}"	$indentation$ public $whitespace$ indentation $whitespace$ setsize ( int $whitespace$ size ) { $newline$ $indentation$ this . size $whitespace$ = $whitespace$ size ; $newline$ $indentation$ format ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ indentation $whitespace$ setsize ( int $whitespace$ size ) { $newline$ $indentation$ this. size $whitespace$ = $whitespace$ size ; $newline$ $indentation$ format ( ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
setTabWidth	124	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/PrettyPrinterConfiguration.java	0.6773779988288879	MID	"		@Deprecated
		public PrettyPrinterConfiguration setTabWidth(int tabWidth){
		    setIndentSize(assertPositive(tabWidth));
		    return this;
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ prettyprinterconfiguration $whitespace$ settabwidth ( int $whitespace$ tabwidth ) { $newline$ $indentation$ setindentsize ( assertpositive ( tabwidth ) ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ prettyprinterconfiguration $whitespace$ settabwidth ( int $whitespace$ tabwidth ) { $newline$ $indentation$ setnewsize ( tabwidth ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
sortImports	38	48	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/imports/DefaultImportOrderingStrategy.java	0.0657090470194816	LOW	"		@Override
		public List<NodeList<ImportDeclaration>> sortImports(NodeList<ImportDeclaration> nodes){
		    if (sortImportsAlphabetically) {
		        Comparator<ImportDeclaration> sortLogic = comparingInt((ImportDeclaration i) -> i.isStatic() ? 0 : 1).thenComparing(NodeWithName::getNameAsString);
		        nodes.sort(sortLogic);
		    }
		    return Collections.singletonList(nodes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ if $whitespace$ ( sortimportsalphabetically ) $whitespace$ { $newline$ $indentation$ comparator < importdeclaration > $whitespace$ sortlogic $whitespace$ = $whitespace$ comparingint ( ( importdeclaration $whitespace$ i ) $whitespace$ - > $whitespace$ i . isstatic ( ) $whitespace$ ? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ) . thencomparing ( nodewithname : : getnameasstring ) ; $newline$ $indentation$ nodes . sort ( sortlogic ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . singletonlist ( nodes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ boolean $whitespace$ isimports $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( sortimportsalphabetically ) $whitespace$ { $newline$ $indentation$ comparator < importdeclaration > $whitespace$ sortlogic $whitespace$ = $whitespace$ comparingint ( ( importdeclaration $whitespace$ i ) $whitespace$ - > $whitespace$ i. isstatic ( ) $whitespace$? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ). thencomparing ( nodewithname : : getnameasstring ) ; $newline$ $indentation$ nodes. sort ( sortlogic ) ; $newline$ $indentation$ return $whitespace$ collections. singletonlist ( nodes ) ; $newline$ $indentation$ }			
sortImports	36	80	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/imports/EclipseImportOrderingStrategy.java	0.0813935846090316	LOW	"		@Override
		public List<NodeList<ImportDeclaration>> sortImports(NodeList<ImportDeclaration> nodes){
		    NodeList<ImportDeclaration> staticImports = new NodeList<>();
		    NodeList<ImportDeclaration> javaImports = new NodeList<>();
		    NodeList<ImportDeclaration> javaXImports = new NodeList<>();
		    NodeList<ImportDeclaration> orgImports = new NodeList<>();
		    NodeList<ImportDeclaration> comImports = new NodeList<>();
		    NodeList<ImportDeclaration> otherImports = new NodeList<>();
		    for (ImportDeclaration importDeclaration : nodes) {
		        // Check if is a static import
		        if (importDeclaration.isStatic()) {
		            staticImports.add(importDeclaration);
		            continue;
		        }
		        String importName = importDeclaration.getNameAsString();
		        if (importName.startsWith(""java."")) {
		            javaImports.add(importDeclaration);
		        } else if (importName.startsWith(""javax."")) {
		            javaXImports.add(importDeclaration);
		        } else if (importName.startsWith(""org."")) {
		            orgImports.add(importDeclaration);
		        } else if (importName.startsWith(""com."")) {
		            comImports.add(importDeclaration);
		        } else {
		            otherImports.add(importDeclaration);
		        }
		    }
		    if (sortImportsAlphabetically) {
		        Comparator<ImportDeclaration> sortLogic = Comparator.comparing(NodeWithName::getNameAsString);
		        staticImports.sort(sortLogic);
		        javaImports.sort(sortLogic);
		        javaXImports.sort(sortLogic);
		        orgImports.sort(sortLogic);
		        comImports.sort(sortLogic);
		        otherImports.sort(sortLogic);
		    }
		    return Arrays.asList(staticImports, javaImports, javaXImports, orgImports, comImports, otherImports);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ staticimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaximports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ orgimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ comimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ otherimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ nodes ) $whitespace$ { $newline$ $indentation$ $//·check·if·is·a·static·import$ $newline$ $indentation$ if $whitespace$ ( importdeclaration . isstatic ( ) ) $whitespace$ { $newline$ $indentation$ staticimports . add ( importdeclaration ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ importname $whitespace$ = $whitespace$ importdeclaration . getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( importname . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ javaimports . add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( importname . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ javaximports . add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( importname . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ orgimports . add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( importname . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ comimports . add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ otherimports . add ( importdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( sortimportsalphabetically ) $whitespace$ { $newline$ $indentation$ comparator < importdeclaration > $whitespace$ sortlogic $whitespace$ = $whitespace$ comparator . comparing ( nodewithname : : getnameasstring ) ; $newline$ $indentation$ staticimports . sort ( sortlogic ) ; $newline$ $indentation$ javaimports . sort ( sortlogic ) ; $newline$ $indentation$ javaximports . sort ( sortlogic ) ; $newline$ $indentation$ orgimports . sort ( sortlogic ) ; $newline$ $indentation$ comimports . sort ( sortlogic ) ; $newline$ $indentation$ otherimports . sort ( sortlogic ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ arrays . aslist ( staticimports , $whitespace$ javaimports , $whitespace$ javaximports , $whitespace$ orgimports , $whitespace$ comimports , $whitespace$ otherimports ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaximports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ orgimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ otherimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ nodes ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////check $whitespace$ if $whitespace$ ( importdeclaration. isstatic ( ) ) $whitespace$ { $newline$ $indentation$ staticimports. add ( importdeclaration ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ importname $whitespace$ = $whitespace$ importdeclaration. getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( importname			
sortImports	36	68	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/configuration/imports/IntelliJImportOrderingStrategy.java	0.2758766114711761	LOW	"		@Override
		public List<NodeList<ImportDeclaration>> sortImports(NodeList<ImportDeclaration> nodes){
		    NodeList<ImportDeclaration> otherImports = new NodeList<>();
		    NodeList<ImportDeclaration> javaImports = new NodeList<>();
		    NodeList<ImportDeclaration> staticImports = new NodeList<>();
		    for (ImportDeclaration importDeclaration : nodes) {
		        // Check if is a static import
		        if (importDeclaration.isStatic()) {
		            staticImports.add(importDeclaration);
		            continue;
		        }
		        String importName = importDeclaration.getNameAsString();
		        if (importName.startsWith(""java."") || importName.startsWith(""javax."")) {
		            javaImports.add(importDeclaration);
		        } else {
		            otherImports.add(importDeclaration);
		        }
		    }
		    if (sortImportsAlphabetically) {
		        Comparator<ImportDeclaration> sortLogic = Comparator.comparing(NodeWithName::getNameAsString);
		        otherImports.sort(sortLogic);
		        javaImports.sort(sortLogic);
		        staticImports.sort(sortLogic);
		    }
		    return Arrays.asList(otherImports, javaImports, staticImports);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ otherimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ staticimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ nodes ) $whitespace$ { $newline$ $indentation$ $//·check·if·is·a·static·import$ $newline$ $indentation$ if $whitespace$ ( importdeclaration . isstatic ( ) ) $whitespace$ { $newline$ $indentation$ staticimports . add ( importdeclaration ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ importname $whitespace$ = $whitespace$ importdeclaration . getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( importname . startswith ( $string$ ) $whitespace$ || $whitespace$ importname . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ javaimports . add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ otherimports . add ( importdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( sortimportsalphabetically ) $whitespace$ { $newline$ $indentation$ comparator < importdeclaration > $whitespace$ sortlogic $whitespace$ = $whitespace$ comparator . comparing ( nodewithname : : getnameasstring ) ; $newline$ $indentation$ otherimports . sort ( sortlogic ) ; $newline$ $indentation$ javaimports . sort ( sortlogic ) ; $newline$ $indentation$ staticimports . sort ( sortlogic ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ arrays . aslist ( otherimports , $whitespace$ javaimports , $whitespace$ staticimports ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < nodelist < importdeclaration >> $whitespace$ sortimports ( nodelist < importdeclaration > $whitespace$ nodes ) { $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ otherimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ nodelist < importdeclaration > $whitespace$ javaimports $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ nodes ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdeclaration. isstatic ( ) ) $whitespace$ { $newline$ $indentation$ staticimports. add ( importdeclaration ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ importname $whitespace$ = $whitespace$ importdeclaration. getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( importname. startswith ( $string$ ) $whitespace$ || $whitespace$ importname. startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ javaimports. add ( importdeclaration ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ otherimports. add ( importdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( sortimportsalphabetically )			
equals	63	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/ChildTextElement.java	0.7238441109657288	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ChildTextElement that = (ChildTextElement) o;
		    return child.equals(that.child);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ childtextelement $whitespace$ that $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ child . equals ( that . child ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ childtextelement $whitespace$ that $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ child. equals ( that. child ) ; $newline$ $indentation$ }			
applyRemovedDiffElement	476	598	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.000117227937153	LOW	"		private void applyRemovedDiffElement(RemovedGroup removedGroup, Removed removed, TextElement originalElement, boolean originalElementIsChild, boolean originalElementIsToken){
		    if (removed.isChild() && originalElementIsChild) {
		        ChildTextElement originalElementChild = (ChildTextElement) originalElement;
		        if (originalElementChild.isComment()) {
		            // We expected to remove a proper node but we found a comment in between.
		            // If the comment is associated to the node we want to remove we remove it as well, otherwise we keep it
		            Comment comment = (Comment) originalElementChild.getChild();
		            if (!comment.isOrphan() && comment.getCommentedNode().isPresent() && comment.getCommentedNode().get().equals(removed.getChild())) {
		                nodeText.removeElement(originalIndex);
		            } else {
		                originalIndex++;
		            }
		        } else {
		            // If we delete the first element, it is possible that there is an indentation to be deleted which is stored in the parent node.
		            NodeText parentNodeText = new NodeText();
		            List<TextElement> indentationTokens = new ArrayList<>();
		            if (originalIndex == 0 && removed.getChild().getParentNode().isPresent()) {
		                Node startingNodeForFindingIndentation = removed.getChild();
		                Node parentNode = removed.getChild().getParentNode().get();
		                parentNodeText = LexicalPreservingPrinter.getOrCreateNodeText(parentNode);
		                // If we are trying to delete the first element of a node and that node is also the first element of the parent node, we need to look for the grandfather node which logically contains the indentation characters.
		                // This is the case, for example, when trying to delete an annotation positioned on a method declaration.
		                // The token corresponding to the annotation is the first element of the annotation node
		                // and it is also the first element of the parent node (MethodDeclaration),
		                // so the previous indentation is defined in the parent node of the method declaration.
		                if (!parentNodeText.getElements().isEmpty() && parentNode.getParentNode().isPresent() && parentNodeText.getTextElement(0).equals(nodeText.getTextElement(originalIndex))) {
		                    startingNodeForFindingIndentation = parentNode;
		                    parentNodeText = LexicalPreservingPrinter.getOrCreateNodeText(parentNode.getParentNode().get());
		                }
		                indentationTokens = LexicalPreservingPrinter.findIndentation(startingNodeForFindingIndentation);
		            }
		            nodeText.removeElement(originalIndex);
		            // When we don't try to remove a complete line
		            // and removing the element is not the first action of a replacement (removal followed by addition)
		            // (in the latter case we keep the indentation)
		            // then we want to enforce the indentation.
		            if (isEnforcingIndentationActivable(removedGroup)) {
		                // Since the element has been deleted we try to start the analysis from the element following the one that was deleted
		                originalIndex = considerEnforcingIndentation(nodeText, originalIndex);
		            }
		            // If in front we have one space and before also we had space let's drop one space
		            if (originalElements.size() > originalIndex && originalIndex > 0) {
		                if (originalElements.get(originalIndex).isWhiteSpace() && originalElements.get(originalIndex - 1).isWhiteSpace()) {
		                    // However we do not want to do that when we are about to adding or removing elements
		                    // The intention is not very clear maybe it should clarify this with examples!
		                    // Are we to understand that we can only do this if there is a single modification to process
		                    // OR or if the next change is to keep the element
		                    if ((diffIndex + 1) == diffElements.size() || (diffElements.get(diffIndex + 1).isKept())) {
		                        originalElements.remove(originalIndex--);
		                    }
		                }
		            }
		            // We need to know if, in the original list of elements, the deleted child node is immediately followed by the same comment.
		            // If so, it should also be deleted.
		            if (isFollowedByComment(originalIndex, originalElements)) {
		                int indexOfNextComment = posOfNextComment(originalIndex, originalElements);
		                removeElements(originalIndex, indexOfNextComment, originalElements);
		            }
		            if (isRemovingIndentationActivable(removedGroup)) {
		                // Since the element has been deleted we try to start the analysis from the previous element
		                originalIndex = considerRemovingIndentation(nodeText, originalIndex);
		                // If we delete the first element, it is possible that there is an indentation
		                // to be deleted which is stored in the parent node.
		                // We don't want to remove indentation when the node to remove is not the only
		                // node in the line (if there are other nodes before the next character
		                // indicating the end of line).
		                // This is for example the case when we want to delete an annotation declared on
		                // the same line as a method declaration.
		                if (originalIndex == 0 && !indentationTokens.isEmpty() && !isInlined(nodeText, originalIndex)) {
		                    for (TextElement indentationToken : indentationTokens) {
		                        parentNodeText.removeElement(parentNodeText.findElement(indentationToken.and(indentationToken.matchByRange())));
		                    }
		                }
		            }
		            diffIndex++;
		        }
		    } else if (removed.isChild() && originalElement.isComment()) {
		        // removing the comment first
		        nodeText.removeElement(originalIndex);
		        if (isRemovingIndentationActivable(removedGroup)) {
		            originalIndex = considerRemovingIndentation(nodeText, originalIndex);
		        }
		    } else if (removed.isToken() && originalElementIsToken && (// handle EOLs separately as their token kind might not be equal. This is because the 'removed'
		    removed.getTokenType() == ((TokenTextElement) originalElement).getTokenKind() || // element always has the current operating system's EOL as type
		    (((TokenTextElement) originalElement).getToken().getCategory().isEndOfLine() && removed.isNewLine()))) {
		        nodeText.removeElement(originalIndex);
		        diffIndex++;
		    } else if ((removed.isWhiteSpaceNotEol() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) && originalElement.isSpaceOrTab()) {
		        // remove the current space
		        nodeText.removeElement(originalIndex);
		    } else if (originalElementIsToken && originalElement.isWhiteSpaceOrComment()) {
		        originalIndex++;
		        // skip the newline token which may be generated unnecessarily by the concrete syntax pattern
		        if (removed.isNewLine()) {
		            diffIndex++;
		        }
		    } else if (originalElement.isLiteral()) {
		        nodeText.removeElement(originalIndex);
		        diffIndex++;
		    } else if (removed.isPrimitiveType()) {
		        if (originalElement.isPrimitive()) {
		            nodeText.removeElement(originalIndex);
		            diffIndex++;
		        } else {
		            throw new UnsupportedOperationException(""removed "" + removed.getElement() + "" vs "" + originalElement);
		        }
		    } else if (removed.isWhiteSpace() || removed.getElement() instanceof CsmIndent || removed.getElement() instanceof CsmUnindent) {
		        diffIndex++;
		    } else if (originalElement.isWhiteSpace()) {
		        originalIndex++;
		    } else if (removed.isChild()) {
		        // see issue #3721 this case is linked for example to a change of type of variable declarator
		        nodeText.removeElement(originalIndex);
		        diffIndex++;
		    } else {
		        throw new UnsupportedOperationException(""removed "" + removed.getElement() + "" vs "" + originalElement);
		    }
		    cleanTheLineOfLeftOverSpace(removedGroup, removed);
		}"	$indentation$ private $whitespace$ void $whitespace$ applyremoveddiffelement ( removedgroup $whitespace$ removedgroup , $whitespace$ removed $whitespace$ removed , $whitespace$ textelement $whitespace$ originalelement , $whitespace$ boolean $whitespace$ originalelementischild , $whitespace$ boolean $whitespace$ originalelementistoken ) { $newline$ $indentation$ if $whitespace$ ( removed . ischild ( ) $whitespace$ && $whitespace$ originalelementischild ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ originalelementchild $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ originalelement ; $newline$ $indentation$ if $whitespace$ ( originalelementchild . iscomment ( ) ) $whitespace$ { $newline$ $indentation$ $//·we·expected·to·remove·a·proper·node·but·we·found·a·comment·in·between.$ $newline$ $indentation$ $//·if·the·comment·is·associated·to·the·node·we·want·to·remove·we·remove·it·as·well,·otherwise·we·keep·it$ $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ ( comment ) $whitespace$ originalelementchild . getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( ! comment . isorphan ( ) $whitespace$ && $whitespace$ comment . getcommentednode ( ) . ispresent ( ) $whitespace$ && $whitespace$ comment . getcommentednode ( ) . get ( ) . equals ( removed . getchild ( ) ) ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·if·we·delete·the·first·element,·it·is·possible·that·there·is·an·indentation·to·be·deleted·which·is·stored·in·the·parent·node.$ $newline$ $indentation$ nodetext $whitespace$ parentnodetext $whitespace$ = $whitespace$ new $whitespace$ nodetext ( ) ; $newline$ $indentation$ list < textelement > $whitespace$ indentationtokens $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ removed . getchild ( ) . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ startingnodeforfindingindentation $whitespace$ = $whitespace$ removed . getchild ( ) ; $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ removed . getchild ( ) . getparentnode ( ) . get ( ) ; $newline$ $indentation$ parentnodetext $whitespace$ = $whitespace$ lexicalpreservingprinter . getorcreatenodetext ( parentnode ) ; $newline$ $indentation$ $//·if·we·are·trying·to·delete·the·first·element·of·a·node·and·that·node·is·also·the·first·element·of·the·parent·node,·we·need·to·look·for·the·grandfather·node·which·logically·contains·the·indentation·characters.$ $newline$ $indentation$ $//·this·is·the·case,·for·example,·when·trying·to·delete·an·annotation·positioned·on·a·method·declaration.$ $newline$ $indentation$ $//·the·token·corresponding·to·the·annotation·is·the·first·element·of·the·annotation·node$ $newline$ $indentation$ $//·and·it·is·also·the·first·element·of·the·parent·node·(methoddeclaration),$ $newline$ $indentation$ $//·so·the·previous·indentation·is·defined·in·the·parent·node·of·the·method·declaration.$ $newline$ $indentation$ if $whitespace$ ( ! parentnodetext . getelements ( ) . isempty ( ) $whitespace$ && $whitespace$ parentnode . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ parentnodetext . gettextelement ( $number$ ) . equals ( nodetext . gettextelement ( originalindex ) ) ) $whitespace$ { $newline$ $indentation$ startingnodeforfindingindentation $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ parentnodetext $whitespace$ = $whitespace$ lexicalpreservingprinter . getorcreatenodetext ( parentnode . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ indentationtokens $whitespace$ = $whitespace$ lexicalpreservingprinter . findindentation ( startingnodeforfindingindentation ) ; $newline$ $indentation$ } $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ $//·when·we·don't·try·to·remove·a·complete·line$ $newline$ $indentation$ $//·and·removing·the·element·is·not·the·first·action·of·a·replacement·(removal·followed·by·addition)$ $newline$ $indentation$ $//·(in·the·latter·case·we·keep·the·indentation)$ $newline$ $indentation$ $//·then·we·want·to·enforce·the·indentation.$ $newline$ $indentation$ if $whitespace$ ( isenforcingindentationactivable ( removedgroup ) ) $whitespace$ { $newline$ $indentation$ $//·since·the·element·has·been·deleted·we·try·to·start·the·analysis·from·the·element·following·the·one·that·was·deleted$ $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ considerenforcingindentation ( nodetext , $whitespace$ originalindex ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·in·front·we·have·one·space·and·before·also·we·had·space·let's·drop·one·space$ $newline$ $indentation$ if $whitespace$ ( originalelements . size ( ) $whitespace$ > $whitespace$ originalindex $whitespace$ && $whitespace$ originalindex $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( originalelements . get ( originalindex ) . iswhitespace ( ) $whitespace$ && $whitespace$ originalelements . get ( originalindex $whitespace$ - $whitespace$ $number$ ) . iswhitespace ( ) ) $whitespace$ { $newline$ $indentation$ $//·however·we·do·not·want·to·do·that·when·we·are·about·to·adding·or·removing·elements$ $newline$ $indentation$ $//·the·intention·is·not·very·clear·maybe·it·should·clarify·this·with·examples!$ $newline$ $indentation$ $//·are·we·to·understand·that·we·can·only·do·this·if·there·is·a·single·modification·to·process$ $newline$ $indentation$ $//·or·or·if·the·next·change·is·to·keep·the·element$ $newline$ $indentation$ if $whitespace$ ( ( diffindex $whitespace$ + $whitespace$ $number$ ) $whitespace$ == $whitespace$ diffelements . size ( ) $whitespace$ || $whitespace$ ( diffelements . get ( diffindex $whitespace$ + $whitespace$ $number$ ) . iskept ( ) ) ) $whitespace$ { $newline$ $indentation$ originalelements . remove ( originalindex -- ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·we·need·to·know·if,·in·the·original·list·of·elements,·the·deleted·child·node·is·immediately·followed·by·the·same·comment.$ $newline$ $indentation$ $//·if·so,·it·should·also·be·deleted.$ $newline$ $indentation$ if $whitespace$ ( isfollowedbycomment ( originalindex , $whitespace$ originalelements ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ indexofnextcomment $whitespace$ = $whitespace$ posofnextcomment ( originalindex , $whitespace$ originalelements ) ; $newline$ $indentation$ removeelements ( originalindex , $whitespace$ indexofnextcomment , $whitespace$ originalelements ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isremovingindentationactivable ( removedgroup ) ) $whitespace$ { $newline$ $indentation$ $//·since·the·element·has·been·deleted·we·try·to·start·the·analysis·from·the·previous·element$ $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ considerremovingindentation ( nodetext , $whitespace$ originalindex ) ; $newline$ $indentation$ $//·if·we·delete·the·first·element,·it·is·possible·that·there·is·an·indentation$ $newline$ $indentation$ $//·to·be·deleted·which·is·stored·in·the·parent·node.$ $newline$ $indentation$ $//·we·don't·want·to·remove·indentation·when·the·node·to·remove·is·not·the·only$ $newline$ $indentation$ $//·node·in·the·line·(if·there·are·other·nodes·before·the·next·character$ $newline$ $indentation$ $//·indicating·the·end·of·line).$ $newline$ $indentation$ $//·this·is·for·example·the·case·when·we·want·to·delete·an·annotation·declared·on$ $newline$ $indentation$ $//·the·same·line·as·a·method·declaration.$ $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ ! indentationtokens . isempty ( ) $whitespace$ && $whitespace$ ! isinlined ( nodetext , $whitespace$ originalindex ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ indentationtoken $whitespace$ : $whitespace$ indentationtokens ) $whitespace$ { $newline$ $indentation$ parentnodetext . removeelement ( parentnodetext . findelement ( indentationtoken . and ( indentationtoken . matchbyrange ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( removed . ischild ( ) $whitespace$ && $whitespace$ originalelement . iscomment ( ) ) $whitespace$ { $newline$ $indentation$ $//·removing·the·comment·first$ $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ if $whitespace$ ( isremovingindentationactivable ( removedgroup ) ) $whitespace$ { $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ considerremovingindentation ( nodetext , $whitespace$ originalindex ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( removed . istoken ( ) $whitespace$ && $whitespace$ originalelementistoken $whitespace$ && $whitespace$ ( $//·handle·eols·separately·as·their·token·kind·might·not·be·equal.·this·is·because·the·'removed'$ $newline$ $indentation$ removed . gettokentype ( ) $whitespace$ == $whitespace$ ( ( tokentextelement ) $whitespace$ originalelement ) . gettokenkind ( ) $whitespace$ || $whitespace$ $//·element·always·has·the·current·operating·system's·eol·as·type$ $newline$ $indentation$ ( ( ( tokentextelement ) $whitespace$ originalelement ) . gettoken ( ) . getcategory ( ) . isendofline ( ) $whitespace$ && $whitespace$ removed . isnewline ( ) ) ) ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ( removed . iswhitespacenoteol ( ) $whitespace$ || $whitespace$ removed . getelement ( ) $whitespace$ instanceof $whitespace$ csmindent $whitespace$ || $whitespace$ removed . getelement ( ) $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ && $whitespace$ originalelement . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ $//·remove·the·current·space$ $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( originalelementistoken $whitespace$ && $whitespace$ originalelement . iswhitespaceorcomment ( ) ) $whitespace$ { $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ $//·skip·the·newline·token·which·may·be·generated·unnecessarily·by·the·concrete·syntax·pattern$ $newline$ $indentation$ if $whitespace$ ( removed . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( originalelement . isliteral ( ) ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( removed . isprimitivetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( originalelement . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ removed . getelement ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ originalelement ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( removed . iswhitespace ( ) $whitespace$ || $whitespace$ removed . getelement ( ) $whitespace$ instanceof $whitespace$ csmindent $whitespace$ || $whitespace$ removed . getelement ( ) $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( originalelement . iswhitespace ( ) ) $whitespace$ { $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( removed . ischild ( ) ) $whitespace$ { $newline$ $indentation$ $//·see·issue·#3721·this·case·is·linked·for·example·to·a·change·of·type·of·variable·declarator$ $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ removed . getelement ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ originalelement ) ; $newline$ $indentation$ } $newline$ $indentation$ cleanthelineofleftoverspace ( removedgroup , $whitespace$ removed ) ; $newline$ $indentation$ }	"$indentation$ private $whitespace$ void $whitespace$ applyremoveddiffelement ( removedgroup $whitespace$ removedgroup, $whitespace$ removed $whitespace$ removed, $whitespace$ textelement $whitespace$ originalelement, $whitespace$ boolean $whitespace$ originalelementischild, $whitespace$ boolean $whitespace$ originalelementistoken ) { $newline$ $indentation$ if $whitespace$ ( removed. ischild ( ) $whitespace$ && $whitespace$ originalelementischild ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ originalelementchild $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ originalelement ; $newline$ $indentation$ if $whitespace$ ( originalelementchild. iscomment ( ) ) $whitespace$ { $newline$ $indentation$ $////g$ $newline$ $indentation$ // $whitespace$ """"find $whitespace$ the $whitespace$ current $whitespace$ child $newline$ $indentation$ if $whitespace$ (! comment. isorphan ( ) $whitespace$ && $whitespace$ comment. getcommentednode ( ). ispresent ( ) $whitespace$ && $whitespace$ comment. getcommentednode ( ). get ( ). equals ( removed. getchild ( ) ) ) $whitespace$ { $newline$ $indentation$ nodetext. removeelement ( originalindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ originalelementchild. removeelement ( originalindex ) ; $newline$ $indentation$ } $newline$ $indentation$"			
applyAddedDiffElement	895	1015	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.0010942399967461	LOW	"		private void applyAddedDiffElement(Added added){
		    if (added.isIndent()) {
		        for (int i = 0; i < STANDARD_INDENTATION_SIZE; i++) {
		            indentation.add(new TokenTextElement(GeneratedJavaParserConstants.SPACE));
		        }
		        addedIndentation = true;
		        diffIndex++;
		        return;
		    }
		    if (added.isUnindent()) {
		        for (int i = 0; i < STANDARD_INDENTATION_SIZE && !indentation.isEmpty(); i++) {
		            indentation.remove(indentation.size() - 1);
		        }
		        addedIndentation = false;
		        diffIndex++;
		        return;
		    }
		    TextElement addedTextElement = added.toTextElement();
		    boolean used = false;
		    boolean isPreviousElementNewline = (originalIndex > 0) && originalElements.get(originalIndex - 1).isNewline();
		    if (isPreviousElementNewline) {
		        List<TextElement> elements = processIndentation(indentation, originalElements.subList(0, originalIndex - 1));
		        boolean nextIsRightBrace = nextIsRightBrace(originalIndex);
		        for (TextElement e : elements) {
		            if (!nextIsRightBrace && e instanceof TokenTextElement && originalElements.get(originalIndex).isToken(((TokenTextElement) e).getTokenKind())) {
		                originalIndex++;
		            } else {
		                nodeText.addElement(originalIndex++, e);
		            }
		        }
		    } else if (isAfterLBrace(nodeText, originalIndex) && !isAReplacement(diffIndex)) {
		        if (addedTextElement.isNewline()) {
		            used = true;
		        }
		        nodeText.addElement(originalIndex++, new TokenTextElement(TokenTypes.eolTokenKind()));
		        // This remove the space in ""{ }"" when adding a new line
		        while (originalIndex >= 2 && originalElements.get(originalIndex - 2).isSpaceOrTab()) {
		            originalElements.remove(originalIndex - 2);
		            originalIndex--;
		        }
		        for (TextElement e : processIndentation(indentation, originalElements.subList(0, originalIndex - 1))) {
		            nodeText.addElement(originalIndex++, e);
		        }
		        // Indentation is painful...
		        // Sometimes we want to force indentation: this is the case when indentation was expected but
		        // was actually not there. For example if we have ""{ }"" we would expect indentation but it is
		        // not there, so when adding new elements we force it. However if the indentation has been
		        // inserted by us in this transformation we do not want to insert it again
		        if (!addedIndentation) {
		            for (TextElement e : indentationBlock()) {
		                nodeText.addElement(originalIndex++, e);
		            }
		        }
		    }
		    if (!used) {
		        // Handling trailing comments
		        boolean sufficientTokensRemainToSkip = nodeText.numberOfElements() > originalIndex + 2;
		        boolean currentIsAComment = nodeText.getTextElement(originalIndex).isComment();
		        boolean previousIsAComment = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isComment();
		        boolean currentIsNewline = nodeText.getTextElement(originalIndex).isNewline();
		        boolean isFirstElement = originalIndex == 0;
		        boolean previousIsWhiteSpace = originalIndex > 0 && nodeText.getTextElement(originalIndex - 1).isWhiteSpace();
		        boolean commentIsBeforeAddedElement = currentIsAComment && addedTextElement.getRange().isPresent() && nodeText.getTextElement(originalIndex).getRange().map(range -> range.isBefore(addedTextElement.getRange().get())).orElse(false);
		        if (sufficientTokensRemainToSkip && currentIsAComment && commentIsBeforeAddedElement) {
		            // Need to get behind the comment:
		            // FIXME: Why 2? This comment and the next newline?
		            originalIndex += 2;
		            // Defer originalIndex increment
		            nodeText.addElement(originalIndex, addedTextElement);
		            // We want to adjust the indentation while considering the new element that we added
		            originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);
		            // Now we can increment
		            originalIndex++;
		        } else if (currentIsNewline && previousIsAComment) {
		            /*
		                 * Manage the case where we want to add an element, after an expression which is followed by a comment on the same line.
		                 * This is not the same case as the one who handles the trailing comments, because in this case the node text element is a new line (not a comment)
		                 * For example : {@code private String a; // this is a }
		                 */
		            // Insert after the new line which follows this comment.
		            originalIndex++;
		            // We want to adjust the indentation while considering the new element that we added
		            originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);
		            // Defer originalIndex increment
		            nodeText.addElement(originalIndex, addedTextElement);
		            // Now we can increment.
		            originalIndex++;
		        } else if (currentIsNewline && addedTextElement.isChild()) {
		            // here we want to place the new child element after the current new line character.
		            // Except if indentation has been inserted just before this step (in the case where isPreviousElementNewline is true)
		            // or if the previous character is a space (it could be the case if we want to replace a statement)
		            // Example 1 : if we insert a statement (a duplicated method call expression ) after this one <code>  value();\n\n</code>
		            // we want to have this result <code>  value();\n  value();\n</code> not <code>  value();\n  \nvalue();</code>
		            // Example 2 : if we want to insert a statement after this one <code>  \n</code> we want to have <code>  value();\n</code>
		            // not <code>  \nvalue();</code> --> this case appears on member replacement for example
		            if (!isPreviousElementNewline && !isFirstElement && !previousIsWhiteSpace) {
		                // Insert after the new line
		                originalIndex++;
		                // We want to adjust the indentation while considering the new element that we
		                // added
		                originalIndex = adjustIndentation(indentation, nodeText, originalIndex, false);
		            }
		            nodeText.addElement(originalIndex, addedTextElement);
		            originalIndex++;
		        } else {
		            nodeText.addElement(originalIndex, addedTextElement);
		            originalIndex++;
		        }
		    }
		    if (addedTextElement.isNewline()) {
		        boolean followedByUnindent = isFollowedByUnindent(diffElements, diffIndex);
		        boolean nextIsRightBrace = nextIsRightBrace(originalIndex);
		        boolean nextIsNewLine = originalElements.get(originalIndex).isNewline();
		        if ((!nextIsNewLine && !nextIsRightBrace) || followedByUnindent) {
		            originalIndex = adjustIndentation(indentation, nodeText, originalIndex, followedByUnindent);
		        }
		    }
		    diffIndex++;
		}"	"$indentation$ private $whitespace$ void $whitespace$ applyaddeddiffelement ( added $whitespace$ added ) { $newline$ $indentation$ if $whitespace$ ( added . isindent ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ standard_indentation_size ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation . add ( new $whitespace$ tokentextelement ( generatedjavaparserconstants . space ) ) ; $newline$ $indentation$ } $newline$ $indentation$ addedindentation $whitespace$ = $whitespace$ true ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( added . isunindent ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ standard_indentation_size $whitespace$ && $whitespace$ ! indentation . isempty ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation . remove ( indentation . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ addedindentation $whitespace$ = $whitespace$ false ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ textelement $whitespace$ addedtextelement $whitespace$ = $whitespace$ added . totextelement ( ) ; $newline$ $indentation$ boolean $whitespace$ used $whitespace$ = $whitespace$ false ; $newline$ $indentation$ boolean $whitespace$ ispreviouselementnewline $whitespace$ = $whitespace$ ( originalindex $whitespace$ > $whitespace$ $number$ ) $whitespace$ && $whitespace$ originalelements . get ( originalindex $whitespace$ - $whitespace$ $number$ ) . isnewline ( ) ; $newline$ $indentation$ if $whitespace$ ( ispreviouselementnewline ) $whitespace$ { $newline$ $indentation$ list < textelement > $whitespace$ elements $whitespace$ = $whitespace$ processindentation ( indentation , $whitespace$ originalelements . sublist ( $number$ , $whitespace$ originalindex $whitespace$ - $whitespace$ $number$ ) ) ; $newline$ $indentation$ boolean $whitespace$ nextisrightbrace $whitespace$ = $whitespace$ nextisrightbrace ( originalindex ) ; $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! nextisrightbrace $whitespace$ && $whitespace$ e $whitespace$ instanceof $whitespace$ tokentextelement $whitespace$ && $whitespace$ originalelements . get ( originalindex ) . istoken ( ( ( tokentextelement ) $whitespace$ e ) . gettokenkind ( ) ) ) $whitespace$ { $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ nodetext . addelement ( originalindex ++ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( isafterlbrace ( nodetext , $whitespace$ originalindex ) $whitespace$ && $whitespace$ ! isareplacement ( diffindex ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( addedtextelement . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ used $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ nodetext . addelement ( originalindex ++ , $whitespace$ new $whitespace$ tokentextelement ( tokentypes . eoltokenkind ( ) ) ) ; $newline$ $indentation$ $//·this·remove·the·space·in·""{·}""·when·adding·a·new·line$ $newline$ $indentation$ while $whitespace$ ( originalindex $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ originalelements . get ( originalindex $whitespace$ - $whitespace$ $number$ ) . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ originalelements . remove ( originalindex $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ originalindex -- ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ processindentation ( indentation , $whitespace$ originalelements . sublist ( $number$ , $whitespace$ originalindex $whitespace$ - $whitespace$ $number$ ) ) ) $whitespace$ { $newline$ $indentation$ nodetext . addelement ( originalindex ++ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·indentation·is·painful...$ $newline$ $indentation$ $//·sometimes·we·want·to·force·indentation:·this·is·the·case·when·indentation·was·expected·but$ $newline$ $indentation$ $//·was·actually·not·there.·for·example·if·we·have·""{·}""·we·would·expect·indentation·but·it·is$ $newline$ $indentation$ $//·not·there,·so·when·adding·new·elements·we·force·it.·however·if·the·indentation·has·been$ $newline$ $indentation$ $//·inserted·by·us·in·this·transformation·we·do·not·want·to·insert·it·again$ $newline$ $indentation$ if $whitespace$ ( ! addedindentation ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ indentationblock ( ) ) $whitespace$ { $newline$ $indentation$ nodetext . addelement ( originalindex ++ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! used ) $whitespace$ { $newline$ $indentation$ $//·handling·trailing·comments$ $newline$ $indentation$ boolean $whitespace$ sufficienttokensremaintoskip $whitespace$ = $whitespace$ nodetext . numberofelements ( ) $whitespace$ > $whitespace$ originalindex $whitespace$ + $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ currentisacomment $whitespace$ = $whitespace$ nodetext . gettextelement ( originalindex ) . iscomment ( ) ; $newline$ $indentation$ boolean $whitespace$ previousisacomment $whitespace$ = $whitespace$ originalindex $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ nodetext . gettextelement ( originalindex $whitespace$ - $whitespace$ $number$ ) . iscomment ( ) ; $newline$ $indentation$ boolean $whitespace$ currentisnewline $whitespace$ = $whitespace$ nodetext . gettextelement ( originalindex ) . isnewline ( ) ; $newline$ $indentation$ boolean $whitespace$ isfirstelement $whitespace$ = $whitespace$ originalindex $whitespace$ == $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ previousiswhitespace $whitespace$ = $whitespace$ originalindex $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ nodetext . gettextelement ( originalindex $whitespace$ - $whitespace$ $number$ ) . iswhitespace ( ) ; $newline$ $indentation$ boolean $whitespace$ commentisbeforeaddedelement $whitespace$ = $whitespace$ currentisacomment $whitespace$ && $whitespace$ addedtextelement . getrange ( ) . ispresent ( ) $whitespace$ && $whitespace$ nodetext . gettextelement ( originalindex ) . getrange ( ) . map ( range $whitespace$ - > $whitespace$ range . isbefore ( addedtextelement . getrange ( ) . get ( ) ) ) . orelse ( false ) ; $newline$ $indentation$ if $whitespace$ ( sufficienttokensremaintoskip $whitespace$ && $whitespace$ currentisacomment $whitespace$ && $whitespace$ commentisbeforeaddedelement ) $whitespace$ { $newline$ $indentation$ $//·need·to·get·behind·the·comment:$ $newline$ $indentation$ $//·fixme:·why·2?·this·comment·and·the·next·newline?$ $newline$ $indentation$ originalindex $whitespace$ += $whitespace$ $number$ ; $newline$ $indentation$ $//·defer·originalindex·increment$ $newline$ $indentation$ nodetext . addelement ( originalindex , $whitespace$ addedtextelement ) ; $newline$ $indentation$ $//·we·want·to·adjust·the·indentation·while·considering·the·new·element·that·we·added$ $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ adjustindentation ( indentation , $whitespace$ nodetext , $whitespace$ originalindex , $whitespace$ false ) ; $newline$ $indentation$ $//·now·we·can·increment$ $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( currentisnewline $whitespace$ && $whitespace$ previousisacomment ) $whitespace$ { $newline$ $indentation$ $/*····················*·manage·the·case·where·we·want·to·add·an·element,·after·an·expression·which·is·followed·by·a·comment·on·the·same·line.····················*·this·is·not·the·same·case·as·the·one·who·handles·the·trailing·comments,·because·in·this·case·the·node·text·element·is·a·new·line·(not·a·comment)····················*·for·example·:·{@code·private·string·a;·//·this·is·a·}····················*/$ $newline$ $indentation$ $//·insert·after·the·new·line·which·follows·this·comment.$ $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ $//·we·want·to·adjust·the·indentation·while·considering·the·new·element·that·we·added$ $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ adjustindentation ( indentation , $whitespace$ nodetext , $whitespace$ originalindex , $whitespace$ false ) ; $newline$ $indentation$ $//·defer·originalindex·increment$ $newline$ $indentation$ nodetext . addelement ( originalindex , $whitespace$ addedtextelement ) ; $newline$ $indentation$ $//·now·we·can·increment.$ $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( currentisnewline $whitespace$ && $whitespace$ addedtextelement . ischild ( ) ) $whitespace$ { $newline$ $indentation$ $//·here·we·want·to·place·the·new·child·element·after·the·current·new·line·character.$ $newline$ $indentation$ $//·except·if·indentation·has·been·inserted·just·before·this·step·(in·the·case·where·ispreviouselementnewline·is·true)$ $newline$ $indentation$ $//·or·if·the·previous·character·is·a·space·(it·could·be·the·case·if·we·want·to·replace·a·statement)$ $newline$ $indentation$ $//·example·1·:·if·we·insert·a·statement·(a·duplicated·method·call·expression·)·after·this·one·<code>··value();\n\n</code>$ $newline$ $indentation$ $//·we·want·to·have·this·result·<code>··value();\n··value();\n</code>·not·<code>··value();\n··\nvalue();</code>$ $newline$ $indentation$ $//·example·2·:·if·we·want·to·insert·a·statement·after·this·one·<code>··\n</code>·we·want·to·have·<code>··value();\n</code>$ $newline$ $indentation$ $//·not·<code>··\nvalue();</code>·-->·this·case·appears·on·member·replacement·for·example$ $newline$ $indentation$ if $whitespace$ ( ! ispreviouselementnewline $whitespace$ && $whitespace$ ! isfirstelement $whitespace$ && $whitespace$ ! previousiswhitespace ) $whitespace$ { $newline$ $indentation$ $//·insert·after·the·new·line$ $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ $//·we·want·to·adjust·the·indentation·while·considering·the·new·element·that·we$ $newline$ $indentation$ $//·added$ $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ adjustindentation ( indentation , $whitespace$ nodetext , $whitespace$ originalindex , $whitespace$ false ) ; $newline$ $indentation$ } $newline$ $indentation$ nodetext . addelement ( originalindex , $whitespace$ addedtextelement ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ nodetext . addelement ( originalindex , $whitespace$ addedtextelement ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( addedtextelement . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ followedbyunindent $whitespace$ = $whitespace$ isfollowedbyunindent ( diffelements , $whitespace$ diffindex ) ; $newline$ $indentation$ boolean $whitespace$ nextisrightbrace $whitespace$ = $whitespace$ nextisrightbrace ( originalindex ) ; $newline$ $indentation$ boolean $whitespace$ nextisnewline $whitespace$ = $whitespace$ originalelements . get ( originalindex ) . isnewline ( ) ; $newline$ $indentation$ if $whitespace$ ( ( ! nextisnewline $whitespace$ && $whitespace$ ! nextisrightbrace ) $whitespace$ || $whitespace$ followedbyunindent ) $whitespace$ { $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ adjustindentation ( indentation , $whitespace$ nodetext , $whitespace$ originalindex , $whitespace$ followedbyunindent ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ void $whitespace$ applyaddeddiffelement ( added $whitespace$ added ) { $newline$ $indentation$ if $whitespace$ ( added. isnew ( ) ) $whitespace$ { $newline$ $indentation$ indentation. add ( new $whitespace$ tokentextelement ( generatedjavaparserconstants. space ) ) ; $newline$ $indentation$ } $newline$ $indentation$ added. $whitespace$ = $whitespace$ true ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( added. isun ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ standard_new_size $whitespace$ && $whitespace$! indentation. isempty ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation. remove ( indentation. size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ textelement $whitespace$ addedtextelement $whitespace$ = $whitespace$ added. totextelement ( ) ; $newline$ $indentation$ boolean $whitespace$ used $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ standard_new_size $whitespace$ && $whitespace$! indentation. isempty ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation. remove ( indentation. size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ textelement $			
lastIndexOfEol	115	121	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.0307663325220346	LOW	"		 int lastIndexOfEol(List<TextElement> source){
		    return IntStream.range(0, source.size()).map(i -> source.size() - i - 1).filter(i -> source.get(i).isNewline()).findFirst().orElse(-1);
		}"	$indentation$ int $whitespace$ lastindexofeol ( list < textelement > $whitespace$ source ) { $newline$ $indentation$ return $whitespace$ intstream . range ( $number$ , $whitespace$ source . size ( ) ) . map ( i $whitespace$ - > $whitespace$ source . size ( ) $whitespace$ - $whitespace$ i $whitespace$ - $whitespace$ $number$ ) . filter ( i $whitespace$ - > $whitespace$ source . get ( i ) . isnewline ( ) ) . findfirst ( ) . orelse ( $number$ ) ; $newline$ $indentation$ }	$indentation$ int $whitespace$ lastindexofeol ( list < textelement > $whitespace$ source ) { $newline$ $indentation$ return $whitespace$ intstream. range ( $number$, $whitespace$ source. size ( ) ). map ( i $whitespace$ - > $whitespace$ source. size ( ) $whitespace$ - $whitespace$ i $whitespace$ - $whitespace$ $number$ ). filter ( i $whitespace$ - > $whitespace$ source. get ( i ). isnewline ( ) ). findfirst ( ). orelse ( $number$ ) ; $newline$ $indentation$ }			
adjustIndentation	1092	1110	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.0310897585004568	LOW	"		private int adjustIndentation(List<TextElement> indentation, NodeText nodeText, int nodeTextIndex, boolean followedByUnindent){
		    List<TextElement> indentationAdj = processIndentation(indentation, nodeText.getElements().subList(0, nodeTextIndex - 1));
		    if (nodeTextIndex < nodeText.numberOfElements() && nodeText.getTextElement(nodeTextIndex).isToken(RBRACE)) {
		        indentationAdj = indentationAdj.subList(0, indentationAdj.size() - Math.min(STANDARD_INDENTATION_SIZE, indentationAdj.size()));
		    } else if (followedByUnindent) {
		        indentationAdj = indentationAdj.subList(0, Math.max(0, indentationAdj.size() - STANDARD_INDENTATION_SIZE));
		    }
		    for (TextElement e : indentationAdj) {
		        if ((nodeTextIndex < nodeText.numberOfElements()) && nodeText.getTextElement(nodeTextIndex).isSpaceOrTab()) {
		            nodeTextIndex++;
		        } else {
		            nodeText.getElements().add(nodeTextIndex++, e);
		        }
		    }
		    if (nodeTextIndex < 0) {
		        throw new IllegalStateException();
		    }
		    return nodeTextIndex;
		}"	$indentation$ private $whitespace$ int $whitespace$ adjustindentation ( list < textelement > $whitespace$ indentation , $whitespace$ nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ nodetextindex , $whitespace$ boolean $whitespace$ followedbyunindent ) { $newline$ $indentation$ list < textelement > $whitespace$ indentationadj $whitespace$ = $whitespace$ processindentation ( indentation , $whitespace$ nodetext . getelements ( ) . sublist ( $number$ , $whitespace$ nodetextindex $whitespace$ - $whitespace$ $number$ ) ) ; $newline$ $indentation$ if $whitespace$ ( nodetextindex $whitespace$ < $whitespace$ nodetext . numberofelements ( ) $whitespace$ && $whitespace$ nodetext . gettextelement ( nodetextindex ) . istoken ( rbrace ) ) $whitespace$ { $newline$ $indentation$ indentationadj $whitespace$ = $whitespace$ indentationadj . sublist ( $number$ , $whitespace$ indentationadj . size ( ) $whitespace$ - $whitespace$ math . min ( standard_indentation_size , $whitespace$ indentationadj . size ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( followedbyunindent ) $whitespace$ { $newline$ $indentation$ indentationadj $whitespace$ = $whitespace$ indentationadj . sublist ( $number$ , $whitespace$ math . max ( $number$ , $whitespace$ indentationadj . size ( ) $whitespace$ - $whitespace$ standard_indentation_size ) ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ indentationadj ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( nodetextindex $whitespace$ < $whitespace$ nodetext . numberofelements ( ) ) $whitespace$ && $whitespace$ nodetext . gettextelement ( nodetextindex ) . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ nodetextindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ nodetext . getelements ( ) . add ( nodetextindex ++ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodetextindex $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nodetextindex ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ adjustnewation ( list < textelement > $whitespace$ indentation, $whitespace$ nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ nodetextindex, $whitespace$ boolean $whitespace$ followedbyunnew ) { $newline$ $indentation$ list < textelement > $whitespace$ indentationadj $whitespace$ = $whitespace$ processline ( indentation, $whitespace$ nodetext. getelements ( ). sublist ( $number$, $whitespace$ nodetextindex $whitespace$ - $whitespace$ $number$ ) ) ; $newline$ $indentation$ if $whitespace$ ( nodetextindex $whitespace$ < $whitespace$ nodetext. numberofelements ( ) $whitespace$ && $whitespace$ nodetext. gettextelement ( nodetextindex ). istoken ( rbrace ) ) $whitespace$ { $newline$ $indentation$ indentationadj $whitespace$ = $whitespace$ indentationadj. sublist ( $number$, $whitespace$ indentationadj. size ( ) $whitespace$ - $whitespace$ math. min ( standard_$ation_size, $whitespace$ indentationadj. size ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( followedbyunnew ) $whitespace$ { $newline$ $indentation$ indentationadj $whitespace$ = $whitespace$ indentationadj. sublist ( $number$, $whitespace$ math. max ( $number$, $whitespace$ indentationadj. size ( ) $whitespace$ - $whitespace$ standard_newline$ $indentation$_size ) ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ indentationadj ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( nodetextindex $whitespace$ < $whitespace$ nodetext. numberofelements ( ) ) $whitespace$ && $whitespace$ nodetext. gettextelement ( nodetextindex ). isspaceortab ( )			
apply	370	395	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.0752106234431266	LOW	"		 void apply(){
		    ReshuffledDiffElementExtractor.of(nodeText).extract(diffElements);
		    Map<Removed, RemovedGroup> removedGroups = combineRemovedElementsToRemovedGroups();
		    do {
		        boolean isLeftOverDiffElement = applyLeftOverDiffElements();
		        boolean isLeftOverOriginalElement = applyLeftOverOriginalElements();
		        if (!isLeftOverDiffElement && !isLeftOverOriginalElement) {
		            DifferenceElement diffElement = diffElements.get(diffIndex);
		            if (diffElement.isAdded()) {
		                applyAddedDiffElement((Added) diffElement);
		            } else {
		                TextElement originalElement = originalElements.get(originalIndex);
		                boolean originalElementIsChild = originalElement instanceof ChildTextElement;
		                boolean originalElementIsToken = originalElement instanceof TokenTextElement;
		                if (diffElement.isKept()) {
		                    applyKeptDiffElement((Kept) diffElement, originalElement, originalElementIsChild, originalElementIsToken);
		                } else if (diffElement.isRemoved()) {
		                    Removed removed = (Removed) diffElement;
		                    applyRemovedDiffElement(removedGroups.get(removed), removed, originalElement, originalElementIsChild, originalElementIsToken);
		                } else {
		                    throw new UnsupportedOperationException(""Unable to apply operations from "" + diffElement.getClass().getSimpleName() + "" to "" + originalElement.getClass().getSimpleName());
		                }
		            }
		        }
		    } while (diffIndex < diffElements.size() || originalIndex < originalElements.size());
		}"	$indentation$ void $whitespace$ apply ( ) { $newline$ $indentation$ reshuffleddiffelementextractor . of ( nodetext ) . extract ( diffelements ) ; $newline$ $indentation$ map < removed , $whitespace$ removedgroup > $whitespace$ removedgroups $whitespace$ = $whitespace$ combineremovedelementstoremovedgroups ( ) ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isleftoverdiffelement $whitespace$ = $whitespace$ applyleftoverdiffelements ( ) ; $newline$ $indentation$ boolean $whitespace$ isleftoveroriginalelement $whitespace$ = $whitespace$ applyleftoveroriginalelements ( ) ; $newline$ $indentation$ if $whitespace$ ( ! isleftoverdiffelement $whitespace$ && $whitespace$ ! isleftoveroriginalelement ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements . get ( diffindex ) ; $newline$ $indentation$ if $whitespace$ ( diffelement . isadded ( ) ) $whitespace$ { $newline$ $indentation$ applyaddeddiffelement ( ( added ) $whitespace$ diffelement ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ textelement $whitespace$ originalelement $whitespace$ = $whitespace$ originalelements . get ( originalindex ) ; $newline$ $indentation$ boolean $whitespace$ originalelementischild $whitespace$ = $whitespace$ originalelement $whitespace$ instanceof $whitespace$ childtextelement ; $newline$ $indentation$ boolean $whitespace$ originalelementistoken $whitespace$ = $whitespace$ originalelement $whitespace$ instanceof $whitespace$ tokentextelement ; $newline$ $indentation$ if $whitespace$ ( diffelement . iskept ( ) ) $whitespace$ { $newline$ $indentation$ applykeptdiffelement ( ( kept ) $whitespace$ diffelement , $whitespace$ originalelement , $whitespace$ originalelementischild , $whitespace$ originalelementistoken ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( diffelement . isremoved ( ) ) $whitespace$ { $newline$ $indentation$ removed $whitespace$ removed $whitespace$ = $whitespace$ ( removed ) $whitespace$ diffelement ; $newline$ $indentation$ applyremoveddiffelement ( removedgroups . get ( removed ) , $whitespace$ removed , $whitespace$ originalelement , $whitespace$ originalelementischild , $whitespace$ originalelementistoken ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ diffelement . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ originalelement . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ while $whitespace$ ( diffindex $whitespace$ < $whitespace$ diffelements . size ( ) $whitespace$ || $whitespace$ originalindex $whitespace$ < $whitespace$ originalelements . size ( ) ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ apply ( ) { $newline$ $indentation$ reshuffleddiffelementextractor. of ( nodetext ). extract ( diffelements ) ; $newline$ $indentation$ map < removed, $whitespace$ removedgroup > $whitespace$ removedgroups $whitespace$ = $whitespace$ combineremovedelementstoremovedgroups ( ) ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ for $whitespace$ ( char $whitespace$ v $whitespace$ : $whitespace$ moveleftoverdiffelement ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! isleftoverdiffelement $whitespace$ && $whitespace$! isleftoveroriginalelement ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements. get ( diffindex ) ; $newline$ $indentation$ if $whitespace$ ( diffelement. isadded ( ) ) $whitespace$ { $newline$ $indentation$ applyaddeddiffelement ( ( added ) $whitespace$ diffelement ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ textelement $whitespace$ originalelement $whitespace$ = $whitespace$ originalelements. get ( originalindex ) ; $newline$ $indentation$ boolean $whitespace$ originalelementischild $whitespace$ = $whitespace$ originalelement $whitespace$ instanceof $whitespace$ childtextelement ; $newline$ $indentation$ if $whitespace$ ( diffelement. iskept ( ) ) $whitespace$ { $newline$ $indentation$ applykeptdiffelement ( ( kept ) $whitespace$ diffelement, $whitespace$ originalelement, $whitespace$ originalelementischild, $whitespace$ originalelementistoken ) ;			
isRemovingIndentationActivable	252	256	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.1008119061589241	LOW	"		private boolean isRemovingIndentationActivable(RemovedGroup removedGroup){
		    return (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements, diffIndex).isAdded())) && originalIndex < originalElements.size() && removedGroup.isACompleteLine();
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isremovingindentationactivable ( removedgroup $whitespace$ removedgroup ) { $newline$ $indentation$ return $whitespace$ ( islastelement ( diffelements , $whitespace$ diffindex ) $whitespace$ || $whitespace$ ! ( nextdiffelement ( diffelements , $whitespace$ diffindex ) . isadded ( ) ) ) $whitespace$ && $whitespace$ originalindex $whitespace$ < $whitespace$ originalelements . size ( ) $whitespace$ && $whitespace$ removedgroup . isacompleteline ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isremoving ( removedgroup $whitespace$ removedgroup ) { $newline$ $indentation$ return $whitespace$ ( islastelement ( diffelements, $whitespace$ diffindex ) $whitespace$ || $whitespace$! ( nextdiffelement ( diffelements, $whitespace$ diffindex ). isadded ( ) ) ) $whitespace$ && $whitespace$ originalindex $whitespace$ < $whitespace$ originalelements. size ( ) $whitespace$ && $whitespace$ removedgroup. isacompleteline ( ) ; $newline$ $indentation$ }			
isEnforcingIndentationActivable	246	250	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.1014835089445114	LOW	"		private boolean isEnforcingIndentationActivable(RemovedGroup removedGroup){
		    return (isLastElement(diffElements, diffIndex) || !(nextDiffElement(diffElements, diffIndex).isAdded())) && originalIndex < originalElements.size() && !removedGroup.isACompleteLine();
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isenforcingindentationactivable ( removedgroup $whitespace$ removedgroup ) { $newline$ $indentation$ return $whitespace$ ( islastelement ( diffelements , $whitespace$ diffindex ) $whitespace$ || $whitespace$ ! ( nextdiffelement ( diffelements , $whitespace$ diffindex ) . isadded ( ) ) ) $whitespace$ && $whitespace$ originalindex $whitespace$ < $whitespace$ originalelements . size ( ) $whitespace$ && $whitespace$ ! removedgroup . isacompleteline ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isenforcingationationactivable ( removedgroup $whitespace$ removedgroup ) { $newline$ $indentation$ return $whitespace$ ( islastelement ( diffelements, $whitespace$ diffindex ) $whitespace$ || $whitespace$! ( nextdiffelement ( diffelements, $whitespace$ diffindex ). isadded ( ) ) ) $whitespace$ && $whitespace$ originalindex $whitespace$ < $whitespace$ originalelements. size ( ) $whitespace$ && $whitespace$! removedgroup. isacompleteline ( ) ; $newline$ $indentation$ }			
combineRemovedElementsToRemovedGroups	444	457	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.1133982688188552	LOW	"		private Map<Removed, RemovedGroup> combineRemovedElementsToRemovedGroups(){
		    Map<Integer, List<Removed>> removedElementsMap = groupConsecutiveRemovedElements();
		    List<RemovedGroup> removedGroups = new ArrayList<>();
		    for (Map.Entry<Integer, List<Removed>> entry : removedElementsMap.entrySet()) {
		        removedGroups.add(RemovedGroup.of(entry.getKey(), entry.getValue()));
		    }
		    Map<Removed, RemovedGroup> map = new HashMap<>();
		    for (RemovedGroup removedGroup : removedGroups) {
		        for (Removed index : removedGroup) {
		            map.put(index, removedGroup);
		        }
		    }
		    return map;
		}"	$indentation$ private $whitespace$ map < removed , $whitespace$ removedgroup > $whitespace$ combineremovedelementstoremovedgroups ( ) { $newline$ $indentation$ map < integer , $whitespace$ list < removed >> $whitespace$ removedelementsmap $whitespace$ = $whitespace$ groupconsecutiveremovedelements ( ) ; $newline$ $indentation$ list < removedgroup > $whitespace$ removedgroups $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( map . entry < integer , $whitespace$ list < removed >> $whitespace$ entry $whitespace$ : $whitespace$ removedelementsmap . entryset ( ) ) $whitespace$ { $newline$ $indentation$ removedgroups . add ( removedgroup . of ( entry . getkey ( ) , $whitespace$ entry . getvalue ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ map < removed , $whitespace$ removedgroup > $whitespace$ map $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( removedgroup $whitespace$ removedgroup $whitespace$ : $whitespace$ removedgroups ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( removed $whitespace$ index $whitespace$ : $whitespace$ removedgroup ) $whitespace$ { $newline$ $indentation$ map . put ( index , $whitespace$ removedgroup ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ map ; $newline$ $indentation$ }	$indentation$ private $whitespace$ map < removed, $whitespace$ removedgroup > $whitespace$ combineremovedelementstoremovedgroups ( ) { $newline$ $indentation$ map < integer, $whitespace$ list < removed >> $whitespace$ removedelementsmap $whitespace$ = $whitespace$ groupconsecutiveremovedelements ( ) ; $newline$ $indentation$ list < removedgroup > $whitespace$ removedgroups $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( map. entry < integer, $whitespace$ list < removed >> $whitespace$ entry $whitespace$ : $whitespace$ removedelementsmap. entryset ( ) ) $whitespace$ { $newline$ $indentation$ removedgroups. add ( removedgroup. of ( entry. getkey ( ), $whitespace$ entry. getvalue ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ map < removed, $whitespace$ removedgroup > $whitespace$ map $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( removedgroup $whitespace$ removedgroup $whitespace$ : $whitespace$ removedgroups ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( removed $whitespace$ index $whitespace$ : $whitespace$ removedgroup ) $whitespace$ { $newline$ $indentation$ map. put ( index, $whitespace$ removedgroup ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ map ; $newline$ $indentation$ }			
isNodeWithTypeArguments	761	769	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.1437103003263473	LOW	"		private boolean isNodeWithTypeArguments(DifferenceElement element){
		    if (!element.isChild())
		        return false;
		    CsmChild child = (CsmChild) element.getElement();
		    if (!NodeWithTypeArguments.class.isAssignableFrom(child.getChild().getClass()))
		        return false;
		    Optional<NodeList<Type>> typeArgs = ((NodeWithTypeArguments) child.getChild()).getTypeArguments();
		    return typeArgs.isPresent() && typeArgs.get().size() > 0;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isnodewithtypearguments ( differenceelement $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ ( ! element . ischild ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ csmchild $whitespace$ child $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ element . getelement ( ) ; $newline$ $indentation$ if $whitespace$ ( ! nodewithtypearguments . class . isassignablefrom ( child . getchild ( ) . getclass ( ) ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ optional < nodelist < type >> $whitespace$ typeargs $whitespace$ = $whitespace$ ( ( nodewithtypearguments ) $whitespace$ child . getchild ( ) ) . gettypearguments ( ) ; $newline$ $indentation$ return $whitespace$ typeargs . ispresent ( ) $whitespace$ && $whitespace$ typeargs . get ( ) . size ( ) $whitespace$ > $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isnodewithtypearguments ( differenceelement $whitespace$ element ) { $newline$ $indentation$ if $whitespace$ (! element. ischild ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ csmchild $whitespace$ child $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ element. getelement ( ) ; $newline$ $indentation$ if $whitespace$ (! nodewithtypearguments. class. isassignablefrom ( child. getchild ( ). getclass ( ) ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ optional < nodelist < type >> $whitespace$ typeargs $whitespace$ = $whitespace$ ( ( nodewithtypearguments ) $whitespace$ child. getchild ( ) ). gettypearguments ( ) ; $newline$ $indentation$ return $whitespace$ typeargs. ispresent ( ) $whitespace$ && $whitespace$ typeargs. get ( ). size ( ) $whitespace$ > $whitespace$ $number$ ; $newline$ $indentation$ }			
groupConsecutiveRemovedElements	459	474	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.1672696769237518	LOW	"		private Map<Integer, List<Removed>> groupConsecutiveRemovedElements(){
		    Map<Integer, List<Removed>> removedElementsMap = new HashMap<>();
		    Integer firstElement = null;
		    for (int i = 0; i < diffElements.size(); i++) {
		        DifferenceElement diffElement = diffElements.get(i);
		        if (diffElement.isRemoved()) {
		            if (firstElement == null) {
		                firstElement = i;
		            }
		            removedElementsMap.computeIfAbsent(firstElement, key -> new ArrayList<>()).add((Removed) diffElement);
		        } else {
		            firstElement = null;
		        }
		    }
		    return removedElementsMap;
		}"	$indentation$ private $whitespace$ map < integer , $whitespace$ list < removed >> $whitespace$ groupconsecutiveremovedelements ( ) { $newline$ $indentation$ map < integer , $whitespace$ list < removed >> $whitespace$ removedelementsmap $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ integer $whitespace$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ diffelements . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( diffelement . isremoved ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstelement $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ firstelement $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ removedelementsmap . computeifabsent ( firstelement , $whitespace$ key $whitespace$ - > $whitespace$ new $whitespace$ arraylist < > ( ) ) . add ( ( removed ) $whitespace$ diffelement ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removedelementsmap ; $newline$ $indentation$ }	$indentation$ private $whitespace$ map < integer, $whitespace$ list < removed >> $whitespace$ groupconsecutiveremovedelements ( ) { $newline$ $indentation$ map < integer, $whitespace$ list < removed >> $whitespace$ removedelementsmap $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ integer $whitespace$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ diffelements. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements. get ( i ) ; $newline$ $indentation$ if $whitespace$ ( diffelement. isremoved ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( firstelement $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ firstelement $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ removedelementsmap. computeifabsent ( firstelement, $whitespace$ key $whitespace$ - > $whitespace$ new $whitespace$ arraylist < > ( ) ). add ( ( removed ) $whitespace$ diffelement ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ removedelementsmap ; $newline$ $indentation$ }			
processIndentation	87	95	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.2059160321950912	LOW	"		 List<TextElement> processIndentation(List<TextElement> indentation, List<TextElement> prevElements){
		    int eolIndex = lastIndexOfEol(prevElements);
		    // Return ""indentation"" as is if no EOL element was found
		    if (eolIndex < 0)
		        return indentation;
		    // Find consecutive space characters after the EOL element
		    indentation = takeWhile(prevElements.subList(eolIndex + 1, prevElements.size()), element -> element.isWhiteSpace());
		    return indentation;
		}"	"$indentation$ list < textelement > $whitespace$ processindentation ( list < textelement > $whitespace$ indentation , $whitespace$ list < textelement > $whitespace$ prevelements ) { $newline$ $indentation$ int $whitespace$ eolindex $whitespace$ = $whitespace$ lastindexofeol ( prevelements ) ; $newline$ $indentation$ $//·return·""indentation""·as·is·if·no·eol·element·was·found$ $newline$ $indentation$ if $whitespace$ ( eolindex $whitespace$ < $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ indentation ; $newline$ $indentation$ $//·find·consecutive·space·characters·after·the·eol·element$ $newline$ $indentation$ indentation $whitespace$ = $whitespace$ takewhile ( prevelements . sublist ( eolindex $whitespace$ + $whitespace$ $number$ , $whitespace$ prevelements . size ( ) ) , $whitespace$ element $whitespace$ - > $whitespace$ element . iswhitespace ( ) ) ; $newline$ $indentation$ return $whitespace$ indentation ; $newline$ $indentation$ }"	$indentation$ list < textelement > $whitespace$ processnewation ( list < textelement > $whitespace$ indentation, $whitespace$ list < textelement > $whitespace$ prevelements ) { $newline$ $indentation$ int $whitespace$ eolindex $whitespace$ = $whitespace$ lastindexofeol ( prevelements ) ; $newline$ $indentation$ return $whitespace$ indentation ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ int $whitespace$ eolindex $whitespace$ = $whitespace$ lastindexofeol ( prevelements ) ; $newline$ $indentation$ return $whitespace$ eol ; $newline$ $indentation$ }			
considerIndentation	230	244	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.2719779014587402	LOW	"		private int considerIndentation(NodeText nodeText, int nodeTextIndex, int numberOfCharactersToPreserve){
		    EnforcingIndentationContext enforcingIndentationContext = defineEnforcingIndentationContext(nodeText, nodeTextIndex);
		    // the next position in the list (by default the current position)
		    int res = nodeTextIndex;
		    if (enforcingIndentationContext.extraCharacters > 0) {
		        int extraCharacters = enforcingIndentationContext.extraCharacters > numberOfCharactersToPreserve ? enforcingIndentationContext.extraCharacters - numberOfCharactersToPreserve : 0;
		        res = removeExtraCharacters(nodeText, enforcingIndentationContext.start, extraCharacters);
		        // The next position must take into account the indentation
		        res = extraCharacters > 0 ? res + numberOfCharactersToPreserve : res;
		    }
		    if (res < 0) {
		        throw new IllegalStateException();
		    }
		    return res;
		}"	$indentation$ private $whitespace$ int $whitespace$ considerindentation ( nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ nodetextindex , $whitespace$ int $whitespace$ numberofcharacterstopreserve ) { $newline$ $indentation$ enforcingindentationcontext $whitespace$ enforcingindentationcontext $whitespace$ = $whitespace$ defineenforcingindentationcontext ( nodetext , $whitespace$ nodetextindex ) ; $newline$ $indentation$ $//·the·next·position·in·the·list·(by·default·the·current·position)$ $newline$ $indentation$ int $whitespace$ res $whitespace$ = $whitespace$ nodetextindex ; $newline$ $indentation$ if $whitespace$ ( enforcingindentationcontext . extracharacters $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ extracharacters $whitespace$ = $whitespace$ enforcingindentationcontext . extracharacters $whitespace$ > $whitespace$ numberofcharacterstopreserve $whitespace$ ? $whitespace$ enforcingindentationcontext . extracharacters $whitespace$ - $whitespace$ numberofcharacterstopreserve $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ res $whitespace$ = $whitespace$ removeextracharacters ( nodetext , $whitespace$ enforcingindentationcontext . start , $whitespace$ extracharacters ) ; $newline$ $indentation$ $//·the·next·position·must·take·into·account·the·indentation$ $newline$ $indentation$ res $whitespace$ = $whitespace$ extracharacters $whitespace$ > $whitespace$ $number$ $whitespace$ ? $whitespace$ res $whitespace$ + $whitespace$ numberofcharacterstopreserve $whitespace$ : $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( res $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ considernewation ( nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ nodetextindex, $whitespace$ int $whitespace$ numberofcharacterstopreserve ) { $newline$ $indentation$ enforcing $whitespace$ enforcing $whitespace$ = $whitespace$ defineenforcing. builder ( nodetext, $whitespace$ nodetextindex ) ; $newline$ $indentation$ if $whitespace$ ( enforcing. extracharacters $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ extracharacters $whitespace$ = $whitespace$ enforcing. extracharacters $whitespace$ > $whitespace$ numberofcharacterstopreserve $whitespace$? $whitespace$ enforcingationcontext. extracharacters $whitespace$ - $whitespace$ numberofcharacterstopreserve $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ res $whitespace$ = $whitespace$ removeextracharacters ( nodetext, $whitespace$ enforcingationcontext. start, $whitespace$ extracharacters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( res $whitespace$			
cleanTheLineOfLeftOverSpace	603	636	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.2958441376686096	LOW	"		private void cleanTheLineOfLeftOverSpace(RemovedGroup removedGroup, Removed removed){
		    if (originalIndex >= originalElements.size()) {
		        // if all elements were already processed there is nothing to do
		        return;
		    }
		    // we dont want to remove the indentation if the last removed element is a newline
		    // because in this case we are trying to remove the indentation of the next child element
		    if (!removedGroup.isProcessed() && removedGroup.isLastElement(removed) && removedGroup.isACompleteLine() && !removed.isNewLine()) {
		        Integer lastElementIndex = removedGroup.getLastElementIndex();
		        Optional<Integer> indentation = removedGroup.getIndentation();
		        if (indentation.isPresent() && !isReplaced(lastElementIndex)) {
		            for (int i = 0; i < indentation.get(); i++) {
		                if (originalElements.get(originalIndex).isSpaceOrTab()) {
		                    // If the current element is a space, remove it
		                    nodeText.removeElement(originalIndex);
		                } else if (originalIndex >= 1 && originalElements.get(originalIndex - 1).isSpaceOrTab()) {
		                    // If the current element is not a space itself we remove the space in front of (before) it
		                    nodeText.removeElement(originalIndex - 1);
		                    originalIndex--;
		                }
		                // Remove remaining newline character if needed
		                if (nodeText.getTextElement(originalIndex).isNewline()) {
		                    nodeText.removeElement(originalIndex);
		                    originalIndex = originalIndex > 0 ? originalIndex-- : 0;
		                }
		            }
		        }
		        // Mark RemovedGroup as processed
		        removedGroup.processed();
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ cleanthelineofleftoverspace ( removedgroup $whitespace$ removedgroup , $whitespace$ removed $whitespace$ removed ) { $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ >= $whitespace$ originalelements . size ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·all·elements·were·already·processed·there·is·nothing·to·do$ $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ $//·we·dont·want·to·remove·the·indentation·if·the·last·removed·element·is·a·newline$ $newline$ $indentation$ $//·because·in·this·case·we·are·trying·to·remove·the·indentation·of·the·next·child·element$ $newline$ $indentation$ if $whitespace$ ( ! removedgroup . isprocessed ( ) $whitespace$ && $whitespace$ removedgroup . islastelement ( removed ) $whitespace$ && $whitespace$ removedgroup . isacompleteline ( ) $whitespace$ && $whitespace$ ! removed . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ integer $whitespace$ lastelementindex $whitespace$ = $whitespace$ removedgroup . getlastelementindex ( ) ; $newline$ $indentation$ optional < integer > $whitespace$ indentation $whitespace$ = $whitespace$ removedgroup . getindentation ( ) ; $newline$ $indentation$ if $whitespace$ ( indentation . ispresent ( ) $whitespace$ && $whitespace$ ! isreplaced ( lastelementindex ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ indentation . get ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( originalelements . get ( originalindex ) . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·the·current·element·is·a·space,·remove·it$ $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( originalindex $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ originalelements . get ( originalindex $whitespace$ - $whitespace$ $number$ ) . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·the·current·element·is·not·a·space·itself·we·remove·the·space·in·front·of·(before)·it$ $newline$ $indentation$ nodetext . removeelement ( originalindex $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ originalindex -- ; $newline$ $indentation$ } $newline$ $indentation$ $//·remove·remaining·newline·character·if·needed$ $newline$ $indentation$ if $whitespace$ ( nodetext . gettextelement ( originalindex ) . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( originalindex ) ; $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ originalindex $whitespace$ > $whitespace$ $number$ $whitespace$ ? $whitespace$ originalindex -- $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·mark·removedgroup·as·processed$ $newline$ $indentation$ removedgroup . processed ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ cleanthelineofleftoverspace ( removedgroup $whitespace$ removedgroup, $whitespace$ removed $whitespace$ removed ) { $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ >= $whitespace$ originalelements. size ( ) ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////if $newline$ $indentation$ // $whitespace$ num $whitespace$ right $whitespace$ltimate $whitespace$ one $whitespace$ of $whitespace$ the $whitespace$ original $whitespace$ list $whitespace$ is $whitespace$ removed $newline$ $indentation$ $////// $whitespace$ the $whitespace$ best $whitespace$ index $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ originalindex $whitespace$ >= $whitespace$ originalelements. size ( ) ; $newline$ $indentation$ if $whitespace$ (! removedgroup. isprocessed ( ) $whitespace$ && $whitespace$ removedgroup. islastelement ( removed ) $whitespace$ && $whitespace$ removedgroup. isacompleteline ( ) $whitespace$ && $whitespace$! removed. isnewline ( ) ) $whitespace$ { $newline$ $indentation$ integer $whitespace$ lastelementindex $whitespace$ = $whitespace$ removedgroup. getlastelementindex ( ) ; $newline$ $indentation$ optional < integer > $whitespace$ indentation $whitespace$ = $whitespace$ removedgroup. getnew ( ) ; $newline$ $indentation$ if $whitespace$ ( indentation. ispresent ( ) $whitespace$ && $whitespace$! isreplaced ( lastelementindex ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$			
nextIsRightBrace	885	893	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.6117386817932129	MID	"		private boolean nextIsRightBrace(int index){
		    List<TextElement> elements = originalElements.subList(index, originalElements.size());
		    for (TextElement element : elements) {
		        if (!element.isSpaceOrTab()) {
		            return element.isToken(RBRACE);
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ nextisrightbrace ( int $whitespace$ index ) { $newline$ $indentation$ list < textelement > $whitespace$ elements $whitespace$ = $whitespace$ originalelements . sublist ( index , $whitespace$ originalelements . size ( ) ) ; $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ element $whitespace$ : $whitespace$ elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! element . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ element . istoken ( rbrace ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ nextisrightbrace ( int $whitespace$ index ) { $newline$ $indentation$ list < textelement > $whitespace$ elements $whitespace$ = $whitespace$ originalelements. sublist ( index, $whitespace$ originalelements. size ( ) ) ; $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ element $whitespace$ : $whitespace$ elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! element. isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ element. istoken ( rbrace ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getIndexToNextTokenElement	775	801	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.6693344712257385	MID	"		private int getIndexToNextTokenElement(TokenTextElement element, DifferenceElement kept){
		    // number of token to skip
		    int step = 0;
		    // verify if the DifferenceElement is a ClassOrInterfaceType with a fully qualified name
		    if (!isTypeWithFullyQualifiedName(kept))
		        return 0;
		    CsmChild child = (CsmChild) kept.getElement();
		    // split the type fully qualified node name to an array of tokens
		    String[] parts = ((ClassOrInterfaceType) child.getChild()).getNameWithScope().split(""\\."");
		    JavaToken token = element.getToken();
		    for (String part : parts) {
		        if (part.equals(token.asString())) {
		            // get 'dot' token
		            token = token.getNextToken().get();
		            if (!""."".equals(token.asString()))
		                break;
		            // get the next part
		            token = token.getNextToken().get();
		            step += 2;
		            continue;
		        }
		        // there is no match so we don't have token to skip
		        step = 0;
		        break;
		    }
		    return step;
		}"	$indentation$ private $whitespace$ int $whitespace$ getindextonexttokenelement ( tokentextelement $whitespace$ element , $whitespace$ differenceelement $whitespace$ kept ) { $newline$ $indentation$ $//·number·of·token·to·skip$ $newline$ $indentation$ int $whitespace$ step $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·verify·if·the·differenceelement·is·a·classorinterfacetype·with·a·fully·qualified·name$ $newline$ $indentation$ if $whitespace$ ( ! istypewithfullyqualifiedname ( kept ) ) $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ csmchild $whitespace$ child $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ kept . getelement ( ) ; $newline$ $indentation$ $//·split·the·type·fully·qualified·node·name·to·an·array·of·tokens$ $newline$ $indentation$ string [ ] $whitespace$ parts $whitespace$ = $whitespace$ ( ( classorinterfacetype ) $whitespace$ child . getchild ( ) ) . getnamewithscope ( ) . split ( $string$ ) ; $newline$ $indentation$ javatoken $whitespace$ token $whitespace$ = $whitespace$ element . gettoken ( ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ part $whitespace$ : $whitespace$ parts ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( part . equals ( token . asstring ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·get·'dot'·token$ $newline$ $indentation$ token $whitespace$ = $whitespace$ token . getnexttoken ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! $string$ . equals ( token . asstring ( ) ) ) $newline$ $indentation$ break ; $newline$ $indentation$ $//·get·the·next·part$ $newline$ $indentation$ token $whitespace$ = $whitespace$ token . getnexttoken ( ) . get ( ) ; $newline$ $indentation$ step $whitespace$ += $whitespace$ $number$ ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ $//·there·is·no·match·so·we·don't·have·token·to·skip$ $newline$ $indentation$ step $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ step ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ getindextonexttokenelement ( tokentextelement $whitespace$ element, $whitespace$ differenceelement $whitespace$ kept ) { $newline$ $indentation$ $////intint $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ step $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $whitespace$// $newline$ $indentation$ if $whitespace$ (! istypewithfullyqualifiedname ( kept ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ csmchild $whitespace$ child $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ kept. getelement ( ) ; $newline$ $indentation$ $// ) ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ hasversion ( jsonnode $whitespace$ element ) $whitespace$ { $newline$ $indentation$ return $whitespace$ (! istypewithfullyqualifiedname ( element ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( part. equals ( token. asstring ( ) ) ) $whitespace$ { $newline$ $indentation$ string [ ] $whitespace$ parts $whitespace$ = $whitespace$ ( ( classorinterfacetype ) $whitespace$ child. getchild ( ) ). getnamewithscope ( ). split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$			
posOfNextComment	127	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.684022843837738	MID	"		private int posOfNextComment(int fromIndex, List<TextElement> elements){
		    if (!isValidIndex(fromIndex, elements))
		        return -1;
		    ArrayIterator<TextElement> iterator = new ArrayIterator<>(elements, fromIndex);
		    // search for the next consecutive space characters
		    while (iterator.hasNext()) {
		        TextElement element = iterator.next();
		        if (element.isSpaceOrTab()) {
		            continue;
		        }
		        if (element.isComment()) {
		            return iterator.index();
		        }
		        break;
		    }
		    return -1;
		}"	$indentation$ private $whitespace$ int $whitespace$ posofnextcomment ( int $whitespace$ fromindex , $whitespace$ list < textelement > $whitespace$ elements ) { $newline$ $indentation$ if $whitespace$ ( ! isvalidindex ( fromindex , $whitespace$ elements ) ) $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ arrayiterator < textelement > $whitespace$ iterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elements , $whitespace$ fromindex ) ; $newline$ $indentation$ $//·search·for·the·next·consecutive·space·characters$ $newline$ $indentation$ while $whitespace$ ( iterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ element $whitespace$ = $whitespace$ iterator . next ( ) ; $newline$ $indentation$ if $whitespace$ ( element . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( element . iscomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ iterator . index ( ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ posofnextcomment ( int $whitespace$ fromindex, $whitespace$ list < textelement > $whitespace$ elements ) { $newline$ $indentation$ if $whitespace$ (! isvalidindex ( fromindex, $whitespace$ elements ) ) $whitespace$ return $whitespace$ $number$ ; $newline$ $indentation$ arrayiterator < textelement > $whitespace$ iterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elements, $whitespace$ fromindex ) ; $newline$ $indentation$ $///// $newline$ $indentation$ search $whitespace$ element $whitespace$ = $whitespace$ iterator. next ( ) ; $newline$ $indentation$ if $whitespace$ ( element. isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( element. iscomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ iterator. index ( ) ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }			
defineEnforcingIndentationContext	305	337	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.6873841285705566	MID	"		private EnforcingIndentationContext defineEnforcingIndentationContext(NodeText nodeText, int startIndex){
		    EnforcingIndentationContext ctx = new EnforcingIndentationContext(startIndex);
		    // compute space before startIndex value
		    if (startIndex < nodeText.numberOfElements() && startIndex > 0) {
		        // at this stage startIndex points to the first element before the deleted one
		        for (int i = startIndex - 1; i >= 0 && i < nodeText.numberOfElements(); i--) {
		            if (nodeText.getTextElement(i).isNewline()) {
		                break;
		            }
		            if (!isSpaceOrTabElement(nodeText, i)) {
		                ctx = new EnforcingIndentationContext(startIndex);
		                break;
		            }
		            ctx.start = i;
		            ctx.extraCharacters++;
		        }
		    }
		    // compute space after the deleted element
		    if (startIndex < nodeText.numberOfElements() && isSpaceOrTabElement(nodeText, startIndex)) {
		        //			int startingFromIndex = startIndex == 0 ? startIndex : startIndex + 1;
		        for (int i = startIndex; i >= 0 && i < nodeText.numberOfElements(); i++) {
		            if (nodeText.getTextElement(i).isNewline()) {
		                break;
		            }
		            if (!isSpaceOrTabElement(nodeText, i)) {
		                break;
		            }
		            ctx.extraCharacters++;
		        }
		    }
		    return ctx;
		}"	$indentation$ private $whitespace$ enforcingindentationcontext $whitespace$ defineenforcingindentationcontext ( nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ startindex ) { $newline$ $indentation$ enforcingindentationcontext $whitespace$ ctx $whitespace$ = $whitespace$ new $whitespace$ enforcingindentationcontext ( startindex ) ; $newline$ $indentation$ $//·compute·space·before·startindex·value$ $newline$ $indentation$ if $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext . numberofelements ( ) $whitespace$ && $whitespace$ startindex $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·at·this·stage·startindex·points·to·the·first·element·before·the·deleted·one$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ startindex $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ i $whitespace$ < $whitespace$ nodetext . numberofelements ( ) ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nodetext . gettextelement ( i ) . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! isspaceortabelement ( nodetext , $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ ctx $whitespace$ = $whitespace$ new $whitespace$ enforcingindentationcontext ( startindex ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ ctx . start $whitespace$ = $whitespace$ i ; $newline$ $indentation$ ctx . extracharacters ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·compute·space·after·the·deleted·element$ $newline$ $indentation$ if $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext . numberofelements ( ) $whitespace$ && $whitespace$ isspaceortabelement ( nodetext , $whitespace$ startindex ) ) $whitespace$ { $newline$ $indentation$ $//···int·startingfromindex·=·startindex·==·0·?·startindex·:·startindex·+·1;$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ startindex ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ $whitespace$ && $whitespace$ i $whitespace$ < $whitespace$ nodetext . numberofelements ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nodetext . gettextelement ( i ) . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! isspaceortabelement ( nodetext , $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ ctx . extracharacters ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ctx ; $newline$ $indentation$ }	$indentation$ private $whitespace$ enforcing $whitespace$ defineenforcing ( nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ startindex ) { $newline$ $indentation$ enforcing $whitespace$ ctx $whitespace$ = $whitespace$ new $whitespace$ enforcing ( startindex ) ; $newline$ $indentation$ if $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext. numberofelements ( ) $whitespace$ && $whitespace$ startindex $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ matrixbitr $whitespace$ = $whitespace$ new $whitespace$ enforcing ( startindex ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! isspaceortabelement ( nodetext, $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ ctx $whitespace$ = $whitespace$ new $whitespace$ enforcing ( startindex ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ ctx. start $whitespace$ = $whitespace$ i ; $newline$ $indentation$			
applyLeftOverDiffElements	411	429	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.7337021231651306	MID	"		private boolean applyLeftOverDiffElements(){
		    boolean isLeftOverElement = false;
		    if (diffIndex < diffElements.size() && originalIndex >= originalElements.size()) {
		        DifferenceElement diffElement = diffElements.get(diffIndex);
		        if (diffElement.isKept()) {
		            diffIndex++;
		        } else if (diffElement.isAdded()) {
		            Added addedElement = (Added) diffElement;
		            nodeText.addElement(originalIndex, addedElement.toTextElement());
		            originalIndex++;
		            diffIndex++;
		        } else {
		            // let's forget this element
		            diffIndex++;
		        }
		        isLeftOverElement = true;
		    }
		    return isLeftOverElement;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ applyleftoverdiffelements ( ) { $newline$ $indentation$ boolean $whitespace$ isleftoverelement $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( diffindex $whitespace$ < $whitespace$ diffelements . size ( ) $whitespace$ && $whitespace$ originalindex $whitespace$ >= $whitespace$ originalelements . size ( ) ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements . get ( diffindex ) ; $newline$ $indentation$ if $whitespace$ ( diffelement . iskept ( ) ) $whitespace$ { $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( diffelement . isadded ( ) ) $whitespace$ { $newline$ $indentation$ added $whitespace$ addedelement $whitespace$ = $whitespace$ ( added ) $whitespace$ diffelement ; $newline$ $indentation$ nodetext . addelement ( originalindex , $whitespace$ addedelement . totextelement ( ) ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·let's·forget·this·element$ $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ isleftoverelement $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isleftoverelement ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ applyleftoverdiffelements ( ) { $newline$ $indentation$ boolean $whitespace$ isleftoverelement $whitespace$ = $whitespace$ false ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ iskingleftleft $whitespace$ = $whitespace$ false ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isgraphicsandright $whitespace$ = $whitespace$ false ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isgraphicsandright $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( diffindex $whitespace$ < $whitespace$ diffelements. size ( ) $whitespace$ && $whitespace$ originalindex $whitespace$ >= $whitespace$ originalelements. size ( ) ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ diffelements. get ( diffindex ) ; $newline$ $indentation$ if $whitespace$ ( diffelement. iskept ( ) ) $whitespace$ { $newline$ $indentation$ added $whitespace$ addedelement $whitespace$ = $whitespace$ ( added ) $whitespace$ diffelement ; $newline$ $indentation$ nodetext. addelement ( originalindex, $whitespace$ addedelement. totextelement ( ) ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $////////////////////////////////////let's$ = $whitespace$ ( added ) $whitespace$ diffelement ; $newline$ $indentation$ nodetext. addelement ( originalindex, $whitespace$ addedelement. totextelement ( ) ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ diffindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isleftoverelement ; $newline$ $indentation$ }			
isInlined	342	357	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Difference.java	0.8353278040885925	HIGH	"		private boolean isInlined(NodeText nodeText, int startIndex){
		    boolean inlined = false;
		    if (startIndex < nodeText.numberOfElements() && startIndex >= 0) {
		        // at this stage startIndex points to the first element before the deleted one
		        for (int i = startIndex; i < nodeText.numberOfElements(); i++) {
		            if (nodeText.getTextElement(i).isNewline()) {
		                break;
		            }
		            if (nodeText.getTextElement(i).isChild()) {
		                inlined = true;
		                break;
		            }
		        }
		    }
		    return inlined;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isinlined ( nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ startindex ) { $newline$ $indentation$ boolean $whitespace$ inlined $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext . numberofelements ( ) $whitespace$ && $whitespace$ startindex $whitespace$ >= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·at·this·stage·startindex·points·to·the·first·element·before·the·deleted·one$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ startindex ; $whitespace$ i $whitespace$ < $whitespace$ nodetext . numberofelements ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nodetext . gettextelement ( i ) . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodetext . gettextelement ( i ) . ischild ( ) ) $whitespace$ { $newline$ $indentation$ inlined $whitespace$ = $whitespace$ true ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ inlined ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isinlined ( nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ startindex ) { $newline$ $indentation$ boolean $whitespace$ inlined $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext. numberofelements ( ) $whitespace$ && $whitespace$ startindex $whitespace$ >= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $////// $newline$ $indentation$$$ nanosstagerrr $whitespace$ = $whitespace$ ( startindex $whitespace$ < $whitespace$ nodetext. numberofelements ( ) ; $newline$ $indentation$ if $whitespace$ ( nodetext. gettextelement ( i ). isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nodetext. gettextelement ( i ). ischild ( ) ) $whitespace$ { $newline$ $indentation$ inlined $whitespace$ = $whitespace$ true ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ inlined ; $newline$ $indentation$ }			
calculate	165	241	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.0062783183529973	LOW	"		 static List<DifferenceElement> calculate(LexicalDifferenceCalculator.CalculatedSyntaxModel original, LexicalDifferenceCalculator.CalculatedSyntaxModel after){
		    // For performance reasons we use the positions of matching children
		    // to guide the calculation of the difference
		    //
		    // Suppose we have:
		    // qwerty[A]uiop
		    // qwer[A]uiop
		    //
		    // with [A] being a child and lowercase letters being tokens
		    //
		    // We would calculate the Difference between ""qwerty"" and ""qwer"" then we know the A is kept, and then we
		    // would calculate the difference between ""uiop"" and ""uiop""
		    List<ChildPositionInfo> childrenInOriginal = findChildrenPositions(original);
		    List<ChildPositionInfo> childrenInAfter = findChildrenPositions(after);
		    List<ChildPositionInfo> commonChildren = new ArrayList<>(childrenInOriginal);
		    commonChildren.retainAll(childrenInAfter);
		    List<DifferenceElement> elements = new LinkedList<>();
		    int originalIndex = 0;
		    int afterIndex = 0;
		    int commonChildrenIndex = 0;
		    // undefined
		    int posOfNextChildInOriginal = -1;
		    // undefined
		    int posOfNextChildInAfter = -1;
		    // The algorithm is based on common child elements.
		    // It first analyzes the elements preceding this child.
		    // Then it keeps the common element and continues the analysis between the element
		    // following this child and the common element in the list.
		    while (commonChildrenIndex < commonChildren.size()) {
		        ChildPositionInfo child = commonChildren.get(commonChildrenIndex++);
		        // search the position of the node ""child"" in the original list of cms element
		        final int currentPosOfNextChildInOriginal = posOfNextChildInOriginal;
		        final int currentPosOfNextChildInAfter = posOfNextChildInAfter;
		        posOfNextChildInOriginal = childrenInOriginal.stream().filter(i -> i.equals(child)).map(i -> i.position).filter(position -> position > currentPosOfNextChildInOriginal).findFirst().orElse(posOfNextChildInOriginal);
		        // search the position of the node ""child"" in the modified list of cms element
		        posOfNextChildInAfter = childrenInAfter.stream().filter(i -> i.equals(child)).map(i -> i.position).filter(position -> position > currentPosOfNextChildInAfter).findFirst().orElse(posOfNextChildInAfter);
		        // Imagine that the common elements has been moved, for example in the case where the parameters of a method are reversed
		        // In this case the afterIndex will be greater than the position of the child in
		        // the list
		        // For example : if {@code new Foo(a, b)} become {@code new Foo(b, a)}
		        // Nota: in this example there is 3 child elements Foo, 'a' and 'b', others are tokens
		        // In the orginal list the child element 'a' is at the position 5 and the
		        // element 'b' is at the position 8
		        // After reverting the list of parameters the child element 'a' is at the
		        // position 8 and the element 'b' is at the position 5
		        // When we deal with element 'b', it is in 5th position in the list after the
		        // modification but the previous position in the list was that of element 'a'.
		        if (originalIndex < posOfNextChildInOriginal || afterIndex < posOfNextChildInAfter) {
		            // defines the sublist of elements located before the common element
		            CalculatedSyntaxModel originalSub = originalIndex < posOfNextChildInOriginal ? original.sub(originalIndex, posOfNextChildInOriginal) : new CalculatedSyntaxModel(Collections.EMPTY_LIST);
		            CalculatedSyntaxModel afterSub = afterIndex < posOfNextChildInAfter ? after.sub(afterIndex, posOfNextChildInAfter) : new CalculatedSyntaxModel(Collections.EMPTY_LIST);
		            elements.addAll(calculateImpl(originalSub, afterSub));
		        }
		        if (afterIndex <= posOfNextChildInAfter) {
		            // we need to keep the current common node
		            elements.add(new Kept(new CsmChild(child.node)));
		        } else {
		            // In this case the current node was not found in the list after change
		            // so we need to remove it.
		            elements.add(new Removed(new CsmChild(child.node)));
		        }
		        originalIndex = originalIndex <= posOfNextChildInOriginal ? posOfNextChildInOriginal + 1 : originalIndex;
		        afterIndex = afterIndex <= posOfNextChildInAfter ? posOfNextChildInAfter + 1 : afterIndex;
		    }
		    if (originalIndex < original.elements.size() || afterIndex < after.elements.size()) {
		        CalculatedSyntaxModel originalSub = originalIndex < original.elements.size() ? original.sub(originalIndex, original.elements.size()) : new CalculatedSyntaxModel(Collections.EMPTY_LIST);
		        CalculatedSyntaxModel afterSub = afterIndex < after.elements.size() ? after.sub(afterIndex, after.elements.size()) : new CalculatedSyntaxModel(Collections.EMPTY_LIST);
		        elements.addAll(calculateImpl(originalSub, afterSub));
		    }
		    return elements;
		}"	"$indentation$ static $whitespace$ list < differenceelement > $whitespace$ calculate ( lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ original , $whitespace$ lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ after ) { $newline$ $indentation$ $//·for·performance·reasons·we·use·the·positions·of·matching·children$ $newline$ $indentation$ $//·to·guide·the·calculation·of·the·difference$ $newline$ $indentation$ // $newline$ $indentation$ $//·suppose·we·have:$ $newline$ $indentation$ $//·qwerty[a]uiop$ $newline$ $indentation$ $//·qwer[a]uiop$ $newline$ $indentation$ // $newline$ $indentation$ $//·with·[a]·being·a·child·and·lowercase·letters·being·tokens$ $newline$ $indentation$ // $newline$ $indentation$ $//·we·would·calculate·the·difference·between·""qwerty""·and·""qwer""·then·we·know·the·a·is·kept,·and·then·we$ $newline$ $indentation$ $//·would·calculate·the·difference·between·""uiop""·and·""uiop""$ $newline$ $indentation$ list < childpositioninfo > $whitespace$ childreninoriginal $whitespace$ = $whitespace$ findchildrenpositions ( original ) ; $newline$ $indentation$ list < childpositioninfo > $whitespace$ childreninafter $whitespace$ = $whitespace$ findchildrenpositions ( after ) ; $newline$ $indentation$ list < childpositioninfo > $whitespace$ commonchildren $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( childreninoriginal ) ; $newline$ $indentation$ commonchildren . retainall ( childreninafter ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ originalindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ afterindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ commonchildrenindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·undefined$ $newline$ $indentation$ int $whitespace$ posofnextchildinoriginal $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·undefined$ $newline$ $indentation$ int $whitespace$ posofnextchildinafter $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·the·algorithm·is·based·on·common·child·elements.$ $newline$ $indentation$ $//·it·first·analyzes·the·elements·preceding·this·child.$ $newline$ $indentation$ $//·then·it·keeps·the·common·element·and·continues·the·analysis·between·the·element$ $newline$ $indentation$ $//·following·this·child·and·the·common·element·in·the·list.$ $newline$ $indentation$ while $whitespace$ ( commonchildrenindex $whitespace$ < $whitespace$ commonchildren . size ( ) ) $whitespace$ { $newline$ $indentation$ childpositioninfo $whitespace$ child $whitespace$ = $whitespace$ commonchildren . get ( commonchildrenindex ++ ) ; $newline$ $indentation$ $//·search·the·position·of·the·node·""child""·in·the·original·list·of·cms·element$ $newline$ $indentation$ final $whitespace$ int $whitespace$ currentposofnextchildinoriginal $whitespace$ = $whitespace$ posofnextchildinoriginal ; $newline$ $indentation$ final $whitespace$ int $whitespace$ currentposofnextchildinafter $whitespace$ = $whitespace$ posofnextchildinafter ; $newline$ $indentation$ posofnextchildinoriginal $whitespace$ = $whitespace$ childreninoriginal . stream ( ) . filter ( i $whitespace$ - > $whitespace$ i . equals ( child ) ) . map ( i $whitespace$ - > $whitespace$ i . position ) . filter ( position $whitespace$ - > $whitespace$ position $whitespace$ > $whitespace$ currentposofnextchildinoriginal ) . findfirst ( ) . orelse ( posofnextchildinoriginal ) ; $newline$ $indentation$ $//·search·the·position·of·the·node·""child""·in·the·modified·list·of·cms·element$ $newline$ $indentation$ posofnextchildinafter $whitespace$ = $whitespace$ childreninafter . stream ( ) . filter ( i $whitespace$ - > $whitespace$ i . equals ( child ) ) . map ( i $whitespace$ - > $whitespace$ i . position ) . filter ( position $whitespace$ - > $whitespace$ position $whitespace$ > $whitespace$ currentposofnextchildinafter ) . findfirst ( ) . orelse ( posofnextchildinafter ) ; $newline$ $indentation$ $//·imagine·that·the·common·elements·has·been·moved,·for·example·in·the·case·where·the·parameters·of·a·method·are·reversed$ $newline$ $indentation$ $//·in·this·case·the·afterindex·will·be·greater·than·the·position·of·the·child·in$ $newline$ $indentation$ $//·the·list$ $newline$ $indentation$ $//·for·example·:·if·{@code·new·foo(a,·b)}·become·{@code·new·foo(b,·a)}$ $newline$ $indentation$ $//·nota:·in·this·example·there·is·3·child·elements·foo,·'a'·and·'b',·others·are·tokens$ $newline$ $indentation$ $//·in·the·orginal·list·the·child·element·'a'·is·at·the·position·5·and·the$ $newline$ $indentation$ $//·element·'b'·is·at·the·position·8$ $newline$ $indentation$ $//·after·reverting·the·list·of·parameters·the·child·element·'a'·is·at·the$ $newline$ $indentation$ $//·position·8·and·the·element·'b'·is·at·the·position·5$ $newline$ $indentation$ $//·when·we·deal·with·element·'b',·it·is·in·5th·position·in·the·list·after·the$ $newline$ $indentation$ $//·modification·but·the·previous·position·in·the·list·was·that·of·element·'a'.$ $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ < $whitespace$ posofnextchildinoriginal $whitespace$ || $whitespace$ afterindex $whitespace$ < $whitespace$ posofnextchildinafter ) $whitespace$ { $newline$ $indentation$ $//·defines·the·sublist·of·elements·located·before·the·common·element$ $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ originalsub $whitespace$ = $whitespace$ originalindex $whitespace$ < $whitespace$ posofnextchildinoriginal $whitespace$ ? $whitespace$ original . sub ( originalindex , $whitespace$ posofnextchildinoriginal ) $whitespace$ : $whitespace$ new $whitespace$ calculatedsyntaxmodel ( collections . empty_list ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ aftersub $whitespace$ = $whitespace$ afterindex $whitespace$ < $whitespace$ posofnextchildinafter $whitespace$ ? $whitespace$ after . sub ( afterindex , $whitespace$ posofnextchildinafter ) $whitespace$ : $whitespace$ new $whitespace$ calculatedsyntaxmodel ( collections . empty_list ) ; $newline$ $indentation$ elements . addall ( calculateimpl ( originalsub , $whitespace$ aftersub ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( afterindex $whitespace$ <= $whitespace$ posofnextchildinafter ) $whitespace$ { $newline$ $indentation$ $//·we·need·to·keep·the·current·common·node$ $newline$ $indentation$ elements . add ( new $whitespace$ kept ( new $whitespace$ csmchild ( child . node ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·in·this·case·the·current·node·was·not·found·in·the·list·after·change$ $newline$ $indentation$ $//·so·we·need·to·remove·it.$ $newline$ $indentation$ elements . add ( new $whitespace$ removed ( new $whitespace$ csmchild ( child . node ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ originalindex $whitespace$ <= $whitespace$ posofnextchildinoriginal $whitespace$ ? $whitespace$ posofnextchildinoriginal $whitespace$ + $whitespace$ $number$ $whitespace$ : $whitespace$ originalindex ; $newline$ $indentation$ afterindex $whitespace$ = $whitespace$ afterindex $whitespace$ <= $whitespace$ posofnextchildinafter $whitespace$ ? $whitespace$ posofnextchildinafter $whitespace$ + $whitespace$ $number$ $whitespace$ : $whitespace$ afterindex ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ < $whitespace$ original . elements . size ( ) $whitespace$ || $whitespace$ afterindex $whitespace$ < $whitespace$ after . elements . size ( ) ) $whitespace$ { $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ originalsub $whitespace$ = $whitespace$ originalindex $whitespace$ < $whitespace$ original . elements . size ( ) $whitespace$ ? $whitespace$ original . sub ( originalindex , $whitespace$ original . elements . size ( ) ) $whitespace$ : $whitespace$ new $whitespace$ calculatedsyntaxmodel ( collections . empty_list ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ aftersub $whitespace$ = $whitespace$ afterindex $whitespace$ < $whitespace$ after . elements . size ( ) $whitespace$ ? $whitespace$ after . sub ( afterindex , $whitespace$ after . elements . size ( ) ) $whitespace$ : $whitespace$ new $whitespace$ calculatedsyntaxmodel ( collections . empty_list ) ; $newline$ $indentation$ elements . addall ( calculateimpl ( originalsub , $whitespace$ aftersub ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ elements ; $newline$ $indentation$ }"	$indentation$ static $whitespace$ list < differenceelement > $whitespace$ calculate ( lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ original, $whitespace$ lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ after ) { $newline$ $indentation$ $////////////////////////////////////for$ation$performance ( method method method method method method method $whitespace$ + $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ intstreamferencecalculator. kappa ) $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ $whitespace$// $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ free $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ findchildrenpositions ( original ) ; $newline$ $indentation$ list < childpositioninfo > $whitespace$ childreninoriginal $whitespace$ = $whitespace$ findchildrenpositions ( original ) ; $newline$ $indentation$ list < childpositioninfo > $whitespace$ childreninafter $whitespace$ = $whitespace$ findchildrenpositions ( after ) ; $newline$ $indentation$ list < childpositioninfo > $whitespace$ commonchildren $whitespace$ = $whitespace$ findchildrenpositions ( after ) ;			
calculateImpl	275	326	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.045895267277956	LOW	"		private static List<DifferenceElement> calculateImpl(LexicalDifferenceCalculator.CalculatedSyntaxModel original, LexicalDifferenceCalculator.CalculatedSyntaxModel after){
		    List<DifferenceElement> elements = new LinkedList<>();
		    int originalIndex = 0;
		    int afterIndex = 0;
		    // We move through the two CalculatedSyntaxModel, moving both forward when we have a match
		    // and moving just one side forward when we have an element kept or removed
		    do {
		        if (originalIndex < original.elements.size() && afterIndex >= after.elements.size()) {
		            CsmElement removedElement = original.elements.get(originalIndex);
		            originalIndex = considerRemoval(removedElement, originalIndex, elements);
		        } else if (originalIndex >= original.elements.size() && afterIndex < after.elements.size()) {
		            elements.add(new Added(after.elements.get(afterIndex)));
		            afterIndex++;
		        } else {
		            CsmElement nextOriginal = original.elements.get(originalIndex);
		            CsmElement nextAfter = after.elements.get(afterIndex);
		            if ((nextOriginal instanceof CsmMix) && (nextAfter instanceof CsmMix)) {
		                if (((CsmMix) nextAfter).getElements().equals(((CsmMix) nextOriginal).getElements())) {
		                    // No reason to deal with a reshuffled, we are just going to keep everything as it is
		                    ((CsmMix) nextAfter).getElements().forEach(el -> elements.add(new Kept(el)));
		                } else {
		                    elements.add(new Reshuffled((CsmMix) nextOriginal, (CsmMix) nextAfter));
		                }
		                originalIndex++;
		                afterIndex++;
		            } else if (matching(nextOriginal, nextAfter)) {
		                elements.add(new Kept(nextOriginal));
		                originalIndex++;
		                afterIndex++;
		            } else if (replacement(nextOriginal, nextAfter)) {
		                originalIndex = considerRemoval(nextOriginal, originalIndex, elements);
		                elements.add(new Added(nextAfter));
		                afterIndex++;
		            } else {
		                // We can try to remove the element or add it and look which one leads to the lower difference
		                List<DifferenceElement> addingElements = calculate(original.from(originalIndex), after.from(afterIndex + 1));
		                List<DifferenceElement> removingElements = null;
		                if (cost(addingElements) > 0) {
		                    removingElements = calculate(original.from(originalIndex + 1), after.from(afterIndex));
		                }
		                if (removingElements == null || cost(removingElements) > cost(addingElements)) {
		                    elements.add(new Added(nextAfter));
		                    afterIndex++;
		                } else {
		                    elements.add(new Removed(nextOriginal));
		                    originalIndex++;
		                }
		            }
		        }
		    } while (originalIndex < original.elements.size() || afterIndex < after.elements.size());
		    return elements;
		}"	$indentation$ private $whitespace$ static $whitespace$ list < differenceelement > $whitespace$ calculateimpl ( lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ original , $whitespace$ lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ after ) { $newline$ $indentation$ list < differenceelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ originalindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ afterindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·we·move·through·the·two·calculatedsyntaxmodel,·moving·both·forward·when·we·have·a·match$ $newline$ $indentation$ $//·and·moving·just·one·side·forward·when·we·have·an·element·kept·or·removed$ $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ if $whitespace$ ( originalindex $whitespace$ < $whitespace$ original . elements . size ( ) $whitespace$ && $whitespace$ afterindex $whitespace$ >= $whitespace$ after . elements . size ( ) ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ removedelement $whitespace$ = $whitespace$ original . elements . get ( originalindex ) ; $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ considerremoval ( removedelement , $whitespace$ originalindex , $whitespace$ elements ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( originalindex $whitespace$ >= $whitespace$ original . elements . size ( ) $whitespace$ && $whitespace$ afterindex $whitespace$ < $whitespace$ after . elements . size ( ) ) $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ added ( after . elements . get ( afterindex ) ) ) ; $newline$ $indentation$ afterindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ nextoriginal $whitespace$ = $whitespace$ original . elements . get ( originalindex ) ; $newline$ $indentation$ csmelement $whitespace$ nextafter $whitespace$ = $whitespace$ after . elements . get ( afterindex ) ; $newline$ $indentation$ if $whitespace$ ( ( nextoriginal $whitespace$ instanceof $whitespace$ csmmix ) $whitespace$ && $whitespace$ ( nextafter $whitespace$ instanceof $whitespace$ csmmix ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( csmmix ) $whitespace$ nextafter ) . getelements ( ) . equals ( ( ( csmmix ) $whitespace$ nextoriginal ) . getelements ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·no·reason·to·deal·with·a·reshuffled,·we·are·just·going·to·keep·everything·as·it·is$ $newline$ $indentation$ ( ( csmmix ) $whitespace$ nextafter ) . getelements ( ) . foreach ( el $whitespace$ - > $whitespace$ elements . add ( new $whitespace$ kept ( el ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ reshuffled ( ( csmmix ) $whitespace$ nextoriginal , $whitespace$ ( csmmix ) $whitespace$ nextafter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ afterindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( matching ( nextoriginal , $whitespace$ nextafter ) ) $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ kept ( nextoriginal ) ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ afterindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( replacement ( nextoriginal , $whitespace$ nextafter ) ) $whitespace$ { $newline$ $indentation$ originalindex $whitespace$ = $whitespace$ considerremoval ( nextoriginal , $whitespace$ originalindex , $whitespace$ elements ) ; $newline$ $indentation$ elements . add ( new $whitespace$ added ( nextafter ) ) ; $newline$ $indentation$ afterindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·we·can·try·to·remove·the·element·or·add·it·and·look·which·one·leads·to·the·lower·difference$ $newline$ $indentation$ list < differenceelement > $whitespace$ addingelements $whitespace$ = $whitespace$ calculate ( original . from ( originalindex ) , $whitespace$ after . from ( afterindex $whitespace$ + $whitespace$ $number$ ) ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ removingelements $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( cost ( addingelements ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ removingelements $whitespace$ = $whitespace$ calculate ( original . from ( originalindex $whitespace$ + $whitespace$ $number$ ) , $whitespace$ after . from ( afterindex ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( removingelements $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ cost ( removingelements ) $whitespace$ > $whitespace$ cost ( addingelements ) ) $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ added ( nextafter ) ) ; $newline$ $indentation$ afterindex ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ removed ( nextoriginal ) ) ; $newline$ $indentation$ originalindex ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ while $whitespace$ ( originalindex $whitespace$ < $whitespace$ original . elements . size ( ) $whitespace$ || $whitespace$ afterindex $whitespace$ < $whitespace$ after . elements . size ( ) ) ; $newline$ $indentation$ return $whitespace$ elements ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < differenceelement > $whitespace$ calculateimpl ( lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ original, $whitespace$ lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ after ) { $newline$ $indentation$ list < differenceelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ int $whitespace$ originalindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ afterindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//space$ we $whitespace$$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ get $whitespace$ the $whitespace$ next $whitespace$ generation $whitespace$ of $whitespace$ the $whitespace$ original $whitespace$ generation $whitespace$ $newline$ $indentation$ int $whitespace$ oneint $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ get $whitespace$ the $whitespace$ index $whitespace$ of $whitespace$ the $whitespace$ original $whitespace$ generation $newline$ $indentation$			
equals	49	63	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.1427266746759414	LOW	"		@Override
		public boolean equals(Object other){
		    if (other == null || !(other instanceof ChildPositionInfo))
		        return false;
		    ChildPositionInfo cpi = (ChildPositionInfo) other;
		    // verify that the node content and the position are equal
		    // because we can have nodes with the same content but in different lines
		    // in this case we consider that nodes are not equals
		    // If the nodes have no declared position they are considered equal.
		    return this.node.equals(cpi.node) && (this.node.hasRange() == false && cpi.node.hasRange() == false || (this.node.hasRange() && cpi.node.hasRange() && this.node.getRange().get().contains(cpi.node.getRange().get())));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ( other $whitespace$ instanceof $whitespace$ childpositioninfo ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ childpositioninfo $whitespace$ cpi $whitespace$ = $whitespace$ ( childpositioninfo ) $whitespace$ other ; $newline$ $indentation$ $//·verify·that·the·node·content·and·the·position·are·equal$ $newline$ $indentation$ $//·because·we·can·have·nodes·with·the·same·content·but·in·different·lines$ $newline$ $indentation$ $//·in·this·case·we·consider·that·nodes·are·not·equals$ $newline$ $indentation$ $//·if·the·nodes·have·no·declared·position·they·are·considered·equal.$ $newline$ $indentation$ return $whitespace$ this . node . equals ( cpi . node ) $whitespace$ && $whitespace$ ( this . node . hasrange ( ) $whitespace$ == $whitespace$ false $whitespace$ && $whitespace$ cpi . node . hasrange ( ) $whitespace$ == $whitespace$ false $whitespace$ || $whitespace$ ( this . node . hasrange ( ) $whitespace$ && $whitespace$ cpi . node . hasrange ( ) $whitespace$ && $whitespace$ this . node . getrange ( ) . get ( ) . contains ( cpi . node . getrange ( ) . get ( ) ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$! ( other $whitespace$ instanceof $whitespace$ childpositioninfo ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ childpositioninfo $whitespace$ cpi $whitespace$ = $whitespace$ ( childpositioninfo ) $whitespace$ other ; $newline$ $indentation$ $//// $newline$ $indentation$that ( nodecontainer $whitespace$ is $whitespace$ not $whitespace$ a $whitespace$ childpositioninfo $whitespace$ with $whitespace$ the $whitespace$ same $whitespace$ line $whitespace$ of $whitespace$ the $whitespace$ current $whitespace$ group $whitespace$ is $whitespace$ in $whitespace$ other $newline$ $indentation$ $// $newline$ $indentation$ // $whitespace$ nodecontainer $whitespace$ is $whitespace$ already $whitespace$ same $whitespace$ as $whitespace$ the $whitespace$ same $whitespace$ line $whitespace$ of $whitespace$ the $whitespace$ current $whitespace$ group $whitespace$ is $whitespace$ still $whitespace$ i $newline$ $indentation$ $number$ ) ; $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
findChildrenPositions	150	159	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.247758150100708	LOW	"		private static List<ChildPositionInfo> findChildrenPositions(LexicalDifferenceCalculator.CalculatedSyntaxModel calculatedSyntaxModel){
		    List<ChildPositionInfo> positions = new ArrayList<>();
		    for (int i = 0; i < calculatedSyntaxModel.elements.size(); i++) {
		        CsmElement element = calculatedSyntaxModel.elements.get(i);
		        if (element instanceof CsmChild) {
		            positions.add(new ChildPositionInfo(((CsmChild) element).getChild(), i));
		        }
		    }
		    return positions;
		}"	$indentation$ private $whitespace$ static $whitespace$ list < childpositioninfo > $whitespace$ findchildrenpositions ( lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodel ) { $newline$ $indentation$ list < childpositioninfo > $whitespace$ positions $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ calculatedsyntaxmodel . elements . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ calculatedsyntaxmodel . elements . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ positions . add ( new $whitespace$ childpositioninfo ( ( ( csmchild ) $whitespace$ element ) . getchild ( ) , $whitespace$ i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ positions ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < childpositioninfo > $whitespace$ findchildrenpositions ( lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodel ) { $newline$ $indentation$ list < childpositioninfo > $whitespace$ positions $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ calculatedsyntaxmodel. elements. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ calculatedsyntaxmodel. elements. get ( i ) ; $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ positions. add ( new $whitespace$ childpositioninfo ( ( ( csmchild ) $whitespace$ element ). getchild ( ), $whitespace$ i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ positions ; $newline$ $indentation$ }			
replacement	119	145	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.266776293516159	LOW	"		private static boolean replacement(CsmElement a, CsmElement b){
		    if (a instanceof CsmIndent || b instanceof CsmIndent || a instanceof CsmUnindent || b instanceof CsmUnindent) {
		        return false;
		    }
		    if (a instanceof CsmChild) {
		        if (b instanceof CsmChild) {
		            CsmChild childA = (CsmChild) a;
		            CsmChild childB = (CsmChild) b;
		            return childA.getChild().getClass().equals(childB.getChild().getClass());
		        }
		        if (b instanceof CsmToken) {
		            return false;
		        }
		        throw new UnsupportedOperationException(a.getClass().getSimpleName() + "" "" + b.getClass().getSimpleName());
		    }
		    if (a instanceof CsmToken) {
		        if (b instanceof CsmToken) {
		            CsmToken childA = (CsmToken) a;
		            CsmToken childB = (CsmToken) b;
		            return childA.getTokenType() == childB.getTokenType();
		        }
		        if (b instanceof CsmChild) {
		            return false;
		        }
		    }
		    throw new UnsupportedOperationException(a.getClass().getSimpleName() + "" "" + b.getClass().getSimpleName());
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ replacement ( csmelement $whitespace$ a , $whitespace$ csmelement $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmindent $whitespace$ || $whitespace$ b $whitespace$ instanceof $whitespace$ csmindent $whitespace$ || $whitespace$ a $whitespace$ instanceof $whitespace$ csmunindent $whitespace$ || $whitespace$ b $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ csmchild $whitespace$ childa $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ a ; $newline$ $indentation$ csmchild $whitespace$ childb $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa . getchild ( ) . getclass ( ) . equals ( childb . getchild ( ) . getclass ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ childa $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ a ; $newline$ $indentation$ csmtoken $whitespace$ childb $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa . gettokentype ( ) $whitespace$ == $whitespace$ childb . gettokentype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ replacement ( csmelement $whitespace$ a, $whitespace$ csmelement $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmchild $whitespace$ || $whitespace$ b $whitespace$ instanceof $whitespace$ csm ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ csmchild $whitespace$ childa $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ a ; $newline$ $indentation$ csmchild $whitespace$ childb $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa. getchild ( ). getclass ( ). equals ( childb. getchild ( ). getclass ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a. getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b. getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indent			
matching	71	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/DifferenceElementCalculator.java	0.9114815592765808	HIGH	"		 static boolean matching(CsmElement a, CsmElement b){
		    if (a instanceof CsmChild) {
		        if (b instanceof CsmChild) {
		            CsmChild childA = (CsmChild) a;
		            CsmChild childB = (CsmChild) b;
		            return childA.getChild().equals(childB.getChild());
		        }
		        if (b instanceof CsmToken) {
		            return false;
		        }
		        if (b instanceof CsmIndent) {
		            return false;
		        }
		        if (b instanceof CsmUnindent) {
		            return false;
		        }
		        throw new UnsupportedOperationException(a.getClass().getSimpleName() + "" "" + b.getClass().getSimpleName());
		    }
		    if (a instanceof CsmToken) {
		        if (b instanceof CsmToken) {
		            // fix #2382:
		            // Tokens are described by their type AND their content
		            // and TokenContentCalculator. By using .equals(), all
		            // three values are compared.
		            CsmToken childA = (CsmToken) a;
		            CsmToken childB = (CsmToken) b;
		            return childA.equals(childB);
		        }
		        if (b instanceof CsmChild) {
		            return false;
		        }
		        if (b instanceof CsmIndent) {
		            return false;
		        }
		        if (b instanceof CsmUnindent) {
		            return false;
		        }
		        throw new UnsupportedOperationException(a.getClass().getSimpleName() + "" "" + b.getClass().getSimpleName());
		    }
		    if (a instanceof CsmIndent) {
		        return b instanceof CsmIndent;
		    }
		    if (a instanceof CsmUnindent) {
		        return b instanceof CsmUnindent;
		    }
		    throw new UnsupportedOperationException(a.getClass().getSimpleName() + "" "" + b.getClass().getSimpleName());
		}"	$indentation$ static $whitespace$ boolean $whitespace$ matching ( csmelement $whitespace$ a , $whitespace$ csmelement $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ csmchild $whitespace$ childa $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ a ; $newline$ $indentation$ csmchild $whitespace$ childb $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa . getchild ( ) . equals ( childb . getchild ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ $//·fix·#2382:$ $newline$ $indentation$ $//·tokens·are·described·by·their·type·and·their·content$ $newline$ $indentation$ $//·and·tokencontentcalculator.·by·using·.equals(),·all$ $newline$ $indentation$ $//·three·values·are·compared.$ $newline$ $indentation$ csmtoken $whitespace$ childa $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ a ; $newline$ $indentation$ csmtoken $whitespace$ childb $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa . equals ( childb ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b $whitespace$ instanceof $whitespace$ csmindent ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b $whitespace$ instanceof $whitespace$ csmunindent ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ boolean $whitespace$ matching ( csmelement $whitespace$ a, $whitespace$ csmelement $whitespace$ b ) { $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmchild ) $whitespace$ { $newline$ $indentation$ csmchild $whitespace$ childa $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ a ; $newline$ $indentation$ csmchild $whitespace$ childb $whitespace$ = $whitespace$ ( csmchild ) $whitespace$ b ; $newline$ $indentation$ return $whitespace$ childa. getchild ( ). equals ( childb. getchild ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ csmun ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a. getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ b. getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( a $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( a. getclass ( ). getsimplename ( ) $whitespace$ + $whitespace			
isPrimitiveType	98	104	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java	0.6055291891098022	MID	"		public boolean isPrimitiveType(){
		    if (isChild()) {
		        LexicalDifferenceCalculator.CsmChild csmChild = (LexicalDifferenceCalculator.CsmChild) element;
		        return csmChild.getChild() instanceof PrimitiveType;
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ if $whitespace$ ( ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator . csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator . csmchild ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmchild . getchild ( ) $whitespace$ instanceof $whitespace$ primitivetype ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ if $whitespace$ ( ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator. csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator. csmchild ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmchild. getchild ( ) $whitespace$ instanceof $whitespace$ primitivetype ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getTokenType	63	69	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java	0.6808587312698364	MID	"		public int getTokenType(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.getTokenType();
		    }
		    throw new IllegalStateException(""Kept is not a "" + CsmToken.class.getSimpleName());
		}"	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . gettokentype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ csmtoken . class . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ csmtoken ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ csmtoken. gettokentype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ notvalid ( csmtoken $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ csmtoken. gettokentype ( ) $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isvalid ( csmtoken $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isvalid. gettokentype ( ) $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ }			
isWhiteSpaceOrComment	114	120	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java	0.7024034857749939	MID	"		public boolean isWhiteSpaceOrComment(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return TokenTypes.isWhitespaceOrComment(csmToken.getTokenType());
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespaceorcomment ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ tokentypes . iswhitespaceorcomment ( csmtoken . gettokentype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespace$orcomment ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ tokentypes. iswhiteorcomment ( csmtoken. gettokentype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
isWhiteSpace	106	112	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java	0.847014844417572	HIGH	"		public boolean isWhiteSpace(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.isWhiteSpace();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespace ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . iswhitespace ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespace$ ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isNewLine	122	128	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Kept.java	0.8570863604545593	HIGH	"		public boolean isNewLine(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.isNewLine();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isnewline ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . isnewline ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isnewline ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken. isnewline ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
calculatedSyntaxModelAfterListReplacement	417	422	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.0520119853317737	LOW	"		private CalculatedSyntaxModel calculatedSyntaxModelAfterListReplacement(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue){
		    List<CsmElement> elements = new LinkedList<>();
		    Node container = nodeList.getParentNodeForChildren();
		    calculatedSyntaxModelForNode(csm, container, elements, new ListReplacementChange(observableProperty, index, newValue));
		    return new CalculatedSyntaxModel(elements);
		}"	$indentation$ private $whitespace$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistreplacement ( csmelement $whitespace$ csm , $whitespace$ observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm , $whitespace$ container , $whitespace$ elements , $whitespace$ new $whitespace$ listreplacementchange ( observableproperty , $whitespace$ index , $whitespace$ newvalue ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistreplacement ( csmelement $whitespace$ csm, $whitespace$ observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm, $whitespace$ container, $whitespace$ elements, $whitespace$ new $whitespace$ listreplacementchange ( observableproperty, $whitespace$ index, $whitespace$ newvalue ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }			
calculatedSyntaxModelAfterListAddition	387	392	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.0552027560770511	LOW	"		 CalculatedSyntaxModel calculatedSyntaxModelAfterListAddition(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded){
		    List<CsmElement> elements = new LinkedList<>();
		    Node container = nodeList.getParentNodeForChildren();
		    calculatedSyntaxModelForNode(csm, container, elements, new ListAdditionChange(observableProperty, index, nodeAdded));
		    return new CalculatedSyntaxModel(elements);
		}"	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistaddition ( csmelement $whitespace$ csm , $whitespace$ observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ nodeadded ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm , $whitespace$ container , $whitespace$ elements , $whitespace$ new $whitespace$ listadditionchange ( observableproperty , $whitespace$ index , $whitespace$ nodeadded ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistaddition ( csmelement $whitespace$ csm, $whitespace$ observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ nodeadded ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm, $whitespace$ container, $whitespace$ elements, $whitespace$ new $whitespace$ listadditionchange ( observableproperty, $whitespace$ index, $whitespace$ nodeadded ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }			
calculatedSyntaxModelAfterListRemoval	379	384	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.074724294245243	LOW	"		 CalculatedSyntaxModel calculatedSyntaxModelAfterListRemoval(CsmElement csm, ObservableProperty observableProperty, NodeList<?> nodeList, int index){
		    List<CsmElement> elements = new LinkedList<>();
		    Node container = nodeList.getParentNodeForChildren();
		    calculatedSyntaxModelForNode(csm, container, elements, new ListRemovalChange(observableProperty, index));
		    return new CalculatedSyntaxModel(elements);
		}"	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistremoval ( csmelement $whitespace$ csm , $whitespace$ observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm , $whitespace$ container , $whitespace$ elements , $whitespace$ new $whitespace$ listremovalchange ( observableproperty , $whitespace$ index ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterlistremoval ( csmelement $whitespace$ csm, $whitespace$ observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm, $whitespace$ container, $whitespace$ elements, $whitespace$ new $whitespace$ listremovalchange ( observableproperty, $whitespace$ index ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }			
calculatedSyntaxModelAfterPropertyChange	372	376	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.0762217715382576	LOW	"		 CalculatedSyntaxModel calculatedSyntaxModelAfterPropertyChange(CsmElement csm, Node node, ObservableProperty property, Object oldValue, Object newValue){
		    List<CsmElement> elements = new LinkedList<>();
		    calculatedSyntaxModelForNode(csm, node, elements, new PropertyChange(property, oldValue, newValue));
		    return new CalculatedSyntaxModel(elements);
		}"	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterpropertychange ( csmelement $whitespace$ csm , $whitespace$ node $whitespace$ node , $whitespace$ observableproperty $whitespace$ property , $whitespace$ object $whitespace$ oldvalue , $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm , $whitespace$ node , $whitespace$ elements , $whitespace$ new $whitespace$ propertychange ( property , $whitespace$ oldvalue , $whitespace$ newvalue ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelafterpropertychange ( csmelement $whitespace$ csm, $whitespace$ node $whitespace$ node, $whitespace$ observableproperty $whitespace$ property, $whitespace$ object $whitespace$ oldvalue, $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm, $whitespace$ node, $whitespace$ elements, $whitespace$ new $whitespace$ propertychange ( property, $whitespace$ oldvalue, $whitespace$ newvalue ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }			
calculateListReplacementDifference	159	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.0872953608632087	LOW	"		 List<DifferenceElement> calculateListReplacementDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node newValue){
		    Node container = nodeList.getParentNodeForChildren();
		    CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());
		    CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);
		    CalculatedSyntaxModel after = calculatedSyntaxModelAfterListReplacement(element, observableProperty, nodeList, index, newValue);
		    return DifferenceElementCalculator.calculate(original, after);
		}"	$indentation$ list < differenceelement > $whitespace$ calculatelistreplacementdifference ( observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel . forclass ( container . getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element , $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistreplacement ( element , $whitespace$ observableproperty , $whitespace$ nodelist , $whitespace$ index , $whitespace$ newvalue ) ; $newline$ $indentation$ return $whitespace$ differenceelementcalculator . calculate ( original , $whitespace$ after ) ; $newline$ $indentation$ }	$indentation$ list < differenceelement > $whitespace$ calculatelistreplacementdifference ( observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel. forclass ( container. getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element, $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistreplacement ( element, $whitespace$ observableproperty, $whitespace$ nodelist, $whitespace$ index, $whitespace$ newvalue ) ; $newline$ $indentation$ return $whitespace$ differenceelementcalculator. calculate ( original, $whitespace$ after ) ; $newline$ $indentation$ }			
calculateListAdditionDifference	129	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.1008014157414436	LOW	"		 List<DifferenceElement> calculateListAdditionDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index, Node nodeAdded){
		    Node container = nodeList.getParentNodeForChildren();
		    CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());
		    CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);
		    CalculatedSyntaxModel after = calculatedSyntaxModelAfterListAddition(element, observableProperty, nodeList, index, nodeAdded);
		    List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);
		    // Set the line separator character tokens
		    LineSeparator lineSeparator = container.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);
		    replaceEolTokens(differenceElements, lineSeparator);
		    return differenceElements;
		}"	$indentation$ list < differenceelement > $whitespace$ calculatelistadditiondifference ( observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ nodeadded ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel . forclass ( container . getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element , $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistaddition ( element , $whitespace$ observableproperty , $whitespace$ nodelist , $whitespace$ index , $whitespace$ nodeadded ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ differenceelementcalculator . calculate ( original , $whitespace$ after ) ; $newline$ $indentation$ $//·set·the·line·separator·character·tokens$ $newline$ $indentation$ lineseparator $whitespace$ lineseparator $whitespace$ = $whitespace$ container . getlineendingstyleordefault ( lineseparator . system ) ; $newline$ $indentation$ replaceeoltokens ( differenceelements , $whitespace$ lineseparator ) ; $newline$ $indentation$ return $whitespace$ differenceelements ; $newline$ $indentation$ }	$indentation$ list < differenceelement > $whitespace$ calculatelistadditiondifference ( observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ nodeadded ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel. forclass ( container. getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element, $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistaddition ( element, $whitespace$ observableproperty, $whitespace$ nodelist, $whitespace$ index, $whitespace$ nodeadded ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ differenceelementcalculator. calculate ( original, $whitespace$ after ) ; $newline$ $indentation$ return $whitespace$ differenceelements ; $newline$ $indentation$ }			
calculateListRemovalDifference	121	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.1143458262085914	LOW	"		 List<DifferenceElement> calculateListRemovalDifference(ObservableProperty observableProperty, NodeList<?> nodeList, int index){
		    Node container = nodeList.getParentNodeForChildren();
		    CsmElement element = ConcreteSyntaxModel.forClass(container.getClass());
		    CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, container);
		    CalculatedSyntaxModel after = calculatedSyntaxModelAfterListRemoval(element, observableProperty, nodeList, index);
		    return DifferenceElementCalculator.calculate(original, after);
		}"	$indentation$ list < differenceelement > $whitespace$ calculatelistremovaldifference ( observableproperty $whitespace$ observableproperty , $whitespace$ nodelist < ? > $whitespace$ nodelist , $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel . forclass ( container . getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element , $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistremoval ( element , $whitespace$ observableproperty , $whitespace$ nodelist , $whitespace$ index ) ; $newline$ $indentation$ return $whitespace$ differenceelementcalculator . calculate ( original , $whitespace$ after ) ; $newline$ $indentation$ }	$indentation$ list < differenceelement > $whitespace$ calculatelistremovaldifference ( observableproperty $whitespace$ observableproperty, $whitespace$ nodelist <? > $whitespace$ nodelist, $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ node $whitespace$ container $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel. forclass ( container. getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element, $whitespace$ container ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterlistremoval ( element, $whitespace$ observableproperty, $whitespace$ nodelist, $whitespace$ index ) ; $newline$ $indentation$ return $whitespace$ differenceelementcalculator. calculate ( original, $whitespace$ after ) ; $newline$ $indentation$ }			
calculatePropertyChange	167	177	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.1409648954868316	LOW	"		 void calculatePropertyChange(NodeText nodeText, Node observedNode, ObservableProperty property, Object oldValue, Object newValue){
		    if (nodeText == null) {
		        throw new NullPointerException();
		    }
		    CsmElement element = ConcreteSyntaxModel.forClass(observedNode.getClass());
		    CalculatedSyntaxModel original = calculatedSyntaxModelForNode(element, observedNode);
		    CalculatedSyntaxModel after = calculatedSyntaxModelAfterPropertyChange(element, observedNode, property, oldValue, newValue);
		    List<DifferenceElement> differenceElements = DifferenceElementCalculator.calculate(original, after);
		    Difference difference = new Difference(differenceElements, nodeText, observedNode);
		    difference.apply();
		}"	$indentation$ void $whitespace$ calculatepropertychange ( nodetext $whitespace$ nodetext , $whitespace$ node $whitespace$ observednode , $whitespace$ observableproperty $whitespace$ property , $whitespace$ object $whitespace$ oldvalue , $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( nodetext $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nullpointerexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel . forclass ( observednode . getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element , $whitespace$ observednode ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterpropertychange ( element , $whitespace$ observednode , $whitespace$ property , $whitespace$ oldvalue , $whitespace$ newvalue ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ differenceelementcalculator . calculate ( original , $whitespace$ after ) ; $newline$ $indentation$ difference $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements , $whitespace$ nodetext , $whitespace$ observednode ) ; $newline$ $indentation$ difference . apply ( ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ calculatepropertychange ( nodetext $whitespace$ nodetext, $whitespace$ node $whitespace$ observednode, $whitespace$ observableproperty $whitespace$ property, $whitespace$ object $whitespace$ oldvalue, $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( nodetext $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nullpointerexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ csmelement $whitespace$ element $whitespace$ = $whitespace$ concretesyntaxmodel. forclass ( observednode. getclass ( ) ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ original $whitespace$ = $whitespace$ calculatedsyntaxmodelfornode ( element, $whitespace$ observednode ) ; $newline$ $indentation$ calculatedsyntaxmodel $whitespace$ after $whitespace$ = $whitespace$ calculatedsyntaxmodelafterpropertychange ( element, $whitespace$ observednode, $whitespace$ property, $whitespace$ oldvalue, $whitespace$ newvalue ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ differenceelementcalculator. calculate ( original, $whitespace$ after ) ; $newline$ $indentation$ difference $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements, $whitespace$ nodetext, $whitespace$ observednode ) ; $newline$ $indentation$ difference. apply ( ) ; $newline$ $indentation$ }			
toToken	332	361	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.1769131571054458	LOW	"		public static int toToken(Modifier modifier){
		    switch(modifier.getKeyword()) {
		        case PUBLIC:
		            return GeneratedJavaParserConstants.PUBLIC;
		        case PRIVATE:
		            return GeneratedJavaParserConstants.PRIVATE;
		        case PROTECTED:
		            return GeneratedJavaParserConstants.PROTECTED;
		        case STATIC:
		            return GeneratedJavaParserConstants.STATIC;
		        case FINAL:
		            return GeneratedJavaParserConstants.FINAL;
		        case ABSTRACT:
		            return GeneratedJavaParserConstants.ABSTRACT;
		        case TRANSIENT:
		            return GeneratedJavaParserConstants.TRANSIENT;
		        case SYNCHRONIZED:
		            return GeneratedJavaParserConstants.SYNCHRONIZED;
		        case VOLATILE:
		            return GeneratedJavaParserConstants.VOLATILE;
		        case NATIVE:
		            return GeneratedJavaParserConstants.NATIVE;
		        case STRICTFP:
		            return GeneratedJavaParserConstants.STRICTFP;
		        case TRANSITIVE:
		            return GeneratedJavaParserConstants.TRANSITIVE;
		        default:
		            throw new UnsupportedOperationException(""Not supported keyword"" + modifier.getKeyword().name());
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ int $whitespace$ totoken ( modifier $whitespace$ modifier ) { $newline$ $indentation$ switch ( modifier . getkeyword ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ public : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . public ; $newline$ $indentation$ case $whitespace$ private : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . private ; $newline$ $indentation$ case $whitespace$ protected : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . protected ; $newline$ $indentation$ case $whitespace$ static : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . static ; $newline$ $indentation$ case $whitespace$ final : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . final ; $newline$ $indentation$ case $whitespace$ abstract : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . abstract ; $newline$ $indentation$ case $whitespace$ transient : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . transient ; $newline$ $indentation$ case $whitespace$ synchronized : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . synchronized ; $newline$ $indentation$ case $whitespace$ volatile : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . volatile ; $newline$ $indentation$ case $whitespace$ native : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . native ; $newline$ $indentation$ case $whitespace$ strictfp : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . strictfp ; $newline$ $indentation$ case $whitespace$ transitive : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants . transitive ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ modifier . getkeyword ( ) . name ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ int $whitespace$ totoken ( modifier $whitespace$ modifier ) { $newline$ $indentation$ switch ( modifier. getkeyword ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ public : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. public ; $newline$ $indentation$ case $whitespace$ private : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. private ; $newline$ $indentation$ case $whitespace$ protected : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. protected ; $newline$ $indentation$ case $whitespace$ static : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. abstract ; $newline$ $indentation$ case $whitespace$ transient : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. transient ; $newline$ $indentation$ case $whitespace$ synchronized : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. synchronized ; $newline$ $indentation$ case $whitespace$ volatile : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. extraction ; $newline$ $indentation$ case $whitespace$ native : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. native ; $newline$ $indentation$ case $whitespace$ midnight : $newline$ $indentation$ return $whitespace$ generatedjavaparserconstants. mse ; $newline$ $indentation$ case $whitespace$ midnight ; $newline$ $indentation$ default : $newline$ $indentation$ throw			
calculatedSyntaxModelForNode	180	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalDifferenceCalculator.java	0.2835414409637451	LOW	"		 CalculatedSyntaxModel calculatedSyntaxModelForNode(CsmElement csm, Node node){
		    List<CsmElement> elements = new LinkedList<>();
		    calculatedSyntaxModelForNode(csm, node, elements, new NoChange());
		    return new CalculatedSyntaxModel(elements);
		}"	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelfornode ( csmelement $whitespace$ csm , $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm , $whitespace$ node , $whitespace$ elements , $whitespace$ new $whitespace$ nochange ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }	$indentation$ calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodelfornode ( csmelement $whitespace$ csm, $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ list < csmelement > $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ calculatedsyntaxmodelfornode ( csm, $whitespace$ node, $whitespace$ elements, $whitespace$ new $whitespace$ nochange ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ calculatedsyntaxmodel ( elements ) ; $newline$ $indentation$ }			
findChildTextElementForComment	288	305	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0006465175538323	LOW	"		private List<ChildTextElement> findChildTextElementForComment(Comment oldValue, NodeText nodeText){
		    List<ChildTextElement> matchingChildElements;
		    matchingChildElements = selectMatchingChildElements(oldValue, nodeText);
		    if (matchingChildElements.size() > 1) {
		        // Duplicate child nodes found, refine the result
		        matchingChildElements = matchingChildElements.stream().filter(t -> t.getChild().hasRange() && oldValue.hasRange()).filter(t -> t.getChild().getRange().get().equals(oldValue.getRange().get()) || (t.getChild().getComment().isPresent() && t.getChild().getComment().get().hasRange() && t.getChild().getComment().get().getRange().get().equals(oldValue.getRange().get()))).collect(toList());
		    }
		    if (matchingChildElements.size() != 1) {
		        throw new IllegalStateException(""The matching child text element for the comment to be removed could not be found."");
		    }
		    return matchingChildElements;
		}"	$indentation$ private $whitespace$ list < childtextelement > $whitespace$ findchildtextelementforcomment ( comment $whitespace$ oldvalue , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < childtextelement > $whitespace$ matchingchildelements ; $newline$ $indentation$ matchingchildelements $whitespace$ = $whitespace$ selectmatchingchildelements ( oldvalue , $whitespace$ nodetext ) ; $newline$ $indentation$ if $whitespace$ ( matchingchildelements . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·duplicate·child·nodes·found,·refine·the·result$ $newline$ $indentation$ matchingchildelements $whitespace$ = $whitespace$ matchingchildelements . stream ( ) . filter ( t $whitespace$ - > $whitespace$ t . getchild ( ) . hasrange ( ) $whitespace$ && $whitespace$ oldvalue . hasrange ( ) ) . filter ( t $whitespace$ - > $whitespace$ t . getchild ( ) . getrange ( ) . get ( ) . equals ( oldvalue . getrange ( ) . get ( ) ) $whitespace$ || $whitespace$ ( t . getchild ( ) . getcomment ( ) . ispresent ( ) $whitespace$ && $whitespace$ t . getchild ( ) . getcomment ( ) . get ( ) . hasrange ( ) $whitespace$ && $whitespace$ t . getchild ( ) . getcomment ( ) . get ( ) . getrange ( ) . get ( ) . equals ( oldvalue . getrange ( ) . get ( ) ) ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( matchingchildelements . size ( ) $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ matchingchildelements ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < childtextelement > $whitespace$ findchildtextelementforcomment ( comment $whitespace$ oldvalue, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < childtextelement > $whitespace$ matchingchildelements $whitespace$ = $whitespace$ selectmatchingchildelements ( oldvalue, $whitespace$ nodetext ) ; $newline$ $indentation$ if $whitespace$ ( matchingchildelements. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//// $newline$ $indentation$ nodecombination $whitespace$ currentchild $whitespace$ = $whitespace$ matchingchildelements. stream ( ) $newline$ $indentation$. filter ( t $whitespace$ - > $whitespace$ t. getchild ( ). hasrange ( ) $whitespace$ && $whitespace$ oldvalue. hasrange ( ) ) $newline$ $indentation$. filter ( t $whitespace$ - > $whitespace$ t. getchild ( ). getrange ( ). get ( ). equals ( oldvalue. getrange ( ) ) $newline$ $indentation$ || $whitespace$ ( t. getchild ( ). getcomment ( ). ispresent ( ) $whitespace$ && $whitespace$ t. getchild ( ). getcomment ( ). hasrange ( ) $whitespace$ && $whitespace$ t. getchild ( ). getcomment ( ). get ( ). getrange ( ) ) ) $newline$ $indentation$. collect ( tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( matchingchildelements. size ( ) $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ matchingchildelements			
findTokenTextElementForComment	331	359	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.000716968323104	LOW	"		private List<TokenTextElement> findTokenTextElementForComment(Comment oldValue, NodeText nodeText){
		    List<TokenTextElement> matchingTokens;
		    if (oldValue instanceof JavadocComment) {
		        matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(JAVADOC_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().equals(oldValue.asString())).collect(toList());
		    } else if (oldValue instanceof BlockComment) {
		        matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(MULTI_LINE_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().equals(oldValue.asString())).collect(toList());
		    } else {
		        matchingTokens = nodeText.getElements().stream().filter(e -> e.isToken(SINGLE_LINE_COMMENT)).map(e -> (TokenTextElement) e).filter(t -> t.getText().trim().equals((oldValue.asString()).trim())).collect(toList());
		    }
		    // To check that a comment matches in the list of tokens, if exists the range must be always checked,
		    // as comments with the same content may exist on different lines.
		    return matchingTokens.stream().filter(t -> (!t.getToken().hasRange() && !oldValue.hasRange()) || (t.getToken().hasRange() && oldValue.hasRange() && t.getToken().getRange().get().equals(oldValue.getRange().get()))).collect(toList());
		}"	$indentation$ private $whitespace$ list < tokentextelement > $whitespace$ findtokentextelementforcomment ( comment $whitespace$ oldvalue , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < tokentextelement > $whitespace$ matchingtokens ; $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ instanceof $whitespace$ javadoccomment ) $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext . getelements ( ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . istoken ( javadoc_comment ) ) . map ( e $whitespace$ - > $whitespace$ ( tokentextelement ) $whitespace$ e ) . filter ( t $whitespace$ - > $whitespace$ t . gettext ( ) . equals ( oldvalue . asstring ( ) ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( oldvalue $whitespace$ instanceof $whitespace$ blockcomment ) $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext . getelements ( ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . istoken ( multi_line_comment ) ) . map ( e $whitespace$ - > $whitespace$ ( tokentextelement ) $whitespace$ e ) . filter ( t $whitespace$ - > $whitespace$ t . gettext ( ) . equals ( oldvalue . asstring ( ) ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext . getelements ( ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . istoken ( single_line_comment ) ) . map ( e $whitespace$ - > $whitespace$ ( tokentextelement ) $whitespace$ e ) . filter ( t $whitespace$ - > $whitespace$ t . gettext ( ) . trim ( ) . equals ( ( oldvalue . asstring ( ) ) . trim ( ) ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·to·check·that·a·comment·matches·in·the·list·of·tokens,·if·exists·the·range·must·be·always·checked,$ $newline$ $indentation$ $//·as·comments·with·the·same·content·may·exist·on·different·lines.$ $newline$ $indentation$ return $whitespace$ matchingtokens . stream ( ) . filter ( t $whitespace$ - > $whitespace$ ( ! t . gettoken ( ) . hasrange ( ) $whitespace$ && $whitespace$ ! oldvalue . hasrange ( ) ) $whitespace$ || $whitespace$ ( t . gettoken ( ) . hasrange ( ) $whitespace$ && $whitespace$ oldvalue . hasrange ( ) $whitespace$ && $whitespace$ t . gettoken ( ) . getrange ( ) . get ( ) . equals ( oldvalue . getrange ( ) . get ( ) ) ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < tokentextelement > $whitespace$ findtokentextelementforcomment ( comment $whitespace$ oldvalue, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < tokentextelement > $whitespace$ matchingtokens ; $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ instanceof $whitespace$ javadoccomment ) $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext. getelements ( ). stream ( ) $newline$ $indentation$. filter ( e $whitespace$ - > $whitespace$ e. istoken ( javadoc_comment ) ) $newline$ $indentation$. map ( e $whitespace$ - > $whitespace$ ( tokentextelement ) $whitespace$ e ). filter ( t $whitespace$ - > $whitespace$ t. gettext ( ). equals ( oldvalue. asstring ( ) ) ) $newline$ $indentation$. collect ( tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( oldvalue $whitespace$ instanceof $whitespace$ blockcomment ) $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext. getelements ( ). stream ( ) $newline$ $indentation$. filter ( e $whitespace$ - > $whitespace$ e. istoken ( multi_line_comment ) ) $newline$ $indentation$. map ( e $whitespace$ - > $whitespace$ ( tokentextelement ) $whitespace$ e ). filter ( t $whitespace$ - > $whitespace$ t. gettext ( ). equals ( oldvalue. asstring ( ) ) ) $newline$ $indentation$. collect ( tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ matchingtokens $whitespace$ = $whitespace$ nodetext. getelements ( ). stream ( ). filter ( e $whitespace$ - > $whitespace$ e. istoken ( single_line_			
findNodeListName	693	729	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0235304832458496	LOW	"		private static ObservableProperty findNodeListName(NodeList<?> nodeList){
		    Node parent = nodeList.getParentNodeForChildren();
		    for (Method m : parent.getClass().getMethods()) {
		        if (m.getParameterCount() == 0 && m.getReturnType().getCanonicalName().equals(JAVAPARSER_AST_NODELIST)) {
		            try {
		                Object raw = m.invoke(parent);
		                if (!(raw instanceof NodeList)) {
		                    throw new IllegalStateException(""Expected NodeList, found "" + raw.getClass().getCanonicalName());
		                }
		                NodeList<?> result = (NodeList<?>) raw;
		                if (result == nodeList) {
		                    String name = m.getName();
		                    if (name.startsWith(""get"")) {
		                        name = name.substring(""get"".length());
		                    }
		                    return ObservableProperty.fromCamelCaseName(decapitalize(name));
		                }
		            } catch (IllegalAccessException | InvocationTargetException e) {
		                throw new RuntimeException(e);
		            }
		        } else if (m.getParameterCount() == 0 && isReturningOptionalNodeList(m)) {
		            try {
		                Optional<NodeList<?>> raw = (Optional<NodeList<?>>) m.invoke(parent);
		                if (raw.isPresent() && raw.get() == nodeList) {
		                    String name = m.getName();
		                    if (name.startsWith(""get"")) {
		                        name = name.substring(""get"".length());
		                    }
		                    return ObservableProperty.fromCamelCaseName(decapitalize(name));
		                }
		            } catch (IllegalAccessException | InvocationTargetException e) {
		                throw new RuntimeException(e);
		            }
		        }
		    }
		    throw new IllegalArgumentException(""Cannot find list name of NodeList of size "" + nodeList.size());
		}"	$indentation$ private $whitespace$ static $whitespace$ observableproperty $whitespace$ findnodelistname ( nodelist < ? > $whitespace$ nodelist ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ nodelist . getparentnodeforchildren ( ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ m $whitespace$ : $whitespace$ parent . getclass ( ) . getmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( m . getparametercount ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ m . getreturntype ( ) . getcanonicalname ( ) . equals ( javaparser_ast_nodelist ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ object $whitespace$ raw $whitespace$ = $whitespace$ m . invoke ( parent ) ; $newline$ $indentation$ if $whitespace$ ( ! ( raw $whitespace$ instanceof $whitespace$ nodelist ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ raw . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ nodelist < ? > $whitespace$ result $whitespace$ = $whitespace$ ( nodelist < ? > ) $whitespace$ raw ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ == $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ m . getname ( ) ; $newline$ $indentation$ if $whitespace$ ( name . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ name $whitespace$ = $whitespace$ name . substring ( $string$ . length ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ observableproperty . fromcamelcasename ( decapitalize ( name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( illegalaccessexception $whitespace$ | $whitespace$ invocationtargetexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( m . getparametercount ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ isreturningoptionalnodelist ( m ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ optional < nodelist < ? >> $whitespace$ raw $whitespace$ = $whitespace$ ( optional < nodelist < ? >> ) $whitespace$ m . invoke ( parent ) ; $newline$ $indentation$ if $whitespace$ ( raw . ispresent ( ) $whitespace$ && $whitespace$ raw . get ( ) $whitespace$ == $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ m . getname ( ) ; $newline$ $indentation$ if $whitespace$ ( name . startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ name $whitespace$ = $whitespace$ name . substring ( $string$ . length ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ observableproperty . fromcamelcasename ( decapitalize ( name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( illegalaccessexception $whitespace$ | $whitespace$ invocationtargetexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ nodelist . size ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ observableproperty $whitespace$ findnodelistname ( nodelist <? > $whitespace$ nodelist ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ nodelist. getparentnodeforchildren ( ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ m $whitespace$ : $whitespace$ parent. getclass ( ). getmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( m. getparametercount ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ m. getreturntype ( ). getcanonicalname ( ). equals ( javaparser_ast_nodelist ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ object $whitespace$ raw $whitespace$ = $whitespace$ m. invoke ( parent ) ; $newline$ $indentation$ if $whitespace$ (! ( raw $whitespace$ instanceof $whitespace$ nodelist ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ raw. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ nodelist <? > $whitespace$ result $whitespace$ = $whitespace$ ( nodelist <? > ) $whitespace$ raw ; $newline$ $indentation$ if $whitespace$ ( result $whitespace$ == $whitespace$ nodelist ) $whitespace$ { $newline$ $indentation$ string $whitespace$ name $whitespace$ = $whitespace$ m. getname ( ) ; $newline$ $indentation$ if $whitespace$ ( name. startswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ name $whitespace$ = $whitespace$ name. substring ( $string$. length ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
selectMatchingChildElements	307	325	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0262561049312353	LOW	"		private List<ChildTextElement> selectMatchingChildElements(Comment oldValue, NodeText nodeText){
		    List<ChildTextElement> result = new ArrayList<>();
		    List<ChildTextElement> childTextElements = nodeText.getElements().stream().filter(e -> e.isChild()).map(c -> (ChildTextElement) c).collect(toList());
		    ListIterator<ChildTextElement> iterator = childTextElements.listIterator();
		    while (iterator.hasNext()) {
		        ChildTextElement textElement = iterator.next();
		        if (textElement.isComment() && isSameComment(((Comment) textElement.getChild()), oldValue)) {
		            result.add(textElement);
		            continue;
		        }
		        Node node = textElement.getChild();
		        if (node.getComment().isPresent() && isSameComment(node.getComment().get(), oldValue)) {
		            result.add(textElement);
		            continue;
		        }
		    }
		    return result;
		}"	$indentation$ private $whitespace$ list < childtextelement > $whitespace$ selectmatchingchildelements ( comment $whitespace$ oldvalue , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < childtextelement > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ list < childtextelement > $whitespace$ childtextelements $whitespace$ = $whitespace$ nodetext . getelements ( ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . ischild ( ) ) . map ( c $whitespace$ - > $whitespace$ ( childtextelement ) $whitespace$ c ) . collect ( tolist ( ) ) ; $newline$ $indentation$ listiterator < childtextelement > $whitespace$ iterator $whitespace$ = $whitespace$ childtextelements . listiterator ( ) ; $newline$ $indentation$ while $whitespace$ ( iterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ textelement $whitespace$ = $whitespace$ iterator . next ( ) ; $newline$ $indentation$ if $whitespace$ ( textelement . iscomment ( ) $whitespace$ && $whitespace$ issamecomment ( ( ( comment ) $whitespace$ textelement . getchild ( ) ) , $whitespace$ oldvalue ) ) $whitespace$ { $newline$ $indentation$ result . add ( textelement ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ node $whitespace$ = $whitespace$ textelement . getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( node . getcomment ( ) . ispresent ( ) $whitespace$ && $whitespace$ issamecomment ( node . getcomment ( ) . get ( ) , $whitespace$ oldvalue ) ) $whitespace$ { $newline$ $indentation$ result . add ( textelement ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < childtextelement > $whitespace$ selectmatchingchildelements ( comment $whitespace$ oldvalue, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < childtextelement > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ nodetext $whitespace$ childtextelements $whitespace$ = $whitespace$ nodetext. getelements ( ). stream ( ) $newline$ $indentation$. filter ( e $whitespace$ - > $whitespace$ e. ischild ( ) ) $newline$ $indentation$. map ( childtextelement : : getchild ) $newline$ $indentation$. collect ( tolist ( ) ) ; $newline$ $indentation$ node $whitespace$ node $whitespace$ = $whitespace$ textelement. getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( node. getcomment ( ). ispresent ( ) $whitespace$ && $whitespace$ issamecomment ( node. getcomment ( ). get ( ), $whitespace$ oldvalue ) ) $whitespace$ { $newline$ $indentation$ result. add ( textelement ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ node $whitespace$ = $whitespace$ textelement. getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( node. getcomment ( ). ispresent ( ) $whitespace$ && $whitespace$ issamecomment ( node. getcomment ( ). get ( ), $whitespace$ oldvalue ) ) $whitespace$ { $newline$ $indentation$ result. add ( textelement ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ node $whitespace$ = $whitespace$ textelement. getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( node. getcomment ( ). ispresent ( ) $whitespace$ && $whitespace$ is			
concretePropertyChange	125	197	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0305623058229684	LOW	"		@Override
		public void concretePropertyChange(Node observedNode, ObservableProperty property, Object oldValue, Object newValue){
		    if (oldValue == newValue) {
		        // Not really a change, ignore
		        return;
		    }
		    if (property == ObservableProperty.RANGE || property == ObservableProperty.COMMENTED_NODE) {
		        return;
		    }
		    if (property == ObservableProperty.COMMENT) {
		        Optional<Node> parentNode = observedNode.getParentNode();
		        NodeText nodeText = parentNode.map(parent -> getOrCreateNodeText(parentNode.get())).orElseGet(() -> getOrCreateNodeText(observedNode));
		        if (oldValue == null) {
		            // this case corresponds to the addition of a comment
		            int index = // Find the position of the comment node and put in front of it the [...]
		            parentNode.isPresent() ? //
		            nodeText.findChild(observedNode) : 0;
		            /* Add the same indentation to the comment as the previous node
		                     * for example if we want to add a comment on the body of the method declaration :
		                     * Actual code
		                     * {@code
		                     * public class Foo {
		                     *   void visit(final UnknownType n, final Void arg)
		                     *   {
		                     *   }
		                     * }
		                     * }
		                     * Expected result
		                     * {@code
		                     * public class Foo {
		                     *   void visit(final UnknownType n, final Void arg)
		                     *   //added comment <-- we should insert indentation before the comment
		                     *   {
		                     *   }
		                     * }
		                     * }
		                     */
		            fixIndentOfAddedNode(nodeText, index - 1);
		            LineSeparator lineSeparator = observedNode.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);
		            nodeText.addElement(index++, makeCommentToken((Comment) newValue));
		            nodeText.addToken(index, eolTokenKind(lineSeparator), lineSeparator.asRawString());
		            // code indentation after inserting an eol token may be wrong
		        } else if (newValue == null) {
		            // this case corresponds to a deletion of a comment
		            if (oldValue instanceof Comment) {
		                if (((Comment) oldValue).isOrphan()) {
		                    nodeText = getOrCreateNodeText(observedNode);
		                }
		                int index = getIndexOfComment((Comment) oldValue, nodeText);
		                nodeText.removeElement(index);
		                if (isCompleteLine(nodeText.getElements(), index)) {
		                    removeAllExtraCharacters(nodeText.getElements(), index);
		                } else {
		                    removeAllExtraCharactersStartingFrom(nodeText.getElements().listIterator(index));
		                }
		            } else {
		                throw new UnsupportedOperationException(""Trying to remove something that is not a comment!"");
		            }
		        } else {
		            // this is a replacement of a comment
		            List<TokenTextElement> matchingTokens = findTokenTextElementForComment((Comment) oldValue, nodeText);
		            if (matchingTokens.size() != 1) {
		                throw new IllegalStateException(""The matching comment to be replaced could not be found"");
		            }
		            Comment newComment = (Comment) newValue;
		            TokenTextElement matchingElement = matchingTokens.get(0);
		            nodeText.replace(matchingElement.and(matchingElement.matchByRange()), makeCommentToken(newComment));
		        }
		    }
		    NodeText nodeText = getOrCreateNodeText(observedNode);
		    if (nodeText == null) {
		        throw new NullPointerException(observedNode.getClass().getSimpleName());
		    }
		    LEXICAL_DIFFERENCE_CALCULATOR.calculatePropertyChange(nodeText, observedNode, property, oldValue, newValue);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretepropertychange ( node $whitespace$ observednode , $whitespace$ observableproperty $whitespace$ property , $whitespace$ object $whitespace$ oldvalue , $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ == $whitespace$ newvalue ) $whitespace$ { $newline$ $indentation$ $//·not·really·a·change,·ignore$ $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty . range $whitespace$ || $whitespace$ property $whitespace$ == $whitespace$ observableproperty . commented_node ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty . comment ) $whitespace$ { $newline$ $indentation$ optional < node > $whitespace$ parentnode $whitespace$ = $whitespace$ observednode . getparentnode ( ) ; $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ parentnode . map ( parent $whitespace$ - > $whitespace$ getorcreatenodetext ( parentnode . get ( ) ) ) . orelseget ( ( ) $whitespace$ - > $whitespace$ getorcreatenodetext ( observednode ) ) ; $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·this·case·corresponds·to·the·addition·of·a·comment$ $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $//·find·the·position·of·the·comment·node·and·put·in·front·of·it·the·[...]$ $newline$ $indentation$ parentnode . ispresent ( ) $whitespace$ ? $whitespace$ // $newline$ $indentation$ nodetext . findchild ( observednode ) $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ $/*·add·the·same·indentation·to·the·comment·as·the·previous·node························*·for·example·if·we·want·to·add·a·comment·on·the·body·of·the·method·declaration·:························*·actual·code························*·{@code························*·public·class·foo·{························*···void·visit(final·unknowntype·n,·final·void·arg)························*···{························*···}························*·}························*·}························*·expected·result························*·{@code························*·public·class·foo·{························*···void·visit(final·unknowntype·n,·final·void·arg)························*···//added·comment·<--·we·should·insert·indentation·before·the·comment························*···{························*···}························*·}························*·}························*/$ $newline$ $indentation$ fixindentofaddednode ( nodetext , $whitespace$ index $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ lineseparator $whitespace$ lineseparator $whitespace$ = $whitespace$ observednode . getlineendingstyleordefault ( lineseparator . system ) ; $newline$ $indentation$ nodetext . addelement ( index ++ , $whitespace$ makecommenttoken ( ( comment ) $whitespace$ newvalue ) ) ; $newline$ $indentation$ nodetext . addtoken ( index , $whitespace$ eoltokenkind ( lineseparator ) , $whitespace$ lineseparator . asrawstring ( ) ) ; $newline$ $indentation$ $//·code·indentation·after·inserting·an·eol·token·may·be·wrong$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( newvalue $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·this·case·corresponds·to·a·deletion·of·a·comment$ $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ instanceof $whitespace$ comment ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( comment ) $whitespace$ oldvalue ) . isorphan ( ) ) $whitespace$ { $newline$ $indentation$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( observednode ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ getindexofcomment ( ( comment ) $whitespace$ oldvalue , $whitespace$ nodetext ) ; $newline$ $indentation$ nodetext . removeelement ( index ) ; $newline$ $indentation$ if $whitespace$ ( iscompleteline ( nodetext . getelements ( ) , $whitespace$ index ) ) $whitespace$ { $newline$ $indentation$ removeallextracharacters ( nodetext . getelements ( ) , $whitespace$ index ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ removeallextracharactersstartingfrom ( nodetext . getelements ( ) . listiterator ( index ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·this·is·a·replacement·of·a·comment$ $newline$ $indentation$ list < tokentextelement > $whitespace$ matchingtokens $whitespace$ = $whitespace$ findtokentextelementforcomment ( ( comment ) $whitespace$ oldvalue , $whitespace$ nodetext ) ; $newline$ $indentation$ if $whitespace$ ( matchingtokens . size ( ) $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ comment $whitespace$ newcomment $whitespace$ = $whitespace$ ( comment ) $whitespace$ newvalue ; $newline$ $indentation$ tokentextelement $whitespace$ matchingelement $whitespace$ = $whitespace$ matchingtokens . get ( $number$ ) ; $newline$ $indentation$ nodetext . replace ( matchingelement . and ( matchingelement . matchbyrange ( ) ) , $whitespace$ makecommenttoken ( newcomment ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( observednode ) ; $newline$ $indentation$ if $whitespace$ ( nodetext $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nullpointerexception ( observednode . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ lexical_difference_calculator . calculatepropertychange ( nodetext , $whitespace$ observednode , $whitespace$ property , $whitespace$ oldvalue , $whitespace$ newvalue ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretepropertychange ( node $whitespace$ observednode, $whitespace$ observableproperty $whitespace$ property, $whitespace$ object $whitespace$ oldvalue, $whitespace$ object $whitespace$ newvalue ) { $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ == $whitespace$ newvalue ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty. range $whitespace$ || $whitespace$ property $whitespace$ == $whitespace$ observableproperty. commented_node ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty. comment ) $whitespace$ { $newline$ $indentation$ optional < node > $whitespace$ parentnode $whitespace$ = $whitespace$ observednode. getparentnode ( ) ; $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ parentnode. map ( parent $whitespace$ - > $whitespace$ getorcreatenodetext ( parentnode. get ( ) ) ). orelseget ( ( ) $whitespace$ - > $whitespace$ getorcreatenodetext ( observednode ) ) ; $newline$ $indentation$ if $whitespace$ ( oldvalue $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty. comment ) $whitespace$ { $newline$ $indentation$ optional < node > $whitespace$ parentnode $whitespace$ = $whitespace$ observednode. getparentnode ( ) ; $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ parentnode. map ( parent			
interpret	584	646	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0426265560090541	LOW	"		private static NodeText interpret(Node node, CsmElement csm, NodeText nodeText){
		    LexicalDifferenceCalculator.CalculatedSyntaxModel calculatedSyntaxModel = new LexicalDifferenceCalculator().calculatedSyntaxModelForNode(csm, node);
		    List<TextElement> indentation = findIndentation(node);
		    boolean pendingIndentation = false;
		    // Add a comment and line separator if necessary
		    node.getComment().ifPresent(comment -> {
		        // new comment has no range so in this case we want to force the comment before the node
		        if (!comment.hasRange()) {
		            LineSeparator lineSeparator = node.getLineEndingStyleOrDefault(LineSeparator.SYSTEM);
		            calculatedSyntaxModel.elements.add(0, new CsmToken(eolTokenKind(lineSeparator), lineSeparator.asRawString()));
		            calculatedSyntaxModel.elements.add(0, new CsmChild(comment));
		        }
		    });
		    for (CsmElement element : calculatedSyntaxModel.elements) {
		        if (element instanceof CsmIndent) {
		            int indexCurrentElement = calculatedSyntaxModel.elements.indexOf(element);
		            if (calculatedSyntaxModel.elements.size() > indexCurrentElement && !(calculatedSyntaxModel.elements.get(indexCurrentElement + 1) instanceof CsmUnindent)) {
		                for (int i = 0; i < Difference.STANDARD_INDENTATION_SIZE; i++) {
		                    indentation.add(new TokenTextElement(SPACE, "" ""));
		                }
		            }
		        } else if (element instanceof CsmUnindent) {
		            for (int i = 0; i < Difference.STANDARD_INDENTATION_SIZE && indentation.size() > 0; i++) {
		                indentation.remove(indentation.size() - 1);
		            }
		        }
		        if (pendingIndentation && !(element instanceof CsmToken && ((CsmToken) element).isNewLine())) {
		            indentation.forEach(nodeText::addElement);
		        }
		        pendingIndentation = false;
		        if (element instanceof LexicalDifferenceCalculator.CsmChild) {
		            nodeText.addChild(((LexicalDifferenceCalculator.CsmChild) element).getChild());
		        } else if (element instanceof CsmToken) {
		            CsmToken csmToken = (CsmToken) element;
		            nodeText.addToken(csmToken.getTokenType(), csmToken.getContent());
		            if (csmToken.isNewLine()) {
		                pendingIndentation = true;
		            }
		        } else if (element instanceof CsmMix) {
		            CsmMix csmMix = (CsmMix) element;
		            csmMix.getElements().forEach(e -> interpret(node, e, nodeText));
		        } else {
		            // Indentation should probably be dealt with before because an indentation has effects also on the
		            // following lines
		            if (!(element instanceof CsmIndent) && !(element instanceof CsmUnindent)) {
		                throw new UnsupportedOperationException(""Unknown element type: "" + element.getClass().getSimpleName());
		            }
		        }
		    }
		    // Array brackets are a pain... we do not have a way to represent them explicitly in the AST
		    // so they have to be handled in a special way
		    if (node instanceof VariableDeclarator) {
		        VariableDeclarator variableDeclarator = (VariableDeclarator) node;
		        variableDeclarator.getParentNode().ifPresent(parent -> ((NodeWithVariables<?>) parent).getMaximumCommonType().ifPresent(mct -> {
		            int extraArrayLevels = variableDeclarator.getType().getArrayLevel() - mct.getArrayLevel();
		            for (int i = 0; i < extraArrayLevels; i++) {
		                nodeText.addElement(new TokenTextElement(LBRACKET));
		                nodeText.addElement(new TokenTextElement(RBRACKET));
		            }
		        }));
		    }
		    return nodeText;
		}"	$indentation$ private $whitespace$ static $whitespace$ nodetext $whitespace$ interpret ( node $whitespace$ node , $whitespace$ csmelement $whitespace$ csm , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ lexicaldifferencecalculator . calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodel $whitespace$ = $whitespace$ new $whitespace$ lexicaldifferencecalculator ( ) . calculatedsyntaxmodelfornode ( csm , $whitespace$ node ) ; $newline$ $indentation$ list < textelement > $whitespace$ indentation $whitespace$ = $whitespace$ findindentation ( node ) ; $newline$ $indentation$ boolean $whitespace$ pendingindentation $whitespace$ = $whitespace$ false ; $newline$ $indentation$ $//·add·a·comment·and·line·separator·if·necessary$ $newline$ $indentation$ node . getcomment ( ) . ifpresent ( comment $whitespace$ - > $whitespace$ { $newline$ $indentation$ $//·new·comment·has·no·range·so·in·this·case·we·want·to·force·the·comment·before·the·node$ $newline$ $indentation$ if $whitespace$ ( ! comment . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ lineseparator $whitespace$ lineseparator $whitespace$ = $whitespace$ node . getlineendingstyleordefault ( lineseparator . system ) ; $newline$ $indentation$ calculatedsyntaxmodel . elements . add ( $number$ , $whitespace$ new $whitespace$ csmtoken ( eoltokenkind ( lineseparator ) , $whitespace$ lineseparator . asrawstring ( ) ) ) ; $newline$ $indentation$ calculatedsyntaxmodel . elements . add ( $number$ , $whitespace$ new $whitespace$ csmchild ( comment ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ for $whitespace$ ( csmelement $whitespace$ element $whitespace$ : $whitespace$ calculatedsyntaxmodel . elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmindent ) $whitespace$ { $newline$ $indentation$ int $whitespace$ indexcurrentelement $whitespace$ = $whitespace$ calculatedsyntaxmodel . elements . indexof ( element ) ; $newline$ $indentation$ if $whitespace$ ( calculatedsyntaxmodel . elements . size ( ) $whitespace$ > $whitespace$ indexcurrentelement $whitespace$ && $whitespace$ ! ( calculatedsyntaxmodel . elements . get ( indexcurrentelement $whitespace$ + $whitespace$ $number$ ) $whitespace$ instanceof $whitespace$ csmunindent ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ difference . standard_indentation_size ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation . add ( new $whitespace$ tokentextelement ( space , $whitespace$ $string$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmunindent ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ difference . standard_indentation_size $whitespace$ && $whitespace$ indentation . size ( ) $whitespace$ > $whitespace$ $number$ ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ indentation . remove ( indentation . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( pendingindentation $whitespace$ && $whitespace$ ! ( element $whitespace$ instanceof $whitespace$ csmtoken $whitespace$ && $whitespace$ ( ( csmtoken ) $whitespace$ element ) . isnewline ( ) ) ) $whitespace$ { $newline$ $indentation$ indentation . foreach ( nodetext : : addelement ) ; $newline$ $indentation$ } $newline$ $indentation$ pendingindentation $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ lexicaldifferencecalculator . csmchild ) $whitespace$ { $newline$ $indentation$ nodetext . addchild ( ( ( lexicaldifferencecalculator . csmchild ) $whitespace$ element ) . getchild ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ nodetext . addtoken ( csmtoken . gettokentype ( ) , $whitespace$ csmtoken . getcontent ( ) ) ; $newline$ $indentation$ if $whitespace$ ( csmtoken . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ pendingindentation $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( element $whitespace$ instanceof $whitespace$ csmmix ) $whitespace$ { $newline$ $indentation$ csmmix $whitespace$ csmmix $whitespace$ = $whitespace$ ( csmmix ) $whitespace$ element ; $newline$ $indentation$ csmmix . getelements ( ) . foreach ( e $whitespace$ - > $whitespace$ interpret ( node , $whitespace$ e , $whitespace$ nodetext ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·indentation·should·probably·be·dealt·with·before·because·an·indentation·has·effects·also·on·the$ $newline$ $indentation$ $//·following·lines$ $newline$ $indentation$ if $whitespace$ ( ! ( element $whitespace$ instanceof $whitespace$ csmindent ) $whitespace$ && $whitespace$ ! ( element $whitespace$ instanceof $whitespace$ csmunindent ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ element . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·array·brackets·are·a·pain...·we·do·not·have·a·way·to·represent·them·explicitly·in·the·ast$ $newline$ $indentation$ $//·so·they·have·to·be·handled·in·a·special·way$ $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ ( variabledeclarator ) $whitespace$ node ; $newline$ $indentation$ variabledeclarator . getparentnode ( ) . ifpresent ( parent $whitespace$ - > $whitespace$ ( ( nodewithvariables < ? > ) $whitespace$ parent ) . getmaximumcommontype ( ) . ifpresent ( mct $whitespace$ - > $whitespace$ { $newline$ $indentation$ int $whitespace$ extraarraylevels $whitespace$ = $whitespace$ variabledeclarator . gettype ( ) . getarraylevel ( ) $whitespace$ - $whitespace$ mct . getarraylevel ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ extraarraylevels ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ nodetext . addelement ( new $whitespace$ tokentextelement ( lbracket ) ) ; $newline$ $indentation$ nodetext . addelement ( new $whitespace$ tokentextelement ( rbracket ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nodetext ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ nodetext $whitespace$ interpret ( node $whitespace$ node, $whitespace$ csmelement $whitespace$ csm, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ lexicaldifferencecalculator. calculatedsyntaxmodel $whitespace$ calculatedsyntaxmodel $whitespace$ = $whitespace$ new $whitespace$ lexicaldifferencecalculator ( ). calculatedsyntaxmodelfornode ( csm, $whitespace$ node ) ; $newline$ $indentation$ list < textelement > $whitespace$ indentation $whitespace$ = $whitespace$ find $newline$ $indentation$ ( node ) ; $newline$ $indentation$ boolean $whitespace$ pending ; $newline$ $indentation$ $whitespace$ = $whitespace$ false ; $newline$ $indentation$ $whitespace$////			
storeInitialTextForOneNode	468	486	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0823772773146629	LOW	"		private static void storeInitialTextForOneNode(Node node, List<JavaToken> nodeTokens){
		    if (nodeTokens == null) {
		        nodeTokens = Collections.emptyList();
		    }
		    List<Pair<Range, TextElement>> elements = new LinkedList<>();
		    for (Node child : node.getChildNodes()) {
		        if (!child.isPhantom()) {
		            if (!child.hasRange()) {
		                throw new RuntimeException(""Range not present on node "" + child);
		            }
		            elements.add(new Pair<>(child.getRange().get(), new ChildTextElement(child)));
		        }
		    }
		    for (JavaToken token : nodeTokens) {
		        elements.add(new Pair<>(token.getRange().get(), new TokenTextElement(token)));
		    }
		    elements.sort(comparing(e -> e.a.begin));
		    node.setData(NODE_TEXT_DATA, new NodeText(elements.stream().map(p -> p.b).collect(toList())));
		}"	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ storeinitialtextforonenode ( node $whitespace$ node , $whitespace$ list < javatoken > $whitespace$ nodetokens ) { $newline$ $indentation$ if $whitespace$ ( nodetokens $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ nodetokens $whitespace$ = $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < pair < range , $whitespace$ textelement >> $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ child $whitespace$ : $whitespace$ node . getchildnodes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! child . isphantom ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! child . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ child ) ; $newline$ $indentation$ } $newline$ $indentation$ elements . add ( new $whitespace$ pair < > ( child . getrange ( ) . get ( ) , $whitespace$ new $whitespace$ childtextelement ( child ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( javatoken $whitespace$ token $whitespace$ : $whitespace$ nodetokens ) $whitespace$ { $newline$ $indentation$ elements . add ( new $whitespace$ pair < > ( token . getrange ( ) . get ( ) , $whitespace$ new $whitespace$ tokentextelement ( token ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ elements . sort ( comparing ( e $whitespace$ - > $whitespace$ e . a . begin ) ) ; $newline$ $indentation$ node . setdata ( node_text_data , $whitespace$ new $whitespace$ nodetext ( elements . stream ( ) . map ( p $whitespace$ - > $whitespace$ p . b ) . collect ( tolist ( ) ) ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ storeinitialtextforonenode ( node $whitespace$ node, $whitespace$ list < javatoken > $whitespace$ nodetokens ) { $newline$ $indentation$ if $whitespace$ ( nodetokens $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ currentnodetokens $whitespace$ = $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < pair < range, $whitespace$ textelement >> $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ child $whitespace$ : $whitespace$ nodetokens ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! child. isphantom ( ) ) $whitespace$ { $newline$ $indentation$ arraylist <! child. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ child ) ; $newline$ $indentation$ } $newline$ $indentation$ elements. add ( new $whitespace$ pair < > ( child. getrange ( ). get ( ), $whitespace$ new $whitespace$ tokentextelement ( child ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ elements. sort ( comparing ( e $whitespace$ - > $whitespace$ e. a. begin )			
prettyPrintingTextNode	525	579	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0895814448595047	LOW	"		private static void prettyPrintingTextNode(Node node, NodeText nodeText){
		    if (node instanceof PrimitiveType) {
		        PrimitiveType primitiveType = (PrimitiveType) node;
		        switch(primitiveType.getType()) {
		            case BOOLEAN:
		                nodeText.addToken(BOOLEAN, node.toString());
		                break;
		            case CHAR:
		                nodeText.addToken(CHAR, node.toString());
		                break;
		            case BYTE:
		                nodeText.addToken(BYTE, node.toString());
		                break;
		            case SHORT:
		                nodeText.addToken(SHORT, node.toString());
		                break;
		            case INT:
		                nodeText.addToken(INT, node.toString());
		                break;
		            case LONG:
		                nodeText.addToken(LONG, node.toString());
		                break;
		            case FLOAT:
		                nodeText.addToken(FLOAT, node.toString());
		                break;
		            case DOUBLE:
		                nodeText.addToken(DOUBLE, node.toString());
		                break;
		            default:
		                throw new IllegalArgumentException();
		        }
		        return;
		    }
		    if (node instanceof JavadocComment) {
		        Comment comment = (JavadocComment) node;
		        nodeText.addToken(JAVADOC_COMMENT, comment.getHeader() + ((JavadocComment) node).getContent() + comment.getFooter());
		        return;
		    }
		    if (node instanceof BlockComment) {
		        Comment comment = (BlockComment) node;
		        nodeText.addToken(MULTI_LINE_COMMENT, comment.getHeader() + ((BlockComment) node).getContent() + comment.getFooter());
		        return;
		    }
		    if (node instanceof LineComment) {
		        Comment comment = (LineComment) node;
		        nodeText.addToken(SINGLE_LINE_COMMENT, comment.getHeader() + comment.getContent());
		        return;
		    }
		    if (node instanceof Modifier) {
		        Modifier modifier = (Modifier) node;
		        nodeText.addToken(LexicalDifferenceCalculator.toToken(modifier), modifier.getKeyword().asString());
		        return;
		    }
		    interpret(node, ConcreteSyntaxModel.forClass(node.getClass()), nodeText);
		}"	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ prettyprintingtextnode ( node $whitespace$ node , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ primitivetype ) $whitespace$ { $newline$ $indentation$ primitivetype $whitespace$ primitivetype $whitespace$ = $whitespace$ ( primitivetype ) $whitespace$ node ; $newline$ $indentation$ switch ( primitivetype . gettype ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ boolean : $newline$ $indentation$ nodetext . addtoken ( boolean , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ char : $newline$ $indentation$ nodetext . addtoken ( char , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ byte : $newline$ $indentation$ nodetext . addtoken ( byte , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ short : $newline$ $indentation$ nodetext . addtoken ( short , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ int : $newline$ $indentation$ nodetext . addtoken ( int , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ long : $newline$ $indentation$ nodetext . addtoken ( long , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ float : $newline$ $indentation$ nodetext . addtoken ( float , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ double : $newline$ $indentation$ nodetext . addtoken ( double , $whitespace$ node . tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ javadoccomment ) $whitespace$ { $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ ( javadoccomment ) $whitespace$ node ; $newline$ $indentation$ nodetext . addtoken ( javadoc_comment , $whitespace$ comment . getheader ( ) $whitespace$ + $whitespace$ ( ( javadoccomment ) $whitespace$ node ) . getcontent ( ) $whitespace$ + $whitespace$ comment . getfooter ( ) ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ blockcomment ) $whitespace$ { $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ ( blockcomment ) $whitespace$ node ; $newline$ $indentation$ nodetext . addtoken ( multi_line_comment , $whitespace$ comment . getheader ( ) $whitespace$ + $whitespace$ ( ( blockcomment ) $whitespace$ node ) . getcontent ( ) $whitespace$ + $whitespace$ comment . getfooter ( ) ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ linecomment ) $whitespace$ { $newline$ $indentation$ comment $whitespace$ comment $whitespace$ = $whitespace$ ( linecomment ) $whitespace$ node ; $newline$ $indentation$ nodetext . addtoken ( single_line_comment , $whitespace$ comment . getheader ( ) $whitespace$ + $whitespace$ comment . getcontent ( ) ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ modifier ) $whitespace$ { $newline$ $indentation$ modifier $whitespace$ modifier $whitespace$ = $whitespace$ ( modifier ) $whitespace$ node ; $newline$ $indentation$ nodetext . addtoken ( lexicaldifferencecalculator . totoken ( modifier ) , $whitespace$ modifier . getkeyword ( ) . asstring ( ) ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ interpret ( node , $whitespace$ concretesyntaxmodel . forclass ( node . getclass ( ) ) , $whitespace$ nodetext ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ prettyprintingtextnode ( node $whitespace$ node, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ primitivetype ) $whitespace$ { $newline$ $indentation$ primitivetype $whitespace$ primitivetype $whitespace$ = $whitespace$ ( primitivetype ) $whitespace$ node ; $newline$ $indentation$ primitivetype. addtoken ( boolean, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ char : $newline$ $indentation$ nodetext. addtoken ( char, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ byte : $newline$ $indentation$ nodetext. addtoken ( byte, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ short : $newline$ $indentation$ nodetext. addtoken ( short, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ long : $newline$ $indentation$ nodetext. addtoken ( long, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ float : $newline$ $indentation$ nodetext. addtoken ( float, $whitespace$ node. tostring ( ) ) ; $newline$ $indentation$ break ;			
tokensPreceeding	491	506	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.0944321453571319	LOW	"		private static Iterator<TokenTextElement> tokensPreceeding(final Node node){
		    if (!node.getParentNode().isPresent()) {
		        return new TextElementIteratorsFactory.EmptyIterator<>();
		    }
		    // There is the awfully painful case of the fake types involved in variable declarators and
		    // fields or variable declaration that are, of course, an exception...
		    NodeText parentNodeText = getOrCreateNodeText(node.getParentNode().get());
		    int index = parentNodeText.tryToFindChild(node);
		    if (index == NodeText.NOT_FOUND) {
		        if (node.getParentNode().get() instanceof VariableDeclarator) {
		            return tokensPreceeding(node.getParentNode().get());
		        }
		        return new TextElementIteratorsFactory.EmptyIterator<TokenTextElement>();
		    }
		    return new TextElementIteratorsFactory.CascadingIterator<>(TextElementIteratorsFactory.partialReverseIterator(parentNodeText, index - 1), () -> tokensPreceeding(node.getParentNode().get()));
		}"	$indentation$ private $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ tokenspreceeding ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ! node . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory . emptyiterator < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·there·is·the·awfully·painful·case·of·the·fake·types·involved·in·variable·declarators·and$ $newline$ $indentation$ $//·fields·or·variable·declaration·that·are,·of·course,·an·exception...$ $newline$ $indentation$ nodetext $whitespace$ parentnodetext $whitespace$ = $whitespace$ getorcreatenodetext ( node . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ parentnodetext . trytofindchild ( node ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ nodetext . not_found ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokenspreceeding ( node . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory . emptyiterator < tokentextelement > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory . cascadingiterator < > ( textelementiteratorsfactory . partialreverseiterator ( parentnodetext , $whitespace$ index $whitespace$ - $whitespace$ $number$ ) , $whitespace$ ( ) $whitespace$ - > $whitespace$ tokenspreceeding ( node . getparentnode ( ) . get ( ) ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ tokenspreceeding ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ (! node. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory. emptyiterator < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory. emptyiterator < tokentextelement > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ init ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node. getparentnode ( ). get ( ) $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokenspreceeding ( node. getparentnode ( ). get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ scope $whitespace$ curscope $whitespace$ = $whitespace$ new $whitespace$ scope ( node ) ; $newline$ $indentation$ if $whitespace$ ( curscope $whitespace$ instanceof $whitespace$ variabledeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokenspreceeding ( node. getparentnode ( ). get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementiteratorsfactory. cascadingiterator < > ( textelementiterator			
concreteListChange	398	411	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.1113034263253212	LOW	"		@Override
		public void concreteListChange(NodeList<?> changedList, ListChangeType type, int index, Node nodeAddedOrRemoved){
		    NodeText nodeText = getOrCreateNodeText(changedList.getParentNodeForChildren());
		    final List<DifferenceElement> differenceElements;
		    if (type == AstObserver.ListChangeType.REMOVAL) {
		        differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListRemovalDifference(findNodeListName(changedList), changedList, index);
		    } else if (type == AstObserver.ListChangeType.ADDITION) {
		        differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListAdditionDifference(findNodeListName(changedList), changedList, index, nodeAddedOrRemoved);
		    } else {
		        throw new UnsupportedOperationException(""Unknown change type: "" + type);
		    }
		    Difference difference = new Difference(differenceElements, nodeText, changedList.getParentNodeForChildren());
		    difference.apply();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretelistchange ( nodelist < ? > $whitespace$ changedlist , $whitespace$ listchangetype $whitespace$ type , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ nodeaddedorremoved ) { $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( changedlist . getparentnodeforchildren ( ) ) ; $newline$ $indentation$ final $whitespace$ list < differenceelement > $whitespace$ differenceelements ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ astobserver . listchangetype . removal ) $whitespace$ { $newline$ $indentation$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator . calculatelistremovaldifference ( findnodelistname ( changedlist ) , $whitespace$ changedlist , $whitespace$ index ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( type $whitespace$ == $whitespace$ astobserver . listchangetype . addition ) $whitespace$ { $newline$ $indentation$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator . calculatelistadditiondifference ( findnodelistname ( changedlist ) , $whitespace$ changedlist , $whitespace$ index , $whitespace$ nodeaddedorremoved ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type ) ; $newline$ $indentation$ } $newline$ $indentation$ difference $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements , $whitespace$ nodetext , $whitespace$ changedlist . getparentnodeforchildren ( ) ) ; $newline$ $indentation$ difference . apply ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretelistchange ( nodelist <? > $whitespace$ changedlist, $whitespace$ listchangetype $whitespace$ type, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ nodeaddedorremoved ) { $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( changedlist. getparentnodeforchildren ( ) ) ; $newline$ $indentation$ final $whitespace$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ imagetext. getordefault ( ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ astobserver. listchangetype. removal ) $whitespace$ { $newline$ $indentation$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator. calculatelistremovaldifference ( findnodelistname ( changedlist ), $whitespace$ changedlist, $whitespace$ index ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( type $whitespace$ == $whitespace$ astobserver. listchangetype. addition ) $whitespace$ { $newline$ $indentation$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator. calculatelistadditiondifference ( findnodelistname ( changedlist ), $whitespace$ changedlist, $whitespace$ index, $whitespace$ nodeaddedorremoved ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ list < differenceelement > $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements, $whitespace$ nodetext, $whitespace$ changedlist. getparentnodeforchildren ( ) )			
concreteListReplacement	413	419	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.1127344369888305	LOW	"		@Override
		public void concreteListReplacement(NodeList<?> changedList, int index, Node oldValue, Node newValue){
		    NodeText nodeText = getOrCreateNodeText(changedList.getParentNodeForChildren());
		    List<DifferenceElement> differenceElements = LEXICAL_DIFFERENCE_CALCULATOR.calculateListReplacementDifference(findNodeListName(changedList), changedList, index, newValue);
		    Difference difference = new Difference(differenceElements, nodeText, changedList.getParentNodeForChildren());
		    difference.apply();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretelistreplacement ( nodelist < ? > $whitespace$ changedlist , $whitespace$ int $whitespace$ index , $whitespace$ node $whitespace$ oldvalue , $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( changedlist . getparentnodeforchildren ( ) ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator . calculatelistreplacementdifference ( findnodelistname ( changedlist ) , $whitespace$ changedlist , $whitespace$ index , $whitespace$ newvalue ) ; $newline$ $indentation$ difference $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements , $whitespace$ nodetext , $whitespace$ changedlist . getparentnodeforchildren ( ) ) ; $newline$ $indentation$ difference . apply ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ concretelistreplacement ( nodelist <? > $whitespace$ changedlist, $whitespace$ int $whitespace$ index, $whitespace$ node $whitespace$ oldvalue, $whitespace$ node $whitespace$ newvalue ) { $newline$ $indentation$ nodetext $whitespace$ nodetext $whitespace$ = $whitespace$ getorcreatenodetext ( changedlist. getparentnodeforchildren ( ) ) ; $newline$ $indentation$ list < differenceelement > $whitespace$ differenceelements $whitespace$ = $whitespace$ lexical_difference_calculator. calculatelistreplacementdifference ( findnodelistname ( changedlist ), $whitespace$ changedlist, $whitespace$ index, $whitespace$ newvalue ) ; $newline$ $indentation$ difference $whitespace$ difference $whitespace$ = $whitespace$ new $whitespace$ difference ( differenceelements, $whitespace$ nodetext, $whitespace$ changedlist. getparentnodeforchildren ( ) ) ; $newline$ $indentation$ difference. apply ( ) ; $newline$ $indentation$ }			
makeCommentToken	260	271	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.2252058684825897	LOW	"		private TokenTextElement makeCommentToken(Comment newComment){
		    if (newComment.isJavadocComment()) {
		        return new TokenTextElement(JAVADOC_COMMENT, newComment.getHeader() + newComment.getContent() + newComment.getFooter());
		    }
		    if (newComment.isLineComment()) {
		        return new TokenTextElement(SINGLE_LINE_COMMENT, newComment.getHeader() + newComment.getContent());
		    }
		    if (newComment.isBlockComment()) {
		        return new TokenTextElement(MULTI_LINE_COMMENT, newComment.getHeader() + newComment.getContent() + newComment.getFooter());
		    }
		    throw new UnsupportedOperationException(""Unknown type of comment: "" + newComment.getClass().getSimpleName());
		}"	$indentation$ private $whitespace$ tokentextelement $whitespace$ makecommenttoken ( comment $whitespace$ newcomment ) { $newline$ $indentation$ if $whitespace$ ( newcomment . isjavadoccomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( javadoc_comment , $whitespace$ newcomment . getheader ( ) $whitespace$ + $whitespace$ newcomment . getcontent ( ) $whitespace$ + $whitespace$ newcomment . getfooter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( newcomment . islinecomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( single_line_comment , $whitespace$ newcomment . getheader ( ) $whitespace$ + $whitespace$ newcomment . getcontent ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( newcomment . isblockcomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( multi_line_comment , $whitespace$ newcomment . getheader ( ) $whitespace$ + $whitespace$ newcomment . getcontent ( ) $whitespace$ + $whitespace$ newcomment . getfooter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ newcomment . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ tokentextelement $whitespace$ makecommenttoken ( comment $whitespace$ newcomment ) { $newline$ $indentation$ if $whitespace$ ( newcomment. isjavadoccomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( add_comment, $whitespace$ newcomment. getheader ( ) $whitespace$ + $whitespace$ newcomment. getcontent ( ) $whitespace$ + $whitespace$ newcomment. getfooter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( newcomment. islinecomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( single_line_comment, $whitespace$ newcomment. getheader ( ) $whitespace$ + $whitespace$ newcomment. getcontent ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( newcomment. isblockcomment ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokentextelement ( multi_line_comment, $whitespace$ newcomment. getheader ( ) $whitespace$ + $whitespace$ newcomment. getcontent ( ) $whitespace$ + $whitespace$ newcomment. getfooter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ newcomment. getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ }			
isReturningOptionalNodeList	681	691	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.2596738338470459	LOW	"		private static boolean isReturningOptionalNodeList(Method m){
		    if (!m.getReturnType().getCanonicalName().equals(JAVA_UTIL_OPTIONAL)) {
		        return false;
		    }
		    if (!(m.getGenericReturnType() instanceof ParameterizedType)) {
		        return false;
		    }
		    ParameterizedType parameterizedType = (ParameterizedType) m.getGenericReturnType();
		    java.lang.reflect.Type optionalArgument = parameterizedType.getActualTypeArguments()[0];
		    return (optionalArgument.getTypeName().startsWith(JAVAPARSER_AST_NODELIST));
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isreturningoptionalnodelist ( method $whitespace$ m ) { $newline$ $indentation$ if $whitespace$ ( ! m . getreturntype ( ) . getcanonicalname ( ) . equals ( java_util_optional ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( m . getgenericreturntype ( ) $whitespace$ instanceof $whitespace$ parameterizedtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ parameterizedtype $whitespace$ parameterizedtype $whitespace$ = $whitespace$ ( parameterizedtype ) $whitespace$ m . getgenericreturntype ( ) ; $newline$ $indentation$ java . lang . reflect . type $whitespace$ optionalargument $whitespace$ = $whitespace$ parameterizedtype . getactualtypearguments ( ) [ $number$ ] ; $newline$ $indentation$ return $whitespace$ ( optionalargument . gettypename ( ) . startswith ( javaparser_ast_nodelist ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isreturningoptionalnodelist ( method $whitespace$ m ) { $newline$ $indentation$ return $whitespace$! m. getreturntype ( ). getcanonicalname ( ). equals ( java_util_optional ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( m. getgenericreturntype ( ) $whitespace$ instanceof $whitespace$ parameterizedtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ parameterizedtype $whitespace$ parameterizedtype $whitespace$ = $whitespace$ ( parameterizedtype ) $whitespace$ m. getgenericreturntype ( ) ; $newline$ $indentation$ return $whitespace$ ( optionalargument. gettypename ( ). startswith ( javaparser_ast_nodelist ) ) ; $newline$ $indentation$ }			
getIndexOfComment	273	283	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.2673927545547485	LOW	"		private int getIndexOfComment(Comment oldValue, NodeText nodeText){
		    List<TokenTextElement> matchingTokens = findTokenTextElementForComment(oldValue, nodeText);
		    if (!matchingTokens.isEmpty()) {
		        TextElement matchingElement = matchingTokens.get(0);
		        return nodeText.findElement(matchingElement.and(matchingElement.matchByRange()));
		    }
		    // If no matching TokenTextElements were found, we try searching through ChildTextElements as well
		    List<ChildTextElement> matchingChilds = findChildTextElementForComment(oldValue, nodeText);
		    ChildTextElement matchingChild = matchingChilds.get(0);
		    return nodeText.findElement(matchingChild.and(matchingChild.matchByRange()));
		}"	$indentation$ private $whitespace$ int $whitespace$ getindexofcomment ( comment $whitespace$ oldvalue , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < tokentextelement > $whitespace$ matchingtokens $whitespace$ = $whitespace$ findtokentextelementforcomment ( oldvalue , $whitespace$ nodetext ) ; $newline$ $indentation$ if $whitespace$ ( ! matchingtokens . isempty ( ) ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ matchingelement $whitespace$ = $whitespace$ matchingtokens . get ( $number$ ) ; $newline$ $indentation$ return $whitespace$ nodetext . findelement ( matchingelement . and ( matchingelement . matchbyrange ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·no·matching·tokentextelements·were·found,·we·try·searching·through·childtextelements·as·well$ $newline$ $indentation$ list < childtextelement > $whitespace$ matchingchilds $whitespace$ = $whitespace$ findchildtextelementforcomment ( oldvalue , $whitespace$ nodetext ) ; $newline$ $indentation$ childtextelement $whitespace$ matchingchild $whitespace$ = $whitespace$ matchingchilds . get ( $number$ ) ; $newline$ $indentation$ return $whitespace$ nodetext . findelement ( matchingchild . and ( matchingchild . matchbyrange ( ) ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ int $whitespace$ getindexofcomment ( comment $whitespace$ oldvalue, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < tokentextelement > $whitespace$ matchingtokens $whitespace$ = $whitespace$ findsplittertextelementforcomment ( oldvalue, $whitespace$ nodetext ) ; $newline$ $indentation$ if $whitespace$ ( matchingtokens. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nodetext. findelement ( matchingelement. and ( $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////if $whitespace$ the $whitespace$ current $whitespace$ token $whitespace$ operations $whitespace$ ----- $whitespace$ we $whitespace$ are $whitespace$ forced $whitespace$ to, $whitespace$ or $whitespace$ 80% $whitespace$ of $whitespace$ the $whitespace$ time $whitespace$ that $whitespace$ we $whitespace$ are $whitespace$ not, $whitespace$ otherwise $whitespace$ use $whitespace$ between $whitespace$ 2 $whitespace$ and $whitespace$ 4 $whitespace$ data $whitespace$ paths $newline$ $indentation$ list < childtextelement > $whitespace$ matchingchilds $whitespace$ = $whitespace$ findsplitterelementforcomment ( oldvalue, $whitespace$ nodetext ) ; $newline$ $indentation$ childtextelement $whitespace$ matchingchild $whitespace$ = $whitespace$ matchingchilds. get ( $number$ ) ; $newline$ $indentation$ return $whitespace$ nodetext. findelement ( matchingchild. and ( matchingchild. matchbyrange ( ) ) ) ; $newline$ $indentation$ }			
findIndentation	659	676	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.2920238077640533	LOW	"		 static List<TextElement> findIndentation(Node node){
		    List<TextElement> followingNewlines = new LinkedList<>();
		    Iterator<TokenTextElement> it = tokensPreceeding(node);
		    while (it.hasNext()) {
		        TokenTextElement tte = it.next();
		        if (tte.getTokenKind() == SINGLE_LINE_COMMENT || tte.isNewline()) {
		            break;
		        }
		        followingNewlines.add(tte);
		    }
		    Collections.reverse(followingNewlines);
		    for (int i = 0; i < followingNewlines.size(); i++) {
		        if (!followingNewlines.get(i).isSpaceOrTab()) {
		            return followingNewlines.subList(0, i);
		        }
		    }
		    return followingNewlines;
		}"	$indentation$ static $whitespace$ list < textelement > $whitespace$ findindentation ( node $whitespace$ node ) { $newline$ $indentation$ list < textelement > $whitespace$ followingnewlines $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ iterator < tokentextelement > $whitespace$ it $whitespace$ = $whitespace$ tokenspreceeding ( node ) ; $newline$ $indentation$ while $whitespace$ ( it . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ tokentextelement $whitespace$ tte $whitespace$ = $whitespace$ it . next ( ) ; $newline$ $indentation$ if $whitespace$ ( tte . gettokenkind ( ) $whitespace$ == $whitespace$ single_line_comment $whitespace$ || $whitespace$ tte . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ followingnewlines . add ( tte ) ; $newline$ $indentation$ } $newline$ $indentation$ collections . reverse ( followingnewlines ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ followingnewlines . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! followingnewlines . get ( i ) . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ followingnewlines . sublist ( $number$ , $whitespace$ i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ followingnewlines ; $newline$ $indentation$ }	$indentation$ static $whitespace$ list < textelement > $whitespace$ findnewline ( node $whitespace$ node ) { $newline$ $indentation$ list < textelement > $whitespace$ followingnewlines $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ iterator < tokentextelement > $whitespace$ it $whitespace$ = $whitespace$ tokenspreceeding ( node ) ; $newline$ $indentation$ while $whitespace$ ( it. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ tokentextelement $whitespace$ tte $whitespace$ = $whitespace$ it. next ( ) ; $newline$ $indentation$ if $whitespace$ ( tte. gettokenkind ( ) $whitespace$ == $whitespace$ single_line_comment $whitespace$ || $whitespace$ tte. isnewline ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ followingnewlines. add ( tte ) ; $newline$ $indentation$ } $newline$ $indentation$ collections. reverse ( followingnewlines ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ followingnewlines. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! followingnewlines. get ( i ). isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ followingnewlines. sublist ( $number$, $whitespace$ i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ followingnewlines ; $newline$ $indentation$ }			
removeAllExtraCharactersBeforePosition	232	241	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/LexicalPreservingPrinter.java	0.6159437894821167	MID	"		private void removeAllExtraCharactersBeforePosition(ListIterator<TextElement> iterator){
		    while (iterator.hasPrevious()) {
		        TextElement textElement = iterator.previous();
		        if (textElement.isSpaceOrTab()) {
		            iterator.remove();
		            continue;
		        }
		        break;
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ removeallextracharactersbeforeposition ( listiterator < textelement > $whitespace$ iterator ) { $newline$ $indentation$ while $whitespace$ ( iterator . hasprevious ( ) ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ iterator . previous ( ) ; $newline$ $indentation$ if $whitespace$ ( textelement . isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ iterator . remove ( ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ removeallextracharactersbeforeposition ( listiterator < textelement > $whitespace$ iterator ) { $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ iterator. previous ( ) ; $newline$ $indentation$ while $whitespace$ ( textelement. hasprevious ( ) ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ iterator. previous ( ) ; $newline$ $indentation$ if $whitespace$ ( textelement. isspaceortab ( ) ) $whitespace$ { $newline$ $indentation$ iterator. remove ( ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ }			
expand	171	175	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/NodeText.java	0.6506094336509705	MID	"		 String expand(){
		    StringBuffer sb = new StringBuffer();
		    elements.forEach(e -> sb.append(e.expand()));
		    return sb.toString();
		}"	$indentation$ string $whitespace$ expand ( ) { $newline$ $indentation$ stringbuffer $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuffer ( ) ; $newline$ $indentation$ elements . foreach ( e $whitespace$ - > $whitespace$ sb . append ( e . expand ( ) ) ) ; $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ string $whitespace$ expand ( ) { $newline$ $indentation$ stringbuffer $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuffer ( ) ; $newline$ $indentation$ elements. foreach ( e $whitespace$ - > $whitespace$ sb. append ( e. expand ( ) ) ) ; $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
remove	129	147	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/NodeText.java	0.6999921202659607	MID	"		public void remove(TextElementMatcher matcher, boolean potentiallyFollowingWhitespace){
		    int i = 0;
		    for (TextElement e : elements) {
		        if (matcher.match(e)) {
		            elements.remove(e);
		            if (potentiallyFollowingWhitespace) {
		                if (i < elements.size()) {
		                    if (elements.get(i).isWhiteSpace()) {
		                        elements.remove(i);
		                    }
		                } else {
		                    throw new UnsupportedOperationException(""There is no element to remove!"");
		                }
		            }
		            return;
		        }
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ public $whitespace$ void $whitespace$ remove ( textelementmatcher $whitespace$ matcher , $whitespace$ boolean $whitespace$ potentiallyfollowingwhitespace ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( matcher . match ( e ) ) $whitespace$ { $newline$ $indentation$ elements . remove ( e ) ; $newline$ $indentation$ if $whitespace$ ( potentiallyfollowingwhitespace ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ elements . size ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( elements . get ( i ) . iswhitespace ( ) ) $whitespace$ { $newline$ $indentation$ elements . remove ( i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ remove ( textelementmatcher $whitespace$ matcher, $whitespace$ boolean $whitespace$ potentiallyfollowingwhitespace ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( textelement $whitespace$ e $whitespace$ : $whitespace$ elements ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( matcher. match ( e ) ) $whitespace$ { $newline$ $indentation$ elements. remove ( e ) ; $newline$ $indentation$ if $whitespace$ ( potentiallyfollowingwhitespace ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ elements. size ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( elements. get ( i ). iswhitespace$ ( ) ) $whitespace$ { $newline$ $indentation$ elements. remove ( i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
add	215	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.830910861492157	HIGH	"		@Override
		public void add(E e){
		    if (slotFilled) {
		        throw new IllegalStateException(""peek() or element() called before add()"");
		    }
		    iterator.add(e);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ add ( e $whitespace$ e ) { $newline$ $indentation$ if $whitespace$ ( slotfilled ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ iterator . add ( e ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ add ( e $whitespace$ e ) { $newline$ $indentation$ if $whitespace$ ( slotfilled ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ iterator. add ( e ) ; $newline$ $indentation$ }			
set	206	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.830910861492157	HIGH	"		@Override
		public void set(E e){
		    if (slotFilled) {
		        throw new IllegalStateException(""peek() or element() called before set()"");
		    }
		    iterator.set(e);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ set ( e $whitespace$ e ) { $newline$ $indentation$ if $whitespace$ ( slotfilled ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ iterator . set ( e ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ set ( e $whitespace$ e ) { $newline$ $indentation$ if $whitespace$ ( slotfilled ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ iterator. set ( e ) ; $newline$ $indentation$ }			
next	145	155	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.8690889477729797	HIGH	"		@Override
		public E next(){
		    if (!hasNext()) {
		        throw new NoSuchElementException();
		    }
		    final E x = slotFilled ? slot : iterator.next();
		    // reset the lookahead slot
		    slot = null;
		    slotFilled = false;
		    return x;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ next ( ) { $newline$ $indentation$ if $whitespace$ ( ! hasnext ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nosuchelementexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ e $whitespace$ x $whitespace$ = $whitespace$ slotfilled $whitespace$ ? $whitespace$ slot $whitespace$ : $whitespace$ iterator . next ( ) ; $newline$ $indentation$ $//·reset·the·lookahead·slot$ $newline$ $indentation$ slot $whitespace$ = $whitespace$ null ; $newline$ $indentation$ slotfilled $whitespace$ = $whitespace$ false ; $newline$ $indentation$ return $whitespace$ x ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ next ( ) { $newline$ $indentation$ if $whitespace$ (! hasnext ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nosuchelementexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ e $whitespace$ x $whitespace$ = $whitespace$ slotfilled $whitespace$? $whitespace$ slot $whitespace$ : $whitespace$ iterator. next ( ) ; $newline$ $indentation$ $////slationreset $whitespace$ = $whitespace$ ( null $whitespace$ == $whitespace$ integer. up ) $whitespace$? $whitespace$ $number$ $whitespace$ : $whitespace$ iterator. next ( ) ; $newline$ $indentation$ $whitespace$// $newline$ $indentation$ return $whitespace$ x ; $newline$ $indentation$ }			
element	136	143	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.8726573586463928	HIGH	"		@Override
		public E element(){
		    fill();
		    if (exhausted) {
		        throw new NoSuchElementException();
		    }
		    return slot;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ element ( ) { $newline$ $indentation$ fill ( ) ; $newline$ $indentation$ if $whitespace$ ( exhausted ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nosuchelementexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ slot ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ element ( ) { $newline$ $indentation$ fill ( ) ; $newline$ $indentation$ if $whitespace$ ( backslash $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nosuchelementexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ slot ; $newline$ $indentation$ }			
peek	123	127	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.8870252966880798	HIGH	"		@Override
		public E peek(){
		    fill();
		    return exhausted ? null : slot;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ peek ( ) { $newline$ $indentation$ fill ( ) ; $newline$ $indentation$ return $whitespace$ exhausted $whitespace$ ? $whitespace$ null $whitespace$ : $whitespace$ slot ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ e $whitespace$ peek ( ) { $newline$ $indentation$ fill ( ) ; $newline$ $indentation$ return $whitespace$ $whitespace$? $whitespace$ null $whitespace$ : $whitespace$ slot ; $newline$ $indentation$ }			
hasNext	103	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PeekingIterator.java	0.9024744033813475	HIGH	"		@Override
		public boolean hasNext(){
		    if (exhausted) {
		        return false;
		    }
		    return slotFilled || iterator.hasNext();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) { $newline$ $indentation$ if $whitespace$ ( exhausted ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ slotfilled $whitespace$ || $whitespace$ iterator . hasnext ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) { $newline$ $indentation$ return $whitespace$ ( excludes ) $whitespace$ || $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ return $whitespace$ true $whitespace$ only $whitespace$ if $whitespace$ the $whitespace$ value $whitespace$ is $whitespace$ not $whitespace$ legit $newline$ $indentation$ return $whitespace$ slotfilled $whitespace$ || $whitespace$ iterator. hasnext ( ) ; $newline$ $indentation$ }			
isPhantomNode	52	63	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/PhantomNodeLogic.java	0.066288985311985	LOW	"		 static boolean isPhantomNode(Node node){
		    if (isPhantomNodeCache.containsKey(node)) {
		        return isPhantomNodeCache.get(node);
		    }
		    if (node instanceof UnknownType) {
		        return true;
		    }
		    boolean res = (node.getParentNode().isPresent() && node.getParentNode().get().hasRange() && node.hasRange() && !node.getParentNode().get().getRange().get().contains(node.getRange().get()) || inPhantomNode(node, LEVELS_TO_EXPLORE));
		    isPhantomNodeCache.put(node, res);
		    node.register(cacheCleaner);
		    return res;
		}"	$indentation$ static $whitespace$ boolean $whitespace$ isphantomnode ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( isphantomnodecache . containskey ( node ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isphantomnodecache . get ( node ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ unknowntype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ res $whitespace$ = $whitespace$ ( node . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ node . getparentnode ( ) . get ( ) . hasrange ( ) $whitespace$ && $whitespace$ node . hasrange ( ) $whitespace$ && $whitespace$ ! node . getparentnode ( ) . get ( ) . getrange ( ) . get ( ) . contains ( node . getrange ( ) . get ( ) ) $whitespace$ || $whitespace$ inphantomnode ( node , $whitespace$ levels_to_explore ) ) ; $newline$ $indentation$ isphantomnodecache . put ( node , $whitespace$ res ) ; $newline$ $indentation$ node . register ( cachecleaner ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ static $whitespace$ boolean $whitespace$ isphantomnode ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( isphantomnodecache. containskey ( node ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isphantomnodecache. get ( node ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ unknowntype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ res $whitespace$ = $whitespace$ ( node. getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ node. getparentnode ( ). get ( ). hasrange ( ) $whitespace$ && $whitespace$ node. hasrange ( ) $whitespace$ && $whitespace$! node. getparentnode ( ). get ( ). getrange ( ). get ( ). contains ( node. getrange ( ). get ( ) ) $whitespace$ || $whitespace$ inphantomnode ( node, $whitespace$ levels_to_explore ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }			
isPrimitiveType	96	102	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Removed.java	0.6055291891098022	MID	"		public boolean isPrimitiveType(){
		    if (isChild()) {
		        LexicalDifferenceCalculator.CsmChild csmChild = (LexicalDifferenceCalculator.CsmChild) element;
		        return csmChild.getChild() instanceof PrimitiveType;
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ if $whitespace$ ( ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator . csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator . csmchild ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmchild . getchild ( ) $whitespace$ instanceof $whitespace$ primitivetype ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isprimitivetype ( ) { $newline$ $indentation$ if $whitespace$ ( ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator. csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator. csmchild ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmchild. getchild ( ) $whitespace$ instanceof $whitespace$ primitivetype ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getTokenType	69	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Removed.java	0.677758514881134	MID	"		public int getTokenType(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.getTokenType();
		    }
		    throw new IllegalStateException(""Removed is not a "" + CsmToken.class.getSimpleName());
		}"	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . gettokentype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ csmtoken . class . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ int $whitespace$ gettokentype ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ csmtoken ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ csmtoken. gettokentype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ notvalid ( csmtoken $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ csmtoken. gettokentype ( ) $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isvalid ( csmtoken $whitespace$ csmtoken ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isvalid. gettokentype ( ) $whitespace$ == $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ }			
isWhiteSpace	104	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Removed.java	0.847014844417572	HIGH	"		public boolean isWhiteSpace(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.isWhiteSpace();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespace ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . iswhitespace ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ iswhitespace$ ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
isNewLine	120	126	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Removed.java	0.8570863604545593	HIGH	"		public boolean isNewLine(){
		    if (isToken()) {
		        CsmToken csmToken = (CsmToken) element;
		        return csmToken.isNewLine();
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isnewline ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken . isnewline ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isnewline ( ) { $newline$ $indentation$ if $whitespace$ ( istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ csmtoken $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ element ; $newline$ $indentation$ return $whitespace$ csmtoken. isnewline ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
hasOnlyWhitespace	159	175	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/RemovedGroup.java	0.1263976693153381	LOW	"		private boolean hasOnlyWhitespace(Removed startElement, Function<TokenRange, Boolean> hasOnlyWhitespaceFunction){
		    boolean hasOnlyWhitespace = false;
		    if (startElement.isChild()) {
		        LexicalDifferenceCalculator.CsmChild csmChild = (LexicalDifferenceCalculator.CsmChild) startElement.getElement();
		        Node child = csmChild.getChild();
		        Optional<TokenRange> tokenRange = child.getTokenRange();
		        if (tokenRange.isPresent()) {
		            hasOnlyWhitespace = hasOnlyWhitespaceFunction.apply(tokenRange.get());
		        }
		    } else if (startElement.isToken()) {
		        CsmToken token = (CsmToken) startElement.getElement();
		        if (token.isNewLine()) {
		            hasOnlyWhitespace = true;
		        }
		    }
		    return hasOnlyWhitespace;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ hasonlywhitespace ( removed $whitespace$ startelement , $whitespace$ function < tokenrange , $whitespace$ boolean > $whitespace$ hasonlywhitespacefunction ) { $newline$ $indentation$ boolean $whitespace$ hasonlywhitespace $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( startelement . ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator . csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator . csmchild ) $whitespace$ startelement . getelement ( ) ; $newline$ $indentation$ node $whitespace$ child $whitespace$ = $whitespace$ csmchild . getchild ( ) ; $newline$ $indentation$ optional < tokenrange > $whitespace$ tokenrange $whitespace$ = $whitespace$ child . gettokenrange ( ) ; $newline$ $indentation$ if $whitespace$ ( tokenrange . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ hasonlywhitespace $whitespace$ = $whitespace$ hasonlywhitespacefunction . apply ( tokenrange . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( startelement . istoken ( ) ) $whitespace$ { $newline$ $indentation$ csmtoken $whitespace$ token $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ startelement . getelement ( ) ; $newline$ $indentation$ if $whitespace$ ( token . isnewline ( ) ) $whitespace$ { $newline$ $indentation$ hasonlywhitespace $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ hasonlywhitespace ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ hasonlywhitespace ( removed $whitespace$ startelement, $whitespace$ function < tokenrange, $whitespace$ boolean > $whitespace$ hasonlywhitespacefunction ) { $newline$ $indentation$ boolean $whitespace$ hasonlywhitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( startelement. ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator. csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator. csmchild ) $whitespace$ startelement. getelement ( ) ; $newline$ $indentation$ node $whitespace$ child $whitespace$ = $whitespace$ csmchild. getchild ( ) ; $newline$ $indentation$ optional < tokenrange > $whitespace$ tokenrange $whitespace$ = $whitespace$ child. gettokenrange ( ) ; $newline$ $indentation$ if $whitespace$ ( tokenrange. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ esmtoken $whitespace$ token $whitespace$ = $whitespace$ ( csmtoken ) $whitespace$ startelement. getelement ( ) ; $newline$ $indentation$ if $whitespace$ ( token. isnewline ( ) ) $whitespace$ { $newline$ $indentation$ hasonly $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ hasonly ; $newline$ $indentation$ }			
getIndentation	204	238	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/RemovedGroup.java	0.1660479009151458	LOW	"		 final Optional<Integer> getIndentation(){
		    Removed firstElement = null;
		    int indentation = 0;
		    // search for the first element which is not a new line
		    Iterator it = iterator();
		    while (it.hasNext()) {
		        firstElement = (Removed) it.next();
		        if (firstElement.isNewLine())
		            continue;
		        break;
		    }
		    if (firstElement.isChild()) {
		        LexicalDifferenceCalculator.CsmChild csmChild = (LexicalDifferenceCalculator.CsmChild) firstElement.getElement();
		        Node child = csmChild.getChild();
		        Optional<TokenRange> tokenRange = child.getTokenRange();
		        if (tokenRange.isPresent()) {
		            JavaToken begin = tokenRange.get().getBegin();
		            if (hasOnlyWhitespaceJavaTokenInFrontFunction.apply(begin)) {
		                Optional<JavaToken> previousToken = begin.getPreviousToken();
		                while (previousToken.isPresent() && (TokenTypes.isWhitespaceButNotEndOfLine(previousToken.get().getKind()))) {
		                    indentation++;
		                    previousToken = previousToken.get().getPreviousToken();
		                }
		                if (previousToken.isPresent()) {
		                    if (TokenTypes.isEndOfLineToken(previousToken.get().getKind())) {
		                        return Optional.of(Integer.valueOf(indentation));
		                    }
		                    return Optional.empty();
		                }
		                return Optional.of(Integer.valueOf(indentation));
		            }
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ final $whitespace$ optional < integer > $whitespace$ getindentation ( ) { $newline$ $indentation$ removed $whitespace$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ int $whitespace$ indentation $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·search·for·the·first·element·which·is·not·a·new·line$ $newline$ $indentation$ iterator $whitespace$ it $whitespace$ = $whitespace$ iterator ( ) ; $newline$ $indentation$ while $whitespace$ ( it . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ firstelement $whitespace$ = $whitespace$ ( removed ) $whitespace$ it . next ( ) ; $newline$ $indentation$ if $whitespace$ ( firstelement . isnewline ( ) ) $newline$ $indentation$ continue ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( firstelement . ischild ( ) ) $whitespace$ { $newline$ $indentation$ lexicaldifferencecalculator . csmchild $whitespace$ csmchild $whitespace$ = $whitespace$ ( lexicaldifferencecalculator . csmchild ) $whitespace$ firstelement . getelement ( ) ; $newline$ $indentation$ node $whitespace$ child $whitespace$ = $whitespace$ csmchild . getchild ( ) ; $newline$ $indentation$ optional < tokenrange > $whitespace$ tokenrange $whitespace$ = $whitespace$ child . gettokenrange ( ) ; $newline$ $indentation$ if $whitespace$ ( tokenrange . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ tokenrange . get ( ) . getbegin ( ) ; $newline$ $indentation$ if $whitespace$ ( hasonlywhitespacejavatokeninfrontfunction . apply ( begin ) ) $whitespace$ { $newline$ $indentation$ optional < javatoken > $whitespace$ previoustoken $whitespace$ = $whitespace$ begin . getprevioustoken ( ) ; $newline$ $indentation$ while $whitespace$ ( previoustoken . ispresent ( ) $whitespace$ && $whitespace$ ( tokentypes . iswhitespacebutnotendofline ( previoustoken . get ( ) . getkind ( ) ) ) ) $whitespace$ { $newline$ $indentation$ indentation ++ ; $newline$ $indentation$ previoustoken $whitespace$ = $whitespace$ previoustoken . get ( ) . getprevioustoken ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( previoustoken . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tokentypes . isendoflinetoken ( previoustoken . get ( ) . getkind ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( integer . valueof ( indentation ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( integer . valueof ( indentation ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ final $whitespace$ optional < integer > $whitespace$ getnew ( ) { $newline$ $indentation$ removed $whitespace$ firstelement $whitespace$ = $whitespace$ null ; $newline$ $indentation$ final $whitespace$ int $whitespace$ indentation $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ final $whitespace$ iterator $whitespace$ it $whitespace$ = $whitespace$ iterator ( ) ; $newline$ $indentation$ while $whitespace$ ( it. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ if $whitespace$ ( firstelement. isnewline ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ int $whitespace$ one $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( tokenrange > $whitespace$ tokenrange $whitespace$ : $whitespace$ tokenrange. get ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ int $whitespace$ child $whitespace$ = $whitespace$ tokenrange. getchild ( ) ; $newline$ $indentation$ if $whitespace$ ( tokenrange. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ tokenrange. get ( ). getbegin ( ) ; $newline$ $indentation$ if $whitespace$ ( hasonlywhitespacejavatokeninfrontfunction. apply ( begin ) ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ tokenrange. get ( ). getbegin ( ) ; $newline$ $indentation$ if $whitespace$ ( hasonlywhitespace$javatokeninfrontfunction. apply ( begin ) ) $whitespace$ { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ tokenrange. get ( ). getbegin ( ) ; $newline$ $indentation$ if $whitespace$ ( hasonlywhitespace$javatokeninfrontfunction			
hasOnlyWhiteSpaceForTokenFunction	177	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/RemovedGroup.java	0.2777537405490875	LOW	"		private boolean hasOnlyWhiteSpaceForTokenFunction(JavaToken token, Function<JavaToken, Optional<JavaToken>> tokenFunction){
		    Optional<JavaToken> tokenResult = tokenFunction.apply(token);
		    if (tokenResult.isPresent()) {
		        if (TokenTypes.isWhitespaceButNotEndOfLine(tokenResult.get().getKind())) {
		            return hasOnlyWhiteSpaceForTokenFunction(tokenResult.get(), tokenFunction);
		        }
		        if (TokenTypes.isEndOfLineToken(tokenResult.get().getKind())) {
		            return true;
		        }
		        return false;
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ hasonlywhitespacefortokenfunction ( javatoken $whitespace$ token , $whitespace$ function < javatoken , $whitespace$ optional < javatoken >> $whitespace$ tokenfunction ) { $newline$ $indentation$ optional < javatoken > $whitespace$ tokenresult $whitespace$ = $whitespace$ tokenfunction . apply ( token ) ; $newline$ $indentation$ if $whitespace$ ( tokenresult . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tokentypes . iswhitespacebutnotendofline ( tokenresult . get ( ) . getkind ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ hasonlywhitespacefortokenfunction ( tokenresult . get ( ) , $whitespace$ tokenfunction ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( tokentypes . isendoflinetoken ( tokenresult . get ( ) . getkind ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ hasonlywhitespacefortokenfunction ( javatoken $whitespace$ token, $whitespace$ function < javatoken, $whitespace$ optional < javatoken >> $whitespace$ tokenfunction ) { $newline$ $indentation$ optional < javatoken > $whitespace$ tokenresult $whitespace$ = $whitespace$ tokenfunction. apply ( token ) ; $newline$ $indentation$ if $whitespace$ ( tokenresult. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ tokentypes. iswhitespace$butnotendofline ( tokenresult. get ( ). getkind ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( tokentypes. isendoflinetoken ( tokenresult. get ( ). getkind ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
iterator	240	256	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/RemovedGroup.java	0.667324443658193	MID	"		@Override
		public final Iterator<Removed> iterator(){
		    return new Iterator<Removed>() {
		
		        private int currentIndex = 0;
		
		        @Override
		        public boolean hasNext() {
		            return currentIndex < removedList.size() && removedList.get(currentIndex) != null;
		        }
		
		        @Override
		        public Removed next() {
		            return removedList.get(currentIndex++);
		        }
		    };
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ iterator < removed > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < removed > ( ) $whitespace$ { $newline$ $indentation$ private $whitespace$ int $whitespace$ currentindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ currentindex $whitespace$ < $whitespace$ removedlist . size ( ) $whitespace$ && $whitespace$ removedlist . get ( currentindex ) $whitespace$ != $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ removed $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ removedlist . get ( currentindex ++ ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ iterator < removed > $whitespace$ iterator ( ) $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < > ( ) $newline$ $indentation$ { $newline$ $indentation$ int $whitespace$ currentindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( removed $whitespace$ value $whitespace$ : $whitespace$ removedlist ) $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ value ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ removed $whitespace$ next ( ) $newline$ $indentation$ { $newline$ $indentation$ return $whitespace$ removedlist. get ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
equals	50	60	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/Reshuffled.java	0.7066028118133545	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    Reshuffled that = (Reshuffled) o;
		    if (!previousOrder.equals(that.previousOrder))
		        return false;
		    return nextOrder.equals(that.nextOrder);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ reshuffled $whitespace$ that $whitespace$ = $whitespace$ ( reshuffled ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! previousorder . equals ( that . previousorder ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ nextorder . equals ( that . nextorder ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ reshuffled $whitespace$ that $whitespace$ = $whitespace$ ( reshuffled ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! previousorder. equals ( that. previousorder ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nextorder. equals ( that. nextorder ) ; $newline$ $indentation$ }			
extract	57	140	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/ReshuffledDiffElementExtractor.java	0.0090322634205222	LOW	"		public void extract(List<DifferenceElement> diffElements){
		    ArrayIterator<DifferenceElement> iterator = new ArrayIterator<>(diffElements);
		    while (iterator.hasNext()) {
		        DifferenceElement diffElement = iterator.next();
		        if (diffElement instanceof Reshuffled) {
		            Reshuffled reshuffled = (Reshuffled) diffElement;
		            // First, let's see how many tokens we need to attribute to the previous version of the of the CsmMix
		            CsmMix elementsFromPreviousOrder = reshuffled.getPreviousOrder();
		            CsmMix elementsFromNextOrder = reshuffled.getNextOrder();
		            // This contains indexes from elementsFromNextOrder to indexes from elementsFromPreviousOrder
		            Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = getCorrespondanceBetweenNextOrderAndPreviousOrder(elementsFromPreviousOrder, elementsFromNextOrder);
		            // We now find out which Node Text elements corresponds to the elements in the original CSM
		            List<Integer> nodeTextIndexOfPreviousElements = findIndexOfCorrespondingNodeTextElement(elementsFromPreviousOrder.getElements(), nodeText);
		            PeekingIterator<Integer> nodeTextIndexOfPreviousElementsIterator = new PeekingIterator<>(nodeTextIndexOfPreviousElements);
		            Map<Integer, Integer> nodeTextIndexToPreviousCSMIndex = new HashMap<>();
		            while (nodeTextIndexOfPreviousElementsIterator.hasNext()) {
		                int value = nodeTextIndexOfPreviousElementsIterator.next();
		                if (value != -1) {
		                    nodeTextIndexToPreviousCSMIndex.put(value, nodeTextIndexOfPreviousElementsIterator.currentIndex());
		                }
		            }
		            int lastNodeTextIndex = nodeTextIndexOfPreviousElements.stream().max(Integer::compareTo).orElse(-1);
		            // Elements to be added at the end
		            List<CsmElement> elementsToBeAddedAtTheEnd = new LinkedList<>();
		            List<CsmElement> nextOrderElements = elementsFromNextOrder.getElements();
		            Map<Integer, List<CsmElement>> elementsToAddBeforeGivenOriginalCSMElement = new HashMap<>();
		            for (int ni = 0; ni < nextOrderElements.size(); ni++) {
		                // If it has a mapping, then it is kept
		                if (!correspondanceBetweenNextOrderAndPreviousOrder.containsKey(ni)) {
		                    // Ok, it is something new. Where to put it? Let's see what is the first following
		                    // element that has a mapping
		                    int originalCsmIndex = -1;
		                    for (int nj = ni + 1; nj < nextOrderElements.size() && originalCsmIndex == -1; nj++) {
		                        if (correspondanceBetweenNextOrderAndPreviousOrder.containsKey(nj)) {
		                            originalCsmIndex = correspondanceBetweenNextOrderAndPreviousOrder.get(nj);
		                            if (!elementsToAddBeforeGivenOriginalCSMElement.containsKey(originalCsmIndex)) {
		                                elementsToAddBeforeGivenOriginalCSMElement.put(originalCsmIndex, new LinkedList<>());
		                            }
		                            elementsToAddBeforeGivenOriginalCSMElement.get(originalCsmIndex).add(nextOrderElements.get(ni));
		                        }
		                    }
		                    // it does not preceed anything, so it goes at the end
		                    if (originalCsmIndex == -1) {
		                        elementsToBeAddedAtTheEnd.add(nextOrderElements.get(ni));
		                    }
		                }
		            }
		            // We go over the original node text elements, in the order they appear in the NodeText.
		            // Considering an original node text element (ONE)
		            // * we verify if it corresponds to a CSM element. If it does not we just move on, otherwise
		            // we find the correspond OCE (Original CSM Element)
		            // * we first add new elements that are marked to be added before OCE
		            // * if OCE is marked to be present also in the ""after"" CSM we add a kept element,
		            // otherwise we add a removed element
		            // Remove the whole Reshuffled element
		            iterator.remove();
		            if (lastNodeTextIndex != -1) {
		                for (int ntIndex = 0; ntIndex <= lastNodeTextIndex; ntIndex++) {
		                    if (nodeTextIndexToPreviousCSMIndex.containsKey(ntIndex)) {
		                        int indexOfOriginalCSMElement = nodeTextIndexToPreviousCSMIndex.get(ntIndex);
		                        if (elementsToAddBeforeGivenOriginalCSMElement.containsKey(indexOfOriginalCSMElement)) {
		                            for (CsmElement elementToAdd : elementsToAddBeforeGivenOriginalCSMElement.get(indexOfOriginalCSMElement)) {
		                                iterator.add(new Added(elementToAdd));
		                            }
		                        }
		                        CsmElement originalCSMElement = elementsFromPreviousOrder.getElements().get(indexOfOriginalCSMElement);
		                        boolean toBeKept = correspondanceBetweenNextOrderAndPreviousOrder.containsValue(indexOfOriginalCSMElement);
		                        if (toBeKept) {
		                            iterator.add(new Kept(originalCSMElement));
		                        } else {
		                            iterator.add(new Removed(originalCSMElement));
		                        }
		                    }
		                    // else we have a simple node text element, without associated csm element, just keep ignore it
		                }
		            }
		            // Finally we look for the remaining new elements that were not yet added and
		            // add all of them
		            for (CsmElement elementToAdd : elementsToBeAddedAtTheEnd) {
		                iterator.add(new Added(elementToAdd));
		            }
		        }
		    }
		}"	"$indentation$ public $whitespace$ void $whitespace$ extract ( list < differenceelement > $whitespace$ diffelements ) { $newline$ $indentation$ arrayiterator < differenceelement > $whitespace$ iterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( diffelements ) ; $newline$ $indentation$ while $whitespace$ ( iterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ iterator . next ( ) ; $newline$ $indentation$ if $whitespace$ ( diffelement $whitespace$ instanceof $whitespace$ reshuffled ) $whitespace$ { $newline$ $indentation$ reshuffled $whitespace$ reshuffled $whitespace$ = $whitespace$ ( reshuffled ) $whitespace$ diffelement ; $newline$ $indentation$ $//·first,·let's·see·how·many·tokens·we·need·to·attribute·to·the·previous·version·of·the·of·the·csmmix$ $newline$ $indentation$ csmmix $whitespace$ elementsfrompreviousorder $whitespace$ = $whitespace$ reshuffled . getpreviousorder ( ) ; $newline$ $indentation$ csmmix $whitespace$ elementsfromnextorder $whitespace$ = $whitespace$ reshuffled . getnextorder ( ) ; $newline$ $indentation$ $//·this·contains·indexes·from·elementsfromnextorder·to·indexes·from·elementsfrompreviousorder$ $newline$ $indentation$ map < integer , $whitespace$ integer > $whitespace$ correspondancebetweennextorderandpreviousorder $whitespace$ = $whitespace$ getcorrespondancebetweennextorderandpreviousorder ( elementsfrompreviousorder , $whitespace$ elementsfromnextorder ) ; $newline$ $indentation$ $//·we·now·find·out·which·node·text·elements·corresponds·to·the·elements·in·the·original·csm$ $newline$ $indentation$ list < integer > $whitespace$ nodetextindexofpreviouselements $whitespace$ = $whitespace$ findindexofcorrespondingnodetextelement ( elementsfrompreviousorder . getelements ( ) , $whitespace$ nodetext ) ; $newline$ $indentation$ peekingiterator < integer > $whitespace$ nodetextindexofpreviouselementsiterator $whitespace$ = $whitespace$ new $whitespace$ peekingiterator < > ( nodetextindexofpreviouselements ) ; $newline$ $indentation$ map < integer , $whitespace$ integer > $whitespace$ nodetextindextopreviouscsmindex $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ while $whitespace$ ( nodetextindexofpreviouselementsiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ value $whitespace$ = $whitespace$ nodetextindexofpreviouselementsiterator . next ( ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ nodetextindextopreviouscsmindex . put ( value , $whitespace$ nodetextindexofpreviouselementsiterator . currentindex ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ lastnodetextindex $whitespace$ = $whitespace$ nodetextindexofpreviouselements . stream ( ) . max ( integer : : compareto ) . orelse ( $number$ ) ; $newline$ $indentation$ $//·elements·to·be·added·at·the·end$ $newline$ $indentation$ list < csmelement > $whitespace$ elementstobeaddedattheend $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ list < csmelement > $whitespace$ nextorderelements $whitespace$ = $whitespace$ elementsfromnextorder . getelements ( ) ; $newline$ $indentation$ map < integer , $whitespace$ list < csmelement >> $whitespace$ elementstoaddbeforegivenoriginalcsmelement $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ ni $whitespace$ = $whitespace$ $number$ ; $whitespace$ ni $whitespace$ < $whitespace$ nextorderelements . size ( ) ; $whitespace$ ni ++ ) $whitespace$ { $newline$ $indentation$ $//·if·it·has·a·mapping,·then·it·is·kept$ $newline$ $indentation$ if $whitespace$ ( ! correspondancebetweennextorderandpreviousorder . containskey ( ni ) ) $whitespace$ { $newline$ $indentation$ $//·ok,·it·is·something·new.·where·to·put·it?·let's·see·what·is·the·first·following$ $newline$ $indentation$ $//·element·that·has·a·mapping$ $newline$ $indentation$ int $whitespace$ originalcsmindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ nj $whitespace$ = $whitespace$ ni $whitespace$ + $whitespace$ $number$ ; $whitespace$ nj $whitespace$ < $whitespace$ nextorderelements . size ( ) $whitespace$ && $whitespace$ originalcsmindex $whitespace$ == $whitespace$ $number$ ; $whitespace$ nj ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( correspondancebetweennextorderandpreviousorder . containskey ( nj ) ) $whitespace$ { $newline$ $indentation$ originalcsmindex $whitespace$ = $whitespace$ correspondancebetweennextorderandpreviousorder . get ( nj ) ; $newline$ $indentation$ if $whitespace$ ( ! elementstoaddbeforegivenoriginalcsmelement . containskey ( originalcsmindex ) ) $whitespace$ { $newline$ $indentation$ elementstoaddbeforegivenoriginalcsmelement . put ( originalcsmindex , $whitespace$ new $whitespace$ linkedlist < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ elementstoaddbeforegivenoriginalcsmelement . get ( originalcsmindex ) . add ( nextorderelements . get ( ni ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·it·does·not·preceed·anything,·so·it·goes·at·the·end$ $newline$ $indentation$ if $whitespace$ ( originalcsmindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ elementstobeaddedattheend . add ( nextorderelements . get ( ni ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·we·go·over·the·original·node·text·elements,·in·the·order·they·appear·in·the·nodetext.$ $newline$ $indentation$ $//·considering·an·original·node·text·element·(one)$ $newline$ $indentation$ $//·*·we·verify·if·it·corresponds·to·a·csm·element.·if·it·does·not·we·just·move·on,·otherwise$ $newline$ $indentation$ $//·we·find·the·correspond·oce·(original·csm·element)$ $newline$ $indentation$ $//·*·we·first·add·new·elements·that·are·marked·to·be·added·before·oce$ $newline$ $indentation$ $//·*·if·oce·is·marked·to·be·present·also·in·the·""after""·csm·we·add·a·kept·element,$ $newline$ $indentation$ $//·otherwise·we·add·a·removed·element$ $newline$ $indentation$ $//·remove·the·whole·reshuffled·element$ $newline$ $indentation$ iterator . remove ( ) ; $newline$ $indentation$ if $whitespace$ ( lastnodetextindex $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ ntindex $whitespace$ = $whitespace$ $number$ ; $whitespace$ ntindex $whitespace$ <= $whitespace$ lastnodetextindex ; $whitespace$ ntindex ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nodetextindextopreviouscsmindex . containskey ( ntindex ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ indexoforiginalcsmelement $whitespace$ = $whitespace$ nodetextindextopreviouscsmindex . get ( ntindex ) ; $newline$ $indentation$ if $whitespace$ ( elementstoaddbeforegivenoriginalcsmelement . containskey ( indexoforiginalcsmelement ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( csmelement $whitespace$ elementtoadd $whitespace$ : $whitespace$ elementstoaddbeforegivenoriginalcsmelement . get ( indexoforiginalcsmelement ) ) $whitespace$ { $newline$ $indentation$ iterator . add ( new $whitespace$ added ( elementtoadd ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ csmelement $whitespace$ originalcsmelement $whitespace$ = $whitespace$ elementsfrompreviousorder . getelements ( ) . get ( indexoforiginalcsmelement ) ; $newline$ $indentation$ boolean $whitespace$ tobekept $whitespace$ = $whitespace$ correspondancebetweennextorderandpreviousorder . containsvalue ( indexoforiginalcsmelement ) ; $newline$ $indentation$ if $whitespace$ ( tobekept ) $whitespace$ { $newline$ $indentation$ iterator . add ( new $whitespace$ kept ( originalcsmelement ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ iterator . add ( new $whitespace$ removed ( originalcsmelement ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·else·we·have·a·simple·node·text·element,·without·associated·csm·element,·just·keep·ignore·it$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·finally·we·look·for·the·remaining·new·elements·that·were·not·yet·added·and$ $newline$ $indentation$ $//·add·all·of·them$ $newline$ $indentation$ for $whitespace$ ( csmelement $whitespace$ elementtoadd $whitespace$ : $whitespace$ elementstobeaddedattheend ) $whitespace$ { $newline$ $indentation$ iterator . add ( new $whitespace$ added ( elementtoadd ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }"	$indentation$ public $whitespace$ void $whitespace$ extract ( list < differenceelement > $whitespace$ diffelements ) { $newline$ $indentation$ arrayiterator < differenceelement > $whitespace$ iterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( diffelements ) ; $newline$ $indentation$ while $whitespace$ ( iterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ differenceelement $whitespace$ diffelement $whitespace$ = $whitespace$ iterator. next ( ) ; $newline$ $indentation$ if $whitespace$ ( diffelement $whitespace$ instanceof $whitespace$ reshuffled ) $whitespace$ { $newline$ $indentation$ reshuffled $whitespace$ reshuffled $whitespace$ = $whitespace$ ( reshuffled ) $whitespace$ diffelement ; $newline$ $indentation$ $////// $whitespace$ a $whitespace$ set $whitespace$ of $whitespace$ reshuffled $whitespace$ in $whitespace$ the $whitespace$ $newline$ $indentation$ // $whitespace$ it $whitespace$ is $whitespace$ get $whitespace$ only $whitespace$ the $whitespace$ previous $whitespace$ group $whitespace$ of $whitespace$ the $whitespace$ weekly $whitespace$ view $newline$ $indentation$ int $whitespace$ numberofaccountsfrompreviousorder $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ int $whitespace$ reshuffled $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( iterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ // $whitespace$ the $whitespace$ next $whitespace$ non-null $whitespace$ generic $whitespace$ exception $newline$ $indentation$ reshuffled $whitespace$ reshuffled $whitespace$ = $whitespace$ ( reshuffled ) $whitespace$ diffelement ; $newline$ $indentation$ $//space$$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$			
findIndexOfCorrespondingNodeTextElement	181	230	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/ReshuffledDiffElementExtractor.java	0.0162084642797708	LOW	"		private List<Integer> findIndexOfCorrespondingNodeTextElement(List<CsmElement> elements, NodeText nodeText){
		    List<Integer> correspondingIndices = new ArrayList<>();
		    PeekingIterator<CsmElement> csmElementListIterator = new PeekingIterator<>(elements);
		    while (csmElementListIterator.hasNext()) {
		        boolean isFirstIterationOnCsmElements = !csmElementListIterator.hasPrevious();
		        int previousCsmElementIndex = csmElementListIterator.previousIndex();
		        CsmElement csmElement = csmElementListIterator.next();
		        Map<MatchClassification, Integer> potentialMatches = new EnumMap<>(MatchClassification.class);
		        PeekingIterator<TextElement> nodeTextListIterator = new PeekingIterator<>(nodeText.getElements());
		        while (nodeTextListIterator.hasNext()) {
		            boolean isFirstIterationOnNodeTextElements = !nodeTextListIterator.hasPrevious();
		            TextElement textElement = nodeTextListIterator.next();
		            int currentTextElementIndex = nodeTextListIterator.currentIndex();
		            if (!correspondingIndices.contains(currentTextElementIndex)) {
		                boolean isCorresponding = csmElement.isCorrespondingElement(textElement);
		                if (isCorresponding) {
		                    boolean hasSamePreviousElement = false;
		                    if (!isFirstIterationOnNodeTextElements && !isFirstIterationOnCsmElements) {
		                        TextElement previousTextElement = nodeText.getTextElement(currentTextElementIndex - 1);
		                        hasSamePreviousElement = elements.get(previousCsmElementIndex).isCorrespondingElement(previousTextElement);
		                    }
		                    boolean hasSameNextElement = false;
		                    if (csmElementListIterator.hasNext()) {
		                        TextElement nextTextElement = nodeTextListIterator.peek();
		                        hasSameNextElement = elements.get(csmElementListIterator.nextIndex()).isCorrespondingElement(nextTextElement);
		                    }
		                    if (hasSamePreviousElement && hasSameNextElement) {
		                        potentialMatches.putIfAbsent(MatchClassification.ALL, currentTextElementIndex);
		                    } else if (hasSamePreviousElement) {
		                        potentialMatches.putIfAbsent(MatchClassification.PREVIOUS_AND_SAME, currentTextElementIndex);
		                    } else if (hasSameNextElement) {
		                        potentialMatches.putIfAbsent(MatchClassification.NEXT_AND_SAME, currentTextElementIndex);
		                    } else {
		                        potentialMatches.putIfAbsent(MatchClassification.SAME_ONLY, currentTextElementIndex);
		                    }
		                } else if (isAlmostCorrespondingElement(textElement, csmElement)) {
		                    potentialMatches.putIfAbsent(MatchClassification.ALMOST, currentTextElementIndex);
		                }
		            }
		        }
		        // Prioritize the matches from best to worst
		        Optional<MatchClassification> bestMatchKey = potentialMatches.keySet().stream().min(Comparator.comparing(MatchClassification::getPriority));
		        if (bestMatchKey.isPresent()) {
		            correspondingIndices.add(potentialMatches.get(bestMatchKey.get()));
		        } else {
		            correspondingIndices.add(-1);
		        }
		    }
		    return correspondingIndices;
		}"	$indentation$ private $whitespace$ list < integer > $whitespace$ findindexofcorrespondingnodetextelement ( list < csmelement > $whitespace$ elements , $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < integer > $whitespace$ correspondingindices $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ peekingiterator < csmelement > $whitespace$ csmelementlistiterator $whitespace$ = $whitespace$ new $whitespace$ peekingiterator < > ( elements ) ; $newline$ $indentation$ while $whitespace$ ( csmelementlistiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isfirstiterationoncsmelements $whitespace$ = $whitespace$ ! csmelementlistiterator . hasprevious ( ) ; $newline$ $indentation$ int $whitespace$ previouscsmelementindex $whitespace$ = $whitespace$ csmelementlistiterator . previousindex ( ) ; $newline$ $indentation$ csmelement $whitespace$ csmelement $whitespace$ = $whitespace$ csmelementlistiterator . next ( ) ; $newline$ $indentation$ map < matchclassification , $whitespace$ integer > $whitespace$ potentialmatches $whitespace$ = $whitespace$ new $whitespace$ enummap < > ( matchclassification . class ) ; $newline$ $indentation$ peekingiterator < textelement > $whitespace$ nodetextlistiterator $whitespace$ = $whitespace$ new $whitespace$ peekingiterator < > ( nodetext . getelements ( ) ) ; $newline$ $indentation$ while $whitespace$ ( nodetextlistiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isfirstiterationonnodetextelements $whitespace$ = $whitespace$ ! nodetextlistiterator . hasprevious ( ) ; $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ nodetextlistiterator . next ( ) ; $newline$ $indentation$ int $whitespace$ currenttextelementindex $whitespace$ = $whitespace$ nodetextlistiterator . currentindex ( ) ; $newline$ $indentation$ if $whitespace$ ( ! correspondingindices . contains ( currenttextelementindex ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ iscorresponding $whitespace$ = $whitespace$ csmelement . iscorrespondingelement ( textelement ) ; $newline$ $indentation$ if $whitespace$ ( iscorresponding ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ hassamepreviouselement $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! isfirstiterationonnodetextelements $whitespace$ && $whitespace$ ! isfirstiterationoncsmelements ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ previoustextelement $whitespace$ = $whitespace$ nodetext . gettextelement ( currenttextelementindex $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ hassamepreviouselement $whitespace$ = $whitespace$ elements . get ( previouscsmelementindex ) . iscorrespondingelement ( previoustextelement ) ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ hassamenextelement $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( csmelementlistiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ textelement $whitespace$ nexttextelement $whitespace$ = $whitespace$ nodetextlistiterator . peek ( ) ; $newline$ $indentation$ hassamenextelement $whitespace$ = $whitespace$ elements . get ( csmelementlistiterator . nextindex ( ) ) . iscorrespondingelement ( nexttextelement ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( hassamepreviouselement $whitespace$ && $whitespace$ hassamenextelement ) $whitespace$ { $newline$ $indentation$ potentialmatches . putifabsent ( matchclassification . all , $whitespace$ currenttextelementindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( hassamepreviouselement ) $whitespace$ { $newline$ $indentation$ potentialmatches . putifabsent ( matchclassification . previous_and_same , $whitespace$ currenttextelementindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( hassamenextelement ) $whitespace$ { $newline$ $indentation$ potentialmatches . putifabsent ( matchclassification . next_and_same , $whitespace$ currenttextelementindex ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ potentialmatches . putifabsent ( matchclassification . same_only , $whitespace$ currenttextelementindex ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( isalmostcorrespondingelement ( textelement , $whitespace$ csmelement ) ) $whitespace$ { $newline$ $indentation$ potentialmatches . putifabsent ( matchclassification . almost , $whitespace$ currenttextelementindex ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·prioritize·the·matches·from·best·to·worst$ $newline$ $indentation$ optional < matchclassification > $whitespace$ bestmatchkey $whitespace$ = $whitespace$ potentialmatches . keyset ( ) . stream ( ) . min ( comparator . comparing ( matchclassification : : getpriority ) ) ; $newline$ $indentation$ if $whitespace$ ( bestmatchkey . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ correspondingindices . add ( potentialmatches . get ( bestmatchkey . get ( ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ correspondingindices . add ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ correspondingindices ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < integer > $whitespace$ findindexofcorrespondingnodetextelement ( list < csmelement > $whitespace$ elements, $whitespace$ nodetext $whitespace$ nodetext ) { $newline$ $indentation$ list < integer > $whitespace$ correspondingindices $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ peekingiterator < csmelement > $whitespace$ csmelementlistiterator $whitespace$ = $whitespace$ new $whitespace$ peekingiterator < > ( elements ) ; $newline$ $indentation$ while $whitespace$ ( csmelementlistiterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isfirstiterationoncsmelements $whitespace$ = $whitespace$! csmelementlistiterator. hasprevious ( ) ; $newline$ $indentation$ int $whitespace$ previouscsmelementindex $whitespace$ = $whitespace$ csmelementlistiterator. previousindex ( ) ; $newline$ $indentation$ csmelement $whitespace$ csmelement $whitespace$ = $whitespace$ csmelementlistiterator. next ( ) ; $newline$ $indentation$ map < matchclassification, $whitespace$ integer > $whitespace$ potentialmatches $whitespace$ = $whitespace$ new $whitespace$ enummap < > ( matchclassification. class ) ; $newline$ $indentation$ peekingiterator < textelement > $whitespace$ nodetextlistiterator $whitespace$ = $whitespace$ new $whitespace$ peekingiterator < > ( nodetext. getelements ( ) ) ; $newline$ $indentation$ while $whitespace$ ( nodetextlistiterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isfirstiterationonnodetextelements $whitespace$ = $whitespace$! nodetextlistiterator. hasprevious ( ) ; $newline$ $indentation$ int $whitespace$ previous			
getCorrespondanceBetweenNextOrderAndPreviousOrder	156	179	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/ReshuffledDiffElementExtractor.java	0.1035178005695343	LOW	"		private Map<Integer, Integer> getCorrespondanceBetweenNextOrderAndPreviousOrder(CsmMix elementsFromPreviousOrder, CsmMix elementsFromNextOrder){
		    Map<Integer, Integer> correspondanceBetweenNextOrderAndPreviousOrder = new HashMap<>();
		    ArrayIterator<CsmElement> previousOrderElementsIterator = new ArrayIterator<>(elementsFromPreviousOrder.getElements());
		    int syncNextIndex = 0;
		    while (previousOrderElementsIterator.hasNext()) {
		        CsmElement pe = previousOrderElementsIterator.next();
		        ArrayIterator<CsmElement> nextOrderElementsIterator = new ArrayIterator<>(elementsFromNextOrder.getElements(), syncNextIndex);
		        while (nextOrderElementsIterator.hasNext()) {
		            CsmElement ne = nextOrderElementsIterator.next();
		            if (!correspondanceBetweenNextOrderAndPreviousOrder.values().contains(previousOrderElementsIterator.index()) && DifferenceElementCalculator.matching(ne, pe)) {
		                correspondanceBetweenNextOrderAndPreviousOrder.put(nextOrderElementsIterator.index(), previousOrderElementsIterator.index());
		                // set the position to start on the next {@code nextOrderElementsIterator} iteration
		                syncNextIndex = nextOrderElementsIterator.index();
		                break;
		            }
		        }
		    }
		    return correspondanceBetweenNextOrderAndPreviousOrder;
		}"	$indentation$ private $whitespace$ map < integer , $whitespace$ integer > $whitespace$ getcorrespondancebetweennextorderandpreviousorder ( csmmix $whitespace$ elementsfrompreviousorder , $whitespace$ csmmix $whitespace$ elementsfromnextorder ) { $newline$ $indentation$ map < integer , $whitespace$ integer > $whitespace$ correspondancebetweennextorderandpreviousorder $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ arrayiterator < csmelement > $whitespace$ previousorderelementsiterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elementsfrompreviousorder . getelements ( ) ) ; $newline$ $indentation$ int $whitespace$ syncnextindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( previousorderelementsiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ pe $whitespace$ = $whitespace$ previousorderelementsiterator . next ( ) ; $newline$ $indentation$ arrayiterator < csmelement > $whitespace$ nextorderelementsiterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elementsfromnextorder . getelements ( ) , $whitespace$ syncnextindex ) ; $newline$ $indentation$ while $whitespace$ ( nextorderelementsiterator . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ ne $whitespace$ = $whitespace$ nextorderelementsiterator . next ( ) ; $newline$ $indentation$ if $whitespace$ ( ! correspondancebetweennextorderandpreviousorder . values ( ) . contains ( previousorderelementsiterator . index ( ) ) $whitespace$ && $whitespace$ differenceelementcalculator . matching ( ne , $whitespace$ pe ) ) $whitespace$ { $newline$ $indentation$ correspondancebetweennextorderandpreviousorder . put ( nextorderelementsiterator . index ( ) , $whitespace$ previousorderelementsiterator . index ( ) ) ; $newline$ $indentation$ $//·set·the·position·to·start·on·the·next·{@code·nextorderelementsiterator}·iteration$ $newline$ $indentation$ syncnextindex $whitespace$ = $whitespace$ nextorderelementsiterator . index ( ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ correspondancebetweennextorderandpreviousorder ; $newline$ $indentation$ }	$indentation$ private $whitespace$ map < integer, $whitespace$ integer > $whitespace$ getcorrespondancebetweennextorderandpreviousorder ( csmmix $whitespace$ elementsfrompreviousorder, $whitespace$ csmmix $whitespace$ elementsfromnextorder ) { $newline$ $indentation$ map < integer, $whitespace$ integer > $whitespace$ correspondancebetweennextorderandpreviousorder $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ arrayiterator < csmelement > $whitespace$ previousorderelementsiterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elementsfrompreviousorder. getelements ( ) ) ; $newline$ $indentation$ int $whitespace$ syncnextindex $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( previousorderelementsiterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ pe $whitespace$ = $whitespace$ previousorderelementsiterator. next ( ) ; $newline$ $indentation$ arrayiterator < csmelement > $whitespace$ nextorderelementsiterator $whitespace$ = $whitespace$ new $whitespace$ arrayiterator < > ( elementsfromnextorder. getelements ( ), $whitespace$ syncnextindex ) ; $newline$ $indentation$ while $whitespace$ ( nextorderelementsiterator. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ csmelement $whitespace$ ne $whitespace$ = $whitespace$ nextorderelementsiterator. next ( ) ; $newline$ $indentation$ if $whitespace$ (! correspondancebetweennextorderandpreviousorder. values ( ). contains ( previousorderelementsiterator. index ( ) ) $newline$ $indentation$ && $whitespace$ differenceelementcalculator. matching ( ne, $whitespace$ pe ) ) $whitespace$ { $newline$ $indentation$ correspondancebetweennextorderandpreviousorder. put ( nextorderelementsiterator. index ( ), $whitespace$ previousorderelementsiterator. index ( ) ) ; $newline$ $indentation$ $////			
partialReverseIterator	190	196	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementIteratorsFactory.java	0.1920792311429977	LOW	"		public static Iterator<TokenTextElement> partialReverseIterator(NodeText nodeText, int fromIndex){
		    List<Iterator<TokenTextElement>> elements = new LinkedList<>();
		    for (int i = fromIndex; i >= 0; i--) {
		        elements.add(reverseIterator(nodeText, i));
		    }
		    return new ComposedIterator<>(elements);
		}"	$indentation$ public $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ partialreverseiterator ( nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ fromindex ) { $newline$ $indentation$ list < iterator < tokentextelement >> $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ fromindex ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ elements . add ( reverseiterator ( nodetext , $whitespace$ i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ composediterator < > ( elements ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ partialreverseiterator ( nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ fromindex ) { $newline$ $indentation$ list < iterator < tokentextelement >> $whitespace$ elements $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ fromindex ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ elements. add ( reverseiterator ( nodetext, $whitespace$ i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ modeliterator < > ( elements ) ; $newline$ $indentation$ }			
reverseIterator	167	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementIteratorsFactory.java	0.657407134771347	MID	"		private static Iterator<TokenTextElement> reverseIterator(NodeText nodeText, int index){
		    TextElement textElement = nodeText.getTextElement(index);
		    if (textElement instanceof TokenTextElement) {
		        return new SingleElementIterator<TokenTextElement>((TokenTextElement) textElement) {
		
		            @Override
		            public void remove() {
		                nodeText.removeElement(index);
		            }
		        };
		    }
		    if (textElement instanceof ChildTextElement) {
		        ChildTextElement childTextElement = (ChildTextElement) textElement;
		        NodeText textForChild = childTextElement.getNodeTextForWrappedNode();
		        return reverseIterator(textForChild);
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ private $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ reverseiterator ( nodetext $whitespace$ nodetext , $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ nodetext . gettextelement ( index ) ; $newline$ $indentation$ if $whitespace$ ( textelement $whitespace$ instanceof $whitespace$ tokentextelement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ singleelementiterator < tokentextelement > ( ( tokentextelement ) $whitespace$ textelement ) $whitespace$ { $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ nodetext . removeelement ( index ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( textelement $whitespace$ instanceof $whitespace$ childtextelement ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ childtextelement $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ textelement ; $newline$ $indentation$ nodetext $whitespace$ textforchild $whitespace$ = $whitespace$ childtextelement . getnodetextforwrappednode ( ) ; $newline$ $indentation$ return $whitespace$ reverseiterator ( textforchild ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ iterator < tokentextelement > $whitespace$ reverseiterator ( nodetext $whitespace$ nodetext, $whitespace$ int $whitespace$ index ) { $newline$ $indentation$ textelement $whitespace$ textelement $whitespace$ = $whitespace$ nodetext. gettextelement ( index ) ; $newline$ $indentation$ if $whitespace$ ( textelement $whitespace$ instanceof $whitespace$ tokentextelement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ singleelementiterator < tokentextelement > ( ( tokentextelement ) $whitespace$ textelement ) ; $newline$ $indentation$ } $newline$ $indentation$ nodetext $whitespace$ textforchild $whitespace$ = $whitespace$ childtextelement. getnodetextforwrappednode ( ) ; $newline$ $indentation$ return $whitespace$ reverseiterator ( textforchild ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ childtextelement $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ textelement ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ childtextelement $whitespace$ ( childtextelement $whitespace$ childtextelement ) $whitespace$ { $newline$ $indentation$ childtextelement $whitespace$ childtextelement $whitespace$ = $whitespace$ ( childtextelement ) $whitespace$ textelement ; $newline$ $indentation$ return $whitespace$ reverseiterator ( textforchild ) ; $newline$ $indentation$ } $newline$ $indentation$			
hasNext	51	60	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementIteratorsFactory.java	0.8389253616333008	HIGH	"		@Override
		public boolean hasNext(){
		    if (current.hasNext()) {
		        return true;
		    }
		    if (next == null) {
		        next = nextProvider.provide();
		    }
		    return next.hasNext();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) { $newline$ $indentation$ if $whitespace$ ( current . hasnext ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( next $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ next $whitespace$ = $whitespace$ nextprovider . provide ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ next . hasnext ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) { $newline$ $indentation$ if $whitespace$ ( current. hasnext ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( next $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ next $whitespace$ = $whitespace$ nextprovider. provide ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ next. hasnext ( ) ; $newline$ $indentation$ }			
remove	77	88	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementIteratorsFactory.java	0.8628210425376892	HIGH	"		@Override
		public void remove(){
		    if (lastReturnedFromCurrent) {
		        current.remove();
		        return;
		    }
		    if (lastReturnedFromNext) {
		        next.remove();
		        return;
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) { $newline$ $indentation$ if $whitespace$ ( lastreturnedfromcurrent ) $whitespace$ { $newline$ $indentation$ current . remove ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( lastreturnedfromnext ) $whitespace$ { $newline$ $indentation$ next . remove ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) { $newline$ $indentation$ if $whitespace$ ( lastreturnedfromcurrent ) $whitespace$ { $newline$ $indentation$ current. remove ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( lastreturnedfromnext ) $whitespace$ { $newline$ $indentation$ next. remove ( ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
byNode	31	44	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TextElementMatchers.java	0.8832518458366394	HIGH	"		 static TextElementMatcher byNode(final Node node){
		    return new TextElementMatcher() {
		
		        @Override
		        public boolean match(TextElement textElement) {
		            return textElement.isNode(node);
		        }
		
		        @Override
		        public String toString() {
		            return ""match node "" + node;
		        }
		    };
		}"	$indentation$ static $whitespace$ textelementmatcher $whitespace$ bynode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementmatcher ( ) $whitespace$ { $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ match ( textelement $whitespace$ textelement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ textelement . isnode ( node ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ node ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ static $whitespace$ textelementmatcher $whitespace$ bynode ( final $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ textelementmatcher ( ) $whitespace$ { $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ match ( textelement $whitespace$ textelement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ textelement. isnode ( node ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ node ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }			
equals	64	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/TokenTextElement.java	0.7220030426979065	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    TokenTextElement that = (TokenTextElement) o;
		    return token.equals(that.token);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ tokentextelement $whitespace$ that $whitespace$ = $whitespace$ ( tokentextelement ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ token . equals ( that . token ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ token. equals ( that. token ) ; $newline$ $indentation$ }			
evaluate	33	47	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/Change.java	0.1244945377111435	LOW	"		 boolean evaluate(CsmConditional csmConditional, Node node){
		    switch(csmConditional.getCondition()) {
		        case FLAG:
		            return csmConditional.getProperties().stream().anyMatch(p -> (Boolean) getValue(p, node));
		        case IS_NOT_EMPTY:
		            return !Utils.valueIsNullOrEmpty(getValue(csmConditional.getProperty(), node));
		        case IS_EMPTY:
		            return Utils.valueIsNullOrEmpty(getValue(csmConditional.getProperty(), node));
		        case IS_PRESENT:
		            return !Utils.valueIsNullOrEmptyStringOrOptional(getValue(csmConditional.getProperty(), node)) && !isEvaluatedOnDerivedProperty(csmConditional.getProperty());
		        default:
		            throw new UnsupportedOperationException("""" + csmConditional.getProperty() + "" "" + csmConditional.getCondition());
		    }
		}"	$indentation$ boolean $whitespace$ evaluate ( csmconditional $whitespace$ csmconditional , $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ switch ( csmconditional . getcondition ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ flag : $newline$ $indentation$ return $whitespace$ csmconditional . getproperties ( ) . stream ( ) . anymatch ( p $whitespace$ - > $whitespace$ ( boolean ) $whitespace$ getvalue ( p , $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_not_empty : $newline$ $indentation$ return $whitespace$ ! utils . valueisnullorempty ( getvalue ( csmconditional . getproperty ( ) , $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_empty : $newline$ $indentation$ return $whitespace$ utils . valueisnullorempty ( getvalue ( csmconditional . getproperty ( ) , $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_present : $newline$ $indentation$ return $whitespace$ ! utils . valueisnulloremptystringoroptional ( getvalue ( csmconditional . getproperty ( ) , $whitespace$ node ) ) $whitespace$ && $whitespace$ ! isevaluatedonderivedproperty ( csmconditional . getproperty ( ) ) ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ csmconditional . getproperty ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ csmconditional . getcondition ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ boolean $whitespace$ evaluate ( csmconditional $whitespace$ csmconditional, $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ switch ( csmconditional. getcondition ( ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ flag : $newline$ $indentation$ return $whitespace$ csmconditional. getproperties ( ). stream ( ). anymatch ( p $whitespace$ - > $whitespace$ ( boolean ) $whitespace$ getvalue ( p, $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_not_empty : $newline$ $indentation$ return $whitespace$! utils. valueisnullorempty ( getvalue ( csmconditional. getproperty ( ), $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_empty : $newline$ $indentation$ return $whitespace$ utils. valueisnullorempty ( getvalue ( csmconditional. getproperty ( ), $whitespace$ node ) ) ; $newline$ $indentation$ case $whitespace$ is_present : $newline$ $indentation$ return $whitespace$! utils. valueisnulloremptystringoroptional ( getvalue ( csmconditional. getproperty ( ), $whitespace$ node ) ) $whitespace$ && $whitespace$! isevaluatedonderivedproperty ( csmconditional. getproperty ( ) ) ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ csmconditional. getproperty ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ csmconditional. getcondition ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
isEvaluatedOnDerivedProperty	90	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/Change.java	0.706139862537384	MID	"		 boolean isEvaluatedOnDerivedProperty(ObservableProperty property){
		    ObservableProperty currentProperty = getProperty();
		    /*
				 * By convention we admit that the derived property is suffixed with the name of
				 * the property it derives from (e.g. EXPRESSION_BODY which matches an
				 * expression would derive from BODY which matches a list of expressions), so we
				 * could deduce that EXPRESSION_BODY and BODY actually represent the same
				 * field but the validation condition must not be checked.
				 * Be careful because NoChange property must not affect this evaluation.
				 */
		    return currentProperty != null && (property.isDerived() && property.name().endsWith(currentProperty.name()));
		}"	$indentation$ boolean $whitespace$ isevaluatedonderivedproperty ( observableproperty $whitespace$ property ) { $newline$ $indentation$ observableproperty $whitespace$ currentproperty $whitespace$ = $whitespace$ getproperty ( ) ; $newline$ $indentation$ $/*······*·by·convention·we·admit·that·the·derived·property·is·suffixed·with·the·name·of······*·the·property·it·derives·from·(e.g.·expression_body·which·matches·an······*·expression·would·derive·from·body·which·matches·a·list·of·expressions),·so·we······*·could·deduce·that·expression_body·and·body·actually·represent·the·same······*·field·but·the·validation·condition·must·not·be·checked.······*·be·careful·because·nochange·property·must·not·affect·this·evaluation.······*/$ $newline$ $indentation$ return $whitespace$ currentproperty $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ( property . isderived ( ) $whitespace$ && $whitespace$ property . name ( ) . endswith ( currentproperty . name ( ) ) ) ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ isevaluatedonderivedproperty ( observableproperty $whitespace$ property ) { $newline$ $indentation$ boolean $whitespace$ currentproperty $whitespace$ = $whitespace$ getproperty ( ) ; $newline$ $indentation$ int/*ation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ getproperty ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ currentproperty $whitespace$ = $whitespace$ getproperty ( ) ; $newline$ $indentation$ int $whitespace$ rightsubarray $whitespace$ = $whitespace$ getproperty ( ) ; $newline$ $indentation$ int $whitespace$ nextvalue $whitespace$ = $whitespace$ getproperty ( ) ; $newline$ $indentation$ return $whitespace$ currentproperty $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ ( property. isderived ( ) $whitespace$ && $whitespace$ property. name ( ). endswith ( currentproperty. name ( ) ) ) ; $newline$ $indentation$ }			
getValue	44	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/printer/lexicalpreservation/changes/ListRemovalChange.java	0.1673983186483383	LOW	"		@Override
		public Object getValue(ObservableProperty property, Node node){
		    if (property == observableProperty) {
		        Object currentRawValue = new NoChange().getValue(property, node);
		        if (currentRawValue instanceof Optional) {
		            Optional<?> optional = (Optional<?>) currentRawValue;
		            currentRawValue = optional.orElse(null);
		        }
		        if (!(currentRawValue instanceof NodeList)) {
		            throw new IllegalStateException(""Expected NodeList, found "" + currentRawValue.getClass().getCanonicalName());
		        }
		        NodeList<Node> currentNodeList = (NodeList<Node>) currentRawValue;
		        // Note: When adding to a node list children get assigned the list's parent, thus we must set the list's parent before adding children (#2592).
		        NodeList<Node> newNodeList = new NodeList<>();
		        // fix #2187 set the parent node in the new list
		        newNodeList.setParentNode(currentNodeList.getParentNodeForChildren());
		        // Here we want to obtain a sub-list that does not contain an element.
		        // It is important not to implement this by first adding all the elements in the
		        // list and then deleting the element to be removed, as this involves event
		        // propagation mechanisms, particularly for lexical preservation,
		        // which deletes the relationship between a node and its parent node.
		        // This relationship is necessary to reinforce indentation, for example when
		        // deleting a node, as indentation can be carried by the parent node.
		        currentNodeList.stream().filter(n -> !isSameNode(currentNodeList.get(index), n)).forEach(selectedNode -> newNodeList.add(selectedNode));
		        return newNodeList;
		    }
		    return new NoChange().getValue(property, node);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ object $whitespace$ getvalue ( observableproperty $whitespace$ property , $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty ) $whitespace$ { $newline$ $indentation$ object $whitespace$ currentrawvalue $whitespace$ = $whitespace$ new $whitespace$ nochange ( ) . getvalue ( property , $whitespace$ node ) ; $newline$ $indentation$ if $whitespace$ ( currentrawvalue $whitespace$ instanceof $whitespace$ optional ) $whitespace$ { $newline$ $indentation$ optional < ? > $whitespace$ optional $whitespace$ = $whitespace$ ( optional < ? > ) $whitespace$ currentrawvalue ; $newline$ $indentation$ currentrawvalue $whitespace$ = $whitespace$ optional . orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( currentrawvalue $whitespace$ instanceof $whitespace$ nodelist ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ currentrawvalue . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ nodelist < node > $whitespace$ currentnodelist $whitespace$ = $whitespace$ ( nodelist < node > ) $whitespace$ currentrawvalue ; $newline$ $indentation$ $//·note:·when·adding·to·a·node·list·children·get·assigned·the·list's·parent,·thus·we·must·set·the·list's·parent·before·adding·children·(#2592).$ $newline$ $indentation$ nodelist < node > $whitespace$ newnodelist $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ $//·fix·#2187·set·the·parent·node·in·the·new·list$ $newline$ $indentation$ newnodelist . setparentnode ( currentnodelist . getparentnodeforchildren ( ) ) ; $newline$ $indentation$ $//·here·we·want·to·obtain·a·sub-list·that·does·not·contain·an·element.$ $newline$ $indentation$ $//·it·is·important·not·to·implement·this·by·first·adding·all·the·elements·in·the$ $newline$ $indentation$ $//·list·and·then·deleting·the·element·to·be·removed,·as·this·involves·event$ $newline$ $indentation$ $//·propagation·mechanisms,·particularly·for·lexical·preservation,$ $newline$ $indentation$ $//·which·deletes·the·relationship·between·a·node·and·its·parent·node.$ $newline$ $indentation$ $//·this·relationship·is·necessary·to·reinforce·indentation,·for·example·when$ $newline$ $indentation$ $//·deleting·a·node,·as·indentation·can·be·carried·by·the·parent·node.$ $newline$ $indentation$ currentnodelist . stream ( ) . filter ( n $whitespace$ - > $whitespace$ ! issamenode ( currentnodelist . get ( index ) , $whitespace$ n ) ) . foreach ( selectednode $whitespace$ - > $whitespace$ newnodelist . add ( selectednode ) ) ; $newline$ $indentation$ return $whitespace$ newnodelist ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ nochange ( ) . getvalue ( property , $whitespace$ node ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ object $whitespace$ getvalue ( observableproperty $whitespace$ property, $whitespace$ node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( property $whitespace$ == $whitespace$ observableproperty ) $whitespace$ { $newline$ $indentation$ object $whitespace$ currentrawvalue $whitespace$ = $whitespace$ new $whitespace$ nochange ( ). getvalue ( property, $whitespace$ node ) ; $newline$ $indentation$ if $whitespace$ ( currentrawvalue $whitespace$ instanceof $whitespace$ optional ) $whitespace$ { $newline$ $indentation$ optional <? > $whitespace$ optional $whitespace$ = $whitespace$ ( optional <? > ) $whitespace$ currentrawvalue ; $newline$ $indentation$ currentrawvalue $whitespace$ = $whitespace$ optional. orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( currentrawvalue $whitespace$ instanceof $whitespace$ nodelist ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ currentrawvalue. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ nodelist < node > $whitespace$ currentnodelist $whitespace$ = $whitespace$ ( nodelist < node > ) $whitespace$ currentrawvalue ; $newline$ $indentation$ $whitespace$// = =ed $whitespace$ nodelist < node > $whitespace$ newnodelist $whitespace$ = $whitespace$ new $whitespace$			
fieldDeclarationInScope	364	383	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.0958900600671768	LOW	"		 Optional<ResolvedFieldDeclaration> fieldDeclarationInScope(String name){
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    Context parentContext = getParent().get();
		    // First check if the parameter is directly declared within this context.
		    Node wrappedNode = getWrappedNode();
		    Optional<ResolvedFieldDeclaration> localResolutionResults = parentContext.fieldsExposedToChild(wrappedNode).stream().filter(vd -> vd.getName().equals(name)).findFirst();
		    if (localResolutionResults.isPresent()) {
		        return localResolutionResults;
		    }
		    // If we don't find the field locally, escalate up the scope hierarchy to see if it is declared there.
		    return parentContext.fieldDeclarationInScope(name);
		}"	$indentation$ optional < resolvedfielddeclaration > $whitespace$ fielddeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ $//·first·check·if·the·parameter·is·directly·declared·within·this·context.$ $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext . fieldsexposedtochild ( wrappednode ) . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getname ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·don't·find·the·field·locally,·escalate·up·the·scope·hierarchy·to·see·if·it·is·declared·there.$ $newline$ $indentation$ return $whitespace$ parentcontext . fielddeclarationinscope ( name ) ; $newline$ $indentation$ }	$indentation$ optional < resolvedfielddeclaration > $whitespace$ fielddeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! getparent ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ). get ( ) ; $newline$ $indentation$ string $whitespace$ processednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext. fieldsexposedtochild ( wrappednode ). stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getname ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ if $whitespace$ there $whitespace$ is $whitespace$ a $whitespace$ valid $whitespace$ cors $whitespace$ request $newline$ $indentation$ boolean $whitespace$ validcourses $whitespace$ = $whitespace$ parentcontext. fieldsexposedtochild ( wrappednode ). stream ( ). filter ( vd $white			
localVariableDeclarationInScope	274	295	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.1034434810280799	LOW	"		 Optional<VariableDeclarator> localVariableDeclarationInScope(String name){
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    // First check if the variable is directly declared within this context.
		    Node wrappedNode = getWrappedNode();
		    Context parentContext = getParent().get();
		    Optional<VariableDeclarator> localResolutionResults = parentContext.localVariablesExposedToChild(wrappedNode).stream().filter(vd -> vd.getNameAsString().equals(name)).findFirst();
		    if (localResolutionResults.isPresent()) {
		        return localResolutionResults;
		    }
		    // If we don't find the variable locally, escalate up the scope hierarchy to see if it is declared there.
		    return parentContext.localVariableDeclarationInScope(name);
		}"	$indentation$ optional < variabledeclarator > $whitespace$ localvariabledeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·first·check·if·the·variable·is·directly·declared·within·this·context.$ $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ optional < variabledeclarator > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext . localvariablesexposedtochild ( wrappednode ) . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getnameasstring ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·don't·find·the·variable·locally,·escalate·up·the·scope·hierarchy·to·see·if·it·is·declared·there.$ $newline$ $indentation$ return $whitespace$ parentcontext . localvariabledeclarationinscope ( name ) ; $newline$ $indentation$ }	$indentation$ optional < variabledeclarator > $whitespace$ localvariabledeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! getparent ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $indentation$ $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext. localvariablesexposedtochild ( wrappednode ). stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext. localvariablesexposedtochild ( wrappednode ). stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext. localvariabledeclarationinscope ( name ) ; $newline$ $indentation$ return $whitespace$ parentcontext. localvariabledeclarationinscope ( name ) ; $newline$ $indentation$ }			
parameterDeclarationInScope	297	317	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.1237199231982231	LOW	"		 Optional<Parameter> parameterDeclarationInScope(String name){
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    // First check if the parameter is directly declared within this context.
		    Node wrappedNode = getWrappedNode();
		    Context parentContext = getParent().get();
		    Optional<Parameter> localResolutionResults = parentContext.parametersExposedToChild(wrappedNode).stream().filter(vd -> vd.getNameAsString().equals(name)).findFirst();
		    if (localResolutionResults.isPresent()) {
		        return localResolutionResults;
		    }
		    // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.
		    return parentContext.parameterDeclarationInScope(name);
		}"	$indentation$ optional < parameter > $whitespace$ parameterdeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·first·check·if·the·parameter·is·directly·declared·within·this·context.$ $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ optional < parameter > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext . parametersexposedtochild ( wrappednode ) . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getnameasstring ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·don't·find·the·parameter·locally,·escalate·up·the·scope·hierarchy·to·see·if·it·is·declared·there.$ $newline$ $indentation$ return $whitespace$ parentcontext . parameterdeclarationinscope ( name ) ; $newline$ $indentation$ }	$indentation$ optional < parameter > $whitespace$ parameterdeclarationinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! getparent ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $indentation$ $whitespace$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ current $whitespace$ generation $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ */ $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ). get ( ) ; $newline$ $indentation$ optional < parameter > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext. parametersexposedtochild ( wrappednode ). stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $			
solveTypeInParentContext	147	155	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.1776180118322372	LOW	"		 SymbolReference<ResolvedTypeDeclaration> solveTypeInParentContext(String name, @Nullable List<ResolvedType> typeArguments){
		    Optional<Context> optionalParentContext = getParent();
		    if (!optionalParentContext.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    // Delegate solving to the parent context.
		    return optionalParentContext.get().solveType(name, typeArguments);
		}"	$indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetypeinparentcontext ( string $whitespace$ name , $whitespace$ @ nullable $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentcontext . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·delegate·solving·to·the·parent·context.$ $newline$ $indentation$ return $whitespace$ optionalparentcontext . get ( ) . solvetype ( name , $whitespace$ typearguments ) ; $newline$ $indentation$ }	$indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetypeinparentcontext ( string $whitespace$ name, $whitespace$ @ nullable $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ (! optionalparentcontext. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! optionalparentcontext. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optionalparentcontext. get ( ). solvetype ( name, $whitespace$ typearguments ) ; $newline$ $indentation$ }			
patternExprInScope	339	362	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.1877534538507461	LOW	"		 Optional<PatternExpr> patternExprInScope(String name){
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    Context parentContext = getParent().get();
		    // FIXME: ""scroll backwards"" from the wrapped node
		    // FIXME: If there are multiple patterns, throw an error?
		    // First check if the pattern is directly declared within this context.
		    Node wrappedNode = getWrappedNode();
		    Optional<PatternExpr> localResolutionResults = parentContext.patternExprsExposedToChild(wrappedNode).stream().filter(vd -> vd.getNameAsString().equals(name)).findFirst();
		    if (localResolutionResults.isPresent()) {
		        return localResolutionResults;
		    }
		    // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.
		    return parentContext.patternExprInScope(name);
		}"	"$indentation$ optional < patternexpr > $whitespace$ patternexprinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ $//·fixme:·""scroll·backwards""·from·the·wrapped·node$ $newline$ $indentation$ $//·fixme:·if·there·are·multiple·patterns,·throw·an·error?$ $newline$ $indentation$ $//·first·check·if·the·pattern·is·directly·declared·within·this·context.$ $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ optional < patternexpr > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ parentcontext . patternexprsexposedtochild ( wrappednode ) . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getnameasstring ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·don't·find·the·parameter·locally,·escalate·up·the·scope·hierarchy·to·see·if·it·is·declared·there.$ $newline$ $indentation$ return $whitespace$ parentcontext . patternexprinscope ( name ) ; $newline$ $indentation$ }"	$indentation$ optional < patternexpr > $whitespace$ patternexprinscope ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! getparent ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ). get ( ) ; $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ parentcontext. patternexprsexposedtochild ( wrappednode ). stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ list $whitespace$ is $whitespace$ not $whitespace$ empty $whitespace$ string $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ (! getwrappednode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ local			
solveMethodInParentContext	405	413	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Context.java	0.1900214999914169	LOW	"		 SymbolReference<ResolvedMethodDeclaration> solveMethodInParentContext(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    Optional<Context> optionalParentContext = getParent();
		    if (!optionalParentContext.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    // Delegate solving to the parent context.
		    return optionalParentContext.get().solveMethod(name, argumentsTypes, staticOnly);
		}"	$indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethodinparentcontext ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentcontext . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·delegate·solving·to·the·parent·context.$ $newline$ $indentation$ return $whitespace$ optionalparentcontext . get ( ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ }	$indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethodinparentcontext ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ (! optionalparentcontext. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optionalparentcontext. get ( ). solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ }			
replaceTypeParameter	144	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/MethodUsage.java	0.0642700046300888	LOW	"		public MethodUsage replaceTypeParameter(ResolvedTypeParameterDeclaration typeParameter, ResolvedType type){
		    if (type == null) {
		        throw new IllegalArgumentException();
		    }
		    // TODO if the method declaration has a type param with that name ignore this call
		    MethodUsage res = new MethodUsage(declaration, paramTypes, returnType, exceptionTypes, typeParametersMap.toBuilder().setValue(typeParameter, type).build());
		    Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		    for (int i = 0; i < paramTypes.size(); i++) {
		        ResolvedType originalParamType = paramTypes.get(i);
		        ResolvedType newParamType = originalParamType.replaceTypeVariables(typeParameter, type, inferredTypes);
		        res = res.replaceParamType(i, newParamType);
		    }
		    for (int i = 0; i < exceptionTypes.size(); i++) {
		        ResolvedType originalType = exceptionTypes.get(i);
		        ResolvedType newType = originalType.replaceTypeVariables(typeParameter, type, inferredTypes);
		        res = res.replaceExceptionType(i, newType);
		    }
		    ResolvedType oldReturnType = res.returnType;
		    ResolvedType newReturnType = oldReturnType.replaceTypeVariables(typeParameter, type, inferredTypes);
		    res = res.replaceReturnType(newReturnType);
		    return res;
		}"	$indentation$ public $whitespace$ methodusage $whitespace$ replacetypeparameter ( resolvedtypeparameterdeclaration $whitespace$ typeparameter , $whitespace$ resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo·if·the·method·declaration·has·a·type·param·with·that·name·ignore·this·call$ $newline$ $indentation$ methodusage $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ methodusage ( declaration , $whitespace$ paramtypes , $whitespace$ returntype , $whitespace$ exceptiontypes , $whitespace$ typeparametersmap . tobuilder ( ) . setvalue ( typeparameter , $whitespace$ type ) . build ( ) ) ; $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ paramtypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ originalparamtype $whitespace$ = $whitespace$ paramtypes . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ newparamtype $whitespace$ = $whitespace$ originalparamtype . replacetypevariables ( typeparameter , $whitespace$ type , $whitespace$ inferredtypes ) ; $newline$ $indentation$ res $whitespace$ = $whitespace$ res . replaceparamtype ( i , $whitespace$ newparamtype ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ exceptiontypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ originaltype $whitespace$ = $whitespace$ exceptiontypes . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ newtype $whitespace$ = $whitespace$ originaltype . replacetypevariables ( typeparameter , $whitespace$ type , $whitespace$ inferredtypes ) ; $newline$ $indentation$ res $whitespace$ = $whitespace$ res . replaceexceptiontype ( i , $whitespace$ newtype ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ oldreturntype $whitespace$ = $whitespace$ res . returntype ; $newline$ $indentation$ resolvedtype $whitespace$ newreturntype $whitespace$ = $whitespace$ oldreturntype . replacetypevariables ( typeparameter , $whitespace$ type , $whitespace$ inferredtypes ) ; $newline$ $indentation$ res $whitespace$ = $whitespace$ res . replacereturntype ( newreturntype ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methodusage $whitespace$ replacetypeparameter ( resolvedtypeparameterdeclaration $whitespace$ typeparameter, $whitespace$ resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////todo $whitespace$ method $whitespace$ = $whitespace$ new $whitespace$ methodusage ( declaration, $whitespace$ paramtypes, $whitespace$ returntype, $whitespace$ exceptiontypes, $whitespace$ typeparametersmap. tobuilder ( ). setvalue ( typeparameter, $whitespace$ type ). build ( ) ) ; $newline$ $indentation$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ paramtypes. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ originalparamtype $whitespace$ = $whitespace$ paramtypes. get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ newparamtype $whitespace$ = $whitespace$ originalparamtype. replacetypevariables ( typeparameter, $whitespace$ type, $whitespace$ inferredtypes ) ; $newline$ $indentation$ res $whitespace$ = $whitespace$ res. replaceparamtype ( i, $whitespace$ newparamtype ) ; $newline$ $indentation$ } $newline$ $indentation$			
replaceExceptionType	111	121	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/MethodUsage.java	0.2751126587390899	LOW	"		public MethodUsage replaceExceptionType(int i, ResolvedType replaced){
		    if (i < 0 || i >= exceptionTypes.size()) {
		        throw new IllegalArgumentException();
		    }
		    if (exceptionTypes.get(i) == replaced) {
		        return this;
		    }
		    List<ResolvedType> newTypes = new LinkedList<>(exceptionTypes);
		    newTypes.set(i, replaced);
		    return new MethodUsage(declaration, paramTypes, returnType, newTypes, typeParametersMap);
		}"	$indentation$ public $whitespace$ methodusage $whitespace$ replaceexceptiontype ( int $whitespace$ i , $whitespace$ resolvedtype $whitespace$ replaced ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ exceptiontypes . size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( exceptiontypes . get ( i ) $whitespace$ == $whitespace$ replaced ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ newtypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( exceptiontypes ) ; $newline$ $indentation$ newtypes . set ( i , $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( declaration , $whitespace$ paramtypes , $whitespace$ returntype , $whitespace$ newtypes , $whitespace$ typeparametersmap ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methodusage $whitespace$ replaceexceptiontype ( int $whitespace$ i, $whitespace$ resolvedtype $whitespace$ replaced ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ exceptiontypes. size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( exceptiontypes. get ( i ) $whitespace$ == $whitespace$ replaced ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ newtypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( exceptiontypes ) ; $newline$ $indentation$ newtypes. set ( i, $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( declaration, $whitespace$ paramtypes, $whitespace$ returntype, $whitespace$ newtypes, $whitespace$ typeparametersmap ) ; $newline$ $indentation$ }			
replaceParamType	99	109	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/MethodUsage.java	0.2870617806911468	LOW	"		public MethodUsage replaceParamType(int i, ResolvedType replaced){
		    if (i < 0 || i >= getNoParams()) {
		        throw new IllegalArgumentException();
		    }
		    if (paramTypes.get(i) == replaced) {
		        return this;
		    }
		    List<ResolvedType> newParams = new LinkedList<>(paramTypes);
		    newParams.set(i, replaced);
		    return new MethodUsage(declaration, newParams, returnType, exceptionTypes, typeParametersMap);
		}"	$indentation$ public $whitespace$ methodusage $whitespace$ replaceparamtype ( int $whitespace$ i , $whitespace$ resolvedtype $whitespace$ replaced ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ getnoparams ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( paramtypes . get ( i ) $whitespace$ == $whitespace$ replaced ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ newparams $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( paramtypes ) ; $newline$ $indentation$ newparams . set ( i , $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( declaration , $whitespace$ newparams , $whitespace$ returntype , $whitespace$ exceptiontypes , $whitespace$ typeparametersmap ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methodusage $whitespace$ replaceparamtype ( int $whitespace$ i, $whitespace$ resolvedtype $whitespace$ replaced ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ getnoparams ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( stringutils. isnotblank ( replaced ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ newparams $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( paramtypes ) ; $newline$ $indentation$ newparams. set ( i, $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( declaration, $whitespace$ newparams, $whitespace$ returntype, $whitespace$ exceptiontypes, $whitespace$ typeparametersmap ) ; $newline$ $indentation$ }			
demandClassOrInterface	57	61	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.0057428302243351	LOW	"		public static ClassOrInterfaceDeclaration demandClassOrInterface(CompilationUnit compilationUnit, String qualifiedName){
		    return findType(compilationUnit, qualifiedName).map(res -> res.toClassOrInterfaceDeclaration().orElseThrow(() -> new IllegalStateException(""Type is not a class or an interface, it is "" + res.getClass().getCanonicalName()))).orElseThrow(() -> new IllegalStateException(""No type named '"" + qualifiedName + ""'found""));
		}"	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandclassorinterface ( compilationunit $whitespace$ compilationunit , $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ return $whitespace$ findtype ( compilationunit , $whitespace$ qualifiedname ) . map ( res $whitespace$ - > $whitespace$ res . toclassorinterfacedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ res . getclass ( ) . getcanonicalname ( ) ) ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ qualifiedname $whitespace$ + $whitespace$ $string$ ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandclassorinterface ( compilationunit $whitespace$ compilationunit, $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ return $whitespace$ findtype ( compilationunit, $whitespace$ qualifiedname ). map ( res $whitespace$ - > $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ res. getclass ( ). getcanonicalname ( ) ) ) ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ qualifiedname $whitespace$ + $whitespace$ $string$ ) ) ; $newline$ $indentation$ }			
findType	226	239	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.0769543573260307	LOW	"		public static Optional<TypeDeclaration<?>> findType(CompilationUnit cu, String qualifiedName){
		    if (cu.getTypes().isEmpty()) {
		        return Optional.empty();
		    }
		    final String typeName = getOuterTypeName(qualifiedName);
		    Optional<TypeDeclaration<?>> type = cu.getTypes().stream().filter((t) -> t.getName().getId().equals(typeName)).findFirst();
		    final String innerTypeName = getInnerTypeName(qualifiedName);
		    if (type.isPresent() && !innerTypeName.isEmpty()) {
		        return findType(type.get(), innerTypeName);
		    }
		    return type;
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < typedeclaration < ? >> $whitespace$ findtype ( compilationunit $whitespace$ cu , $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ if $whitespace$ ( cu . gettypes ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ getoutertypename ( qualifiedname ) ; $newline$ $indentation$ optional < typedeclaration < ? >> $whitespace$ type $whitespace$ = $whitespace$ cu . gettypes ( ) . stream ( ) . filter ( ( t ) $whitespace$ - > $whitespace$ t . getname ( ) . getid ( ) . equals ( typename ) ) . findfirst ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ innertypename $whitespace$ = $whitespace$ getinnertypename ( qualifiedname ) ; $newline$ $indentation$ if $whitespace$ ( type . ispresent ( ) $whitespace$ && $whitespace$ ! innertypename . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ findtype ( type . get ( ) , $whitespace$ innertypename ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < typedeclaration <? >> $whitespace$ findtype ( compilationunit $whitespace$ cu, $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ if $whitespace$ ( cu. gettypes ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ typename $whitespace$ = $whitespace$ getoutertypename ( qualifiedname ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ innertypename $whitespace$ = $whitespace$ getinnertypename ( qualifiedname ) ; $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
demandInterface	116	122	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.6055226922035217	MID	"		public static ClassOrInterfaceDeclaration demandInterface(CompilationUnit cu, String qualifiedName){
		    ClassOrInterfaceDeclaration cd = demandClassOrInterface(cu, qualifiedName);
		    if (!cd.isInterface()) {
		        throw new IllegalStateException(""Type is not an interface"");
		    }
		    return cd;
		}"	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandinterface ( compilationunit $whitespace$ cu , $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ classorinterfacedeclaration $whitespace$ cd $whitespace$ = $whitespace$ demandclassorinterface ( cu , $whitespace$ qualifiedname ) ; $newline$ $indentation$ if $whitespace$ ( ! cd . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ cd ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandinterface ( compilationunit $whitespace$ cu, $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ classorinterfacedeclaration $whitespace$ cd $whitespace$ = $whitespace$ demandclassorinterface ( cu, $whitespace$ qualifiedname ) ; $newline$ $indentation$ if $whitespace$ (! cd. isinterface ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ cd ; $newline$ $indentation$ }			
demandClass	49	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.6154118776321411	MID	"		public static ClassOrInterfaceDeclaration demandClass(CompilationUnit cu, String qualifiedName){
		    ClassOrInterfaceDeclaration cd = demandClassOrInterface(cu, qualifiedName);
		    if (cd.isInterface()) {
		        throw new IllegalStateException(""Type is not a class"");
		    }
		    return cd;
		}"	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandclass ( compilationunit $whitespace$ cu , $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ classorinterfacedeclaration $whitespace$ cd $whitespace$ = $whitespace$ demandclassorinterface ( cu , $whitespace$ qualifiedname ) ; $newline$ $indentation$ if $whitespace$ ( cd . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ cd ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ classorinterfacedeclaration $whitespace$ demandclass ( compilationunit $whitespace$ cu, $whitespace$ string $whitespace$ qualifiedname ) { $newline$ $indentation$ classorinterfacedeclaration $whitespace$ cd $whitespace$ = $whitespace$ demandclassorinterface ( cu, $whitespace$ qualifiedname ) ; $newline$ $indentation$ if $whitespace$ ( cd. isinterface ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ cd ; $newline$ $indentation$ }			
demandParentNode	156	162	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.6265040636062622	MID	"		public static Node demandParentNode(Node node, Predicate<Node> isAcceptedParentNode){
		    Node parent = node;
		    do {
		        parent = demandParentNode(parent);
		    } while (!isAcceptedParentNode.test(parent));
		    return parent;
		}"	$indentation$ public $whitespace$ static $whitespace$ node $whitespace$ demandparentnode ( node $whitespace$ node , $whitespace$ predicate < node > $whitespace$ isacceptedparentnode ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ ( ! isacceptedparentnode . test ( parent ) ) ; $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ node $whitespace$ demandparentnode ( node $whitespace$ node, $whitespace$ predicate < node > $whitespace$ isacceptedparentnode ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ (! isacceptedparentnode. test ( parent ) ) ; $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ }			
getInnerTypeName	264	269	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/Navigator.java	0.8344507813453674	HIGH	"		private static String getInnerTypeName(String qualifiedName){
		    if (qualifiedName.contains(""."")) {
		        return qualifiedName.split(""\\."", 2)[1];
		    }
		    return """";
		}"	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ getinnertypename ( string $whitespace$ qualifiedname ) { $newline$ $indentation$ if $whitespace$ ( qualifiedname . contains ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifiedname . split ( $string$ , $whitespace$ $number$ ) [ $number$ ] ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ string $whitespace$ getinnertypename ( string $whitespace$ qualifiedname ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ qualifiedname $whitespace$ = $whitespace$ qualifiedname. contains ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( qualifiedname. contains ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifiedname. split ( $string$, $whitespace$ $number$ ) [ $number$ ] ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ }			
getRoot	40	45	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/TypeSolver.java	0.8807581663131714	HIGH	"		 TypeSolver getRoot(){
		    if (getParent() == null) {
		        return this;
		    }
		    return getParent().getRoot();
		}"	$indentation$ typesolver $whitespace$ getroot ( ) { $newline$ $indentation$ if $whitespace$ ( getparent ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getparent ( ) . getroot ( ) ; $newline$ $indentation$ }	$indentation$ typesolver $whitespace$ getroot ( ) { $newline$ $indentation$ if $whitespace$ ( getparent ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getparent ( ). getroot ( ) ; $newline$ $indentation$ }			
toAst	68	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/AssociableToAST.java	0.2673631310462951	LOW	"		 Optional<N> toAst(Class<N> clazz){
		    return toAst().filter(clazz::isInstance).map(clazz::cast);
		}"	$indentation$ optional < n > $whitespace$ toast ( class < n > $whitespace$ clazz ) { $newline$ $indentation$ return $whitespace$ toast ( ) . filter ( clazz : : isinstance ) . map ( clazz : : cast ) ; $newline$ $indentation$ }	$indentation$ optional < n > $whitespace$ toast ( class < n > $whitespace$ clazz ) { $newline$ $indentation$ return $whitespace$ toast ( ). filter ( clazz : : isinstance ). map ( clazz : : cast ) ; $newline$ $indentation$ }			
isReturnTypeSubstituable	72	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedMethodDeclaration.java	0.6432832479476929	MID	"		 boolean isReturnTypeSubstituable(ResolvedType otherResolvedType){
		    ResolvedType returnType = getReturnType();
		    if (returnType.isVoid()) {
		        return otherResolvedType.isVoid();
		    }
		    if (returnType.isPrimitive()) {
		        return otherResolvedType.isPrimitive() && returnType.asPrimitive().equals(otherResolvedType.asPrimitive());
		    }
		    // If R1 is a reference type then one of the following is true:
		    // R1, adapted to the type parameters of d2 (§8.4.4), is a subtype of R2.
		    // Below we are trying to compare a reference type for example an Object to a type variable let's say T
		    // we can certainly simplify by saying that this is always true.
		    if (otherResolvedType.isTypeVariable()) {
		        return true;
		    }
		    // R1 can be converted to a subtype of R2 by unchecked conversion (§5.1.9).
		    // d1 does not have the same signature as d2 (§8.4.2), and R1 = |R2|.
		    if (returnType.describe().equals(otherResolvedType.erasure().describe())) {
		        return true;
		    }
		    throw new UnsupportedOperationException(""Return-Type-Substituable must be implemented on reference type."");
		}"	$indentation$ boolean $whitespace$ isreturntypesubstituable ( resolvedtype $whitespace$ otherresolvedtype ) { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ getreturntype ( ) ; $newline$ $indentation$ if $whitespace$ ( returntype . isvoid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ otherresolvedtype . isvoid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( returntype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ otherresolvedtype . isprimitive ( ) $whitespace$ && $whitespace$ returntype . asprimitive ( ) . equals ( otherresolvedtype . asprimitive ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·r1·is·a·reference·type·then·one·of·the·following·is·true:$ $newline$ $indentation$ $//·r1,·adapted·to·the·type·parameters·of·d2·(§8.4.4),·is·a·subtype·of·r2.$ $newline$ $indentation$ $//·below·we·are·trying·to·compare·a·reference·type·for·example·an·object·to·a·type·variable·let's·say·t$ $newline$ $indentation$ $//·we·can·certainly·simplify·by·saying·that·this·is·always·true.$ $newline$ $indentation$ if $whitespace$ ( otherresolvedtype . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·r1·can·be·converted·to·a·subtype·of·r2·by·unchecked·conversion·(§5.1.9).$ $newline$ $indentation$ $//·d1·does·not·have·the·same·signature·as·d2·(§8.4.2),·and·r1·=·|r2|.$ $newline$ $indentation$ if $whitespace$ ( returntype . describe ( ) . equals ( otherresolvedtype . erasure ( ) . describe ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ isreturntypesubstituable ( resolvedtype $whitespace$ otherresolvedtype ) { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ getreturntype ( ) ; $newline$ $indentation$ if $whitespace$ ( returntype. isvoid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ otherresolvedtype. isvoid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( returntype. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ otherresolvedtype. isprimitive ( ) $whitespace$ && $whitespace$ returntype. asprimitive ( ). equals ( otherresolvedtype. asprimitive ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl gl			
getSignature	62	74	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedMethodLikeDeclaration.java	0.7079451680183411	MID	"		 String getSignature(){
		    StringBuilder sb = new StringBuilder();
		    sb.append(getName());
		    sb.append(""("");
		    for (int i = 0; i < getNumberOfParams(); i++) {
		        if (i != 0) {
		            sb.append("", "");
		        }
		        sb.append(getParam(i).describeType());
		    }
		    sb.append("")"");
		    return sb.toString();
		}"	$indentation$ string $whitespace$ getsignature ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ sb . append ( getname ( ) ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb . append ( getparam ( i ) . describetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ string $whitespace$ getsignature ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ sb. append ( getname ( ) ) $newline$ $indentation$. append ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( i $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ sb. append ( getparam ( i ). describetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
hasVariadicParameter	129	134	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedMethodLikeDeclaration.java	0.7206817269325256	MID	"		 boolean hasVariadicParameter(){
		    if (getNumberOfParams() == 0) {
		        return false;
		    }
		    return getParam(getNumberOfParams() - 1).isVariadic();
		}"	$indentation$ boolean $whitespace$ hasvariadicparameter ( ) { $newline$ $indentation$ if $whitespace$ ( getnumberofparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getparam ( getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ) . isvariadic ( ) ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ hasvariadicparameter ( ) { $newline$ $indentation$ if $whitespace$ ( getnumberofparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getparam ( getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ). isvariadic ( ) ; $newline$ $indentation$ }			
describeType	56	61	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedParameterDeclaration.java	0.6811189651489258	MID	"		 String describeType(){
		    if (isVariadic()) {
		        return getType().asArrayType().getComponentType().describe() + ""..."";
		    }
		    return getType().describe();
		}"	$indentation$ string $whitespace$ describetype ( ) { $newline$ $indentation$ if $whitespace$ ( isvariadic ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ gettype ( ) . asarraytype ( ) . getcomponenttype ( ) . describe ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ gettype ( ) . describe ( ) ; $newline$ $indentation$ }	$indentation$ string $whitespace$ describetype ( ) { $newline$ $indentation$ system. out. printf ( $string$, $whitespace$ x, $whitespace$ y ) ; $newline$ $indentation$ return $whitespace$ gettype ( ). describe ( ) ; $newline$ $indentation$ }			
hasAnnotation	292	302	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedReferenceTypeDeclaration.java	0.002503159455955	LOW	"		 boolean hasAnnotation(String qualifiedName){
		    if (hasDirectlyAnnotation(qualifiedName)) {
		        return true;
		    }
		    return isClass() && getAllAncestors().stream().filter(it -> it.asReferenceType().getTypeDeclaration().isPresent()).filter(it -> it.asReferenceType().getTypeDeclaration().get().isClass()).map(it -> it.asReferenceType().getTypeDeclaration().get()).anyMatch(rrtd -> rrtd.hasDirectlyAnnotation(qualifiedName) && rrtd.isInheritedAnnotation(qualifiedName));
		}"	$indentation$ boolean $whitespace$ hasannotation ( string $whitespace$ qualifiedname ) { $newline$ $indentation$ if $whitespace$ ( hasdirectlyannotation ( qualifiedname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isclass ( ) $whitespace$ && $whitespace$ getallancestors ( ) . stream ( ) . filter ( it $whitespace$ - > $whitespace$ it . asreferencetype ( ) . gettypedeclaration ( ) . ispresent ( ) ) . filter ( it $whitespace$ - > $whitespace$ it . asreferencetype ( ) . gettypedeclaration ( ) . get ( ) . isclass ( ) ) . map ( it $whitespace$ - > $whitespace$ it . asreferencetype ( ) . gettypedeclaration ( ) . get ( ) ) . anymatch ( rrtd $whitespace$ - > $whitespace$ rrtd . hasdirectlyannotation ( qualifiedname ) $whitespace$ && $whitespace$ rrtd . isinheritedannotation ( qualifiedname ) ) ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ hasannotation ( string $whitespace$ qualifiedname ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ isclass $whitespace$ = $whitespace$ hasdirectlyannotation ( qualifiedname ) ; $newline$ $indentation$ if $whitespace$ (! isclass ( ) $whitespace$ && $whitespace$! getallancestors ( ). stream ( ). filter ( it $whitespace$ - > $whitespace$ it. asreferencetype ( ). gettypedeclaration ( ). ispresent ( ) ). filter ( it $whitespace$ - > $whitespace$ it. asreferencetype ( ). gettypedeclaration ( ). get ( ). isclass ( ) ). map ( it $whitespace$ - > $whitespace$ it. asreferencetype ( ). gettypedeclaration ( ). get ( ) ). anymatch ( rrtd $whitespace$ - > $whitespace$ rrtd. hasdirectlyannotation ( qualifiedname ) $whitespace$ && $whitespace$ rrtd. isinheritedannotation ( qualifiedname ) ) ; $newline$ $indentation$ }			
getDeclaredAnnotation	315	319	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedReferenceTypeDeclaration.java	0.0966379269957542	LOW	"		 Optional<ResolvedAnnotationDeclaration> getDeclaredAnnotation(String name){
		    return getDeclaredAnnotations().stream().filter(annotation -> annotation.getQualifiedName().endsWith(name)).findFirst();
		}"	$indentation$ optional < resolvedannotationdeclaration > $whitespace$ getdeclaredannotation ( string $whitespace$ name ) { $newline$ $indentation$ return $whitespace$ getdeclaredannotations ( ) . stream ( ) . filter ( annotation $whitespace$ - > $whitespace$ annotation . getqualifiedname ( ) . endswith ( name ) ) . findfirst ( ) ; $newline$ $indentation$ }	$indentation$ optional < resolvedannotationdeclaration > $whitespace$ getdeclaredannotation ( string $whitespace$ name ) { $newline$ $indentation$ return $whitespace$ getdeclaredannotations ( ). stream ( ). filter ( annotation $whitespace$ - > $whitespace$ annotation. getqualifiedname ( ). endswith ( name ) ). findfirst ( ) ; $newline$ $indentation$ }			
getVisibleField	187	193	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedReferenceTypeDeclaration.java	0.1884309202432632	LOW	"		 ResolvedFieldDeclaration getVisibleField(String name){
		    Optional<ResolvedFieldDeclaration> field = getVisibleFields().stream().filter(f -> f.getName().equals(name)).findFirst();
		    if (field.isPresent()) {
		        return field.get();
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ resolvedfielddeclaration $whitespace$ getvisiblefield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ getvisiblefields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . getname ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( field . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ field . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ resolvedfielddeclaration $whitespace$ getvisiblefield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ getvisiblefields ( ). stream ( ). filter ( f $whitespace$ - > $whitespace$ f. getname ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( field. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ field. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
getField	176	182	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedReferenceTypeDeclaration.java	0.2332699596881866	LOW	"		 ResolvedFieldDeclaration getField(String name){
		    Optional<ResolvedFieldDeclaration> field = this.getAllFields().stream().filter(f -> f.getName().equals(name)).findFirst();
		    if (field.isPresent()) {
		        return field.get();
		    }
		    throw new UnsolvedSymbolException(""Field not found: "" + name);
		}"	$indentation$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ this . getallfields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . getname ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( field . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ field . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ name ) ; $newline$ $indentation$ }	$indentation$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ this. getallfields ( ). stream ( ). filter ( f $whitespace$ - > $whitespace$ f. getname ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( field. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ field. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ name ) ; $newline$ $indentation$ }			
hashCode	343	348	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java	0.6996782422065735	MID	"		@Override
		public int hashCode(){
		    int result = (extendsBound ? 1 : 0);
		    result = 31 * result + (type != null ? type.hashCode() : 0);
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ ( extendsbound $whitespace$ ? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ ( type $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ type . hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ ( extendsbound $whitespace$? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ ( type $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ type. hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
getUpperBound	233	240	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java	0.8381047248840332	HIGH	"		 ResolvedType getUpperBound(){
		    for (Bound b : getBounds()) {
		        if (b.isExtends()) {
		            return b.getType();
		        }
		    }
		    throw new IllegalStateException();
		}"	$indentation$ resolvedtype $whitespace$ getupperbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ }	$indentation$ resolvedtype $whitespace$ getupperbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b. gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ }			
getLowerBound	219	226	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java	0.8434818983078003	HIGH	"		 ResolvedType getLowerBound(){
		    for (Bound b : getBounds()) {
		        if (b.isSuper()) {
		            return b.getType();
		        }
		    }
		    throw new IllegalStateException();
		}"	$indentation$ resolvedtype $whitespace$ getlowerbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ }	$indentation$ resolvedtype $whitespace$ getlowerbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b. gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ }			
hasUpperBound	205	212	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java	0.9286195635795592	HIGH	"		 boolean hasUpperBound(){
		    for (Bound b : getBounds()) {
		        if (b.isExtends()) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ boolean $whitespace$ hasupperbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ hasupperbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
hasLowerBound	193	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/declarations/ResolvedTypeParameterDeclaration.java	0.93378484249115	HIGH	"		 boolean hasLowerBound(){
		    for (Bound b : getBounds()) {
		        if (b.isSuper()) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ boolean $whitespace$ haslowerbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ haslowerbound ( ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
isApplicable	70	145	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/ConstructorResolutionLogic.java	0.0080251200124621	LOW	"		private static boolean isApplicable(ResolvedConstructorDeclaration constructor, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, boolean withWildcardTolerance){
		    if (constructor.hasVariadicParameter()) {
		        int pos = constructor.getNumberOfParams() - 1;
		        if (constructor.getNumberOfParams() == argumentsTypes.size()) {
		            // check if the last value is directly assignable as an array
		            ResolvedType expectedType = constructor.getLastParam().getType();
		            ResolvedType actualType = argumentsTypes.get(pos);
		            if (!expectedType.isAssignableBy(actualType)) {
		                for (ResolvedTypeParameterDeclaration tp : constructor.getTypeParameters()) {
		                    expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);
		                }
		                if (!expectedType.isAssignableBy(actualType)) {
		                    if (actualType.isArray() && expectedType.isAssignableBy(actualType.asArrayType().getComponentType())) {
		                        argumentsTypes.set(pos, actualType.asArrayType().getComponentType());
		                    } else {
		                        argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, constructor.getLastParam().getType());
		                    }
		                }
		            }
		            // else it is already assignable, nothing to do
		        } else {
		            if (pos > argumentsTypes.size()) {
		                return false;
		            }
		            argumentsTypes = groupVariadicParamValues(argumentsTypes, pos, constructor.getLastParam().getType());
		        }
		    }
		    if (constructor.getNumberOfParams() != argumentsTypes.size()) {
		        return false;
		    }
		    Map<String, ResolvedType> matchedParameters = new HashMap<>();
		    boolean needForWildCardTolerance = false;
		    for (int i = 0; i < constructor.getNumberOfParams(); i++) {
		        ResolvedType expectedType = constructor.getParam(i).getType();
		        ResolvedType actualType = argumentsTypes.get(i);
		        if ((expectedType.isTypeVariable() && !(expectedType.isWildcard())) && expectedType.asTypeParameter().declaredOnMethod()) {
		            matchedParameters.put(expectedType.asTypeParameter().getName(), actualType);
		            continue;
		        }
		        boolean isAssignableWithoutSubstitution = expectedType.isAssignableBy(actualType) || (constructor.getParam(i).isVariadic() && new ResolvedArrayType(expectedType).isAssignableBy(actualType));
		        if (!isAssignableWithoutSubstitution && expectedType.isReferenceType() && actualType.isReferenceType()) {
		            isAssignableWithoutSubstitution = MethodResolutionLogic.isAssignableMatchTypeParameters(expectedType.asReferenceType(), actualType.asReferenceType(), matchedParameters);
		        }
		        if (!isAssignableWithoutSubstitution) {
		            for (ResolvedTypeParameterDeclaration tp : constructor.getTypeParameters()) {
		                expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);
		            }
		            for (ResolvedTypeParameterDeclaration tp : constructor.declaringType().getTypeParameters()) {
		                expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);
		            }
		            if (!expectedType.isAssignableBy(actualType)) {
		                if (actualType.isWildcard() && withWildcardTolerance && !expectedType.isPrimitive()) {
		                    needForWildCardTolerance = true;
		                    continue;
		                }
		                if (constructor.hasVariadicParameter() && i == constructor.getNumberOfParams() - 1) {
		                    if (new ResolvedArrayType(expectedType).isAssignableBy(actualType)) {
		                        continue;
		                    }
		                }
		                return false;
		            }
		        }
		    }
		    return !withWildcardTolerance || needForWildCardTolerance;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isapplicable ( resolvedconstructordeclaration $whitespace$ constructor , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ boolean $whitespace$ withwildcardtolerance ) { $newline$ $indentation$ if $whitespace$ ( constructor . hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ constructor . getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( constructor . getnumberofparams ( ) $whitespace$ == $whitespace$ argumentstypes . size ( ) ) $whitespace$ { $newline$ $indentation$ $//·check·if·the·last·value·is·directly·assignable·as·an·array$ $newline$ $indentation$ resolvedtype $whitespace$ expectedtype $whitespace$ = $whitespace$ constructor . getlastparam ( ) . gettype ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualtype $whitespace$ = $whitespace$ argumentstypes . get ( pos ) ; $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ constructor . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic . replacetypeparam ( expectedtype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualtype . isarray ( ) $whitespace$ && $whitespace$ expectedtype . isassignableby ( actualtype . asarraytype ( ) . getcomponenttype ( ) ) ) $whitespace$ { $newline$ $indentation$ argumentstypes . set ( pos , $whitespace$ actualtype . asarraytype ( ) . getcomponenttype ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ argumentstypes $whitespace$ = $whitespace$ groupvariadicparamvalues ( argumentstypes , $whitespace$ pos , $whitespace$ constructor . getlastparam ( ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·else·it·is·already·assignable,·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( pos $whitespace$ > $whitespace$ argumentstypes . size ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ argumentstypes $whitespace$ = $whitespace$ groupvariadicparamvalues ( argumentstypes , $whitespace$ pos , $whitespace$ constructor . getlastparam ( ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( constructor . getnumberofparams ( ) $whitespace$ != $whitespace$ argumentstypes . size ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ map < string , $whitespace$ resolvedtype > $whitespace$ matchedparameters $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ boolean $whitespace$ needforwildcardtolerance $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ constructor . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ expectedtype $whitespace$ = $whitespace$ constructor . getparam ( i ) . gettype ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualtype $whitespace$ = $whitespace$ argumentstypes . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ( expectedtype . istypevariable ( ) $whitespace$ && $whitespace$ ! ( expectedtype . iswildcard ( ) ) ) $whitespace$ && $whitespace$ expectedtype . astypeparameter ( ) . declaredonmethod ( ) ) $whitespace$ { $newline$ $indentation$ matchedparameters . put ( expectedtype . astypeparameter ( ) . getname ( ) , $whitespace$ actualtype ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ isassignablewithoutsubstitution $whitespace$ = $whitespace$ expectedtype . isassignableby ( actualtype ) $whitespace$ || $whitespace$ ( constructor . getparam ( i ) . isvariadic ( ) $whitespace$ && $whitespace$ new $whitespace$ resolvedarraytype ( expectedtype ) . isassignableby ( actualtype ) ) ; $newline$ $indentation$ if $whitespace$ ( ! isassignablewithoutsubstitution $whitespace$ && $whitespace$ expectedtype . isreferencetype ( ) $whitespace$ && $whitespace$ actualtype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ isassignablewithoutsubstitution $whitespace$ = $whitespace$ methodresolutionlogic . isassignablematchtypeparameters ( expectedtype . asreferencetype ( ) , $whitespace$ actualtype . asreferencetype ( ) , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! isassignablewithoutsubstitution ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ constructor . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic . replacetypeparam ( expectedtype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ constructor . declaringtype ( ) . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic . replacetypeparam ( expectedtype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualtype . iswildcard ( ) $whitespace$ && $whitespace$ withwildcardtolerance $whitespace$ && $whitespace$ ! expectedtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ needforwildcardtolerance $whitespace$ = $whitespace$ true ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( constructor . hasvariadicparameter ( ) $whitespace$ && $whitespace$ i $whitespace$ == $whitespace$ constructor . getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( new $whitespace$ resolvedarraytype ( expectedtype ) . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ! withwildcardtolerance $whitespace$ || $whitespace$ needforwildcardtolerance ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isapplicable ( resolvedconstructordeclaration $whitespace$ constructor, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ boolean $whitespace$ withwildcardtolerance ) { $newline$ $indentation$ if $whitespace$ ( constructor. hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ constructor. getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( constructor. getnumberofparams ( ) $whitespace$ == $whitespace$ argumentstypes. size ( ) ) $whitespace$ { $newline$ $indentation$ $////g$ $newline$ $indentation$if $whitespace$ = $whitespace$ constructor. getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ (! constructor. getnumberofparams ( ) $whitespace$ == $whitespace$ argumentstypes. size ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ constructor. gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic. replacetypeparam ( expectedtype, $whitespace$ tp, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! expectedtype. isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ travel $whitespace$ : $whitespace$ constructor. gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic. replacetypeparam ( expectedtype, $whitespace			
findMostApplicable	153	161	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/ConstructorResolutionLogic.java	0.0555003881454467	LOW	"		public static SymbolReference<ResolvedConstructorDeclaration> findMostApplicable(List<ResolvedConstructorDeclaration> constructors, List<ResolvedType> argumentsTypes, TypeSolver typeSolver){
		    SymbolReference<ResolvedConstructorDeclaration> res = findMostApplicable(constructors, argumentsTypes, typeSolver, false);
		    if (res.isSolved()) {
		        return res;
		    }
		    return findMostApplicable(constructors, argumentsTypes, typeSolver, true);
		}"	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ findmostapplicable ( list < resolvedconstructordeclaration > $whitespace$ constructors , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ symbolreference < resolvedconstructordeclaration > $whitespace$ res $whitespace$ = $whitespace$ findmostapplicable ( constructors , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ findmostapplicable ( constructors , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ true ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ findmostapplicable ( list < resolvedconstructordeclaration > $whitespace$ constructors, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ symbolreference < resolvedconstructordeclaration > $whitespace$ res $whitespace$ = $whitespace$ findmostapplicable ( constructors, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( res. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ findmostapplicable ( constructors, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ true ) ; $newline$ $indentation$ }			
groupVariadicParamValues	43	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/ConstructorResolutionLogic.java	0.1916733235120773	LOW	"		private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType){
		    List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));
		    List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());
		    if (variadicValues.isEmpty()) {
		        // TODO if there are no variadic values we should default to the bound of the formal type
		        res.add(variadicType);
		    } else {
		        ResolvedType componentType = findCommonType(variadicValues);
		        res.add(new ResolvedArrayType(componentType));
		    }
		    return res;
		}"	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ groupvariadicparamvalues ( list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ int $whitespace$ startvariadic , $whitespace$ resolvedtype $whitespace$ variadictype ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( argumentstypes . sublist ( $number$ , $whitespace$ startvariadic ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes . sublist ( startvariadic , $whitespace$ argumentstypes . size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( variadicvalues . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·todo·if·there·are·no·variadic·values·we·should·default·to·the·bound·of·the·formal·type$ $newline$ $indentation$ res . add ( variadictype ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ componenttype $whitespace$ = $whitespace$ findcommontype ( variadicvalues ) ; $newline$ $indentation$ res . add ( new $whitespace$ resolvedarraytype ( componenttype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ groupvariadicparamvalues ( list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ int $whitespace$ startvariadic, $whitespace$ resolvedtype $whitespace$ variadictype ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( argumentstypes. sublist ( $number$, $whitespace$ startvariadic ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes. sublist ( startvariadic, $whitespace$ argumentstypes. size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( variadicvalues. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes. sublist ( startvariadic, $whitespace$ argumentstypes. size ( ) ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }			
findCommonType	57	63	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/ConstructorResolutionLogic.java	0.6565725207328796	MID	"		private static ResolvedType findCommonType(List<ResolvedType> variadicValues){
		    if (variadicValues.isEmpty()) {
		        throw new IllegalArgumentException();
		    }
		    // TODO implement this decently
		    return variadicValues.get(0);
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ findcommontype ( list < resolvedtype > $whitespace$ variadicvalues ) { $newline$ $indentation$ if $whitespace$ ( variadicvalues . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo·implement·this·decently$ $newline$ $indentation$ return $whitespace$ variadicvalues . get ( $number$ ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ findcommontype ( list < resolvedtype > $whitespace$ variadicvalues ) { $newline$ $indentation$ if $whitespace$ ( variadicvalues. isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ variadicvalues. get ( $number$ ) ; $newline$ $indentation$ return $whitespace$ variadicvalues. get ( $number$ ) ; $newline$ $indentation$ }			
getFunctionalMethod	48	59	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/FunctionalInterfaceLogic.java	0.2147802263498306	LOW	"		public static Optional<MethodUsage> getFunctionalMethod(ResolvedType type){
		    Optional<ResolvedReferenceTypeDeclaration> optionalTypeDeclaration = type.asReferenceType().getTypeDeclaration();
		    if (!optionalTypeDeclaration.isPresent()) {
		        return Optional.empty();
		    }
		    ResolvedReferenceTypeDeclaration typeDeclaration = optionalTypeDeclaration.get();
		    if (type.isReferenceType() && typeDeclaration.isInterface()) {
		        return getFunctionalMethod(typeDeclaration);
		    }
		    return Optional.empty();
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ getfunctionalmethod ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionaltypedeclaration $whitespace$ = $whitespace$ type . asreferencetype ( ) . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionaltypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ optionaltypedeclaration . get ( ) ; $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) $whitespace$ && $whitespace$ typedeclaration . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getfunctionalmethod ( typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ getfunctionalmethod ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionaltypedeclaration $whitespace$ = $whitespace$ type. asreferencetype ( ). gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ (! optionaltypedeclaration. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ optionaltypedeclaration. get ( ) ; $newline$ $indentation$ if $whitespace$ ( type. isreferencetype ( ) $whitespace$ && $whitespace$ typedeclaration. isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getfunctionalmethod ( typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
registerCorrespondance	72	189	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceContext.java	8.400967885791033e-07	LOW	"		private void registerCorrespondance(ResolvedType formalType, ResolvedType actualType){
		    if (formalType.isReferenceType() && actualType.isReferenceType()) {
		        ResolvedReferenceType formalTypeAsReference = formalType.asReferenceType();
		        ResolvedReferenceType actualTypeAsReference = actualType.asReferenceType();
		        if (!formalTypeAsReference.getQualifiedName().equals(actualTypeAsReference.getQualifiedName())) {
		            List<ResolvedReferenceType> ancestors = actualTypeAsReference.getAllAncestors();
		            final String formalParamTypeQName = formalTypeAsReference.getQualifiedName();
		            // Interfaces do not extend the class Object,
		            // which means that if the formal parameter is of type Object,
		            // all types can match including the actual type.
		            List<ResolvedType> correspondingFormalType = ""java.lang.Object"".equals(formalParamTypeQName) ? Stream.concat(new ArrayList<ResolvedType>(Arrays.asList(actualType)).stream(), ancestors.stream().map(ancestor -> ancestor.asReferenceType()).collect(Collectors.toList()).stream()).collect(Collectors.toList()) : ancestors.stream().filter((a) -> a.getQualifiedName().equals(formalParamTypeQName)).collect(Collectors.toList());
		            if (correspondingFormalType.isEmpty()) {
		                ancestors = formalTypeAsReference.getAllAncestors();
		                final String actualParamTypeQname = actualTypeAsReference.getQualifiedName();
		                List<ResolvedType> correspondingActualType = ancestors.stream().filter(a -> a.getQualifiedName().equals(actualParamTypeQname)).collect(Collectors.toList());
		                if (correspondingActualType.isEmpty()) {
		                    throw new ConflictingGenericTypesException(formalType, actualType);
		                }
		                correspondingFormalType = correspondingActualType;
		            }
		            actualTypeAsReference = correspondingFormalType.get(0).asReferenceType();
		        }
		        if (formalTypeAsReference.getQualifiedName().equals(actualTypeAsReference.getQualifiedName())) {
		            if (!formalTypeAsReference.typeParametersValues().isEmpty()) {
		                if (actualTypeAsReference.isRawType()) {
		                    // nothing to do
		                } else {
		                    int i = 0;
		                    for (ResolvedType formalTypeParameter : formalTypeAsReference.typeParametersValues()) {
		                        registerCorrespondance(formalTypeParameter, actualTypeAsReference.typeParametersValues().get(i));
		                        i++;
		                    }
		                }
		            }
		        }
		    } else if (formalType instanceof InferenceVariableType && !actualType.isPrimitive()) {
		        ((InferenceVariableType) formalType).registerEquivalentType(actualType);
		        if (actualType instanceof InferenceVariableType) {
		            ((InferenceVariableType) actualType).registerEquivalentType(formalType);
		        }
		    } else if (actualType.isNull()) {
		        // nothing to do
		    } else if (actualType.equals(formalType)) {
		        // nothing to do
		    } else if (actualType.isArray() && formalType.isArray()) {
		        registerCorrespondance(formalType.asArrayType().getComponentType(), actualType.asArrayType().getComponentType());
		    } else if (formalType.isWildcard()) {
		        // nothing to do
		        if ((actualType instanceof InferenceVariableType) && formalType.asWildcard().isBounded()) {
		            ((InferenceVariableType) actualType).registerEquivalentType(formalType.asWildcard().getBoundedType());
		            if (formalType.asWildcard().getBoundedType() instanceof InferenceVariableType) {
		                ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualType);
		            }
		        }
		        if (actualType.isWildcard()) {
		            ResolvedWildcard formalWildcard = formalType.asWildcard();
		            ResolvedWildcard actualWildcard = actualType.asWildcard();
		            if (formalWildcard.isBounded() && formalWildcard.getBoundedType() instanceof InferenceVariableType) {
		                if (formalWildcard.isSuper() && actualWildcard.isSuper()) {
		                    ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualWildcard.getBoundedType());
		                } else if (formalWildcard.isExtends() && actualWildcard.isExtends()) {
		                    ((InferenceVariableType) formalType.asWildcard().getBoundedType()).registerEquivalentType(actualWildcard.getBoundedType());
		                }
		            }
		        }
		        if (actualType.isReferenceType()) {
		            if (formalType.asWildcard().isBounded()) {
		                registerCorrespondance(formalType.asWildcard().getBoundedType(), actualType);
		            }
		        }
		    } else if (actualType instanceof InferenceVariableType) {
		        if (formalType instanceof ResolvedReferenceType) {
		            ((InferenceVariableType) actualType).registerEquivalentType(formalType);
		        } else if (formalType instanceof InferenceVariableType) {
		            ((InferenceVariableType) actualType).registerEquivalentType(formalType);
		        }
		    } else if (actualType.isConstraint()) {
		        ResolvedLambdaConstraintType constraintType = actualType.asConstraintType();
		        if (constraintType.getBound() instanceof InferenceVariableType) {
		            ((InferenceVariableType) constraintType.getBound()).registerEquivalentType(formalType);
		        }
		    } else if (actualType.isPrimitive()) {
		        if (formalType.isPrimitive()) {
		            // nothing to do
		        } else {
		            ResolvedReferenceTypeDeclaration resolvedTypedeclaration = typeSolver.solveType(actualType.asPrimitive().getBoxTypeQName());
		            registerCorrespondance(formalType, new ReferenceTypeImpl(resolvedTypedeclaration));
		        }
		    } else if (actualType.isReferenceType()) {
		        if (formalType.isPrimitive()) {
		            if (formalType.asPrimitive().getBoxTypeQName().equals(actualType.describe())) {
		                ResolvedReferenceTypeDeclaration resolvedTypedeclaration = typeSolver.solveType(formalType.asPrimitive().getBoxTypeQName());
		                registerCorrespondance(new ReferenceTypeImpl(resolvedTypedeclaration), actualType);
		            } else {
		                // nothing to do
		            }
		        } else {
		            // nothing to do
		        }
		    } else if (formalType.isReferenceType()) {
		        ResolvedReferenceType formalTypeAsReference = formalType.asReferenceType();
		        if (formalTypeAsReference.isJavaLangObject()) {
		            // nothing to do
		        } else {
		            throw new UnsupportedOperationException(formalType.describe() + "" "" + actualType.describe());
		        }
		    } else {
		        throw new UnsupportedOperationException(formalType.describe() + "" "" + actualType.describe());
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ registercorrespondance ( resolvedtype $whitespace$ formaltype , $whitespace$ resolvedtype $whitespace$ actualtype ) { $newline$ $indentation$ if $whitespace$ ( formaltype . isreferencetype ( ) $whitespace$ && $whitespace$ actualtype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ formaltypeasreference $whitespace$ = $whitespace$ formaltype . asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ actualtypeasreference $whitespace$ = $whitespace$ actualtype . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( ! formaltypeasreference . getqualifiedname ( ) . equals ( actualtypeasreference . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ actualtypeasreference . getallancestors ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ formalparamtypeqname $whitespace$ = $whitespace$ formaltypeasreference . getqualifiedname ( ) ; $newline$ $indentation$ $//·interfaces·do·not·extend·the·class·object,$ $newline$ $indentation$ $//·which·means·that·if·the·formal·parameter·is·of·type·object,$ $newline$ $indentation$ $//·all·types·can·match·including·the·actual·type.$ $newline$ $indentation$ list < resolvedtype > $whitespace$ correspondingformaltype $whitespace$ = $whitespace$ $string$ . equals ( formalparamtypeqname ) $whitespace$ ? $whitespace$ stream . concat ( new $whitespace$ arraylist < resolvedtype > ( arrays . aslist ( actualtype ) ) . stream ( ) , $whitespace$ ancestors . stream ( ) . map ( ancestor $whitespace$ - > $whitespace$ ancestor . asreferencetype ( ) ) . collect ( collectors . tolist ( ) ) . stream ( ) ) . collect ( collectors . tolist ( ) ) $whitespace$ : $whitespace$ ancestors . stream ( ) . filter ( ( a ) $whitespace$ - > $whitespace$ a . getqualifiedname ( ) . equals ( formalparamtypeqname ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( correspondingformaltype . isempty ( ) ) $whitespace$ { $newline$ $indentation$ ancestors $whitespace$ = $whitespace$ formaltypeasreference . getallancestors ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ actualparamtypeqname $whitespace$ = $whitespace$ actualtypeasreference . getqualifiedname ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ correspondingactualtype $whitespace$ = $whitespace$ ancestors . stream ( ) . filter ( a $whitespace$ - > $whitespace$ a . getqualifiedname ( ) . equals ( actualparamtypeqname ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( correspondingactualtype . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ conflictinggenerictypesexception ( formaltype , $whitespace$ actualtype ) ; $newline$ $indentation$ } $newline$ $indentation$ correspondingformaltype $whitespace$ = $whitespace$ correspondingactualtype ; $newline$ $indentation$ } $newline$ $indentation$ actualtypeasreference $whitespace$ = $whitespace$ correspondingformaltype . get ( $number$ ) . asreferencetype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( formaltypeasreference . getqualifiedname ( ) . equals ( actualtypeasreference . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! formaltypeasreference . typeparametersvalues ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualtypeasreference . israwtype ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ formaltypeparameter $whitespace$ : $whitespace$ formaltypeasreference . typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ registercorrespondance ( formaltypeparameter , $whitespace$ actualtypeasreference . typeparametersvalues ( ) . get ( i ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( formaltype $whitespace$ instanceof $whitespace$ inferencevariabletype $whitespace$ && $whitespace$ ! actualtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ formaltype ) . registerequivalenttype ( actualtype ) ; $newline$ $indentation$ if $whitespace$ ( actualtype $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ actualtype ) . registerequivalenttype ( formaltype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . isnull ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . equals ( formaltype ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . isarray ( ) $whitespace$ && $whitespace$ formaltype . isarray ( ) ) $whitespace$ { $newline$ $indentation$ registercorrespondance ( formaltype . asarraytype ( ) . getcomponenttype ( ) , $whitespace$ actualtype . asarraytype ( ) . getcomponenttype ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( formaltype . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ if $whitespace$ ( ( actualtype $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ && $whitespace$ formaltype . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ actualtype ) . registerequivalenttype ( formaltype . aswildcard ( ) . getboundedtype ( ) ) ; $newline$ $indentation$ if $whitespace$ ( formaltype . aswildcard ( ) . getboundedtype ( ) $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ formaltype . aswildcard ( ) . getboundedtype ( ) ) . registerequivalenttype ( actualtype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( actualtype . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ resolvedwildcard $whitespace$ formalwildcard $whitespace$ = $whitespace$ formaltype . aswildcard ( ) ; $newline$ $indentation$ resolvedwildcard $whitespace$ actualwildcard $whitespace$ = $whitespace$ actualtype . aswildcard ( ) ; $newline$ $indentation$ if $whitespace$ ( formalwildcard . isbounded ( ) $whitespace$ && $whitespace$ formalwildcard . getboundedtype ( ) $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formalwildcard . issuper ( ) $whitespace$ && $whitespace$ actualwildcard . issuper ( ) ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ formaltype . aswildcard ( ) . getboundedtype ( ) ) . registerequivalenttype ( actualwildcard . getboundedtype ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( formalwildcard . isextends ( ) $whitespace$ && $whitespace$ actualwildcard . isextends ( ) ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ formaltype . aswildcard ( ) . getboundedtype ( ) ) . registerequivalenttype ( actualwildcard . getboundedtype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( actualtype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formaltype . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ registercorrespondance ( formaltype . aswildcard ( ) . getboundedtype ( ) , $whitespace$ actualtype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formaltype $whitespace$ instanceof $whitespace$ resolvedreferencetype ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ actualtype ) . registerequivalenttype ( formaltype ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( formaltype $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ actualtype ) . registerequivalenttype ( formaltype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ resolvedlambdaconstrainttype $whitespace$ constrainttype $whitespace$ = $whitespace$ actualtype . asconstrainttype ( ) ; $newline$ $indentation$ if $whitespace$ ( constrainttype . getbound ( ) $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ ( ( inferencevariabletype ) $whitespace$ constrainttype . getbound ( ) ) . registerequivalenttype ( formaltype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formaltype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( actualtype . asprimitive ( ) . getboxtypeqname ( ) ) ; $newline$ $indentation$ registercorrespondance ( formaltype , $whitespace$ new $whitespace$ referencetypeimpl ( resolvedtypedeclaration ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( actualtype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formaltype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( formaltype . asprimitive ( ) . getboxtypeqname ( ) . equals ( actualtype . describe ( ) ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( formaltype . asprimitive ( ) . getboxtypeqname ( ) ) ; $newline$ $indentation$ registercorrespondance ( new $whitespace$ referencetypeimpl ( resolvedtypedeclaration ) , $whitespace$ actualtype ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( formaltype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ formaltypeasreference $whitespace$ = $whitespace$ formaltype . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( formaltypeasreference . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( formaltype . describe ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ actualtype . describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( formaltype . describe ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ actualtype . describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ registercorrespondance ( resolvedtype $whitespace$ formaltype, $whitespace$ resolvedtype $whitespace$ actualtype ) { $newline$ $indentation$ if $whitespace$ ( formaltype. isreferencetype ( ) $whitespace$ && $whitespace$ actualtype. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ matchingexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ formalparamtypeqname $whitespace$ = $whitespace$ formaltypeasreference. getallancestors ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ formalparamtypeasreference $whitespace$ = $whitespace$ingtypeasreference. getallancestors ( ) ; $newline$ $indentation$ if $whitespace$ (! formaltypeasreference. getqualifiedname ( ). equals ( actualtypeasreference. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ matchingexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ formalparamtypeqname $whitespace$ = $whitespace$ formaltypeasreference. getqualifiedname ( ) ; $newline$ $indentation$ $whitespace$//str $whitespace$ = $whitespace$ insertnewtypeasreference ( formaltypeasreference ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ formalparamtypeqname $whitespace$ = $whitespace$ formaltypeasreference. getqualifiedname ( ) ; $newline$ $indentation$ $whitespace$//filter $whitespace$ = $whitespace$ $whitespace$ new $whitespace$ arraylist < resolvedtype > ( arrays. aslist ( actualtype ) ). stream ( ), $whitespace$ ancestors. stream ( ). map ( ancestor $whitespace$ - > $whitespace$ { $newline$ $indentation$ list < resolvedtype > $whitespace$ correspondingformal			
placeInferenceVariables	191	220	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceContext.java	0.0536572188138961	LOW	"		private ResolvedType placeInferenceVariables(ResolvedType type){
		    if (type.isWildcard()) {
		        if (type.asWildcard().isExtends()) {
		            return ResolvedWildcard.extendsBound(placeInferenceVariables(type.asWildcard().getBoundedType()));
		        }
		        if (type.asWildcard().isSuper()) {
		            return ResolvedWildcard.superBound(placeInferenceVariables(type.asWildcard().getBoundedType()));
		        }
		        return type;
		    }
		    if (type.isTypeVariable()) {
		        return inferenceVariableTypeForTp(type.asTypeParameter());
		    }
		    if (type.isReferenceType()) {
		        return type.asReferenceType().transformTypeParameters(tp -> placeInferenceVariables(tp));
		    }
		    if (type.isArray()) {
		        return new ResolvedArrayType(placeInferenceVariables(type.asArrayType().getComponentType()));
		    }
		    if (type.isNull() || type.isPrimitive() || type.isVoid()) {
		        return type;
		    }
		    if (type.isConstraint()) {
		        return ResolvedLambdaConstraintType.bound(placeInferenceVariables(type.asConstraintType().getBound()));
		    }
		    if (type instanceof InferenceVariableType) {
		        return type;
		    }
		    throw new UnsupportedOperationException(type.describe());
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ placeinferencevariables ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . extendsbound ( placeinferencevariables ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . aswildcard ( ) . issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . superbound ( placeinferencevariables ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ inferencevariabletypefortp ( type . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type . asreferencetype ( ) . transformtypeparameters ( tp $whitespace$ - > $whitespace$ placeinferencevariables ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( placeinferencevariables ( type . asarraytype ( ) . getcomponenttype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isnull ( ) $whitespace$ || $whitespace$ type . isprimitive ( ) $whitespace$ || $whitespace$ type . isvoid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedlambdaconstrainttype . bound ( placeinferencevariables ( type . asconstrainttype ( ) . getbound ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . describe ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ placeinferencevariables ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type. iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type. aswildcard ( ). isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ jdtadapter. getname ( type ) $newline$ $indentation$. stream ( ) $newline$ $indentation$. map ( type : : asreferencetype ) $newline$ $indentation$. collect ( collectors. tomap ( extract $whitespace$ - > $whitespace$ placeinferencevariables ( tp ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ inferencevariabletypefortp ( type. astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( placeinferencevariables ( type. asarraytype ( ). getcomponenttype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( placeinferencevariables ( type. asarraytype ( ). getcomponenttype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isnull ( ) $whitespace$			
resolve	222	246	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceContext.java	0.1262276172637939	LOW	"		public ResolvedType resolve(ResolvedType type){
		    if (type instanceof InferenceVariableType) {
		        InferenceVariableType inferenceVariableType = (InferenceVariableType) type;
		        return inferenceVariableType.equivalentType();
		    }
		    if (type.isReferenceType()) {
		        return type.asReferenceType().transformTypeParameters(tp -> resolve(tp));
		    }
		    if (type.isNull() || type.isPrimitive() || type.isVoid()) {
		        return type;
		    }
		    if (type.isArray()) {
		        return new ResolvedArrayType(resolve(type.asArrayType().getComponentType()));
		    }
		    if (type.isWildcard()) {
		        if (type.asWildcard().isExtends()) {
		            return ResolvedWildcard.extendsBound(resolve(type.asWildcard().getBoundedType()));
		        }
		        if (type.asWildcard().isSuper()) {
		            return ResolvedWildcard.superBound(resolve(type.asWildcard().getBoundedType()));
		        }
		        return type;
		    }
		    throw new UnsupportedOperationException(type.describe());
		}"	$indentation$ public $whitespace$ resolvedtype $whitespace$ resolve ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ inferencevariabletype $whitespace$ inferencevariabletype $whitespace$ = $whitespace$ ( inferencevariabletype ) $whitespace$ type ; $newline$ $indentation$ return $whitespace$ inferencevariabletype . equivalenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type . asreferencetype ( ) . transformtypeparameters ( tp $whitespace$ - > $whitespace$ resolve ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isnull ( ) $whitespace$ || $whitespace$ type . isprimitive ( ) $whitespace$ || $whitespace$ type . isvoid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( resolve ( type . asarraytype ( ) . getcomponenttype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . extendsbound ( resolve ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . aswildcard ( ) . issuper ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . superbound ( resolve ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . describe ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedtype $whitespace$ resolve ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ inferencevariabletype ) $whitespace$ { $newline$ $indentation$ inferencevariabletype $whitespace$ inferencevariabletype $whitespace$ = $whitespace$ ( inferencevariabletype ) $whitespace$ type ; $newline$ $indentation$ return $whitespace$ inferencevariabletype. equivalenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type. asreferencetype ( ). transformtypeparameters ( tp $whitespace$ - > $whitespace$ resolve ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isnull ( ) $whitespace$ || $whitespace$ type. isprimitive ( ) $whitespace$ || $whitespace$ type. isvoid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isarray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type. aswildcard ( ). isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard. extendsbound ( resolve ( type. aswildcard ( ). getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. aswildcard ( ). issuper ( ) ) $whitespace$ {			
equivalentType	109	133	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceVariableType.java	0.0156222367659211	LOW	"		public ResolvedType equivalentType(){
		    Set<ResolvedType> concreteEquivalent = concreteEquivalentTypesAlsoIndirectly(new HashSet<>(), this);
		    if (concreteEquivalent.isEmpty()) {
		        if (correspondingTp == null) {
		            return new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());
		        }
		        return new ResolvedTypeVariable(correspondingTp);
		    }
		    if (concreteEquivalent.size() == 1) {
		        return concreteEquivalent.iterator().next();
		    }
		    Set<ResolvedType> notTypeVariables = equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !hasInferenceVariables(t)).collect(Collectors.toSet());
		    if (notTypeVariables.size() == 1) {
		        return notTypeVariables.iterator().next();
		    }
		    if (notTypeVariables.size() == 0 && !superTypes.isEmpty()) {
		        if (superTypes.size() == 1) {
		            return superTypes.iterator().next();
		        }
		        throw new IllegalStateException(""Super types are: "" + superTypes);
		    }
		    throw new IllegalStateException(""Equivalent types are: "" + equivalentTypes);
		}"	$indentation$ public $whitespace$ resolvedtype $whitespace$ equivalenttype ( ) { $newline$ $indentation$ set < resolvedtype > $whitespace$ concreteequivalent $whitespace$ = $whitespace$ concreteequivalenttypesalsoindirectly ( new $whitespace$ hashset < > ( ) , $whitespace$ this ) ; $newline$ $indentation$ if $whitespace$ ( concreteequivalent . isempty ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( correspondingtp $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( correspondingtp ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( concreteequivalent . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ concreteequivalent . iterator ( ) . next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ set < resolvedtype > $whitespace$ nottypevariables $whitespace$ = $whitespace$ equivalenttypes . stream ( ) . filter ( t $whitespace$ - > $whitespace$ ! t . istypevariable ( ) $whitespace$ && $whitespace$ ! hasinferencevariables ( t ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ if $whitespace$ ( nottypevariables . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nottypevariables . iterator ( ) . next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nottypevariables . size ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ ! supertypes . isempty ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( supertypes . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ supertypes . iterator ( ) . next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ supertypes ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ equivalenttypes ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedtype $whitespace$ equivalenttype ( ) { $newline$ $indentation$ set < resolvedtype > $whitespace$ concreteequivalent $whitespace$ = $whitespace$ concreteequivalenttypesalsoindirectly ( new $whitespace$ hashset < > ( ), $whitespace$ this ) ; $newline$ $indentation$ if $whitespace$ ( concreteequivalent. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typesolver. getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( correspondingtp ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( concreteequivalent. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ concreteequivalent. iterator ( ). next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ set < resolvedtype > $whitespace$ nottypevariables $whitespace$ = $whitespace$ equivalenttypes. stream ( ). filter ( t $whitespace$ - > $whitespace$! t. istypevariable ( ) $whitespace$ && $whitespace$! hasinferencevariables ( t ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( nottypevariables. size ( ) $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$! supertypes.			
concreteEquivalentTypesAlsoIndirectly	96	107	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceVariableType.java	0.0431931987404823	LOW	"		private Set<ResolvedType> concreteEquivalentTypesAlsoIndirectly(Set<InferenceVariableType> considered, InferenceVariableType inferenceVariableType){
		    considered.add(inferenceVariableType);
		    Set<ResolvedType> result = new HashSet<>();
		    result.addAll(inferenceVariableType.equivalentTypes.stream().filter(t -> !t.isTypeVariable() && !(t instanceof InferenceVariableType)).collect(Collectors.toSet()));
		    inferenceVariableType.equivalentTypes.stream().filter(t -> t instanceof InferenceVariableType).forEach(t -> {
		        InferenceVariableType ivt = (InferenceVariableType) t;
		        if (!considered.contains(ivt)) {
		            result.addAll(concreteEquivalentTypesAlsoIndirectly(considered, ivt));
		        }
		    });
		    return result;
		}"	$indentation$ private $whitespace$ set < resolvedtype > $whitespace$ concreteequivalenttypesalsoindirectly ( set < inferencevariabletype > $whitespace$ considered , $whitespace$ inferencevariabletype $whitespace$ inferencevariabletype ) { $newline$ $indentation$ considered . add ( inferencevariabletype ) ; $newline$ $indentation$ set < resolvedtype > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ result . addall ( inferencevariabletype . equivalenttypes . stream ( ) . filter ( t $whitespace$ - > $whitespace$ ! t . istypevariable ( ) $whitespace$ && $whitespace$ ! ( t $whitespace$ instanceof $whitespace$ inferencevariabletype ) ) . collect ( collectors . toset ( ) ) ) ; $newline$ $indentation$ inferencevariabletype . equivalenttypes . stream ( ) . filter ( t $whitespace$ - > $whitespace$ t $whitespace$ instanceof $whitespace$ inferencevariabletype ) . foreach ( t $whitespace$ - > $whitespace$ { $newline$ $indentation$ inferencevariabletype $whitespace$ ivt $whitespace$ = $whitespace$ ( inferencevariabletype ) $whitespace$ t ; $newline$ $indentation$ if $whitespace$ ( ! considered . contains ( ivt ) ) $whitespace$ { $newline$ $indentation$ result . addall ( concreteequivalenttypesalsoindirectly ( considered , $whitespace$ ivt ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ private $whitespace$ set < resolvedtype > $whitespace$ concreteequivalenttypesalsoindirectly ( set < inferencevariabletype > $whitespace$ considered, $whitespace$ inferencevariabletype $whitespace$ inferencevariabletype ) { $newline$ $indentation$ considered. add ( inferencevariabletype ) ; $newline$ $indentation$ set < resolvedtype > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ result. addall ( inferencevariabletype. equivalenttypes. stream ( ). filter ( t $whitespace$ - > $whitespace$! t. istypevariable ( ) $whitespace$ && $whitespace$! ( t $whitespace$ instanceof $whitespace$ inferencevariabletype ) ). collect ( collectors. toset ( ) ) ) ; $newline$ $indentation$ inferencevariabletype. equivalenttypes. stream ( ). filter ( t $whitespace$ - > $whitespace$ t $whitespace$ instanceof $whitespace$ inferencevariabletype ). foreach ( t $whitespace$ - > $whitespace$ { $newline$ $indentation$ inferencevariabletype $whitespace$ ivt $whitespace$ = $whitespace$ ( inferencevariabletype ) $whitespace$ t ; $newline$ $indentation$ if $whitespace$ (! considered. contains ( ivt ) ) $whitespace$ { $newline$ $indentation$ result. addall ( concreteequivalenttypesalsoindirectly ( considered, $whitespace$ ivt ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	42	47	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/InferenceVariableType.java	0.9332800507545472	HIGH	"		@Override
		public String toString(){
		    return ""InferenceVariableType{"" + ""id="" + id + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ id $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ id $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
isApplicable	79	202	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0091090071946382	LOW	"		private static boolean isApplicable(ResolvedMethodDeclaration methodDeclaration, String needleName, List<ResolvedType> needleArgumentTypes, TypeSolver typeSolver, boolean withWildcardTolerance){
		    if (!methodDeclaration.getName().equals(needleName)) {
		        return false;
		    }
		    // The index of the final method parameter (on the method declaration).
		    int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();
		    // The index of the final argument passed (on the method usage).
		    int countOfNeedleArgumentsPassed = needleArgumentTypes.size();
		    boolean methodIsDeclaredWithVariadicParameter = methodDeclaration.hasVariadicParameter();
		    if (!methodIsDeclaredWithVariadicParameter && (countOfNeedleArgumentsPassed != countOfMethodParametersDeclared)) {
		        // If it is not variadic, and the number of parameters/arguments are unequal -- this is not a match.
		        return false;
		    }
		    if (methodIsDeclaredWithVariadicParameter) {
		        if (countOfNeedleArgumentsPassed <= (countOfMethodParametersDeclared - 2)) {
		            // If it is variadic, and the number of arguments are short by **two or more** -- this is not a match.
		            // Note that omitting the variadic parameter is treated as an empty array
		            //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).
		            return false;
		        }
		        // If the method declaration we're considering has a variadic parameter,
		        // attempt to convert the given list of arguments to fit this pattern
		        // e.g. foo(String s, String... s2) {} --- consider the first argument, then group the remainder as an array
		        ResolvedType expectedVariadicParameterType = methodDeclaration.getLastParam().getType();
		        for (ResolvedTypeParameterDeclaration tp : methodDeclaration.getTypeParameters()) {
		            expectedVariadicParameterType = replaceTypeParam(expectedVariadicParameterType, tp, typeSolver);
		        }
		        if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {
		            // If it is variadic, and we have an ""excess"" of arguments, group the ""trailing"" arguments into an array.
		            // Confirm all of these grouped ""trailing"" arguments have the required type -- if not, this is not a valid type. (Maybe this is also done later..?)
		            for (int variadicArgumentIndex = countOfMethodParametersDeclared; variadicArgumentIndex < countOfNeedleArgumentsPassed; variadicArgumentIndex++) {
		                ResolvedType currentArgumentType = needleArgumentTypes.get(variadicArgumentIndex);
		                boolean argumentIsAssignableToVariadicComponentType = expectedVariadicParameterType.asArrayType().getComponentType().isAssignableBy(currentArgumentType);
		                if (!argumentIsAssignableToVariadicComponentType) {
		                    // If any of the arguments are not assignable to the expected variadic type, this is not a match.
		                    return false;
		                }
		            }
		        }
		        needleArgumentTypes = groupTrailingArgumentsIntoArray(methodDeclaration, needleArgumentTypes, expectedVariadicParameterType);
		    }
		    // The index of the final argument passed (on the method usage).
		    int countOfNeedleArgumentsPassedAfterGrouping = needleArgumentTypes.size();
		    // If variadic parameters are possible then they will have been ""grouped"" into a single argument.
		    // At this point, therefore, the number of arguments must be equal -- if they're not, then there is no match.
		    if (countOfNeedleArgumentsPassedAfterGrouping != countOfMethodParametersDeclared) {
		        return false;
		    }
		    Map<String, ResolvedType> matchedParameters = new HashMap<>();
		    boolean needForWildCardTolerance = false;
		    for (int i = 0; i < countOfMethodParametersDeclared; i++) {
		        ResolvedType expectedDeclaredType = methodDeclaration.getParam(i).getType();
		        ResolvedType actualArgumentType = needleArgumentTypes.get(i);
		        if ((expectedDeclaredType.isTypeVariable() && !(expectedDeclaredType.isWildcard())) && expectedDeclaredType.asTypeParameter().declaredOnMethod()) {
		            matchedParameters.put(expectedDeclaredType.asTypeParameter().getName(), actualArgumentType);
		            continue;
		        }
		        // if this is a variable arity method and we are trying to evaluate the last parameter
		        // then we consider that an array of objects can be assigned by any array
		        // for example:
		        // The method call expression String.format(""%d"", new int[] {1})
		        // must refer to the method String.format(String, Object...)
		        // even if an array of primitive type cannot be assigned to an array of Object
		        if (methodDeclaration.getParam(i).isVariadic() && (i == countOfMethodParametersDeclared - 1) && isArrayOfObject(expectedDeclaredType) && actualArgumentType.isArray()) {
		            continue;
		        }
		        boolean isAssignableWithoutSubstitution = expectedDeclaredType.isAssignableBy(actualArgumentType) || (methodDeclaration.getParam(i).isVariadic() && convertToVariadicParameter(expectedDeclaredType).isAssignableBy(actualArgumentType));
		        if (!isAssignableWithoutSubstitution && expectedDeclaredType.isReferenceType() && actualArgumentType.isReferenceType()) {
		            isAssignableWithoutSubstitution = isAssignableMatchTypeParameters(expectedDeclaredType.asReferenceType(), actualArgumentType.asReferenceType(), matchedParameters);
		        }
		        if (!isAssignableWithoutSubstitution) {
		            List<ResolvedTypeParameterDeclaration> typeParameters = methodDeclaration.getTypeParameters();
		            typeParameters.addAll(methodDeclaration.declaringType().getTypeParameters());
		            for (ResolvedTypeParameterDeclaration tp : typeParameters) {
		                expectedDeclaredType = replaceTypeParam(expectedDeclaredType, tp, typeSolver);
		            }
		            if (!expectedDeclaredType.isAssignableBy(actualArgumentType)) {
		                if (actualArgumentType.isWildcard() && withWildcardTolerance && !expectedDeclaredType.isPrimitive()) {
		                    needForWildCardTolerance = true;
		                    continue;
		                }
		                // if the expected is java.lang.Math.max(double,double) and the type parameters are defined with constrain
		                // for example LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=T}}}, LambdaConstraintType{bound=TypeVariable {ReflectionTypeParameter{typeVariable=U}}}
		                // we want to keep this method for future resolution
		                if (actualArgumentType.isConstraint() && withWildcardTolerance && expectedDeclaredType.isPrimitive()) {
		                    needForWildCardTolerance = true;
		                    continue;
		                }
		                if (methodIsDeclaredWithVariadicParameter && i == countOfMethodParametersDeclared - 1) {
		                    if (convertToVariadicParameter(expectedDeclaredType).isAssignableBy(actualArgumentType)) {
		                        continue;
		                    }
		                }
		                return false;
		            }
		        }
		    }
		    return !withWildcardTolerance || needForWildCardTolerance;
		}"	"$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isapplicable ( resolvedmethoddeclaration $whitespace$ methoddeclaration , $whitespace$ string $whitespace$ needlename , $whitespace$ list < resolvedtype > $whitespace$ needleargumenttypes , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ boolean $whitespace$ withwildcardtolerance ) { $newline$ $indentation$ if $whitespace$ ( ! methoddeclaration . getname ( ) . equals ( needlename ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·index·of·the·final·method·parameter·(on·the·method·declaration).$ $newline$ $indentation$ int $whitespace$ countofmethodparametersdeclared $whitespace$ = $whitespace$ methoddeclaration . getnumberofparams ( ) ; $newline$ $indentation$ $//·the·index·of·the·final·argument·passed·(on·the·method·usage).$ $newline$ $indentation$ int $whitespace$ countofneedleargumentspassed $whitespace$ = $whitespace$ needleargumenttypes . size ( ) ; $newline$ $indentation$ boolean $whitespace$ methodisdeclaredwithvariadicparameter $whitespace$ = $whitespace$ methoddeclaration . hasvariadicparameter ( ) ; $newline$ $indentation$ if $whitespace$ ( ! methodisdeclaredwithvariadicparameter $whitespace$ && $whitespace$ ( countofneedleargumentspassed $whitespace$ != $whitespace$ countofmethodparametersdeclared ) ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·not·variadic,·and·the·number·of·parameters/arguments·are·unequal·--·this·is·not·a·match.$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( methodisdeclaredwithvariadicparameter ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( countofneedleargumentspassed $whitespace$ <= $whitespace$ ( countofmethodparametersdeclared $whitespace$ - $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·variadic,·and·the·number·of·arguments·are·short·by·**two·or·more**·--·this·is·not·a·match.$ $newline$ $indentation$ $//·note·that·omitting·the·variadic·parameter·is·treated·as·an·empty·array$ $newline$ $indentation$ $//··(thus·being·short·of·only·1·argument·is·fine,·but·being·short·of·2·or·more·is·not).$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·the·method·declaration·we're·considering·has·a·variadic·parameter,$ $newline$ $indentation$ $//·attempt·to·convert·the·given·list·of·arguments·to·fit·this·pattern$ $newline$ $indentation$ $//·e.g.·foo(string·s,·string...·s2)·{}·---·consider·the·first·argument,·then·group·the·remainder·as·an·array$ $newline$ $indentation$ resolvedtype $whitespace$ expectedvariadicparametertype $whitespace$ = $whitespace$ methoddeclaration . getlastparam ( ) . gettype ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ methoddeclaration . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedvariadicparametertype $whitespace$ = $whitespace$ replacetypeparam ( expectedvariadicparametertype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( countofneedleargumentspassed $whitespace$ > $whitespace$ countofmethodparametersdeclared ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·variadic,·and·we·have·an·""excess""·of·arguments,·group·the·""trailing""·arguments·into·an·array.$ $newline$ $indentation$ $//·confirm·all·of·these·grouped·""trailing""·arguments·have·the·required·type·--·if·not,·this·is·not·a·valid·type.·(maybe·this·is·also·done·later..?)$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ variadicargumentindex $whitespace$ = $whitespace$ countofmethodparametersdeclared ; $whitespace$ variadicargumentindex $whitespace$ < $whitespace$ countofneedleargumentspassed ; $whitespace$ variadicargumentindex ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ currentargumenttype $whitespace$ = $whitespace$ needleargumenttypes . get ( variadicargumentindex ) ; $newline$ $indentation$ boolean $whitespace$ argumentisassignabletovariadiccomponenttype $whitespace$ = $whitespace$ expectedvariadicparametertype . asarraytype ( ) . getcomponenttype ( ) . isassignableby ( currentargumenttype ) ; $newline$ $indentation$ if $whitespace$ ( ! argumentisassignabletovariadiccomponenttype ) $whitespace$ { $newline$ $indentation$ $//·if·any·of·the·arguments·are·not·assignable·to·the·expected·variadic·type,·this·is·not·a·match.$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ needleargumenttypes $whitespace$ = $whitespace$ grouptrailingargumentsintoarray ( methoddeclaration , $whitespace$ needleargumenttypes , $whitespace$ expectedvariadicparametertype ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·index·of·the·final·argument·passed·(on·the·method·usage).$ $newline$ $indentation$ int $whitespace$ countofneedleargumentspassedaftergrouping $whitespace$ = $whitespace$ needleargumenttypes . size ( ) ; $newline$ $indentation$ $//·if·variadic·parameters·are·possible·then·they·will·have·been·""grouped""·into·a·single·argument.$ $newline$ $indentation$ $//·at·this·point,·therefore,·the·number·of·arguments·must·be·equal·--·if·they're·not,·then·there·is·no·match.$ $newline$ $indentation$ if $whitespace$ ( countofneedleargumentspassedaftergrouping $whitespace$ != $whitespace$ countofmethodparametersdeclared ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ map < string , $whitespace$ resolvedtype > $whitespace$ matchedparameters $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ boolean $whitespace$ needforwildcardtolerance $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ countofmethodparametersdeclared ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ expecteddeclaredtype $whitespace$ = $whitespace$ methoddeclaration . getparam ( i ) . gettype ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualargumenttype $whitespace$ = $whitespace$ needleargumenttypes . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ( expecteddeclaredtype . istypevariable ( ) $whitespace$ && $whitespace$ ! ( expecteddeclaredtype . iswildcard ( ) ) ) $whitespace$ && $whitespace$ expecteddeclaredtype . astypeparameter ( ) . declaredonmethod ( ) ) $whitespace$ { $newline$ $indentation$ matchedparameters . put ( expecteddeclaredtype . astypeparameter ( ) . getname ( ) , $whitespace$ actualargumenttype ) ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·this·is·a·variable·arity·method·and·we·are·trying·to·evaluate·the·last·parameter$ $newline$ $indentation$ $//·then·we·consider·that·an·array·of·objects·can·be·assigned·by·any·array$ $newline$ $indentation$ $//·for·example:$ $newline$ $indentation$ $//·the·method·call·expression·string.format(""%d"",·new·int[]·{1})$ $newline$ $indentation$ $//·must·refer·to·the·method·string.format(string,·object...)$ $newline$ $indentation$ $//·even·if·an·array·of·primitive·type·cannot·be·assigned·to·an·array·of·object$ $newline$ $indentation$ if $whitespace$ ( methoddeclaration . getparam ( i ) . isvariadic ( ) $whitespace$ && $whitespace$ ( i $whitespace$ == $whitespace$ countofmethodparametersdeclared $whitespace$ - $whitespace$ $number$ ) $whitespace$ && $whitespace$ isarrayofobject ( expecteddeclaredtype ) $whitespace$ && $whitespace$ actualargumenttype . isarray ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ isassignablewithoutsubstitution $whitespace$ = $whitespace$ expecteddeclaredtype . isassignableby ( actualargumenttype ) $whitespace$ || $whitespace$ ( methoddeclaration . getparam ( i ) . isvariadic ( ) $whitespace$ && $whitespace$ converttovariadicparameter ( expecteddeclaredtype ) . isassignableby ( actualargumenttype ) ) ; $newline$ $indentation$ if $whitespace$ ( ! isassignablewithoutsubstitution $whitespace$ && $whitespace$ expecteddeclaredtype . isreferencetype ( ) $whitespace$ && $whitespace$ actualargumenttype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ isassignablewithoutsubstitution $whitespace$ = $whitespace$ isassignablematchtypeparameters ( expecteddeclaredtype . asreferencetype ( ) , $whitespace$ actualargumenttype . asreferencetype ( ) , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! isassignablewithoutsubstitution ) $whitespace$ { $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typeparameters $whitespace$ = $whitespace$ methoddeclaration . gettypeparameters ( ) ; $newline$ $indentation$ typeparameters . addall ( methoddeclaration . declaringtype ( ) . gettypeparameters ( ) ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparameters ) $whitespace$ { $newline$ $indentation$ expecteddeclaredtype $whitespace$ = $whitespace$ replacetypeparam ( expecteddeclaredtype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expecteddeclaredtype . isassignableby ( actualargumenttype ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualargumenttype . iswildcard ( ) $whitespace$ && $whitespace$ withwildcardtolerance $whitespace$ && $whitespace$ ! expecteddeclaredtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ needforwildcardtolerance $whitespace$ = $whitespace$ true ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·the·expected·is·java.lang.math.max(double,double)·and·the·type·parameters·are·defined·with·constrain$ $newline$ $indentation$ $//·for·example·lambdaconstrainttype{bound=typevariable·{reflectiontypeparameter{typevariable=t}}},·lambdaconstrainttype{bound=typevariable·{reflectiontypeparameter{typevariable=u}}}$ $newline$ $indentation$ $//·we·want·to·keep·this·method·for·future·resolution$ $newline$ $indentation$ if $whitespace$ ( actualargumenttype . isconstraint ( ) $whitespace$ && $whitespace$ withwildcardtolerance $whitespace$ && $whitespace$ expecteddeclaredtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ needforwildcardtolerance $whitespace$ = $whitespace$ true ; $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( methodisdeclaredwithvariadicparameter $whitespace$ && $whitespace$ i $whitespace$ == $whitespace$ countofmethodparametersdeclared $whitespace$ - $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( converttovariadicparameter ( expecteddeclaredtype ) . isassignableby ( actualargumenttype ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ! withwildcardtolerance $whitespace$ || $whitespace$ needforwildcardtolerance ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isapplicable ( resolvedmethoddeclaration $whitespace$ methoddeclaration, $whitespace$ string $whitespace$ needlename, $whitespace$ list < resolvedtype > $whitespace$ needleargumenttypes, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ boolean $whitespace$ withwildcardtolerance ) { $newline$ $indentation$ if $whitespace$ (! methoddeclaration. getname ( ). equals ( needlename ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ method $whitespace$ for $whitespace$ the $whitespace$ current $whitespace$ method $whitespace$ is $whitespace$ set $whitespace$ and $whitespace$ $whitespace$ $newline$ $indentation$ $////// $newline$ $indentation$ if $whitespace$ (! methodisdeclaredwithvariadicparameter $whitespace$ = $whitespace$ methoddeclaration. hasvariadicparameter ( ) ; $newline$ $indentation$ if $whitespace$ (! methodisdeclaredwithvariadicparameter $whitespace$ && $whitespace$ ( countofneedleargumentspassed $whitespace$!= $whitespace$ countofmethodparametersdeclared ) ) $whitespace$ { $newline$ $indentation$ $whitespace$//////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ return $whitespace$ false ; $newline$ $			
findMostApplicableUsage	827	855	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0293007977306842	LOW	"		public static Optional<MethodUsage> findMostApplicableUsage(List<MethodUsage> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver){
		    List<MethodUsage> applicableMethods = methods.stream().filter((m) -> isApplicable(m, name, argumentsTypes, typeSolver)).collect(Collectors.toList());
		    if (applicableMethods.isEmpty()) {
		        return Optional.empty();
		    }
		    if (applicableMethods.size() == 1) {
		        return Optional.of(applicableMethods.get(0));
		    }
		    MethodUsage winningCandidate = applicableMethods.get(0);
		    for (int i = 1; i < applicableMethods.size(); i++) {
		        MethodUsage other = applicableMethods.get(i);
		        if (isMoreSpecific(winningCandidate, other)) {
		            // nothing to do
		        } else if (isMoreSpecific(other, winningCandidate)) {
		            winningCandidate = other;
		        } else {
		            if (winningCandidate.declaringType().getQualifiedName().equals(other.declaringType().getQualifiedName())) {
		                if (!areOverride(winningCandidate, other)) {
		                    throw new MethodAmbiguityException(""Ambiguous method call: cannot find a most applicable method: "" + winningCandidate + "", "" + other + "". First declared in "" + winningCandidate.declaringType().getQualifiedName());
		                }
		            } else {
		                // we expect the methods to be ordered such that inherited methods are later in the list
		                //throw new UnsupportedOperationException();
		            }
		        }
		    }
		    return Optional.of(winningCandidate);
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ findmostapplicableusage ( list < methodusage > $whitespace$ methods , $whitespace$ string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ list < methodusage > $whitespace$ applicablemethods $whitespace$ = $whitespace$ methods . stream ( ) . filter ( ( m ) $whitespace$ - > $whitespace$ isapplicable ( m , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( applicablemethods . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( applicablemethods . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( applicablemethods . get ( $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ winningcandidate $whitespace$ = $whitespace$ applicablemethods . get ( $number$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ applicablemethods . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ other $whitespace$ = $whitespace$ applicablemethods . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ismorespecific ( winningcandidate , $whitespace$ other ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ismorespecific ( other , $whitespace$ winningcandidate ) ) $whitespace$ { $newline$ $indentation$ winningcandidate $whitespace$ = $whitespace$ other ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( winningcandidate . declaringtype ( ) . getqualifiedname ( ) . equals ( other . declaringtype ( ) . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! areoverride ( winningcandidate , $whitespace$ other ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ methodambiguityexception ( $string$ $whitespace$ + $whitespace$ winningcandidate $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ other $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ winningcandidate . declaringtype ( ) . getqualifiedname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·we·expect·the·methods·to·be·ordered·such·that·inherited·methods·are·later·in·the·list$ $newline$ $indentation$ $//throw·new·unsupportedoperationexception();$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( winningcandidate ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ findmostapplicableusage ( list < methodusage > $whitespace$ methods, $whitespace$ string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ list < methodusage > $whitespace$ applicablemethods $whitespace$ = $whitespace$ methods. stream ( ). filter ( ( m ) $whitespace$ - > $whitespace$ isapplicable ( m, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( applicablemethods. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( applicablemethods. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( applicablemethods. get ( $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ winningcandidate $whitespace$ = $whitespace$ applicablemethods. get ( $number$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ applicablemethods. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ other $whitespace$ = $whitespace$ applicablemethods. get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ismorespecific ( winningcandidate, $whitespace$ other ) ) $whitespace$ { $newline$ $indentation$ $//trimtrimnothing ( ) ; $newline$ $indentation$			
isAssignableMatchTypeParametersMatchingQName	296	360	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.032127596437931	LOW	"		private static boolean isAssignableMatchTypeParametersMatchingQName(ResolvedReferenceType expected, ResolvedReferenceType actual, Map<String, ResolvedType> matchedParameters){
		    if (!expected.getQualifiedName().equals(actual.getQualifiedName())) {
		        return false;
		    }
		    if (expected.typeParametersValues().size() != actual.typeParametersValues().size()) {
		        throw new UnsupportedOperationException();
		        //return true;
		    }
		    for (int i = 0; i < expected.typeParametersValues().size(); i++) {
		        ResolvedType expectedParam = expected.typeParametersValues().get(i);
		        ResolvedType actualParam = actual.typeParametersValues().get(i);
		        // In the case of nested parameterizations eg. List<R> <-> List<Integer>
		        // we should peel off one layer and ensure R <-> Integer
		        if (expectedParam.isReferenceType() && actualParam.isReferenceType()) {
		            ResolvedReferenceType r1 = expectedParam.asReferenceType();
		            ResolvedReferenceType r2 = actualParam.asReferenceType();
		            // we can have r1=A and r2=A.B (with B extends A and B is an inner class of A)
		            // in this case we want to verify expected parameter from the actual parameter ancestors
		            return isAssignableMatchTypeParameters(r1, r2, matchedParameters);
		        }
		        if (expectedParam.isArray() && actualParam.isArray()) {
		            ResolvedType r1 = expectedParam.asArrayType().getComponentType();
		            ResolvedType r2 = actualParam.asArrayType().getComponentType();
		            // try to verify the component type of each array
		            return isAssignableMatchTypeParameters(r1, r2, matchedParameters);
		        }
		        if (expectedParam.isTypeVariable()) {
		            String expectedParamName = expectedParam.asTypeParameter().getName();
		            if (!actualParam.isTypeVariable() || !actualParam.asTypeParameter().getName().equals(expectedParamName)) {
		                return matchTypeVariable(expectedParam.asTypeVariable(), actualParam, matchedParameters);
		            }
		            // actualParam is a TypeVariable and actualParam has the same name as expectedParamName
		            // We should definitely consider that types are assignable
		            return true;
		        } else if (expectedParam.isReferenceType()) {
		            if (actualParam.isTypeVariable()) {
		                return matchTypeVariable(actualParam.asTypeVariable(), expectedParam, matchedParameters);
		            }
		            if (!expectedParam.equals(actualParam)) {
		                return false;
		            }
		        }
		        if (expectedParam.isWildcard()) {
		            if (expectedParam.asWildcard().isExtends()) {
		                // trying to compare with unbounded wildcard type parameter <?>
		                if (actualParam.isWildcard() && !actualParam.asWildcard().isBounded()) {
		                    return true;
		                }
		                if (actualParam.isTypeVariable()) {
		                    return matchTypeVariable(actualParam.asTypeVariable(), expectedParam.asWildcard().getBoundedType(), matchedParameters);
		                }
		                return isAssignableMatchTypeParameters(expectedParam.asWildcard().getBoundedType(), actualParam, matchedParameters);
		            }
		            // TODO verify super bound
		            return true;
		        }
		        throw new UnsupportedOperationException(expectedParam.describe());
		    }
		    return true;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isassignablematchtypeparametersmatchingqname ( resolvedreferencetype $whitespace$ expected , $whitespace$ resolvedreferencetype $whitespace$ actual , $whitespace$ map < string , $whitespace$ resolvedtype > $whitespace$ matchedparameters ) { $newline$ $indentation$ if $whitespace$ ( ! expected . getqualifiedname ( ) . equals ( actual . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected . typeparametersvalues ( ) . size ( ) $whitespace$ != $whitespace$ actual . typeparametersvalues ( ) . size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ $//return·true;$ $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ expected . typeparametersvalues ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ expectedparam $whitespace$ = $whitespace$ expected . typeparametersvalues ( ) . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualparam $whitespace$ = $whitespace$ actual . typeparametersvalues ( ) . get ( i ) ; $newline$ $indentation$ $//·in·the·case·of·nested·parameterizations·eg.·list<r>·<->·list<integer>$ $newline$ $indentation$ $//·we·should·peel·off·one·layer·and·ensure·r·<->·integer$ $newline$ $indentation$ if $whitespace$ ( expectedparam . isreferencetype ( ) $whitespace$ && $whitespace$ actualparam . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ r1 $whitespace$ = $whitespace$ expectedparam . asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ r2 $whitespace$ = $whitespace$ actualparam . asreferencetype ( ) ; $newline$ $indentation$ $//·we·can·have·r1=a·and·r2=a.b·(with·b·extends·a·and·b·is·an·inner·class·of·a)$ $newline$ $indentation$ $//·in·this·case·we·want·to·verify·expected·parameter·from·the·actual·parameter·ancestors$ $newline$ $indentation$ return $whitespace$ isassignablematchtypeparameters ( r1 , $whitespace$ r2 , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expectedparam . isarray ( ) $whitespace$ && $whitespace$ actualparam . isarray ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ r1 $whitespace$ = $whitespace$ expectedparam . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ r2 $whitespace$ = $whitespace$ actualparam . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ $//·try·to·verify·the·component·type·of·each·array$ $newline$ $indentation$ return $whitespace$ isassignablematchtypeparameters ( r1 , $whitespace$ r2 , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expectedparam . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ expectedparamname $whitespace$ = $whitespace$ expectedparam . astypeparameter ( ) . getname ( ) ; $newline$ $indentation$ if $whitespace$ ( ! actualparam . istypevariable ( ) $whitespace$ || $whitespace$ ! actualparam . astypeparameter ( ) . getname ( ) . equals ( expectedparamname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ matchtypevariable ( expectedparam . astypevariable ( ) , $whitespace$ actualparam , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·actualparam·is·a·typevariable·and·actualparam·has·the·same·name·as·expectedparamname$ $newline$ $indentation$ $//·we·should·definitely·consider·that·types·are·assignable$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( expectedparam . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualparam . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ matchtypevariable ( actualparam . astypevariable ( ) , $whitespace$ expectedparam , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expectedparam . equals ( actualparam ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expectedparam . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expectedparam . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ $//·trying·to·compare·with·unbounded·wildcard·type·parameter·<?>$ $newline$ $indentation$ if $whitespace$ ( actualparam . iswildcard ( ) $whitespace$ && $whitespace$ ! actualparam . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( actualparam . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ matchtypevariable ( actualparam . astypevariable ( ) , $whitespace$ expectedparam . aswildcard ( ) . getboundedtype ( ) , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ isassignablematchtypeparameters ( expectedparam . aswildcard ( ) . getboundedtype ( ) , $whitespace$ actualparam , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo·verify·super·bound$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( expectedparam . describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isassignablematchtypeparametersmatchingqname ( resolvedreferencetype $whitespace$ expected, $whitespace$ resolvedreferencetype $whitespace$ actual, $whitespace$ map < string, $whitespace$ resolvedtype > $whitespace$ matchedparameters ) { $newline$ $indentation$ if $whitespace$ (! expected. getqualifiedname ( ). equals ( actual. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected. typeparametersvalues ( ). size ( ) $whitespace$!= $whitespace$ actual. typeparametersvalues ( ). size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ expected. typeparametersvalues ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ expectedparam $whitespace$ = $whitespace$ expected. typeparametersvalues ( ). get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualparam $whitespace$ = $whitespace$ actual. typeparametersvalues ( ). get ( i ) ; $newline$ $indentation$ $indentation$ $whitespace$//printprinteration $whitespace$ = $whitespace$ $whitespace$ get$x ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualparam $whitespace$ = $whitespace$ actual. typeparametersvalues ( ). get ( i ) ; $newline$ $indentation$ $whitespace$//trim $whitespace$ other $whitespace$ = $whitespace$ getcontroller ( actual, $whitespace$ target ) ; $newline$ $indentation$ return $whitespace$ boolean. isreferencetype ( ) $whitespace$			
inferTypes	891	943	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0452893525362014	LOW	"		private static void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings){
		    if (source.equals(target)) {
		        return;
		    }
		    if (source.isReferenceType() && target.isReferenceType()) {
		        ResolvedReferenceType sourceRefType = source.asReferenceType();
		        ResolvedReferenceType targetRefType = target.asReferenceType();
		        if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {
		            if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {
		                for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {
		                    inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);
		                }
		            }
		        }
		        return;
		    }
		    if (source.isReferenceType() && target.isWildcard()) {
		        if (target.asWildcard().isBounded()) {
		            inferTypes(source, target.asWildcard().getBoundedType(), mappings);
		            return;
		        }
		        return;
		    }
		    if (source.isWildcard() && target.isWildcard()) {
		        return;
		    }
		    if (source.isReferenceType() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isWildcard() && target.isReferenceType()) {
		        if (source.asWildcard().isBounded()) {
		            inferTypes(source.asWildcard().getBoundedType(), target, mappings);
		        }
		        return;
		    }
		    if (source.isWildcard() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isTypeVariable() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isPrimitive() || target.isPrimitive()) {
		        return;
		    }
		    if (source.isNull()) {
		        return;
		    }
		}"	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ infertypes ( resolvedtype $whitespace$ source , $whitespace$ resolvedtype $whitespace$ target , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ mappings ) { $newline$ $indentation$ if $whitespace$ ( source . equals ( target ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ sourcereftype $whitespace$ = $whitespace$ source . asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ targetreftype $whitespace$ = $whitespace$ target . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( sourcereftype . getqualifiedname ( ) . equals ( targetreftype . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! sourcereftype . israwtype ( ) $whitespace$ && $whitespace$ ! targetreftype . israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ sourcereftype . typeparametersvalues ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ infertypes ( sourcereftype . typeparametersvalues ( ) . get ( i ) , $whitespace$ targetreftype . typeparametersvalues ( ) . get ( i ) , $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( target . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source , $whitespace$ target . aswildcard ( ) . getboundedtype ( ) , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( source . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source . aswildcard ( ) . getboundedtype ( ) , $whitespace$ target , $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . istypevariable ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isprimitive ( ) $whitespace$ || $whitespace$ target . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isnull ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ infertypes ( resolvedtype $whitespace$ source, $whitespace$ resolvedtype $whitespace$ target, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ mappings ) { $newline$ $indentation$ if $whitespace$ ( source. equals ( target ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source. isreferencetype ( ) $whitespace$ && $whitespace$ target. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ sourcereftype $whitespace$ = $whitespace$ source. asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ targetreftype $whitespace$ = $whitespace$ target. asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( sourcereftype. getqualifiedname ( ). equals ( targetreftype. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! sourcereftype. israwtype ( ) $whitespace$ && $whitespace$! targetreftype. israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ sourcereftype. typeparametersvalues ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ infertypes ( sourcereftype. typeparametersvalues ( ). get ( i ), $whitespace$ targetreftype. typeparametersvalues ( ). get ( i ), $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source. isreference			
findMostApplicable	561	568	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0492113940417766	LOW	"		public static SymbolReference<ResolvedMethodDeclaration> findMostApplicable(List<ResolvedMethodDeclaration> methods, String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver){
		    SymbolReference<ResolvedMethodDeclaration> res = findMostApplicable(methods, name, argumentsTypes, typeSolver, false);
		    if (res.isSolved()) {
		        return res;
		    }
		    return findMostApplicable(methods, name, argumentsTypes, typeSolver, true);
		}"	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ findmostapplicable ( list < resolvedmethoddeclaration > $whitespace$ methods , $whitespace$ string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ findmostapplicable ( methods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ findmostapplicable ( methods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ true ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ findmostapplicable ( list < resolvedmethoddeclaration > $whitespace$ methods, $whitespace$ string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ findmostapplicable ( methods, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ false ) ; $newline$ $indentation$ return $whitespace$ findmostapplicable ( methods, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ true ) ; $newline$ $indentation$ }			
replaceTypeParam	381	407	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0516812205314636	LOW	"		public static ResolvedType replaceTypeParam(ResolvedType type, ResolvedTypeParameterDeclaration tp, TypeSolver typeSolver){
		    if (type.isTypeVariable() || type.isWildcard()) {
		        if (type.describe().equals(tp.getName())) {
		            List<ResolvedTypeParameterDeclaration.Bound> bounds = tp.getBounds();
		            if (bounds.size() > 1) {
		                throw new UnsupportedOperationException();
		            }
		            if (bounds.size() == 1) {
		                return bounds.get(0).getType();
		            }
		            return new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_OBJECT));
		        }
		        return type;
		    }
		    if (type.isPrimitive()) {
		        return type;
		    }
		    if (type.isArray()) {
		        return new ResolvedArrayType(replaceTypeParam(type.asArrayType().getComponentType(), tp, typeSolver));
		    }
		    if (type.isReferenceType()) {
		        ResolvedReferenceType result = type.asReferenceType();
		        result = result.transformTypeParameters(typeParam -> replaceTypeParam(typeParam, tp, typeSolver)).asReferenceType();
		        return result;
		    }
		    throw new UnsupportedOperationException(""Replacing "" + type + "", param "" + tp + "" with "" + type.getClass().getCanonicalName());
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ replacetypeparam ( resolvedtype $whitespace$ type , $whitespace$ resolvedtypeparameterdeclaration $whitespace$ tp , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( type . istypevariable ( ) $whitespace$ || $whitespace$ type . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type . describe ( ) . equals ( tp . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ list < resolvedtypeparameterdeclaration . bound > $whitespace$ bounds $whitespace$ = $whitespace$ tp . getbounds ( ) ; $newline$ $indentation$ if $whitespace$ ( bounds . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( bounds . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ bounds . get ( $number$ ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . solvetype ( java_lang_object ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( replacetypeparam ( type . asarraytype ( ) . getcomponenttype ( ) , $whitespace$ tp , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ result $whitespace$ = $whitespace$ type . asreferencetype ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ result . transformtypeparameters ( typeparam $whitespace$ - > $whitespace$ replacetypeparam ( typeparam , $whitespace$ tp , $whitespace$ typesolver ) ) . asreferencetype ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ tp $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ replacetypeparam ( resolvedtype $whitespace$ type, $whitespace$ resolvedtypeparameterdeclaration $whitespace$ tp, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( type. istypevariable ( ) $whitespace$ || $whitespace$ type. iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. describe ( ). equals ( tp. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ list < resolvedtypeparameterdeclaration. bound > $whitespace$ bounds $whitespace$ = $whitespace$ tp. getbounds ( ) ; $newline$ $indentation$ if $whitespace$ ( bounds. size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( bounds. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ bounds. get ( $number$ ). gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typesolver. solvetype ( java_lang_object ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( replacetypeparam ( type. asarraytype ( ). get			
solveMethodInType	872	876	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0652260035276413	LOW	"		public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration, String name, List<ResolvedType> argumentsTypes){
		    return solveMethodInType(typeDeclaration, name, argumentsTypes, false);
		}"	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethodintype ( resolvedtypedeclaration $whitespace$ typedeclaration , $whitespace$ string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ return $whitespace$ solvemethodintype ( typedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethodintype ( resolvedtypedeclaration $whitespace$ typedeclaration, $whitespace$ string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ return $whitespace$ solvemethodintype ( typedeclaration, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
isAssignableMatchTypeParameters	261	279	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.0987310260534286	LOW	"		public static boolean isAssignableMatchTypeParameters(ResolvedType expected, ResolvedType actual, Map<String, ResolvedType> matchedParameters){
		    if (expected.isReferenceType() && actual.isReferenceType()) {
		        return isAssignableMatchTypeParameters(expected.asReferenceType(), actual.asReferenceType(), matchedParameters);
		    }
		    if (expected.isReferenceType() && ResolvedPrimitiveType.isBoxType(expected) && actual.isPrimitive()) {
		        ResolvedPrimitiveType expectedType = ResolvedPrimitiveType.byBoxTypeQName(expected.asReferenceType().getQualifiedName()).get().asPrimitive();
		        return expected.isAssignableBy(actual);
		    }
		    if (expected.isTypeVariable()) {
		        matchedParameters.put(expected.asTypeParameter().getName(), actual);
		        return true;
		    }
		    if (expected.isArray()) {
		        matchedParameters.put(expected.asArrayType().getComponentType().toString(), actual);
		        return true;
		    }
		    throw new UnsupportedOperationException(expected.getClass().getCanonicalName() + "" "" + actual.getClass().getCanonicalName());
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isassignablematchtypeparameters ( resolvedtype $whitespace$ expected , $whitespace$ resolvedtype $whitespace$ actual , $whitespace$ map < string , $whitespace$ resolvedtype > $whitespace$ matchedparameters ) { $newline$ $indentation$ if $whitespace$ ( expected . isreferencetype ( ) $whitespace$ && $whitespace$ actual . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isassignablematchtypeparameters ( expected . asreferencetype ( ) , $whitespace$ actual . asreferencetype ( ) , $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected . isreferencetype ( ) $whitespace$ && $whitespace$ resolvedprimitivetype . isboxtype ( expected ) $whitespace$ && $whitespace$ actual . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ resolvedprimitivetype $whitespace$ expectedtype $whitespace$ = $whitespace$ resolvedprimitivetype . byboxtypeqname ( expected . asreferencetype ( ) . getqualifiedname ( ) ) . get ( ) . asprimitive ( ) ; $newline$ $indentation$ return $whitespace$ expected . isassignableby ( actual ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ matchedparameters . put ( expected . astypeparameter ( ) . getname ( ) , $whitespace$ actual ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected . isarray ( ) ) $whitespace$ { $newline$ $indentation$ matchedparameters . put ( expected . asarraytype ( ) . getcomponenttype ( ) . tostring ( ) , $whitespace$ actual ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( expected . getclass ( ) . getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ actual . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isassignablematchtypeparameters ( resolvedtype $whitespace$ expected, $whitespace$ resolvedtype $whitespace$ actual, $whitespace$ map < string, $whitespace$ resolvedtype > $whitespace$ matchedparameters ) { $newline$ $indentation$ if $whitespace$ ( expected. isreferencetype ( ) $whitespace$ && $whitespace$ actual. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isassignablematchtypeparameters ( expected, $whitespace$ actual. asreferencetype ( ), $whitespace$ matchedparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected. isreferencetype ( ) $whitespace$ && $whitespace$ resolvedprimitivetype. isboxtype ( expected ) $whitespace$ && $whitespace$ actual. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ resolvedprimitivetype $whitespace$ expectedtype $whitespace$ = $whitespace$ resolvedprimitivetype. byboxtypeqname ( expected. asreferencetype ( ). getqualifiedname ( ) ). get ( ). asprimitive ( ) ; $newline$ $indentation$ return $whitespace$ expected. isassignableby ( actual ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expected. istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ matchedparameters. put ( expected. astypeparameter ( ). getname ( ), $whitespace$ actual ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ expectedtype $whitespace$ = $whitespace$ resolvedprimitivetype. byboxtypeqname ( expected. asreferencetype ( ). getqualifiedname ( ) ). get ( ) ; $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$			
groupTrailingArgumentsIntoArray	221	259	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.1589307785034179	LOW	"		private static List<ResolvedType> groupTrailingArgumentsIntoArray(ResolvedMethodDeclaration methodDeclaration, List<ResolvedType> needleArgumentTypes, ResolvedType expectedVariadicParameterType){
		    // The index of the final method parameter (on the method declaration).
		    int countOfMethodParametersDeclared = methodDeclaration.getNumberOfParams();
		    int lastMethodParameterIndex = getLastParameterIndex(countOfMethodParametersDeclared);
		    // The index of the final argument passed (on the method usage).
		    int countOfNeedleArgumentsPassed = needleArgumentTypes.size();
		    int lastNeedleArgumentIndex = getLastParameterIndex(countOfNeedleArgumentsPassed);
		    if (countOfNeedleArgumentsPassed > countOfMethodParametersDeclared) {
		        // If it is variadic, and we have an ""excess"" of arguments, group the ""trailing"" arguments into an array.
		        // Here we are sure that all of these grouped ""trailing"" arguments have the required type
		        needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());
		    }
		    if (countOfNeedleArgumentsPassed == (countOfMethodParametersDeclared - 1)) {
		        // If it is variadic and we are short of **exactly one** parameter, this is a match.
		        // Note that omitting the variadic parameter is treated as an empty array
		        //  (thus being short of only 1 argument is fine, but being short of 2 or more is not).
		        // thus group the ""empty"" value into an empty array...
		        needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());
		    } else if (countOfNeedleArgumentsPassed == countOfMethodParametersDeclared) {
		        ResolvedType actualArgumentType = needleArgumentTypes.get(lastNeedleArgumentIndex);
		        boolean finalArgumentIsArray = actualArgumentType.isArray() && expectedVariadicParameterType.isAssignableBy(actualArgumentType.asArrayType().getComponentType());
		        if (finalArgumentIsArray) {
		            // Treat as an array of values -- in which case the expected parameter type is the common type of this array.
		            // no need to do anything
		            // expectedVariadicParameterType = actualArgumentType.asArrayType().getComponentType();
		        } else {
		            // Treat as a single value -- in which case, the expected parameter type is the same as the single value.
		            needleArgumentTypes = groupVariadicParamValues(needleArgumentTypes, lastMethodParameterIndex, methodDeclaration.getLastParam().getType());
		        }
		    } else {
		        // Should be unreachable.
		    }
		    return needleArgumentTypes;
		}"	"$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ grouptrailingargumentsintoarray ( resolvedmethoddeclaration $whitespace$ methoddeclaration , $whitespace$ list < resolvedtype > $whitespace$ needleargumenttypes , $whitespace$ resolvedtype $whitespace$ expectedvariadicparametertype ) { $newline$ $indentation$ $//·the·index·of·the·final·method·parameter·(on·the·method·declaration).$ $newline$ $indentation$ int $whitespace$ countofmethodparametersdeclared $whitespace$ = $whitespace$ methoddeclaration . getnumberofparams ( ) ; $newline$ $indentation$ int $whitespace$ lastmethodparameterindex $whitespace$ = $whitespace$ getlastparameterindex ( countofmethodparametersdeclared ) ; $newline$ $indentation$ $//·the·index·of·the·final·argument·passed·(on·the·method·usage).$ $newline$ $indentation$ int $whitespace$ countofneedleargumentspassed $whitespace$ = $whitespace$ needleargumenttypes . size ( ) ; $newline$ $indentation$ int $whitespace$ lastneedleargumentindex $whitespace$ = $whitespace$ getlastparameterindex ( countofneedleargumentspassed ) ; $newline$ $indentation$ if $whitespace$ ( countofneedleargumentspassed $whitespace$ > $whitespace$ countofmethodparametersdeclared ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·variadic,·and·we·have·an·""excess""·of·arguments,·group·the·""trailing""·arguments·into·an·array.$ $newline$ $indentation$ $//·here·we·are·sure·that·all·of·these·grouped·""trailing""·arguments·have·the·required·type$ $newline$ $indentation$ needleargumenttypes $whitespace$ = $whitespace$ groupvariadicparamvalues ( needleargumenttypes , $whitespace$ lastmethodparameterindex , $whitespace$ methoddeclaration . getlastparam ( ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( countofneedleargumentspassed $whitespace$ == $whitespace$ ( countofmethodparametersdeclared $whitespace$ - $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·variadic·and·we·are·short·of·**exactly·one**·parameter,·this·is·a·match.$ $newline$ $indentation$ $//·note·that·omitting·the·variadic·parameter·is·treated·as·an·empty·array$ $newline$ $indentation$ $//··(thus·being·short·of·only·1·argument·is·fine,·but·being·short·of·2·or·more·is·not).$ $newline$ $indentation$ $//·thus·group·the·""empty""·value·into·an·empty·array...$ $newline$ $indentation$ needleargumenttypes $whitespace$ = $whitespace$ groupvariadicparamvalues ( needleargumenttypes , $whitespace$ lastmethodparameterindex , $whitespace$ methoddeclaration . getlastparam ( ) . gettype ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( countofneedleargumentspassed $whitespace$ == $whitespace$ countofmethodparametersdeclared ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ actualargumenttype $whitespace$ = $whitespace$ needleargumenttypes . get ( lastneedleargumentindex ) ; $newline$ $indentation$ boolean $whitespace$ finalargumentisarray $whitespace$ = $whitespace$ actualargumenttype . isarray ( ) $whitespace$ && $whitespace$ expectedvariadicparametertype . isassignableby ( actualargumenttype . asarraytype ( ) . getcomponenttype ( ) ) ; $newline$ $indentation$ if $whitespace$ ( finalargumentisarray ) $whitespace$ { $newline$ $indentation$ $//·treat·as·an·array·of·values·--·in·which·case·the·expected·parameter·type·is·the·common·type·of·this·array.$ $newline$ $indentation$ $//·no·need·to·do·anything$ $newline$ $indentation$ $//·expectedvariadicparametertype·=·actualargumenttype.asarraytype().getcomponenttype();$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·treat·as·a·single·value·--·in·which·case,·the·expected·parameter·type·is·the·same·as·the·single·value.$ $newline$ $indentation$ needleargumenttypes $whitespace$ = $whitespace$ groupvariadicparamvalues ( needleargumenttypes , $whitespace$ lastmethodparameterindex , $whitespace$ methoddeclaration . getlastparam ( ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·should·be·unreachable.$ $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ needleargumenttypes ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ grouptrailingargumentsintoarray ( resolvedmethoddeclaration $whitespace$ methoddeclaration, $whitespace$ list < resolvedtype > $whitespace$ needleargumenttypes, $whitespace$ resolvedtype $whitespace$ expectedvariadicparametertype ) { $newline$ $indentation$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ 1 $whitespace$ is $whitespace$ correct $whitespace$ generation $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ 11-20 $newline$ $indentation$ int $whitespace$ countofmethodparametersdeclared $whitespace$ = $whitespace$ methoddeclaration. getnumberofparams ( ) ; $newline$ $indentation$ int $whitespace$ lastmethodparameterindex $whitespace$ = $whitespace$ getlastparameterindex ( countofmethodparametersdeclared ) ; $newline$ $indentation$ $whitespace$ $whitespace$			
groupVariadicParamValues	45	56	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.1789481788873672	LOW	"		private static List<ResolvedType> groupVariadicParamValues(List<ResolvedType> argumentsTypes, int startVariadic, ResolvedType variadicType){
		    List<ResolvedType> res = new ArrayList<>(argumentsTypes.subList(0, startVariadic));
		    List<ResolvedType> variadicValues = argumentsTypes.subList(startVariadic, argumentsTypes.size());
		    if (variadicValues.isEmpty()) {
		        // TODO if there are no variadic values we should default to the bound of the formal type
		        res.add(variadicType);
		    } else {
		        ResolvedType componentType = findCommonType(variadicValues);
		        res.add(convertToVariadicParameter(componentType));
		    }
		    return res;
		}"	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ groupvariadicparamvalues ( list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ int $whitespace$ startvariadic , $whitespace$ resolvedtype $whitespace$ variadictype ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( argumentstypes . sublist ( $number$ , $whitespace$ startvariadic ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes . sublist ( startvariadic , $whitespace$ argumentstypes . size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( variadicvalues . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·todo·if·there·are·no·variadic·values·we·should·default·to·the·bound·of·the·formal·type$ $newline$ $indentation$ res . add ( variadictype ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ componenttype $whitespace$ = $whitespace$ findcommontype ( variadicvalues ) ; $newline$ $indentation$ res . add ( converttovariadicparameter ( componenttype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ groupvariadicparamvalues ( list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ int $whitespace$ startvariadic, $whitespace$ resolvedtype $whitespace$ variadictype ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( argumentstypes. sublist ( $number$, $whitespace$ startvariadic ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes. sublist ( startvariadic, $whitespace$ argumentstypes. size ( ) ) ; $newline$ $indentation$ if $whitespace$ ( variadicvalues. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ variadicvalues $whitespace$ = $whitespace$ argumentstypes. sublist ( startvariadic, $whitespace$ argumentstypes. size ( ) ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }			
isArrayOfObject	204	208	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.2430243641138076	LOW	"		private static boolean isArrayOfObject(ResolvedType type){
		    return type.isArray() && type.asArrayType().getComponentType().isReferenceType() && type.asArrayType().getComponentType().asReferenceType().isJavaLangObject();
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isarrayofobject ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ return $whitespace$ type . isarray ( ) $whitespace$ && $whitespace$ type . asarraytype ( ) . getcomponenttype ( ) . isreferencetype ( ) $whitespace$ && $whitespace$ type . asarraytype ( ) . getcomponenttype ( ) . asreferencetype ( ) . isjavalangobject ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ isarrayofobject ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ return $whitespace$ type. isarray ( ) $whitespace$ && $whitespace$ type. asarraytype ( ). getcomponenttype ( ). isreferencetype ( ) $whitespace$ && $whitespace$ type. asarraytype ( ). getcomponenttype ( ). asreferencetype ( ). isjavalangobject ( ) ; $newline$ $indentation$ }			
isMoreSpecific	690	795	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.250334233045578	LOW	"		private static boolean isMoreSpecific(ResolvedMethodDeclaration methodA, ResolvedMethodDeclaration methodB, List<ResolvedType> argumentTypes){
		    final boolean aVariadic = methodA.hasVariadicParameter();
		    final boolean bVariadic = methodB.hasVariadicParameter();
		    final int aNumberOfParams = methodA.getNumberOfParams();
		    final int bNumberOfParams = methodB.getNumberOfParams();
		    final int numberOfArgs = argumentTypes.size();
		    final ResolvedType lastArgType = numberOfArgs > 0 ? argumentTypes.get(numberOfArgs - 1) : null;
		    final boolean isLastArgArray = lastArgType != null && lastArgType.isArray();
		    int omittedArgs = 0;
		    boolean isMethodAMoreSpecific = false;
		    // If one method declaration has exactly the correct amount of parameters and is not variadic then it is always
		    // preferred to a declaration that is variadic (and hence possibly also has a different amount of parameters).
		    if (!aVariadic && aNumberOfParams == numberOfArgs && (bVariadic && (bNumberOfParams != numberOfArgs || !isLastArgArray))) {
		        return true;
		    }
		    if (!bVariadic && bNumberOfParams == numberOfArgs && (aVariadic && (aNumberOfParams != numberOfArgs || !isLastArgArray))) {
		        return false;
		    }
		    // If both methods are variadic but the calling method omits any varArgs, bump the omitted args to
		    // ensure the varargs type is considered when determining which method is more specific
		    if (aVariadic && bVariadic && aNumberOfParams == bNumberOfParams && numberOfArgs == aNumberOfParams - 1) {
		        omittedArgs++;
		    }
		    // Either both methods are variadic or neither is. So we must compare the parameter types.
		    for (int i = 0; i < numberOfArgs + omittedArgs; i++) {
		        ResolvedType paramTypeA = getMethodsExplicitAndVariadicParameterType(methodA, i);
		        ResolvedType paramTypeB = getMethodsExplicitAndVariadicParameterType(methodB, i);
		        ResolvedType argType = null;
		        if (i < argumentTypes.size()) {
		            argType = argumentTypes.get(i);
		        }
		        // Safety: if a type is null it means a signature with too few parameters managed to get to this point.
		        // This should not happen but it also means that this signature is immediately disqualified.
		        if (paramTypeA == null) {
		            return false;
		        }
		        if (paramTypeB == null) {
		            return true;
		        }
		        // Widening primitive conversions have priority over boxing/unboxing conversions when finding the most
		        // applicable method. E.g. assume we have method call foo(1) and declarations foo(long) and foo(Integer).
		        // The method call will call foo(long), as it requires a widening primitive conversion from int to long
		        // instead of a boxing conversion from int to Integer. See JLS §15.12.2.
		        // This is what we check here.
		        if (argType != null && paramTypeA.isPrimitive() == argType.isPrimitive() && paramTypeB.isPrimitive() != argType.isPrimitive() && paramTypeA.isAssignableBy(argType)) {
		            return true;
		        }
		        if (argType != null && paramTypeB.isPrimitive() == argType.isPrimitive() && paramTypeA.isPrimitive() != argType.isPrimitive() && paramTypeB.isAssignableBy(argType)) {
		            return false;
		            // if paramA and paramB are not the last parameters
		            // and the type of paramA or paramB (which are not more specific at this stage) is java.lang.Object
		            // then we have to consider others parameters before concluding
		        }
		        if ((i < numberOfArgs - 1) && (isJavaLangObject(paramTypeB) || (isJavaLangObject(paramTypeA)))) {
		            // consider others parameters
		            // but eventually mark the method A as more specific if the methodB has an argument of type java.lang.Object
		            isMethodAMoreSpecific = isMethodAMoreSpecific || isJavaLangObject(paramTypeB);
		        } else // If we get to this point then we check whether one of the methods contains a parameter type that is more
		        // specific. If it does, we can assume the entire declaration is more specific as we would otherwise have
		        // a situation where the declarations are ambiguous in the given context.
		        {
		            boolean aAssignableFromB = paramTypeA.isAssignableBy(paramTypeB);
		            boolean bAssignableFromA = paramTypeB.isAssignableBy(paramTypeA);
		            if (bAssignableFromA && !aAssignableFromB) {
		                // A's parameter is more specific
		                return true;
		            }
		            if (aAssignableFromB && !bAssignableFromA) {
		                // B's parameter is more specific
		                return false;
		            }
		        }
		    }
		    if (aVariadic && !bVariadic) {
		        // if the last argument is an array then m1 is more specific
		        return isLastArgArray;
		    }
		    if (!aVariadic && bVariadic) {
		        // if the last argument is an array and m1 is not variadic then
		        // it is not more specific
		        return !isLastArgArray;
		    }
		    return isMethodAMoreSpecific;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ ismorespecific ( resolvedmethoddeclaration $whitespace$ methoda , $whitespace$ resolvedmethoddeclaration $whitespace$ methodb , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ avariadic $whitespace$ = $whitespace$ methoda . hasvariadicparameter ( ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ bvariadic $whitespace$ = $whitespace$ methodb . hasvariadicparameter ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ anumberofparams $whitespace$ = $whitespace$ methoda . getnumberofparams ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ bnumberofparams $whitespace$ = $whitespace$ methodb . getnumberofparams ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ numberofargs $whitespace$ = $whitespace$ argumenttypes . size ( ) ; $newline$ $indentation$ final $whitespace$ resolvedtype $whitespace$ lastargtype $whitespace$ = $whitespace$ numberofargs $whitespace$ > $whitespace$ $number$ $whitespace$ ? $whitespace$ argumenttypes . get ( numberofargs $whitespace$ - $whitespace$ $number$ ) $whitespace$ : $whitespace$ null ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ islastargarray $whitespace$ = $whitespace$ lastargtype $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ lastargtype . isarray ( ) ; $newline$ $indentation$ int $whitespace$ omittedargs $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ ismethodamorespecific $whitespace$ = $whitespace$ false ; $newline$ $indentation$ $//·if·one·method·declaration·has·exactly·the·correct·amount·of·parameters·and·is·not·variadic·then·it·is·always$ $newline$ $indentation$ $//·preferred·to·a·declaration·that·is·variadic·(and·hence·possibly·also·has·a·different·amount·of·parameters).$ $newline$ $indentation$ if $whitespace$ ( ! avariadic $whitespace$ && $whitespace$ anumberofparams $whitespace$ == $whitespace$ numberofargs $whitespace$ && $whitespace$ ( bvariadic $whitespace$ && $whitespace$ ( bnumberofparams $whitespace$ != $whitespace$ numberofargs $whitespace$ || $whitespace$ ! islastargarray ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! bvariadic $whitespace$ && $whitespace$ bnumberofparams $whitespace$ == $whitespace$ numberofargs $whitespace$ && $whitespace$ ( avariadic $whitespace$ && $whitespace$ ( anumberofparams $whitespace$ != $whitespace$ numberofargs $whitespace$ || $whitespace$ ! islastargarray ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·both·methods·are·variadic·but·the·calling·method·omits·any·varargs,·bump·the·omitted·args·to$ $newline$ $indentation$ $//·ensure·the·varargs·type·is·considered·when·determining·which·method·is·more·specific$ $newline$ $indentation$ if $whitespace$ ( avariadic $whitespace$ && $whitespace$ bvariadic $whitespace$ && $whitespace$ anumberofparams $whitespace$ == $whitespace$ bnumberofparams $whitespace$ && $whitespace$ numberofargs $whitespace$ == $whitespace$ anumberofparams $whitespace$ - $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ omittedargs ++ ; $newline$ $indentation$ } $newline$ $indentation$ $//·either·both·methods·are·variadic·or·neither·is.·so·we·must·compare·the·parameter·types.$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ numberofargs $whitespace$ + $whitespace$ omittedargs ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ paramtypea $whitespace$ = $whitespace$ getmethodsexplicitandvariadicparametertype ( methoda , $whitespace$ i ) ; $newline$ $indentation$ resolvedtype $whitespace$ paramtypeb $whitespace$ = $whitespace$ getmethodsexplicitandvariadicparametertype ( methodb , $whitespace$ i ) ; $newline$ $indentation$ resolvedtype $whitespace$ argtype $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ argumenttypes . size ( ) ) $whitespace$ { $newline$ $indentation$ argtype $whitespace$ = $whitespace$ argumenttypes . get ( i ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·safety:·if·a·type·is·null·it·means·a·signature·with·too·few·parameters·managed·to·get·to·this·point.$ $newline$ $indentation$ $//·this·should·not·happen·but·it·also·means·that·this·signature·is·immediately·disqualified.$ $newline$ $indentation$ if $whitespace$ ( paramtypea $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( paramtypeb $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·widening·primitive·conversions·have·priority·over·boxing/unboxing·conversions·when·finding·the·most$ $newline$ $indentation$ $//·applicable·method.·e.g.·assume·we·have·method·call·foo(1)·and·declarations·foo(long)·and·foo(integer).$ $newline$ $indentation$ $//·the·method·call·will·call·foo(long),·as·it·requires·a·widening·primitive·conversion·from·int·to·long$ $newline$ $indentation$ $//·instead·of·a·boxing·conversion·from·int·to·integer.·see·jls·§15.12.2.$ $newline$ $indentation$ $//·this·is·what·we·check·here.$ $newline$ $indentation$ if $whitespace$ ( argtype $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ paramtypea . isprimitive ( ) $whitespace$ == $whitespace$ argtype . isprimitive ( ) $whitespace$ && $whitespace$ paramtypeb . isprimitive ( ) $whitespace$ != $whitespace$ argtype . isprimitive ( ) $whitespace$ && $whitespace$ paramtypea . isassignableby ( argtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( argtype $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ paramtypeb . isprimitive ( ) $whitespace$ == $whitespace$ argtype . isprimitive ( ) $whitespace$ && $whitespace$ paramtypea . isprimitive ( ) $whitespace$ != $whitespace$ argtype . isprimitive ( ) $whitespace$ && $whitespace$ paramtypeb . isassignableby ( argtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ $//·if·parama·and·paramb·are·not·the·last·parameters$ $newline$ $indentation$ $//·and·the·type·of·parama·or·paramb·(which·are·not·more·specific·at·this·stage)·is·java.lang.object$ $newline$ $indentation$ $//·then·we·have·to·consider·others·parameters·before·concluding$ $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ( i $whitespace$ < $whitespace$ numberofargs $whitespace$ - $whitespace$ $number$ ) $whitespace$ && $whitespace$ ( isjavalangobject ( paramtypeb ) $whitespace$ || $whitespace$ ( isjavalangobject ( paramtypea ) ) ) ) $whitespace$ { $newline$ $indentation$ $//·consider·others·parameters$ $newline$ $indentation$ $//·but·eventually·mark·the·method·a·as·more·specific·if·the·methodb·has·an·argument·of·type·java.lang.object$ $newline$ $indentation$ ismethodamorespecific $whitespace$ = $whitespace$ ismethodamorespecific $whitespace$ || $whitespace$ isjavalangobject ( paramtypeb ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ $//·if·we·get·to·this·point·then·we·check·whether·one·of·the·methods·contains·a·parameter·type·that·is·more$ $newline$ $indentation$ $//·specific.·if·it·does,·we·can·assume·the·entire·declaration·is·more·specific·as·we·would·otherwise·have$ $newline$ $indentation$ $//·a·situation·where·the·declarations·are·ambiguous·in·the·given·context.$ $newline$ $indentation$ { $newline$ $indentation$ boolean $whitespace$ aassignablefromb $whitespace$ = $whitespace$ paramtypea . isassignableby ( paramtypeb ) ; $newline$ $indentation$ boolean $whitespace$ bassignablefroma $whitespace$ = $whitespace$ paramtypeb . isassignableby ( paramtypea ) ; $newline$ $indentation$ if $whitespace$ ( bassignablefroma $whitespace$ && $whitespace$ ! aassignablefromb ) $whitespace$ { $newline$ $indentation$ $//·a's·parameter·is·more·specific$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( aassignablefromb $whitespace$ && $whitespace$ ! bassignablefroma ) $whitespace$ { $newline$ $indentation$ $//·b's·parameter·is·more·specific$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( avariadic $whitespace$ && $whitespace$ ! bvariadic ) $whitespace$ { $newline$ $indentation$ $//·if·the·last·argument·is·an·array·then·m1·is·more·specific$ $newline$ $indentation$ return $whitespace$ islastargarray ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! avariadic $whitespace$ && $whitespace$ bvariadic ) $whitespace$ { $newline$ $indentation$ $//·if·the·last·argument·is·an·array·and·m1·is·not·variadic·then$ $newline$ $indentation$ $//·it·is·not·more·specific$ $newline$ $indentation$ return $whitespace$ ! islastargarray ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ismethodamorespecific ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ ismorespecific ( resolvedmethoddeclaration $whitespace$ methoda, $whitespace$ resolvedmethoddeclaration $whitespace$ methodb, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes ) { $newline$ $indentation$ final $whitespace$ boolean $whitespace$ avariadic $whitespace$ = $whitespace$ methoda. hasvariadicparameter ( ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ bnumberofparams $whitespace$ = $whitespace$ methoda. getnumberofparams ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ anumberofparams $whitespace$ = $whitespace$ methoda. getnumberofparams ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ bnumberofparams $whitespace$ = $whitespace$ methodb. getnumberofparams ( ) ; $newline$ $indentation$ final $whitespace$ int $whitespace$ numberofargs $whitespace$ = $whitespace$ argumenttypes. size ( ) ; $newline$ $indentation$ final $whitespace$ resolvedtype $whitespace$ lastargtype $whitespace$ = $whitespace$ numberofargs $whitespace$ > $whitespace$ $number$ $whitespace$? $whitespace$ argumenttypes. get ( numberofargs $whitespace$ - $whitespace$ $number$ ) $whitespace$ : $whitespace$ null ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ islastargarray $whitespace$ = $whitespace$ lastargtype $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ lastargtype. isarray ( ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ omittedargs $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ boolean $whitespace$ ismethodamorespecific $whitespace$ = $whitespace$ false ; $newline$ $indentation$			
findCommonType	58	64	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/logic/MethodResolutionLogic.java	0.6565725207328796	MID	"		private static ResolvedType findCommonType(List<ResolvedType> variadicValues){
		    if (variadicValues.isEmpty()) {
		        throw new IllegalArgumentException();
		    }
		    // TODO implement this decently
		    return variadicValues.get(0);
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ findcommontype ( list < resolvedtype > $whitespace$ variadicvalues ) { $newline$ $indentation$ if $whitespace$ ( variadicvalues . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo·implement·this·decently$ $newline$ $indentation$ return $whitespace$ variadicvalues . get ( $number$ ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ findcommontype ( list < resolvedtype > $whitespace$ variadicvalues ) { $newline$ $indentation$ if $whitespace$ ( variadicvalues. isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ variadicvalues. get ( $number$ ) ; $newline$ $indentation$ return $whitespace$ variadicvalues. get ( $number$ ) ; $newline$ $indentation$ }			
toString	49	55	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/Value.java	0.8979954719543457	HIGH	"		@Override
		public String toString(){
		    return ""Value{"" + ""type="" + type + "", name='"" + name + '\'' + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $string$ } ' ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ type $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$'; $newline$ $indentation$ }			
replaceTypeVariables	125	129	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/typesystem/LazyType.java	0.1468179374933242	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tp, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    return getType().replaceTypeVariables(tp, replaced, inferredTypes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tp , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ return $whitespace$ gettype ( ) . replacetypevariables ( tp , $whitespace$ replaced , $whitespace$ inferredtypes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tp, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ return $whitespace$ gettype ( ). replacetypevariables ( tp, $whitespace$ replaced, $whitespace$ inferredtypes ) ; $newline$ $indentation$ }			
isAssignableBy	82	150	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/typesystem/ReferenceTypeImpl.java	0.0968677178025245	LOW	"		@Override
		public boolean isAssignableBy(ResolvedType other){
		    if (other instanceof NullType) {
		        return !this.isPrimitive();
		    }
		    // everything is assignable to Object except void
		    if (!other.isVoid() && this.isJavaLangObject()) {
		        return true;
		    }
		    // consider boxing
		    if (other.isPrimitive()) {
		        if (this.isJavaLangObject()) {
		            return true;
		        }
		        // Check if 'other' can be boxed to match this type
		        if (isCorrespondingBoxingType(other.describe()))
		            return true;
		        // All numeric types extend Number
		        return other.isNumericType() && this.isReferenceType() && this.asReferenceType().getQualifiedName().equals(Number.class.getCanonicalName());
		    }
		    if (other instanceof LambdaArgumentTypePlaceholder) {
		        return FunctionalInterfaceLogic.isFunctionalInterfaceType(this);
		    }
		    if (other.isReferenceType()) {
		        ResolvedReferenceType otherRef = other.asReferenceType();
		        if (compareConsideringTypeParameters(otherRef)) {
		            return true;
		        }
		        for (ResolvedReferenceType otherAncestor : otherRef.getAllAncestors()) {
		            if (compareConsideringTypeParameters(otherAncestor)) {
		                return true;
		            }
		        }
		        return false;
		    }
		    if (other.isTypeVariable()) {
		        for (ResolvedTypeParameterDeclaration.Bound bound : other.asTypeVariable().asTypeParameter().getBounds()) {
		            if (bound.isExtends()) {
		                if (this.isAssignableBy(bound.getType())) {
		                    return true;
		                }
		            }
		        }
		        return false;
		    }
		    if (other.isConstraint()) {
		        return isAssignableBy(other.asConstraintType().getBound());
		    }
		    if (other.isWildcard()) {
		        if (this.isJavaLangObject()) {
		            return true;
		        }
		        if (other.asWildcard().isExtends()) {
		            return isAssignableBy(other.asWildcard().getBoundedType());
		        }
		        return false;
		    }
		    if (other.isUnionType()) {
		        Optional<ResolvedReferenceType> common = other.asUnionType().getCommonAncestor();
		        return common.map(ancestor -> isAssignableBy(ancestor)).orElse(false);
		    }
		    // An array can be assigned only to a variable of a compatible array type,
		    // or to a variable of type Object, Cloneable or java.io.Serializable.
		    if (other.isArray()) {
		        return isAssignableByReferenceType(getQualifiedName());
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ nulltype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ! this . isprimitive ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·everything·is·assignable·to·object·except·void$ $newline$ $indentation$ if $whitespace$ ( ! other . isvoid ( ) $whitespace$ && $whitespace$ this . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·consider·boxing$ $newline$ $indentation$ if $whitespace$ ( other . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·check·if·'other'·can·be·boxed·to·match·this·type$ $newline$ $indentation$ if $whitespace$ ( iscorrespondingboxingtype ( other . describe ( ) ) ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ $//·all·numeric·types·extend·number$ $newline$ $indentation$ return $whitespace$ other . isnumerictype ( ) $whitespace$ && $whitespace$ this . isreferencetype ( ) $whitespace$ && $whitespace$ this . asreferencetype ( ) . getqualifiedname ( ) . equals ( number . class . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ functionalinterfacelogic . isfunctionalinterfacetype ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ otherref $whitespace$ = $whitespace$ other . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( compareconsideringtypeparameters ( otherref ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ otherancestor $whitespace$ : $whitespace$ otherref . getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( compareconsideringtypeparameters ( otherancestor ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration . bound $whitespace$ bound $whitespace$ : $whitespace$ other . astypevariable ( ) . astypeparameter ( ) . getbounds ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( bound . isextends ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this . isassignableby ( bound . gettype ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isassignableby ( other . asconstrainttype ( ) . getbound ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isassignableby ( other . aswildcard ( ) . getboundedtype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . isuniontype ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ common $whitespace$ = $whitespace$ other . asuniontype ( ) . getcommonancestor ( ) ; $newline$ $indentation$ return $whitespace$ common . map ( ancestor $whitespace$ - > $whitespace$ isassignableby ( ancestor ) ) . orelse ( false ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·an·array·can·be·assigned·only·to·a·variable·of·a·compatible·array·type,$ $newline$ $indentation$ $//·or·to·a·variable·of·type·object,·cloneable·or·java.io.serializable.$ $newline$ $indentation$ if $whitespace$ ( other . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isassignablebyreferencetype ( getqualifiedname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! this. isprimitive ( ) $whitespace$ && $whitespace$! this. isjavalangobject ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////everything $whitespace$ is $whitespace$ method $whitespace$ && $whitespace$ other. isprimitive ( ) $whitespace$ && $whitespace$! this. isjavalangobject ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ if $whitespace$ ( other. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////check $whitespace$ if $whitespace$ ( other. isnumerictype ( ) $whitespace$ && $whitespace$ this. isreferencetype ( ) $whitespace$ && $whitespace$ this. asreferencetype ( ). getqualifiedname ( ). equals ( number. class. getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$			
getAllAncestors	212	223	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/typesystem/ReferenceTypeImpl.java	0.1083943396806716	LOW	"		@Override
		public List<ResolvedReferenceType> getAllAncestors(Function<ResolvedReferenceTypeDeclaration, List<ResolvedReferenceType>> traverser){
		    // We need to go through the inheritance line and propagate the type parameters
		    List<ResolvedReferenceType> ancestors = typeDeclaration.getAllAncestors(traverser);
		    ancestors = ancestors.stream().map(a -> typeParametersMap().replaceAll(a).asReferenceType()).collect(Collectors.toList());
		    return ancestors;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getallancestors ( function < resolvedreferencetypedeclaration , $whitespace$ list < resolvedreferencetype >> $whitespace$ traverser ) { $newline$ $indentation$ $//·we·need·to·go·through·the·inheritance·line·and·propagate·the·type·parameters$ $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ typedeclaration . getallancestors ( traverser ) ; $newline$ $indentation$ ancestors $whitespace$ = $whitespace$ ancestors . stream ( ) . map ( a $whitespace$ - > $whitespace$ typeparametersmap ( ) . replaceall ( a ) . asreferencetype ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getallancestors ( function < resolvedreferencetypedeclaration, $whitespace$ list < resolvedreferencetype >> $whitespace$ traverser ) { $newline$ $indentation$ $//// $newline$ $indentation$$ ). map ( a $whitespace$ - > $whitespace$ typeparametersmap ( ). replaceall ( a ). asreferencetype ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }			
undeterminedParameters	50	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/typesystem/ReferenceTypeImpl.java	0.2088057100772857	LOW	"		public static ResolvedReferenceType undeterminedParameters(ResolvedReferenceTypeDeclaration typeDeclaration){
		    return new ReferenceTypeImpl(typeDeclaration, typeDeclaration.getTypeParameters().stream().map(ResolvedTypeVariable::new).collect(Collectors.toList()));
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedreferencetype $whitespace$ undeterminedparameters ( resolvedreferencetypedeclaration $whitespace$ typedeclaration ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration , $whitespace$ typedeclaration . gettypeparameters ( ) . stream ( ) . map ( resolvedtypevariable : : new ) . collect ( collectors . tolist ( ) ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedreferencetype $whitespace$ undeterminedparameters ( resolvedreferencetypedeclaration $whitespace$ typedeclaration ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration, $whitespace$ typedeclaration. gettypeparameters ( ). stream ( ). map ( resolvedtypevariable : : new ). collect ( collectors. tolist ( ) ) ) ; $newline$ $indentation$ }			
getDirectAncestors	225	250	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/model/typesystem/ReferenceTypeImpl.java	0.212415412068367	LOW	"		@Override
		public List<ResolvedReferenceType> getDirectAncestors(){
		    // We need to go through the inheritance line and propagate the type parameters
		    List<ResolvedReferenceType> ancestors = typeDeclaration.getAncestors();
		    ancestors = ancestors.stream().map(a -> typeParametersMap().replaceAll(a).asReferenceType()).collect(Collectors.toList());
		    // Conditionally re-insert java.lang.Object as an ancestor.
		    if (this.getTypeDeclaration().isPresent()) {
		        ResolvedReferenceTypeDeclaration thisTypeDeclaration = this.getTypeDeclaration().get();
		        // The superclass of interfaces is always null
		        if (thisTypeDeclaration.isClass()) {
		            Optional<ResolvedReferenceType> optionalSuperClass = thisTypeDeclaration.asClass().getSuperClass();
		            boolean superClassIsJavaLangObject = optionalSuperClass.isPresent() && optionalSuperClass.get().isJavaLangObject();
		            boolean thisIsJavaLangObject = thisTypeDeclaration.asClass().isJavaLangObject();
		            if (superClassIsJavaLangObject && !thisIsJavaLangObject) {
		                ancestors.add(optionalSuperClass.get());
		            }
		        }
		    }
		    return ancestors;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getdirectancestors ( ) { $newline$ $indentation$ $//·we·need·to·go·through·the·inheritance·line·and·propagate·the·type·parameters$ $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ typedeclaration . getancestors ( ) ; $newline$ $indentation$ ancestors $whitespace$ = $whitespace$ ancestors . stream ( ) . map ( a $whitespace$ - > $whitespace$ typeparametersmap ( ) . replaceall ( a ) . asreferencetype ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·conditionally·re-insert·java.lang.object·as·an·ancestor.$ $newline$ $indentation$ if $whitespace$ ( this . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ thistypedeclaration $whitespace$ = $whitespace$ this . gettypedeclaration ( ) . get ( ) ; $newline$ $indentation$ $//·the·superclass·of·interfaces·is·always·null$ $newline$ $indentation$ if $whitespace$ ( thistypedeclaration . isclass ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ optionalsuperclass $whitespace$ = $whitespace$ thistypedeclaration . asclass ( ) . getsuperclass ( ) ; $newline$ $indentation$ boolean $whitespace$ superclassisjavalangobject $whitespace$ = $whitespace$ optionalsuperclass . ispresent ( ) $whitespace$ && $whitespace$ optionalsuperclass . get ( ) . isjavalangobject ( ) ; $newline$ $indentation$ boolean $whitespace$ thisisjavalangobject $whitespace$ = $whitespace$ thistypedeclaration . asclass ( ) . isjavalangobject ( ) ; $newline$ $indentation$ if $whitespace$ ( superclassisjavalangobject $whitespace$ && $whitespace$ ! thisisjavalangobject ) $whitespace$ { $newline$ $indentation$ ancestors . add ( optionalsuperclass . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getdirectancestors ( ) { $newline$ $indentation$ $//// $newline$ $indentation$ partitioned $whitespace$ = $whitespace$ getdirectancestors ( ) ; $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ typedeclaration. getancestors ( ) ; $newline$ $indentation$ ancestors $whitespace$ = $whitespace$ ancestors. stream ( ). map ( a $whitespace$ - > $whitespace$ typeparametersmap ( ). replaceall ( a ). asreferencetype ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ if $whitespace$ ( this. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ thistypedeclaration $whitespace$ = $whitespace$ this. gettypedeclaration ( ). get ( ) ; $newline$ $indentation$ $whitespace$//initation $whitespace$ = $whitespace$ thistypedeclaration. asclass ( ) ; $newline$ $indentation$ boolean $whitespace$ superclassisjavalangobject $whitespace$ = $whitespace$ optionalsuperclass. ispresent ( ) $whitespace$ && $whitespace$ optionalsuperclass. get ( ). isjavalangobject ( ) ; $newline$ $indentation$ boolean $whitespace$ thisisjavalangobject $whitespace$ = $whitespace$ optionalsuperclass. get ( ). getsuperclass ( ) ; $newline$ $indentation$ boolean $whitespace$ thisisjavalangobject $whitespace$ = $whitespace$ optionalsuperclass. get ( ). getsuperclass ( ) ; $newline$ $indentation$ boolean $whitespace$ thisisjavalangobject $whitespace$ = $whitespace$ optionalsuperclass. get ( ). getsuperclass ( ) ; $newline$ $indentation$ boolean			
replaceTypeVariables	110	117	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedArrayType.java	0.1742320358753204	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tpToReplace, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    ResolvedType baseTypeReplaced = baseType.replaceTypeVariables(tpToReplace, replaced, inferredTypes);
		    if (baseTypeReplaced == baseType) {
		        return this;
		    }
		    return new ResolvedArrayType(baseTypeReplaced);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ resolvedtype $whitespace$ basetypereplaced $whitespace$ = $whitespace$ basetype . replacetypevariables ( tptoreplace , $whitespace$ replaced , $whitespace$ inferredtypes ) ; $newline$ $indentation$ if $whitespace$ ( basetypereplaced $whitespace$ == $whitespace$ basetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( basetypereplaced ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ resolvedtype $whitespace$ basetypereplaced $whitespace$ = $whitespace$ basetype. replacetypevariables ( tptoreplace, $whitespace$ replaced, $whitespace$ inferredtypes ) ; $newline$ $indentation$ if $whitespace$ ( basetypereplaced $whitespace$ == $whitespace$ basetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( basetypereplaced ) ; $newline$ $indentation$ }			
isAssignableBy	87	108	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedArrayType.java	0.2541080117225647	LOW	"		@Override
		public boolean isAssignableBy(ResolvedType other){
		    if (other.isNull()) {
		        return true;
		    }
		    if (other.isArray()) {
		        if (baseType.isPrimitive() && other.asArrayType().getComponentType().isPrimitive()) {
		            return baseType.equals(other.asArrayType().getComponentType());
		        }
		        // An array of primitive type is not assignable by an array of boxed type nor the reverse
		        // An array of primitive type cannot be assigned to an array of Object
		        if ((baseType.isPrimitive() && other.asArrayType().getComponentType().isReferenceType()) || (baseType.isReferenceType() && other.asArrayType().getComponentType().isPrimitive())) {
		            return false;
		        }
		        // An array can be assigned only to a variable of a compatible array type, or to
		        // a variable of type Object, Cloneable or java.io.Serializable.
		        return baseType.isAssignableBy(other.asArrayType().getComponentType());
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other . isnull ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . isarray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( basetype . isprimitive ( ) $whitespace$ && $whitespace$ other . asarraytype ( ) . getcomponenttype ( ) . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ basetype . equals ( other . asarraytype ( ) . getcomponenttype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·an·array·of·primitive·type·is·not·assignable·by·an·array·of·boxed·type·nor·the·reverse$ $newline$ $indentation$ $//·an·array·of·primitive·type·cannot·be·assigned·to·an·array·of·object$ $newline$ $indentation$ if $whitespace$ ( ( basetype . isprimitive ( ) $whitespace$ && $whitespace$ other . asarraytype ( ) . getcomponenttype ( ) . isreferencetype ( ) ) $whitespace$ || $whitespace$ ( basetype . isreferencetype ( ) $whitespace$ && $whitespace$ other . asarraytype ( ) . getcomponenttype ( ) . isprimitive ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $//·an·array·can·be·assigned·only·to·a·variable·of·a·compatible·array·type,·or·to$ $newline$ $indentation$ $//·a·variable·of·type·object,·cloneable·or·java.io.serializable.$ $newline$ $indentation$ return $whitespace$ basetype . isassignableby ( other . asarraytype ( ) . getcomponenttype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other. isnull ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other. isarray ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( basetype. isprimitive ( ) $whitespace$ && $whitespace$ other. asarraytype ( ). getcomponenttype ( ). isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ basetype. equals ( other. asarraytype ( ). getcomponenttype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ check $whitespace$ for $whitespace$ the $whitespace$ project $whitespace$ github $whitespace$ if $whitespace$ the $whitespace$ project $whitespace$ is $whitespace$ not $whitespace$ supported $newline$ $indentation$ if $whitespace$ ( ( basetype. isprimitive ( ) $whitespace$ && $whitespace$ other. asarraytype ( ). getcomponenttype ( ). isreferencetype ( ) ) $whitespace$ || $whitespace$ ( basetype. isreferencetype ( ) $whitespace$ && $whitespace$ other. asarraytype ( ). getcomponenttype ( ). isprimitive ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////an$ = $whitespace$ jdktype. getcomponenttype ( ) ; $newline$ $indentation$ if $whitespace$ ( ( basetype. isprimitive ( ) $whitespace$ && $whitespace$ other. asarraytype ( ). getcomponenttype ( ). isreferencetype ( ) ) $whitespace$ || $whitespace$ ( basetype. isreferencetype ( ) $whitespace$ && $whitespace$ other. as			
replaceTypeVariables	69	76	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedIntersectionType.java	0.0817305892705917	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tp, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    List<ResolvedType> elementsReplaced = elements.stream().map(e -> e.replaceTypeVariables(tp, replaced, inferredTypes)).collect(Collectors.toList());
		    if (elementsReplaced.equals(elements)) {
		        return this;
		    }
		    return new ResolvedIntersectionType(elementsReplaced);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tp , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ elementsreplaced $whitespace$ = $whitespace$ elements . stream ( ) . map ( e $whitespace$ - > $whitespace$ e . replacetypevariables ( tp , $whitespace$ replaced , $whitespace$ inferredtypes ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( elementsreplaced . equals ( elements ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedintersectiontype ( elementsreplaced ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tp, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ elementsreplaced $whitespace$ = $whitespace$ elements. stream ( ). map ( e $whitespace$ - > $whitespace$ e. replacetypevariables ( tp, $whitespace$ replaced, $whitespace$ inferredtypes ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedintersectiontype ( elementsreplaced ) ; $newline$ $indentation$ }			
unp	204	221	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedPrimitiveType.java	0.1360092908143997	LOW	"		public static ResolvedType unp(ResolvedType type){
		    boolean isUnboxable = type.isReferenceType() && type.asReferenceType().isUnboxable();
		    // If the operand is of compile-time type Byte, Short, Character, or Integer, it is subjected to unboxing conversion (§5.1.8).
		    // The result is then promoted to a value of type int by a widening primitive conversion (§5.1.2) or an identity conversion (§5.1.1).
		    if (isUnboxable && type.asReferenceType().toUnboxedType().get().in(new ResolvedPrimitiveType[] { ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.SHORT, ResolvedPrimitiveType.CHAR, ResolvedPrimitiveType.INT })) {
		        return ResolvedPrimitiveType.INT;
		    }
		    // Otherwise, if the operand is of compile-time type Long, Float, or Double, it is subjected to unboxing conversion (§5.1.8).
		    if (isUnboxable && type.asReferenceType().toUnboxedType().get().in(new ResolvedPrimitiveType[] { ResolvedPrimitiveType.LONG, ResolvedPrimitiveType.FLOAT, ResolvedPrimitiveType.DOUBLE })) {
		        return type.asReferenceType().toUnboxedType().get();
		    }
		    // Otherwise, if the operand is of compile-time type byte, short, or char, it is promoted to a value of type int by a widening primitive conversion (§5.1.2).
		    if (type.isPrimitive() && type.asPrimitive().in(new ResolvedPrimitiveType[] { ResolvedPrimitiveType.BYTE, ResolvedPrimitiveType.CHAR, ResolvedPrimitiveType.SHORT })) {
		        return ResolvedPrimitiveType.INT;
		    }
		    // Otherwise, a unary numeric operand remains as is and is not converted.
		    return type;
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ unp ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ boolean $whitespace$ isunboxable $whitespace$ = $whitespace$ type . isreferencetype ( ) $whitespace$ && $whitespace$ type . asreferencetype ( ) . isunboxable ( ) ; $newline$ $indentation$ $//·if·the·operand·is·of·compile-time·type·byte,·short,·character,·or·integer,·it·is·subjected·to·unboxing·conversion·(§5.1.8).$ $newline$ $indentation$ $//·the·result·is·then·promoted·to·a·value·of·type·int·by·a·widening·primitive·conversion·(§5.1.2)·or·an·identity·conversion·(§5.1.1).$ $newline$ $indentation$ if $whitespace$ ( isunboxable $whitespace$ && $whitespace$ type . asreferencetype ( ) . tounboxedtype ( ) . get ( ) . in ( new $whitespace$ resolvedprimitivetype [ ] $whitespace$ { $whitespace$ resolvedprimitivetype . byte , $whitespace$ resolvedprimitivetype . short , $whitespace$ resolvedprimitivetype . char , $whitespace$ resolvedprimitivetype . int $whitespace$ } ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . int ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·if·the·operand·is·of·compile-time·type·long,·float,·or·double,·it·is·subjected·to·unboxing·conversion·(§5.1.8).$ $newline$ $indentation$ if $whitespace$ ( isunboxable $whitespace$ && $whitespace$ type . asreferencetype ( ) . tounboxedtype ( ) . get ( ) . in ( new $whitespace$ resolvedprimitivetype [ ] $whitespace$ { $whitespace$ resolvedprimitivetype . long , $whitespace$ resolvedprimitivetype . float , $whitespace$ resolvedprimitivetype . double $whitespace$ } ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type . asreferencetype ( ) . tounboxedtype ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·if·the·operand·is·of·compile-time·type·byte,·short,·or·char,·it·is·promoted·to·a·value·of·type·int·by·a·widening·primitive·conversion·(§5.1.2).$ $newline$ $indentation$ if $whitespace$ ( type . isprimitive ( ) $whitespace$ && $whitespace$ type . asprimitive ( ) . in ( new $whitespace$ resolvedprimitivetype [ ] $whitespace$ { $whitespace$ resolvedprimitivetype . byte , $whitespace$ resolvedprimitivetype . char , $whitespace$ resolvedprimitivetype . short $whitespace$ } ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . int ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·a·unary·numeric·operand·remains·as·is·and·is·not·converted.$ $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ unp ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ boolean $whitespace$ isunboxable $whitespace$ = $whitespace$ type. isreferencetype ( ) $whitespace$ && $whitespace$ type. asreferencetype ( ). isunboxable ( ) ; $newline$ $indentation$ $whitespace$ isunboxable $whitespace$ = $whitespace$ type. isreferencetype ( ) $whitespace$ && $whitespace$ type. asreferencetype ( ). isunboxable ( ) ; $newline$ $indentation$ $whitespace$ isunboxable $whitespace$ = $whitespace$ resolvedprimitivetype. int ; $newline$ $indentation$ $whitespace$ isunboxable $whitespace$ = $whitespace$ type. asreferencetype ( ). tounboxedtype ( ) ; $newline$ $indentation$ if $whitespace$ ( isunboxable $whitespace$ && $whitespace$ type. asreferencetype ( ). tounboxedtype ( ). get ( ). in ( new $whitespace$ resolvedprimitivetype [ ] $whitespace$ { $whitespace$ resolvedprimitivetype. byte, $whitespace$ resolvedprimitivetype. short, $whitespace$ resolvedprimitivetype. char, $whitespace$ resolvedprimitivetype. int $whitespace$ } ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype. int ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ does doesimportable ( resolvedprimitivetype ) ; $newline$ $indentation$ return $whitespace$ chopcontainer. readvoltages ( get ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ doesimportable ( resolvedprimitivetype ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ isunboxable $whitespace$ = $whitespace$ type. asreferencetype ( ). tounboxedtype ( ). get ( ). in ( new $whitespace$ resolvedprimitivetype [ ] $whitespace$ { $whitespace$			
byBoxTypeQName	89	96	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedPrimitiveType.java	0.6757733225822449	MID	"		public static Optional<ResolvedType> byBoxTypeQName(String qName){
		    for (ResolvedPrimitiveType ptu : values()) {
		        if (ptu.getBoxTypeQName().equals(qName)) {
		            return Optional.of(ptu);
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < resolvedtype > $whitespace$ byboxtypeqname ( string $whitespace$ qname ) { $newline$ $indentation$ for $whitespace$ ( resolvedprimitivetype $whitespace$ ptu $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ptu . getboxtypeqname ( ) . equals ( qname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( ptu ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < resolvedtype > $whitespace$ byboxtypeqname ( string $whitespace$ qname ) { $newline$ $indentation$ for $whitespace$ ( resolvedprimitivetype $whitespace$ ptu $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ptu. getboxtypeqname ( ). equals ( qname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( ptu ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
isBoxType	73	84	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedPrimitiveType.java	0.7084830403327942	MID	"		public static boolean isBoxType(ResolvedType type){
		    if (!type.isReferenceType()) {
		        return false;
		    }
		    String qName = type.asReferenceType().getQualifiedName();
		    for (ResolvedPrimitiveType ptu : values()) {
		        if (ptu.getBoxTypeQName().equals(qName)) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isboxtype ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( ! type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ type . asreferencetype ( ) . getqualifiedname ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedprimitivetype $whitespace$ ptu $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ptu . getboxtypeqname ( ) . equals ( qname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isboxtype ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ (! type. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ type. asreferencetype ( ). getqualifiedname ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedprimitivetype $whitespace$ ptu $whitespace$ : $whitespace$ values ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ptu. getboxtypeqname ( ). equals ( qname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
erasureOfParamaters	578	591	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.0039008997846394	LOW	"		private List<ResolvedType> erasureOfParamaters(ResolvedTypeParametersMap typeParametersMap){
		    List<ResolvedType> erasedParameters = new ArrayList<ResolvedType>();
		    if (!typeParametersMap.isEmpty()) {
		        // add erased type except java.lang.object
		        List<ResolvedType> parameters = typeParametersMap.getTypes().stream().filter(type -> !type.isReferenceType()).map(type -> type.erasure()).filter(erasedType -> !(isJavaObject(erasedType))).filter(erasedType -> erasedType != null).collect(Collectors.toList());
		        erasedParameters.addAll(parameters);
		    }
		    return erasedParameters;
		}"	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ erasureofparamaters ( resolvedtypeparametersmap $whitespace$ typeparametersmap ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ erasedparameters $whitespace$ = $whitespace$ new $whitespace$ arraylist < resolvedtype > ( ) ; $newline$ $indentation$ if $whitespace$ ( ! typeparametersmap . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·add·erased·type·except·java.lang.object$ $newline$ $indentation$ list < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ typeparametersmap . gettypes ( ) . stream ( ) . filter ( type $whitespace$ - > $whitespace$ ! type . isreferencetype ( ) ) . map ( type $whitespace$ - > $whitespace$ type . erasure ( ) ) . filter ( erasedtype $whitespace$ - > $whitespace$ ! ( isjavaobject ( erasedtype ) ) ) . filter ( erasedtype $whitespace$ - > $whitespace$ erasedtype $whitespace$ != $whitespace$ null ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ erasedparameters . addall ( parameters ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ erasedparameters ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$任ofparamaters ( resolvedtypeparametersmap $whitespace$ typeparametersmap ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ erasedparameters $whitespace$ = $whitespace$ new $whitespace$ arraylist < resolvedtype > ( ) ; $newline$ $indentation$ if $whitespace$ (! typeparametersmap. isempty ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ string $whitespace$ org $whitespace$ = $whitespace$ typeparametersmap. gettypes ( ). stream ( ). filter ( type $whitespace$ - > $whitespace$! type. isreferencetype ( ) ). map ( type $whitespace$ - > $whitespace$ type. reindex ( ) ). filter ( erasedtype $whitespace$ - > $whitespace$! ( isjavaobject ( erasedtype ) ) ). filter ( erasedtype $whitespace$ - > $whitespace$ erasedtype $whitespace$!= $whitespace$ null ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ erasedparameters ; $newline$ $indentation$ }			
getAllFieldsVisibleToInheritors	413	417	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.0147522939369082	LOW	"		public List<ResolvedFieldDeclaration> getAllFieldsVisibleToInheritors(){
		    List<ResolvedFieldDeclaration> res = new LinkedList<>(this.getDeclaredFields().stream().filter(f -> f.accessSpecifier() != AccessSpecifier.PRIVATE).collect(Collectors.toList()));
		    getDirectAncestors().forEach(a -> res.addAll(a.getAllFieldsVisibleToInheritors()));
		    return res;
		}"	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfieldsvisibletoinheritors ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( this . getdeclaredfields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . accessspecifier ( ) $whitespace$ != $whitespace$ accessspecifier . private ) . collect ( collectors . tolist ( ) ) ) ; $newline$ $indentation$ getdirectancestors ( ) . foreach ( a $whitespace$ - > $whitespace$ res . addall ( a . getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfieldsvisibletoinheritors ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( this. getdeclaredfields ( ). stream ( ). filter ( f $whitespace$ - > $whitespace$ f. accessspecifier ( ) $whitespace$!= $whitespace$ accessspecifier. private ). collect ( collectors. tolist ( ) ) ) ; $newline$ $indentation$ getdirectancestors ( ). foreach ( a $whitespace$ - > $whitespace$ res. addall ( a. getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }			
compareConsideringTypeParameters	442	488	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.0303919166326522	LOW	"		protected boolean compareConsideringTypeParameters(ResolvedReferenceType other){
		    if (other.equals(this)) {
		        return true;
		    }
		    if (this.getQualifiedName().equals(other.getQualifiedName())) {
		        if (this.isRawType() || other.isRawType()) {
		            return true;
		        }
		        List<ResolvedType> typeParametersValues = typeParametersValues();
		        if (typeParametersValues.size() != other.typeParametersValues().size()) {
		            throw new IllegalStateException();
		        }
		        for (int i = 0; i < typeParametersValues.size(); i++) {
		            ResolvedType thisParam = typeParametersValues.get(i);
		            ResolvedType otherParam = other.typeParametersValues().get(i);
		            if (!thisParam.equals(otherParam)) {
		                if (thisParam instanceof ResolvedWildcard) {
		                    ResolvedWildcard thisParamAsWildcard = (ResolvedWildcard) thisParam;
		                    if (thisParamAsWildcard.isSuper() && otherParam.isAssignableBy(thisParamAsWildcard.getBoundedType())) {
		                        // ok
		                    } else if (thisParamAsWildcard.isExtends() && thisParamAsWildcard.getBoundedType().isAssignableBy(otherParam)) {
		                        // ok
		                    } else if (!thisParamAsWildcard.isBounded()) {
		                        // ok
		                    } else {
		                        return false;
		                    }
		                } else {
		                    if (thisParam instanceof ResolvedTypeVariable && otherParam instanceof ResolvedTypeVariable) {
		                        List<ResolvedType> thisBounds = thisParam.asTypeVariable().asTypeParameter().getBounds().stream().map(ResolvedTypeParameterDeclaration.Bound::getType).collect(Collectors.toList());
		                        List<ResolvedType> otherBounds = otherParam.asTypeVariable().asTypeParameter().getBounds().stream().map(ResolvedTypeParameterDeclaration.Bound::getType).collect(Collectors.toList());
		                        return thisBounds.size() == otherBounds.size() && otherBounds.containsAll(thisBounds);
		                    }
		                    if (!(thisParam instanceof ResolvedTypeVariable) && otherParam instanceof ResolvedTypeVariable) {
		                        return compareConsideringVariableTypeParameters(thisParam, (ResolvedTypeVariable) otherParam);
		                    }
		                    if (thisParam instanceof ResolvedTypeVariable && !(otherParam instanceof ResolvedTypeVariable)) {
		                        return compareConsideringVariableTypeParameters(otherParam, (ResolvedTypeVariable) thisParam);
		                    }
		                    return false;
		                }
		            }
		        }
		        return true;
		    }
		    return false;
		}"	$indentation$ protected $whitespace$ boolean $whitespace$ compareconsideringtypeparameters ( resolvedreferencetype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other . equals ( this ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( this . getqualifiedname ( ) . equals ( other . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this . israwtype ( ) $whitespace$ || $whitespace$ other . israwtype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparametersvalues $whitespace$ = $whitespace$ typeparametersvalues ( ) ; $newline$ $indentation$ if $whitespace$ ( typeparametersvalues . size ( ) $whitespace$ != $whitespace$ other . typeparametersvalues ( ) . size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparametersvalues . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ thisparam $whitespace$ = $whitespace$ typeparametersvalues . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ otherparam $whitespace$ = $whitespace$ other . typeparametersvalues ( ) . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ! thisparam . equals ( otherparam ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( thisparam $whitespace$ instanceof $whitespace$ resolvedwildcard ) $whitespace$ { $newline$ $indentation$ resolvedwildcard $whitespace$ thisparamaswildcard $whitespace$ = $whitespace$ ( resolvedwildcard ) $whitespace$ thisparam ; $newline$ $indentation$ if $whitespace$ ( thisparamaswildcard . issuper ( ) $whitespace$ && $whitespace$ otherparam . isassignableby ( thisparamaswildcard . getboundedtype ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·ok$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( thisparamaswildcard . isextends ( ) $whitespace$ && $whitespace$ thisparamaswildcard . getboundedtype ( ) . isassignableby ( otherparam ) ) $whitespace$ { $newline$ $indentation$ $//·ok$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ! thisparamaswildcard . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ $//·ok$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ if $whitespace$ ( thisparam $whitespace$ instanceof $whitespace$ resolvedtypevariable $whitespace$ && $whitespace$ otherparam $whitespace$ instanceof $whitespace$ resolvedtypevariable ) $whitespace$ { $newline$ $indentation$ list < resolvedtype > $whitespace$ thisbounds $whitespace$ = $whitespace$ thisparam . astypevariable ( ) . astypeparameter ( ) . getbounds ( ) . stream ( ) . map ( resolvedtypeparameterdeclaration . bound : : gettype ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ otherbounds $whitespace$ = $whitespace$ otherparam . astypevariable ( ) . astypeparameter ( ) . getbounds ( ) . stream ( ) . map ( resolvedtypeparameterdeclaration . bound : : gettype ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ thisbounds . size ( ) $whitespace$ == $whitespace$ otherbounds . size ( ) $whitespace$ && $whitespace$ otherbounds . containsall ( thisbounds ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( thisparam $whitespace$ instanceof $whitespace$ resolvedtypevariable ) $whitespace$ && $whitespace$ otherparam $whitespace$ instanceof $whitespace$ resolvedtypevariable ) $whitespace$ { $newline$ $indentation$ return $whitespace$ compareconsideringvariabletypeparameters ( thisparam , $whitespace$ ( resolvedtypevariable ) $whitespace$ otherparam ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( thisparam $whitespace$ instanceof $whitespace$ resolvedtypevariable $whitespace$ && $whitespace$ ! ( otherparam $whitespace$ instanceof $whitespace$ resolvedtypevariable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ compareconsideringvariabletypeparameters ( otherparam , $whitespace$ ( resolvedtypevariable ) $whitespace$ thisparam ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ boolean $whitespace$ compareconsideringtypeparameters ( resolvedreferencetype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other. equals ( this ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( this. getqualifiedname ( ). equals ( other. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( this. israwtype ( ) $whitespace$ || $whitespace$ other. israwtype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparametersvalues. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ thisparam $whitespace$ = $whitespace$ typeparametersvalues. get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ otherparam $whitespace$ = $whitespace$ other. typeparametersvalues ( ). get ( i ) ; $newline$ $indentation$ if $whitespace$ (! thisparam. equals ( otherparam ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( thisparam $whitespace$ instanceof $whitespace$ resolvedwildcard ) $whitespace$ { $newline$ $indentation$			
getTypeParametersMap	280	288	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.0764288306236267	LOW	"		public List<Pair<ResolvedTypeParameterDeclaration, ResolvedType>> getTypeParametersMap(){
		    List<Pair<ResolvedTypeParameterDeclaration, ResolvedType>> typeParametersMap = new ArrayList<>();
		    if (!isRawType()) {
		        for (int i = 0; i < typeDeclaration.getTypeParameters().size(); i++) {
		            typeParametersMap.add(new Pair<>(typeDeclaration.getTypeParameters().get(i), typeParametersValues().get(i)));
		        }
		    }
		    return typeParametersMap;
		}"	$indentation$ public $whitespace$ list < pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype >> $whitespace$ gettypeparametersmap ( ) { $newline$ $indentation$ list < pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype >> $whitespace$ typeparametersmap $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( ! israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typedeclaration . gettypeparameters ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ typeparametersmap . add ( new $whitespace$ pair < > ( typedeclaration . gettypeparameters ( ) . get ( i ) , $whitespace$ typeparametersvalues ( ) . get ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparametersmap ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < pair < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype >> $whitespace$ gettypeparametersmap ( ) { $newline$ $indentation$ list < pair < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype >> $whitespace$ typeparametersmap $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ (! israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typedeclaration. gettypeparameters ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ typeparametersmap. add ( new $whitespace$ pair < > ( typedeclaration. gettypeparameters ( ). get ( i ), $whitespace$ typeparametersvalues ( ). get ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparametersmap ; $newline$ $indentation$ }			
replaceTypeVariables	168	199	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.1262858808040619	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tpToReplace, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    if (replaced == null) {
		        throw new IllegalArgumentException();
		    }
		    ResolvedReferenceType result = this;
		    int i = 0;
		    for (ResolvedType tp : this.typeParametersValues()) {
		        ResolvedType transformedTp = tp.replaceTypeVariables(tpToReplace, replaced, inferredTypes);
		        // Identity comparison on purpose
		        if (tp.isTypeVariable() && tp.asTypeVariable().describe().equals(tpToReplace.getName())) {
		            inferredTypes.put(tp.asTypeParameter(), replaced);
		        }
		        // FIXME
		        if (true) {
		            List<ResolvedType> typeParametersCorrected = result.asReferenceType().typeParametersValues();
		            typeParametersCorrected.set(i, transformedTp);
		            result = create(typeDeclaration, typeParametersCorrected);
		        }
		        i++;
		    }
		    List<ResolvedType> values = result.typeParametersValues();
		    // FIXME
		    if (values.contains(tpToReplace)) {
		        int index = values.indexOf(tpToReplace);
		        values.set(index, replaced);
		        if (result.getTypeDeclaration().isPresent()) {
		            return create(result.getTypeDeclaration().get(), values);
		        }
		    }
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( replaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetype $whitespace$ result $whitespace$ = $whitespace$ this ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ tp $whitespace$ : $whitespace$ this . typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ transformedtp $whitespace$ = $whitespace$ tp . replacetypevariables ( tptoreplace , $whitespace$ replaced , $whitespace$ inferredtypes ) ; $newline$ $indentation$ $//·identity·comparison·on·purpose$ $newline$ $indentation$ if $whitespace$ ( tp . istypevariable ( ) $whitespace$ && $whitespace$ tp . astypevariable ( ) . describe ( ) . equals ( tptoreplace . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ inferredtypes . put ( tp . astypeparameter ( ) , $whitespace$ replaced ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·fixme$ $newline$ $indentation$ if $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparameterscorrected $whitespace$ = $whitespace$ result . asreferencetype ( ) . typeparametersvalues ( ) ; $newline$ $indentation$ typeparameterscorrected . set ( i , $whitespace$ transformedtp ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ create ( typedeclaration , $whitespace$ typeparameterscorrected ) ; $newline$ $indentation$ } $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ values $whitespace$ = $whitespace$ result . typeparametersvalues ( ) ; $newline$ $indentation$ $//·fixme$ $newline$ $indentation$ if $whitespace$ ( values . contains ( tptoreplace ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ values . indexof ( tptoreplace ) ; $newline$ $indentation$ values . set ( index , $whitespace$ replaced ) ; $newline$ $indentation$ if $whitespace$ ( result . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ create ( result . gettypedeclaration ( ) . get ( ) , $whitespace$ values ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( replaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetype $whitespace$ result $whitespace$ = $whitespace$ this ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ tp $whitespace$ : $whitespace$ this. typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ transformedtp $whitespace$ = $whitespace$ tp. replacetypevariables ( tptoreplace, $whitespace$ replaced, $whitespace$ inferredtypes ) ; $newline$ $indentation$ $////////////////////////////////////identity $whitespace$ = $whitespace$ is $whitespace$ null $newline$ $indentation$ if $whitespace$ ( tp. istypevariable ( ) $whitespace$ && $whitespace$ tp. astypevariable ( ). describe ( ). equals ( tptoreplace. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ inferredtypes. put ( tp. astypeparameter ( ), $whitespace$ replaced ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$			
describe	144	158	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.1291238069534301	LOW	"		@Override
		public String describe(){
		    StringBuilder sb = new StringBuilder();
		    if (hasName()) {
		        sb.append(typeDeclaration.getQualifiedName());
		    } else {
		        sb.append(""<anonymous class>"");
		    }
		    if (!typeParametersMap().isEmpty()) {
		        sb.append(""<"");
		        sb.append(String.join("", "", typeDeclaration.getTypeParameters().stream().map(tp -> typeParametersMap().getValue(tp).describe()).collect(Collectors.toList())));
		        sb.append("">"");
		    }
		    return sb.toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ describe ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ if $whitespace$ ( hasname ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( typedeclaration . getqualifiedname ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! typeparametersmap ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ sb . append ( string . join ( $string$ , $whitespace$ typedeclaration . gettypeparameters ( ) . stream ( ) . map ( tp $whitespace$ - > $whitespace$ typeparametersmap ( ) . getvalue ( tp ) . describe ( ) ) . collect ( collectors . tolist ( ) ) ) ) ; $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ describe ( ) { $newline$ $indentation$ string $whitespace$ value $whitespace$ = $whitespace$ controller. getvalue ( ) ; $newline$ $indentation$ if $whitespace$ (! typeparametersmap ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ sb. append ( string. join ( $string$, $whitespace$ value ) ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! typeparametersmap ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ sb. append ( string. join ( $string$, $whitespace$ value ) ) ; $newline$ $indentation$ sb. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb. tostring ( ) ; $newline$ $indentation$ }			
getAllMethods	397	407	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.2617027163505554	LOW	"		public List<ResolvedMethodDeclaration> getAllMethods(){
		    if (!this.getTypeDeclaration().isPresent()) {
		        // empty list -- consider IllegalStateException or similar
		        return new ArrayList<>();
		    }
		    // Get the methods declared directly on this.
		    List<ResolvedMethodDeclaration> allMethods = new LinkedList<>(this.getTypeDeclaration().get().getDeclaredMethods());
		    // Also get methods inherited from ancestors.
		    getDirectAncestors().forEach(a -> allMethods.addAll(a.getAllMethods()));
		    return allMethods;
		}"	$indentation$ public $whitespace$ list < resolvedmethoddeclaration > $whitespace$ getallmethods ( ) { $newline$ $indentation$ if $whitespace$ ( ! this . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·empty·list·--·consider·illegalstateexception·or·similar$ $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·get·the·methods·declared·directly·on·this.$ $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ allmethods $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( this . gettypedeclaration ( ) . get ( ) . getdeclaredmethods ( ) ) ; $newline$ $indentation$ $//·also·get·methods·inherited·from·ancestors.$ $newline$ $indentation$ getdirectancestors ( ) . foreach ( a $whitespace$ - > $whitespace$ allmethods . addall ( a . getallmethods ( ) ) ) ; $newline$ $indentation$ return $whitespace$ allmethods ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedmethoddeclaration > $whitespace$ getallmethods ( ) { $newline$ $indentation$ if $whitespace$ (! this. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( this. gettypedeclaration ( ). get ( ). getdeclaredmethods ( ) ) ; $newline$ $indentation$ $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( this. gettypedeclaration ( ). get ( ). getdeclaredmethods ( ) ) ; $newline$ $indentation$ return $whitespace$ allmethods ; $newline$ $indentation$ }			
deriveParams	506	515	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.2802808582782745	LOW	"		private static List<ResolvedType> deriveParams(ResolvedReferenceTypeDeclaration typeDeclaration){
		    if (typeDeclaration == null) {
		        throw new IllegalArgumentException(""TypeDeclaration is not expected to be null"");
		    }
		    List<ResolvedTypeParameterDeclaration> typeParameters = typeDeclaration.getTypeParameters();
		    if (typeParameters == null) {
		        throw new RuntimeException(""Type parameters are not expected to be null"");
		    }
		    return typeParameters.stream().map(ResolvedTypeVariable::new).collect(Collectors.toList());
		}"	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ deriveparams ( resolvedreferencetypedeclaration $whitespace$ typedeclaration ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typeparameters $whitespace$ = $whitespace$ typedeclaration . gettypeparameters ( ) ; $newline$ $indentation$ if $whitespace$ ( typeparameters $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparameters . stream ( ) . map ( resolvedtypevariable : : new ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ list < resolvedtype > $whitespace$ deriveparams ( resolvedreferencetypedeclaration $whitespace$ typedeclaration ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typeparameters $whitespace$ = $whitespace$ typedeclaration. gettypeparameters ( ) ; $newline$ $indentation$ if $whitespace$ ( typeparameters $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparameters. stream ( ). map ( resolvedtypevariable : : new ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
equals	87	100	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.2866405248641968	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || (!isLazyType(o) && getClass() != o.getClass()) || (isLazyType(o) && !this.equals(asResolvedReferenceType(o))))
		        return false;
		    ResolvedReferenceType that = asResolvedReferenceType(o);
		    if (!typeDeclaration.equals(that.typeDeclaration))
		        return false;
		    if (!typeParametersMap.equals(that.typeParametersMap))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ( ! islazytype ( o ) $whitespace$ && $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $whitespace$ || $whitespace$ ( islazytype ( o ) $whitespace$ && $whitespace$ ! this . equals ( asresolvedreferencetype ( o ) ) ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ resolvedreferencetype $whitespace$ that $whitespace$ = $whitespace$ asresolvedreferencetype ( o ) ; $newline$ $indentation$ if $whitespace$ ( ! typedeclaration . equals ( that . typedeclaration ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! typeparametersmap . equals ( that . typeparametersmap ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! objects. equals ( this. typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! objects. equals ( this. typeparametersmap ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
erasure	571	576	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.7051900029182434	MID	"		@Override
		public ResolvedType erasure(){
		    if (!typeDeclaration.isGeneric())
		        return this;
		    return create(typeDeclaration, erasureOfParamaters(typeParametersMap));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ erasure ( ) { $newline$ $indentation$ if $whitespace$ ( ! typedeclaration . isgeneric ( ) ) $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ return $whitespace$ create ( typedeclaration , $whitespace$ erasureofparamaters ( typeparametersmap ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ e ( ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration. isgeneric ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ create ( typedeclaration, $whitespace$ chanofparamaters ( typeparametersmap ) ) ; $newline$ $indentation$ }			
asResolvedReferenceType	106	111	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.721583366394043	MID	"		private ResolvedReferenceType asResolvedReferenceType(Object o){
		    if (isLazyType(o)) {
		        return ((LazyType) o).asReferenceType();
		    }
		    return ResolvedReferenceType.class.cast(o);
		}"	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ asresolvedreferencetype ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( islazytype ( o ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( lazytype ) $whitespace$ o ) . asreferencetype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedreferencetype . class . cast ( o ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ asresolvedreferencetype ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( islazytype ( o ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( lazytype ) $whitespace$ o ). asreferencetype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedreferencetype. class. cast ( o ) ; $newline$ $indentation$ }			
isRawType	357	364	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedReferenceType.java	0.8342404961585999	HIGH	"		public boolean isRawType(){
		    if (!typeDeclaration.getTypeParameters().isEmpty()) {
		        if (typeParametersMap().isEmpty()) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ israwtype ( ) { $newline$ $indentation$ if $whitespace$ ( ! typedeclaration . gettypeparameters ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparametersmap ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ israwtype ( ) { $newline$ $indentation$ if $whitespace$ (! typedeclaration. gettypeparameters ( ). isempty ( ) $whitespace$ && $whitespace$ typeparametersmap ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
replaceTypeVariables	78	85	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedTypeVariable.java	0.2267216444015503	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tpToBeReplaced, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    if (tpToBeReplaced.getName().equals(this.typeParameter.getName())) {
		        inferredTypes.put(this.asTypeParameter(), replaced);
		        return replaced;
		    }
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptobereplaced , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( tptobereplaced . getname ( ) . equals ( this . typeparameter . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ inferredtypes . put ( this . astypeparameter ( ) , $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ replaced ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptobereplaced, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( tptobereplaced. getname ( ). equals ( this. typeparameter. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ inferredtypes. put ( this. astypeparameter ( ), $whitespace$ replaced ) ; $newline$ $indentation$ return $whitespace$ replaced ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
equals	52	66	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedTypeVariable.java	0.2746398746967315	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ResolvedTypeVariable that = (ResolvedTypeVariable) o;
		    if (!typeParameter.getName().equals(that.typeParameter.getName()))
		        return false;
		    if (typeParameter.declaredOnType() != that.typeParameter.declaredOnType())
		        return false;
		    if (typeParameter.declaredOnMethod() != that.typeParameter.declaredOnMethod())
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ resolvedtypevariable $whitespace$ that $whitespace$ = $whitespace$ ( resolvedtypevariable ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! typeparameter . getname ( ) . equals ( that . typeparameter . getname ( ) ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( typeparameter . declaredontype ( ) $whitespace$ != $whitespace$ that . typeparameter . declaredontype ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( typeparameter . declaredonmethod ( ) $whitespace$ != $whitespace$ that . typeparameter . declaredonmethod ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$! typeparameter. getname ( ). equals ( that. typeparameter. getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ (! typeparameter. getname ( ). equals ( that. typeparameter. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeparameter. declaredontype ( ) $whitespace$!= $whitespace$ that. typeparameter. declaredontype ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
erasure	131	137	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedTypeVariable.java	0.6869720816612244	MID	"		@Override
		public ResolvedType erasure(){
		    if (typeParameter.isBounded()) {
		        return typeParameter.getBounds().get(0).getType();
		    }
		    return typeParameter.object();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ erasure ( ) { $newline$ $indentation$ if $whitespace$ ( typeparameter . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeparameter . getbounds ( ) . get ( $number$ ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparameter . object ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$任 ( ) { $newline$ $indentation$ if $whitespace$ ( typeparameter. isbounded ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeparameter. getbounds ( ). get ( $number$ ). gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparameter. object ( ) ; $newline$ $indentation$ }			
getCommonAncestor	44	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedUnionType.java	0.0166909154504537	LOW	"		public Optional<ResolvedReferenceType> getCommonAncestor(){
		    Optional<List<ResolvedReferenceType>> reduce = elements.stream().map(ResolvedType::asReferenceType).map(rt -> rt.getAllAncestors(ResolvedReferenceTypeDeclaration.breadthFirstFunc)).reduce((a, b) -> {
		        ArrayList<ResolvedReferenceType> common = new ArrayList<>(a);
		        common.retainAll(b);
		        return common;
		    });
		    return reduce.orElse(new ArrayList<>()).stream().findFirst();
		}"	$indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getcommonancestor ( ) { $newline$ $indentation$ optional < list < resolvedreferencetype >> $whitespace$ reduce $whitespace$ = $whitespace$ elements . stream ( ) . map ( resolvedtype : : asreferencetype ) . map ( rt $whitespace$ - > $whitespace$ rt . getallancestors ( resolvedreferencetypedeclaration . breadthfirstfunc ) ) . reduce ( ( a , $whitespace$ b ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ arraylist < resolvedreferencetype > $whitespace$ common $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( a ) ; $newline$ $indentation$ common . retainall ( b ) ; $newline$ $indentation$ return $whitespace$ common ; $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ reduce . orelse ( new $whitespace$ arraylist < > ( ) ) . stream ( ) . findfirst ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getcommonancestor ( ) { $newline$ $indentation$ optional < list < resolvedreferencetype >> $whitespace$ reduce $whitespace$ = $whitespace$ elements. stream ( ) $newline$ $indentation$. map ( resolvedtype : : asreferencetype ) $newline$ $indentation$. map ( rt $whitespace$ - > $whitespace$ rt. getallancestors ( resolvedreferencetypedeclaration. breadthfirstfunc ) ) $newline$ $indentation$. reduce ( ( a, $whitespace$ b ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ arraylist < resolvedreferencetype > $whitespace$ common $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( a ) ; $newline$ $indentation$ common. retainall ( b ) ; $newline$ $indentation$ return $whitespace$ common ; $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ reduce. orelse ( new $whitespace$ arraylist < > ( ) ). stream ( ). findfirst ( ) ; $newline$ $indentation$ }			
isAssignableBy	40	54	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedVoidType.java	0.9567941427230836	HIGH	"		@Override
		public boolean isAssignableBy(ResolvedType other){
		    // According to https://docs.oracle.com/javase/specs/jls/se16/html/jls-14.html#jls-14.8:
		    // """"""
		    // Note that the Java programming language does not allow a ""cast to void"" - void is not a type - so the
		    // traditional C trick of writing an expression statement such as:
		    //
		    // (void)... ;  // incorrect!
		    //
		    // does not work.
		    // """"""
		    //
		    // In short, nothing can be assign to ""void"".
		    return false;
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ $//·according·to·https://docs.oracle.com/javase/specs/jls/se16/html/jls-14.html#jls-14.8:$ $newline$ $indentation$ $//·""""""$ $newline$ $indentation$ $//·note·that·the·java·programming·language·does·not·allow·a·""cast·to·void""·-·void·is·not·a·type·-·so·the$ $newline$ $indentation$ $//·traditional·c·trick·of·writing·an·expression·statement·such·as:$ $newline$ $indentation$ // $newline$ $indentation$ $//·(void)...·;··//·incorrect!$ $newline$ $indentation$ // $newline$ $indentation$ $//·does·not·work.$ $newline$ $indentation$ $//·""""""$ $newline$ $indentation$ // $newline$ $indentation$ $//·in·short,·nothing·can·be·assign·to·""void"".$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ $indentation$ $whitespace$// $newline$ $indentation$ // $whitespace$ define $whitespace$ the $whitespace$ resolvedtype $whitespace$ other $whitespace$ configurations $newline$ $indentation$ $indentation$ $whitespace$// $newline$ $indentation$ // $whitespace$ reflect $whitespace$ a $whitespace$ brand $whitespace$ new $whitespace$ state $whitespace$ that $whitespace$ the $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
replaceTypeVariables	149	165	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedWildcard.java	0.1271240413188934	LOW	"		@Override
		public ResolvedType replaceTypeVariables(ResolvedTypeParameterDeclaration tpToReplace, ResolvedType replaced, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    if (replaced == null) {
		        throw new IllegalArgumentException();
		    }
		    if (boundedType == null) {
		        return this;
		    }
		    ResolvedType boundedTypeReplaced = boundedType.replaceTypeVariables(tpToReplace, replaced, inferredTypes);
		    if (boundedTypeReplaced == null) {
		        throw new RuntimeException();
		    }
		    if (boundedTypeReplaced != boundedType) {
		        return new ResolvedWildcard(type, boundedTypeReplaced);
		    }
		    return this;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace , $whitespace$ resolvedtype $whitespace$ replaced , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( replaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( boundedtype $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ boundedtypereplaced $whitespace$ = $whitespace$ boundedtype . replacetypevariables ( tptoreplace , $whitespace$ replaced , $whitespace$ inferredtypes ) ; $newline$ $indentation$ if $whitespace$ ( boundedtypereplaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( boundedtypereplaced $whitespace$ != $whitespace$ boundedtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedwildcard ( type , $whitespace$ boundedtypereplaced ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ replacetypevariables ( resolvedtypeparameterdeclaration $whitespace$ tptoreplace, $whitespace$ resolvedtype $whitespace$ replaced, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( replaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( boundedtype $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ boundedtypereplaced $whitespace$ = $whitespace$ boundedtype. replacetypevariables ( tptoreplace, $whitespace$ replaced, $whitespace$ inferredtypes ) ; $newline$ $indentation$ if $whitespace$ ( boundedtypereplaced $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( boundedtypereplaced $whitespace$!= $whitespace$ boundedtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedwildcard ( type, $whitespace$ boundedtypereplaced ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
describe	101	113	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedWildcard.java	0.7299005389213562	MID	"		@Override
		public String describe(){
		    if (type == null) {
		        return ""?"";
		    }
		    if (type == BoundType.SUPER) {
		        return ""? super "" + boundedType.describe();
		    }
		    if (type == BoundType.EXTENDS) {
		        return ""? extends "" + boundedType.describe();
		    }
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ describe ( ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype . super ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ boundedtype . describe ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype . extends ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ boundedtype . describe ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ describe ( ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype. super ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ boundedtype. describe ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype. extends ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ boundedtype. describe ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
isAssignableBy	134	147	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/ResolvedWildcard.java	0.8731824159622192	HIGH	"		@Override
		public boolean isAssignableBy(ResolvedType other){
		    if (boundedType == null) {
		        // return other.isReferenceType() && other.asReferenceType().getQualifiedName().equals(Object.class.getCanonicalName());
		        return false;
		    }
		    if (type == BoundType.SUPER) {
		        return boundedType.isAssignableBy(other);
		    }
		    if (type == BoundType.EXTENDS) {
		        return false;
		    }
		    throw new RuntimeException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( boundedtype $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·return·other.isreferencetype()·&&·other.asreferencetype().getqualifiedname().equals(object.class.getcanonicalname());$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype . super ) $whitespace$ { $newline$ $indentation$ return $whitespace$ boundedtype . isassignableby ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype . extends ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( boundedtype $whitespace$ == $whitespace$ null $whitespace$ && $whitespace$ boundedtype. isassignableby ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype. super ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ boundtype. extends ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ }			
useThisTypeParametersOnTheGivenType	44	71	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/parametrization/ResolvedTypeParameterValueProvider.java	0.1069271042943	LOW	"		 ResolvedType useThisTypeParametersOnTheGivenType(ResolvedType type){
		    if (type.isTypeVariable()) {
		        ResolvedTypeParameterDeclaration typeParameter = type.asTypeParameter();
		        if (typeParameter.declaredOnType()) {
		            Optional<ResolvedType> typeParam = typeParamValue(typeParameter);
		            if (typeParam.isPresent()) {
		                ResolvedType resolvedTypeParam = typeParam.get();
		                // Try to avoid an infinite loop when the type is a wildcard type bounded by a type variable like ""? super T""
		                if (resolvedTypeParam.isWildcard() && (!resolvedTypeParam.asWildcard().equals(ResolvedWildcard.UNBOUNDED) && type.equals(resolvedTypeParam.asWildcard().getBoundedType()))) {
		                    return type;
		                }
		                type = resolvedTypeParam;
		            }
		        }
		    }
		    if (type.isWildcard() && type.asWildcard().isBounded()) {
		        if (type.asWildcard().isExtends()) {
		            return ResolvedWildcard.extendsBound(useThisTypeParametersOnTheGivenType(type.asWildcard().getBoundedType()));
		        }
		        return ResolvedWildcard.superBound(useThisTypeParametersOnTheGivenType(type.asWildcard().getBoundedType()));
		    }
		    if (type.isReferenceType()) {
		        type = type.asReferenceType().transformTypeParameters(this::useThisTypeParametersOnTheGivenType);
		    }
		    return type;
		}"	"$indentation$ resolvedtype $whitespace$ usethistypeparametersonthegiventype ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ typeparameter $whitespace$ = $whitespace$ type . astypeparameter ( ) ; $newline$ $indentation$ if $whitespace$ ( typeparameter . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedtype > $whitespace$ typeparam $whitespace$ = $whitespace$ typeparamvalue ( typeparameter ) ; $newline$ $indentation$ if $whitespace$ ( typeparam . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ resolvedtypeparam $whitespace$ = $whitespace$ typeparam . get ( ) ; $newline$ $indentation$ $//·try·to·avoid·an·infinite·loop·when·the·type·is·a·wildcard·type·bounded·by·a·type·variable·like·""?·super·t""$ $newline$ $indentation$ if $whitespace$ ( resolvedtypeparam . iswildcard ( ) $whitespace$ && $whitespace$ ( ! resolvedtypeparam . aswildcard ( ) . equals ( resolvedwildcard . unbounded ) $whitespace$ && $whitespace$ type . equals ( resolvedtypeparam . aswildcard ( ) . getboundedtype ( ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ type $whitespace$ = $whitespace$ resolvedtypeparam ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . iswildcard ( ) $whitespace$ && $whitespace$ type . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . extendsbound ( usethistypeparametersonthegiventype ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedwildcard . superbound ( usethistypeparametersonthegiventype ( type . aswildcard ( ) . getboundedtype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type . asreferencetype ( ) . transformtypeparameters ( this : : usethistypeparametersonthegiventype ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }"	$indentation$ resolvedtype $whitespace$ usethistypeparametersonthegiventype ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type. istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameter. declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ // $whitespace$ get $whitespace$ the $whitespace$ current $whitespace$ property $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedtype > $whitespace$ typeparam $whitespace$ = $whitespace$ typeparamvalue ( typeparameter ) ; $newline$ $indentation$ if $whitespace$ ( typeparam. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ resolvedtypeparam $whitespace$ = $whitespace$ typeparam. get ( ) ; $newline$ $indentation$ $//hee $whitespace$ = $whitespace$ resolvedtypeparam ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. iswildcard ( ) $whitespace$ && $whitespace$ type. aswildcard ( ).			
replaceAll	133	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/resolution/types/parametrization/ResolvedTypeParametersMap.java	0.2534340620040893	LOW	"		public ResolvedType replaceAll(ResolvedType type){
		    Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		    for (ResolvedTypeParameterDeclaration typeParameterDeclaration : this.nameToDeclaration.values()) {
		        type = type.replaceTypeVariables(typeParameterDeclaration, getValue(typeParameterDeclaration), inferredTypes);
		    }
		    return type;
		}"	$indentation$ public $whitespace$ resolvedtype $whitespace$ replaceall ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ typeparameterdeclaration $whitespace$ : $whitespace$ this . nametodeclaration . values ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type . replacetypevariables ( typeparameterdeclaration , $whitespace$ getvalue ( typeparameterdeclaration ) , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedtype $whitespace$ replaceall ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ typeparameterdeclaration $whitespace$ : $whitespace$ this. nametodeclaration. values ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type. replacetypevariables ( typeparameterdeclaration, $whitespace$ getvalue ( typeparameterdeclaration ), $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
isPrimitiveOrWrapper	68	73	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/ClassUtils.java	0.7360056638717651	MID	"		public static boolean isPrimitiveOrWrapper(final Class<?> type){
		    if (type == null) {
		        return false;
		    }
		    return type.isPrimitive() || isPrimitiveWrapper(type);
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isprimitiveorwrapper ( final $whitespace$ class < ? > $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type . isprimitive ( ) $whitespace$ || $whitespace$ isprimitivewrapper ( type ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isprimitiveorwrapper ( final $whitespace$ class <? > $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ == $whitespace$ null ) $whitespace$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ type. isprimitive ( ) $whitespace$ || $whitespace$ isprimitivewrapper ( type ) ; $newline$ $indentation$ }			
subtractPaths	152	162	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/CodeGenerationUtils.java	0.6436474323272705	MID	"		public static Path subtractPaths(Path full, Path difference){
		    while (difference != null) {
		        if (difference.getFileName().equals(full.getFileName())) {
		            difference = difference.getParent();
		            full = full.getParent();
		        } else {
		            throw new RuntimeException(f(""'%s' could not be subtracted from '%s'"", difference, full));
		        }
		    }
		    return full;
		}"	$indentation$ public $whitespace$ static $whitespace$ path $whitespace$ subtractpaths ( path $whitespace$ full , $whitespace$ path $whitespace$ difference ) { $newline$ $indentation$ while $whitespace$ ( difference $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( difference . getfilename ( ) . equals ( full . getfilename ( ) ) ) $whitespace$ { $newline$ $indentation$ difference $whitespace$ = $whitespace$ difference . getparent ( ) ; $newline$ $indentation$ full $whitespace$ = $whitespace$ full . getparent ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( f ( $string$ , $whitespace$ difference , $whitespace$ full ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ full ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ path $whitespace$ subtractpaths ( path $whitespace$ full, $whitespace$ path $whitespace$ difference ) { $newline$ $indentation$ while $whitespace$ ( difference $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( difference. getfilename ( ). equals ( full. getfilename ( ) ) ) $whitespace$ { $newline$ $indentation$ difference $whitespace$ = $whitespace$ difference. getparent ( ) ; $newline$ $indentation$ full $whitespace$ = $whitespace$ full. getparent ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ full ; $newline$ $indentation$ }			
classLoaderRoot	133	139	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/CodeGenerationUtils.java	0.6680303812026978	MID	"		public static Path classLoaderRoot(Class<?> c){
		    try {
		        return Paths.get(c.getProtectionDomain().getCodeSource().getLocation().toURI());
		    } catch (URISyntaxException e) {
		        throw new AssertionError(""Bug in JavaParser, please report."", e);
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ path $whitespace$ classloaderroot ( class < ? > $whitespace$ c ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ paths . get ( c . getprotectiondomain ( ) . getcodesource ( ) . getlocation ( ) . touri ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( urisyntaxexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ path $whitespace$ classloaderroot ( class <? > $whitespace$ c ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ paths. get ( c. getprotectiondomain ( ). getcodesource ( ). getlocation ( ). touri ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( urisyntaxexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$, $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
optionalOf	69	74	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/CodeGenerationUtils.java	0.9306097626686096	HIGH	"		public static String optionalOf(String text, boolean isOptional){
		    if (isOptional) {
		        return f(""Optional.of(%s)"", text);
		    }
		    return ""Optional.empty()"";
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ optionalof ( string $whitespace$ text , $whitespace$ boolean $whitespace$ isoptional ) { $newline$ $indentation$ if $whitespace$ ( isoptional ) $whitespace$ { $newline$ $indentation$ return $whitespace$ f ( $string$ , $whitespace$ text ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ optionalof ( string $whitespace$ text, $whitespace$ boolean $whitespace$ isoptional ) { $newline$ $indentation$ return $whitespace$ isoptional ) $whitespace$? $whitespace$ f ( $string$, $whitespace$ text ) $whitespace$ : $whitespace$ f ( $string$, $whitespace$ text ) ; $newline$ $indentation$ }			
getRoot	45	73	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/CollectionStrategy.java	0.1926883161067962	LOW	"		 Optional<Path> getRoot(Path file){
		    try {
		        final JavaParser javaParser = new JavaParser(getParserConfiguration());
		        final ParseResult<CompilationUnit> parseResult = javaParser.parse(file);
		        if (parseResult.isSuccessful()) {
		            if (parseResult.getResult().isPresent()) {
		                final Optional<CompilationUnit.Storage> storage = parseResult.getResult().flatMap(CompilationUnit::getStorage);
		                if (storage.isPresent()) {
		                    if (""module-info.java"".equals(storage.get().getFileName())) {
		                        // module-info.java is useless for finding the source root, since it can be placed in any directory.
		                        return Optional.empty();
		                    }
		                    return storage.map(CompilationUnit.Storage::getSourceRoot);
		                }
		                Log.info(""Storage information not present -- an issue with providing a string rather than file reference?"");
		            }
		            Log.info(""Parse result not present"");
		        }
		        Log.info(""Parsing was not successful."");
		        Log.info(""There were (%d) problems parsing file: %s"", () -> parseResult.getProblems().size(), parseResult::getProblems);
		    } catch (ParseProblemException e) {
		        Log.info(""Problem parsing file %s : %s"", () -> file, () -> e.getLocalizedMessage());
		    } catch (RuntimeException e) {
		        Log.info(""Could not parse file %s : %s"", () -> file, () -> e.getLocalizedMessage());
		    } catch (IOException e) {
		        Log.info(""Could not read file %s : %s"", () -> file, () -> e.getLocalizedMessage());
		    }
		    return Optional.empty();
		}"	$indentation$ optional < path > $whitespace$ getroot ( path $whitespace$ file ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ javaparser $whitespace$ javaparser $whitespace$ = $whitespace$ new $whitespace$ javaparser ( getparserconfiguration ( ) ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ javaparser . parse ( file ) ; $newline$ $indentation$ if $whitespace$ ( parseresult . issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parseresult . getresult ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ optional < compilationunit . storage > $whitespace$ storage $whitespace$ = $whitespace$ parseresult . getresult ( ) . flatmap ( compilationunit : : getstorage ) ; $newline$ $indentation$ if $whitespace$ ( storage . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( storage . get ( ) . getfilename ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·module-info.java·is·useless·for·finding·the·source·root,·since·it·can·be·placed·in·any·directory.$ $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ storage . map ( compilationunit . storage : : getsourceroot ) ; $newline$ $indentation$ } $newline$ $indentation$ log . info ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log . info ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log . info ( $string$ ) ; $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ parseresult . getproblems ( ) . size ( ) , $whitespace$ parseresult : : getproblems ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( parseproblemexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ file , $whitespace$ ( ) $whitespace$ - > $whitespace$ e . getlocalizedmessage ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( runtimeexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ file , $whitespace$ ( ) $whitespace$ - > $whitespace$ e . getlocalizedmessage ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ file , $whitespace$ ( ) $whitespace$ - > $whitespace$ e . getlocalizedmessage ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ optional < path > $whitespace$ getroot ( path $whitespace$ file ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ javaparser $whitespace$ javaparser $whitespace$ = $whitespace$ new $whitespace$ javaparser ( getparserconfiguration ( ) ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ javaparser. parse ( file ) ; $newline$ $indentation$ if $whitespace$ ( parseresult. issuccessful ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ optional < compilationunit. storage > $whitespace$ storage $whitespace$ = $whitespace$ parseresult. getresult ( ). flatmap ( compilationunit : : getstorage ) ; $newline$ $indentation$ if $whitespace$ ( storage. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$. equals ( storage. get ( ). getfilename ( ) ) ) $whitespace$ { $newline$ $indentation$ $//g$module-info.java $whitespace$ = $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ storage. map ( compilationunit. storage : : getsourceroot ) ; $newline$ $indentation$ } $newline$ $indentation$ log. info ( $string$ ) ; $newline$ $indentation$ return $whitespace$ string. format ( $string$, $whitespace$ storage. get ( ). getfilename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ log. info ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ log. info ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$			
hashCode	58	62	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Pair.java	0.7152300477027893	MID	"		@Override
		public int hashCode(){
		    int result = a != null ? a.hashCode() : 0;
		    return 31 * result + (b != null ? b.hashCode() : 0);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ a $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ a . hashcode ( ) $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ ( b $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ b . hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ a $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ a. hashcode ( ) $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ return $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ ( b $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ b. hashcode ( ) $whitespace$ : $whitespace$ $number$ ) ; $newline$ $indentation$ }			
equals	44	56	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Pair.java	0.7267675399780273	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    Pair<?, ?> pair = (Pair<?, ?>) o;
		    if (!Objects.equals(a, pair.a))
		        return false;
		    if (!Objects.equals(b, pair.b))
		        return false;
		    return true;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ pair < ? , $whitespace$ ? > $whitespace$ pair $whitespace$ = $whitespace$ ( pair < ? , $whitespace$ ? > ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! objects . equals ( a , $whitespace$ pair . a ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! objects . equals ( b , $whitespace$ pair . b ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ pair <?, $whitespace$? > $whitespace$ pair $whitespace$ = $whitespace$ ( pair <?, $whitespace$? > ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! objects. equals ( a, $whitespace$ pair. a ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
postVisitDirectory	90	97	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/ParserCollectionStrategy.java	0.6133653521537781	MID	"		@Override
		public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException{
		    if (current_root != null && Files.isSameFile(dir, current_root)) {
		        projectRoot.addSourceRoot(dir);
		        current_root = null;
		    }
		    return CONTINUE;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ postvisitdirectory ( path $whitespace$ dir , $whitespace$ ioexception $whitespace$ e ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ files . issamefile ( dir , $whitespace$ current_root ) ) $whitespace$ { $newline$ $indentation$ projectroot . addsourceroot ( dir ) ; $newline$ $indentation$ current_root $whitespace$ = $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ postvisitdirectory ( path $whitespace$ dir, $whitespace$ ioexception $whitespace$ e ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ files. issamefile ( dir, $whitespace$ current_root ) ) $whitespace$ { $newline$ $indentation$ projectroot. addsourceroot ( dir ) ; $newline$ $indentation$ current_root $whitespace$ = $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }			
collect	57	103	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/ParserCollectionStrategy.java	0.6986402571201324	MID	"		@Override
		public ProjectRoot collect(Path path){
		    ProjectRoot projectRoot = new ProjectRoot(path, parserConfiguration);
		    try {
		        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
		
		            Path current_root;
		
		            final PathMatcher javaMatcher = getPathMatcher(""glob:**.java"");
		
		            @Override
		            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
		                if (""module-info.java"".equals(file.getFileName().toString())) {
		                    // module-info.java is useless for finding the source root, since it can be placed within any directory.
		                    return CONTINUE;
		                }
		                if (javaMatcher.matches(file)) {
		                    current_root = getRoot(file).orElse(null);
		                    if (current_root != null) {
		                        return SKIP_SIBLINGS;
		                    }
		                }
		                return CONTINUE;
		            }
		
		            @Override
		            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
		                if (Files.isHidden(dir) || (current_root != null && dir.startsWith(current_root))) {
		                    return SKIP_SUBTREE;
		                }
		                return CONTINUE;
		            }
		
		            @Override
		            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {
		                if (current_root != null && Files.isSameFile(dir, current_root)) {
		                    projectRoot.addSourceRoot(dir);
		                    current_root = null;
		                }
		                return CONTINUE;
		            }
		        });
		    } catch (IOException e) {
		        Log.error(e, ""Unable to walk %s"", () -> path);
		    }
		    return projectRoot;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ projectroot $whitespace$ collect ( path $whitespace$ path ) { $newline$ $indentation$ projectroot $whitespace$ projectroot $whitespace$ = $whitespace$ new $whitespace$ projectroot ( path , $whitespace$ parserconfiguration ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ files . walkfiletree ( path , $whitespace$ new $whitespace$ simplefilevisitor < path > ( ) $whitespace$ { $newline$ $indentation$ path $whitespace$ current_root ; $newline$ $indentation$ final $whitespace$ pathmatcher $whitespace$ javamatcher $whitespace$ = $whitespace$ getpathmatcher ( $string$ ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ visitfile ( path $whitespace$ file , $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( file . getfilename ( ) . tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·module-info.java·is·useless·for·finding·the·source·root,·since·it·can·be·placed·within·any·directory.$ $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( javamatcher . matches ( file ) ) $whitespace$ { $newline$ $indentation$ current_root $whitespace$ = $whitespace$ getroot ( file ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ skip_siblings ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ previsitdirectory ( path $whitespace$ dir , $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ throws $whitespace$ ioexception $whitespace$ { $newline$ $indentation$ if $whitespace$ ( files . ishidden ( dir ) $whitespace$ || $whitespace$ ( current_root $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ dir . startswith ( current_root ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ skip_subtree ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ postvisitdirectory ( path $whitespace$ dir , $whitespace$ ioexception $whitespace$ e ) $whitespace$ throws $whitespace$ ioexception $whitespace$ { $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ files . issamefile ( dir , $whitespace$ current_root ) ) $whitespace$ { $newline$ $indentation$ projectroot . addsourceroot ( dir ) ; $newline$ $indentation$ current_root $whitespace$ = $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log . error ( e , $whitespace$ $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ path ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ projectroot ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ projectroot $whitespace$ collect ( path $whitespace$ path ) { $newline$ $indentation$ final $whitespace$ projectroot $whitespace$ projectroot $whitespace$ = $whitespace$ new $whitespace$ projectroot ( path, $whitespace$ parserconfiguration ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ files. walkfiletree ( path, $whitespace$ new $whitespace$ simplefilevisitor < path > ( ) $whitespace$ { $newline$ $indentation$ path $whitespace$ current_root ; $newline$ $indentation$ final $whitespace$ pathmatcher $whitespace$ javamatcher $whitespace$ = $whitespace$ getpathmatcher ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( $string$. equals ( file. getfilename ( ). tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////module-info.java $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( javamatcher. matches ( file ) ) $whitespace$ { $newline$ $indentation$ current_root $whitespace$ = $whitespace$ getroot ( file ). orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ skip_siblings ; $newline$ $indentation$ } $newline$ $indentation$			
visitFile	67	80	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/ParserCollectionStrategy.java	0.8369004130363464	HIGH	"		@Override
		public FileVisitResult visitFile(Path file, BasicFileAttributes attrs){
		    if (""module-info.java"".equals(file.getFileName().toString())) {
		        // module-info.java is useless for finding the source root, since it can be placed within any directory.
		        return CONTINUE;
		    }
		    if (javaMatcher.matches(file)) {
		        current_root = getRoot(file).orElse(null);
		        if (current_root != null) {
		            return SKIP_SIBLINGS;
		        }
		    }
		    return CONTINUE;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ visitfile ( path $whitespace$ file , $whitespace$ basicfileattributes $whitespace$ attrs ) { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( file . getfilename ( ) . tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·module-info.java·is·useless·for·finding·the·source·root,·since·it·can·be·placed·within·any·directory.$ $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( javamatcher . matches ( file ) ) $whitespace$ { $newline$ $indentation$ current_root $whitespace$ = $whitespace$ getroot ( file ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ skip_siblings ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ visitfile ( path $whitespace$ file, $whitespace$ basicfileattributes $whitespace$ attrs ) { $newline$ $indentation$ if $whitespace$ ( $string$. equals ( file. getfilename ( ). tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////module-info.java $newline$ $indentation$ // $whitespace$ warning $whitespace$ sent $whitespace$ if $whitespace$ so $whitespace$ default $whitespace$ is $whitespace$ set $whitespace$ to $whitespace$ false $newline$ $indentation$ // $whitespace$ default $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ so $whitespace$ default $whitespace$ is $whitespace$ set $whitespace$ to $whitespace$ false $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ return $whitespace$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( javamatcher. matches ( file ) ) $whitespace$ { $newline$ $indentation$ current_root $whitespace$ = $whitespace$ getroot ( file ). orelse ( null ) ; $newline$ $indentation$ // $whitespace$ the $whitespace$ // $whitespace$ is $whitespace$ not $whitespace$ empty $whitespace$ spaces $whitespace$ and $whitespace$ the $whitespace$ ship $whitespace$ is $whitespace$ false $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ skip_siblings ; $newline$ $indentation$ } $newline			
firstNonAnnotationNode	111	141	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/PositionUtils.java	0.040677573531866	LOW	"		private static Node firstNonAnnotationNode(Node node){
		    if (node instanceof ClassOrInterfaceDeclaration) {
		        // Modifiers appear before the class name --
		        ClassOrInterfaceDeclaration casted = (ClassOrInterfaceDeclaration) node;
		        Modifier earliestModifier = casted.getModifiers().stream().filter(modifier -> modifier.hasRange()).min(Comparator.comparing(o -> o.getRange().get().begin)).orElse(null);
		        if (earliestModifier == null) {
		            return casted.getName();
		        }
		        return earliestModifier;
		    }
		    if (node instanceof MethodDeclaration) {
		        // Modifiers appear before the class name --
		        MethodDeclaration casted = (MethodDeclaration) node;
		        Modifier earliestModifier = casted.getModifiers().stream().filter(modifier -> modifier.hasRange()).min(Comparator.comparing(o -> o.getRange().get().begin)).orElse(null);
		        if (earliestModifier == null) {
		            return casted.getType();
		        }
		        return earliestModifier;
		    }
		    if (node instanceof FieldDeclaration) {
		        // Modifiers appear before the class name --
		        FieldDeclaration casted = (FieldDeclaration) node;
		        Modifier earliestModifier = casted.getModifiers().stream().filter(modifier -> modifier.hasRange()).min(Comparator.comparing(o -> o.getRange().get().begin)).orElse(null);
		        if (earliestModifier == null) {
		            return casted.getVariable(0).getType();
		        }
		        return earliestModifier;
		    }
		    return node;
		}"	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ firstnonannotationnode ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ $//·modifiers·appear·before·the·class·name·--$ $newline$ $indentation$ classorinterfacedeclaration $whitespace$ casted $whitespace$ = $whitespace$ ( classorinterfacedeclaration ) $whitespace$ node ; $newline$ $indentation$ modifier $whitespace$ earliestmodifier $whitespace$ = $whitespace$ casted . getmodifiers ( ) . stream ( ) . filter ( modifier $whitespace$ - > $whitespace$ modifier . hasrange ( ) ) . min ( comparator . comparing ( o $whitespace$ - > $whitespace$ o . getrange ( ) . get ( ) . begin ) ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( earliestmodifier $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ casted . getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ earliestmodifier ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ $//·modifiers·appear·before·the·class·name·--$ $newline$ $indentation$ methoddeclaration $whitespace$ casted $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ node ; $newline$ $indentation$ modifier $whitespace$ earliestmodifier $whitespace$ = $whitespace$ casted . getmodifiers ( ) . stream ( ) . filter ( modifier $whitespace$ - > $whitespace$ modifier . hasrange ( ) ) . min ( comparator . comparing ( o $whitespace$ - > $whitespace$ o . getrange ( ) . get ( ) . begin ) ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( earliestmodifier $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ casted . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ earliestmodifier ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fielddeclaration ) $whitespace$ { $newline$ $indentation$ $//·modifiers·appear·before·the·class·name·--$ $newline$ $indentation$ fielddeclaration $whitespace$ casted $whitespace$ = $whitespace$ ( fielddeclaration ) $whitespace$ node ; $newline$ $indentation$ modifier $whitespace$ earliestmodifier $whitespace$ = $whitespace$ casted . getmodifiers ( ) . stream ( ) . filter ( modifier $whitespace$ - > $whitespace$ modifier . hasrange ( ) ) . min ( comparator . comparing ( o $whitespace$ - > $whitespace$ o . getrange ( ) . get ( ) . begin ) ) . orelse ( null ) ; $newline$ $indentation$ if $whitespace$ ( earliestmodifier $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ casted . getvariable ( $number$ ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ earliestmodifier ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ firstnonannotationnode ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ ( classorinterfacedeclaration ) $whitespace$ node ; $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ ( classorinterfacedeclaration ) $whitespace$ node ; $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ ( classorinterfacedeclaration ) $whitespace$ node ; $newline$ $indentation$ if $whitespace$ ( $whitespace$ israngeclicked ( ) $whitespace$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ elt. getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ classannotation $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ node ; $newline$ $indentation$ modifier $whitespace$ earliestmodifier $whitespace$ = $whitespace$ elt. getmodifiers ( ). stream ( ). filter ( modifier $whitespace$ - > $whitespace$ modifier. hasrange ( ) ). min ( comparator. comparing ( o $whitespace$ - > $whitespace$ o. getrange ( ). begin ) ). orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ ( methoddeclaration ) $whitespace$ node ; $newline$ $indentation$ modifier $			
compare	65	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/PositionUtils.java	0.1737245768308639	LOW	"		private static int compare(Node a, Node b, boolean ignoringAnnotations){
		    if (a.hasRange() && !b.hasRange()) {
		        return -1;
		    }
		    if (!a.hasRange() && b.hasRange()) {
		        return 1;
		    }
		    if (!a.hasRange() && !b.hasRange()) {
		        return 0;
		    }
		    if (ignoringAnnotations) {
		        int signLine = signum(beginLineWithoutConsideringAnnotation(a) - beginLineWithoutConsideringAnnotation(b));
		        if (signLine == 0) {
		            return signum(beginColumnWithoutConsideringAnnotation(a) - beginColumnWithoutConsideringAnnotation(b));
		        }
		        return signLine;
		    }
		    Position aBegin = a.getBegin().get();
		    Position bBegin = b.getBegin().get();
		    int signLine = signum(aBegin.line - bBegin.line);
		    if (signLine == 0) {
		        return signum(aBegin.column - bBegin.column);
		    }
		    return signLine;
		}"	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ compare ( node $whitespace$ a , $whitespace$ node $whitespace$ b , $whitespace$ boolean $whitespace$ ignoringannotations ) { $newline$ $indentation$ if $whitespace$ ( a . hasrange ( ) $whitespace$ && $whitespace$ ! b . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! a . hasrange ( ) $whitespace$ && $whitespace$ b . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! a . hasrange ( ) $whitespace$ && $whitespace$ ! b . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ignoringannotations ) $whitespace$ { $newline$ $indentation$ int $whitespace$ signline $whitespace$ = $whitespace$ signum ( beginlinewithoutconsideringannotation ( a ) $whitespace$ - $whitespace$ beginlinewithoutconsideringannotation ( b ) ) ; $newline$ $indentation$ if $whitespace$ ( signline $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ signum ( begincolumnwithoutconsideringannotation ( a ) $whitespace$ - $whitespace$ begincolumnwithoutconsideringannotation ( b ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ signline ; $newline$ $indentation$ } $newline$ $indentation$ position $whitespace$ abegin $whitespace$ = $whitespace$ a . getbegin ( ) . get ( ) ; $newline$ $indentation$ position $whitespace$ bbegin $whitespace$ = $whitespace$ b . getbegin ( ) . get ( ) ; $newline$ $indentation$ int $whitespace$ signline $whitespace$ = $whitespace$ signum ( abegin . line $whitespace$ - $whitespace$ bbegin . line ) ; $newline$ $indentation$ if $whitespace$ ( signline $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ signum ( abegin . column $whitespace$ - $whitespace$ bbegin . column ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ signline ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ compare ( node $whitespace$ a, $whitespace$ node $whitespace$ b, $whitespace$ boolean $whitespace$ ignoringannotations ) { $newline$ $indentation$ if $whitespace$ ( a. hasrange ( ) $whitespace$ && $whitespace$! b. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! a. hasrange ( ) $whitespace$ && $whitespace$ b. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! a. hasrange ( ) $whitespace$ && $whitespace$! b. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ignoringannotations ) $whitespace$ { $newline$ $indentation$ int $whitespace$ signline $whitespace$ = $whitespace$ signum ( beginlinewithoutconsideringannotation ( a ) $whitespace$ - $whitespace$ beginlinewithoutconsideringannotation ( b ) ) ; $newline$ $indentation$ if $whitespace$ ( signline $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ signum ( begincolumnwithoutconsideringannotation ( a ) $whitespace$ - $whitespace$ begincolumnwithoutconsideringannotation ( b ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ signline ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ position $whitespace$ abegin $whitespace$ = $whitespace$ a. getbegin ( ). get ( ) ; $newline$ $indentation$ position $whitespace$ bbegin $white			
nodeContains	153	184	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/PositionUtils.java	0.6408505439758301	MID	"		public static boolean nodeContains(Node container, Node other, boolean ignoringAnnotations){
		    if (!container.hasRange()) {
		        throw new IllegalArgumentException(""Cannot compare the positions of nodes if container node does not have a range."");
		    }
		    if (!other.hasRange()) {
		        throw new IllegalArgumentException(""Cannot compare the positions of nodes if contained node does not have a range."");
		    }
		    // // FIXME: Not all nodes seem to have the compilation unit available?
		    // if (!Objects.equals(container.findCompilationUnit(), other.findCompilationUnit())) {
		    // // Allow the check to complete if they are both within a known CU (i.e. the CUs are the same),
		    // // ... or both not within a CU (i.e. both are Optional.empty())
		    // return false;
		    // }
		    final boolean nodeCanHaveAnnotations = container instanceof NodeWithAnnotations;
		    // final boolean hasAnnotations = PositionUtils.getLastAnnotation(container) != null;
		    if (!ignoringAnnotations || PositionUtils.getLastAnnotation(container) == null) {
		        // No special consideration required - perform simple range check.
		        return container.containsWithinRange(other);
		    }
		    if (!container.containsWithinRange(other)) {
		        return false;
		    }
		    if (!nodeCanHaveAnnotations) {
		        return true;
		    }
		    // If the node is contained, but it comes immediately after the annotations,
		    // let's not consider it contained (i.e. it must be ""strictly contained"").
		    Node nodeWithoutAnnotations = firstNonAnnotationNode(container);
		    Range rangeWithoutAnnotations = container.getRange().get().withBegin(nodeWithoutAnnotations.getBegin().get());
		    return // .contains(other.getRange().get());
		    rangeWithoutAnnotations.strictlyContains(other.getRange().get());
		}"	"$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ nodecontains ( node $whitespace$ container , $whitespace$ node $whitespace$ other , $whitespace$ boolean $whitespace$ ignoringannotations ) { $newline$ $indentation$ if $whitespace$ ( ! container . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! other . hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·//·fixme:·not·all·nodes·seem·to·have·the·compilation·unit·available?$ $newline$ $indentation$ $//·if·(!objects.equals(container.findcompilationunit(),·other.findcompilationunit()))·{$ $newline$ $indentation$ $//·//·allow·the·check·to·complete·if·they·are·both·within·a·known·cu·(i.e.·the·cus·are·the·same),$ $newline$ $indentation$ $//·//·...·or·both·not·within·a·cu·(i.e.·both·are·optional.empty())$ $newline$ $indentation$ $//·return·false;$ $newline$ $indentation$ $//·}$ $newline$ $indentation$ final $whitespace$ boolean $whitespace$ nodecanhaveannotations $whitespace$ = $whitespace$ container $whitespace$ instanceof $whitespace$ nodewithannotations ; $newline$ $indentation$ $//·final·boolean·hasannotations·=·positionutils.getlastannotation(container)·!=·null;$ $newline$ $indentation$ if $whitespace$ ( ! ignoringannotations $whitespace$ || $whitespace$ positionutils . getlastannotation ( container ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·no·special·consideration·required·-·perform·simple·range·check.$ $newline$ $indentation$ return $whitespace$ container . containswithinrange ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! container . containswithinrange ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! nodecanhaveannotations ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·the·node·is·contained,·but·it·comes·immediately·after·the·annotations,$ $newline$ $indentation$ $//·let's·not·consider·it·contained·(i.e.·it·must·be·""strictly·contained"").$ $newline$ $indentation$ node $whitespace$ nodewithoutannotations $whitespace$ = $whitespace$ firstnonannotationnode ( container ) ; $newline$ $indentation$ range $whitespace$ rangewithoutannotations $whitespace$ = $whitespace$ container . getrange ( ) . get ( ) . withbegin ( nodewithoutannotations . getbegin ( ) . get ( ) ) ; $newline$ $indentation$ return $whitespace$ $//·.contains(other.getrange().get());$ $newline$ $indentation$ rangewithoutannotations . strictlycontains ( other . getrange ( ) . get ( ) ) ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ nodecontains ( node $whitespace$ container, $whitespace$ node $whitespace$ other, $whitespace$ boolean $whitespace$ ignoringannotations ) { $newline$ $indentation$ if $whitespace$ (! container. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! other. hasrange ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////// $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ system.out.println(container.findcompilationunit(), $whitespace$$ = $whitespace$ container $whitespace$ instanceof $whitespace$ nodewithannotations ; $newline$ $indentation$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $			
toString	63	67	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SeparatedItemStringBuilder.java	0.9298854470252992	HIGH	"		@Override
		public String toString(){
		    // This order of toStringing avoids debuggers from making a mess.
		    return builder.toString() + postfix;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ $//·this·order·of·tostringing·avoids·debuggers·from·making·a·mess.$ $newline$ $indentation$ return $whitespace$ builder . tostring ( ) $whitespace$ + $whitespace$ postfix ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ postfix ; $newline$ $indentation$ }			
tryToParse	121	135	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.0570373721420764	LOW	"		public ParseResult<CompilationUnit> tryToParse(String startPackage, String filename, ParserConfiguration configuration) throws IOException{
		    assertNotNull(startPackage);
		    assertNotNull(filename);
		    final Path relativePath = fileInPackageRelativePath(startPackage, filename);
		    if (cache.containsKey(relativePath)) {
		        Log.trace(""Retrieving cached %s"", () -> relativePath);
		        return cache.get(relativePath);
		    }
		    final Path path = root.resolve(relativePath);
		    Log.trace(""Parsing %s"", () -> path);
		    final ParseResult<CompilationUnit> result = new JavaParser(configuration).parse(COMPILATION_UNIT, provider(path, configuration.getCharacterEncoding()));
		    result.getResult().ifPresent(cu -> cu.setStorage(path, configuration.getCharacterEncoding()));
		    cache.put(relativePath, result);
		    return result;
		}"	$indentation$ public $whitespace$ parseresult < compilationunit > $whitespace$ trytoparse ( string $whitespace$ startpackage , $whitespace$ string $whitespace$ filename , $whitespace$ parserconfiguration $whitespace$ configuration ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ assertnotnull ( filename ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ relativepath $whitespace$ = $whitespace$ fileinpackagerelativepath ( startpackage , $whitespace$ filename ) ; $newline$ $indentation$ if $whitespace$ ( cache . containskey ( relativepath ) ) $whitespace$ { $newline$ $indentation$ log . trace ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ relativepath ) ; $newline$ $indentation$ return $whitespace$ cache . get ( relativepath ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ root . resolve ( relativepath ) ; $newline$ $indentation$ log . trace ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ path ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ javaparser ( configuration ) . parse ( compilation_unit , $whitespace$ provider ( path , $whitespace$ configuration . getcharacterencoding ( ) ) ) ; $newline$ $indentation$ result . getresult ( ) . ifpresent ( cu $whitespace$ - > $whitespace$ cu . setstorage ( path , $whitespace$ configuration . getcharacterencoding ( ) ) ) ; $newline$ $indentation$ cache . put ( relativepath , $whitespace$ result ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ public $whitespace$ parseresult < compilationunit > $whitespace$ trytoparse ( string $whitespace$ startpackage, $whitespace$ string $whitespace$ filename, $whitespace$ parserconfiguration $whitespace$ configuration ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ assertnotnull ( filename ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ relativepath $whitespace$ = $whitespace$ fileinpackagerelativepath ( startpackage, $whitespace$ filename ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ relativepath $whitespace$ = $whitespace$ root. resolve ( relativepath ) ; $newline$ $indentation$ log. trace ( $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ relativepath ) ; $newline$ $indentation$ return $whitespace$ cache. get ( relativepath ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ root. resolve ( relativepath ) ; $newline$ $indentation$ log. trace ( $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ path ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ javaparser ( configuration ). parse ( compilation_unit, $whitespace$ provider ( path, $whitespace$ configuration. getcharacterencoding ( ) ) ) ; $newline$ $indentation$ result. getresult ( ). ifpresent ( cu $whitespace$ - > $whitespace$ cu. setstorage ( path, $whitespace$ configuration. getcharacterencoding ( ) ) ) ; $newline$ $indentation$ cache. put ( relativepath, $whitespace$ result ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
callback	271	286	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.0827064365148544	LOW	"		private FileVisitResult callback(Path absolutePath, ParserConfiguration configuration, Callback callback) throws IOException{
		    Path localPath = root.relativize(absolutePath);
		    Log.trace(""Parsing %s"", () -> localPath);
		    ParseResult<CompilationUnit> result = new JavaParser(configuration).parse(COMPILATION_UNIT, provider(absolutePath, configuration.getCharacterEncoding()));
		    result.getResult().ifPresent(cu -> cu.setStorage(absolutePath, configuration.getCharacterEncoding()));
		    switch(callback.process(localPath, absolutePath, result)) {
		        case SAVE:
		            result.getResult().ifPresent(cu -> save(cu, absolutePath));
		        case DONT_SAVE:
		            return CONTINUE;
		        case TERMINATE:
		            return TERMINATE;
		        default:
		            throw new AssertionError(""Return an enum defined in SourceRoot.Callback.Result"");
		    }
		}"	$indentation$ private $whitespace$ filevisitresult $whitespace$ callback ( path $whitespace$ absolutepath , $whitespace$ parserconfiguration $whitespace$ configuration , $whitespace$ callback $whitespace$ callback ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ path $whitespace$ localpath $whitespace$ = $whitespace$ root . relativize ( absolutepath ) ; $newline$ $indentation$ log . trace ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ localpath ) ; $newline$ $indentation$ parseresult < compilationunit > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ javaparser ( configuration ) . parse ( compilation_unit , $whitespace$ provider ( absolutepath , $whitespace$ configuration . getcharacterencoding ( ) ) ) ; $newline$ $indentation$ result . getresult ( ) . ifpresent ( cu $whitespace$ - > $whitespace$ cu . setstorage ( absolutepath , $whitespace$ configuration . getcharacterencoding ( ) ) ) ; $newline$ $indentation$ switch ( callback . process ( localpath , $whitespace$ absolutepath , $whitespace$ result ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ save : $newline$ $indentation$ result . getresult ( ) . ifpresent ( cu $whitespace$ - > $whitespace$ save ( cu , $whitespace$ absolutepath ) ) ; $newline$ $indentation$ case $whitespace$ dont_save : $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ case $whitespace$ terminate : $newline$ $indentation$ return $whitespace$ terminate ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ filevisitresult $whitespace$ callback ( path $whitespace$ absolutepath, $whitespace$ parserconfiguration $whitespace$ configuration, $whitespace$ callback $whitespace$ callback ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ path $whitespace$ localpath $whitespace$ = $whitespace$ root. relativize ( absolutepath ) ; $newline$ $indentation$ log. trace ( $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ localpath ) ; $newline$ $indentation$ parseresult < compilationunit > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ javaparser ( configuration ). parse ( compilation_unit, $whitespace$ provider ( absolutepath, $whitespace$ configuration. getcharacterencoding ( ) ) ) ; $newline$ $indentation$ result. getresult ( ). ifpresent ( cu $whitespace$ - > $whitespace$ cu. setstorage ( absolutepath, $whitespace$ configuration. getcharacterencoding ( ) ) ) ; $newline$ $indentation$ switch $whitespace$ ( callback. process ( localpath, $whitespace$ absolutepath, $whitespace$ result ) ) $whitespace$ { $newline$ $indentation$ case $whitespace$ save : $newline$ $indentation$ result. getresult ( ). ifpresent ( cu $whitespace$ - > $whitespace$ save ( cu, $whitespace$ absolutepath ) ) ; $newline$ $indentation$ case $whitespace$ dont_save : $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ case $whitespace$ terminate : $newline$ $indentation$ return $whitespace$ terminate ; $newline$ $indentation$ default : $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
add	419	428	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.2009716182947158	LOW	"		public SourceRoot add(String startPackage, String filename, CompilationUnit compilationUnit){
		    assertNotNull(startPackage);
		    assertNotNull(filename);
		    assertNotNull(compilationUnit);
		    Log.trace(""Adding new file %s.%s"", () -> startPackage, () -> filename);
		    final Path path = fileInPackageRelativePath(startPackage, filename);
		    final ParseResult<CompilationUnit> parseResult = new ParseResult<>(compilationUnit, new ArrayList<>(), null);
		    cache.put(path, parseResult);
		    return this;
		}"	$indentation$ public $whitespace$ sourceroot $whitespace$ add ( string $whitespace$ startpackage , $whitespace$ string $whitespace$ filename , $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ assertnotnull ( filename ) ; $newline$ $indentation$ assertnotnull ( compilationunit ) ; $newline$ $indentation$ log . trace ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ startpackage , $whitespace$ ( ) $whitespace$ - > $whitespace$ filename ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ fileinpackagerelativepath ( startpackage , $whitespace$ filename ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ new $whitespace$ parseresult < > ( compilationunit , $whitespace$ new $whitespace$ arraylist < > ( ) , $whitespace$ null ) ; $newline$ $indentation$ cache . put ( path , $whitespace$ parseresult ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ sourceroot $whitespace$ add ( string $whitespace$ startpackage, $whitespace$ string $whitespace$ filename, $whitespace$ compilationunit $whitespace$ compilationunit ) { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ assertnotnull ( filename ) ; $newline$ $indentation$ assertnotnull ( compilationunit ) ; $newline$ $indentation$ log. trace ( $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ startpackage, $whitespace$ ( ) $whitespace$ - > $whitespace$ filename ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ fileinpackagerelativepath ( startpackage, $whitespace$ filename ) ; $newline$ $indentation$ final $whitespace$ parseresult < compilationunit > $whitespace$ parseresult $whitespace$ = $whitespace$ new $whitespace$ parseresult < > ( compilationunit, $whitespace$ new $whitespace$ arraylist < > ( ), $whitespace$ null ) ; $newline$ $indentation$ cache. put ( path, $whitespace$ parseresult ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
tryToParseParallelized	215	233	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.2867578566074371	LOW	"		public List<ParseResult<CompilationUnit>> tryToParseParallelized(String startPackage){
		    assertNotNull(startPackage);
		    logPackage(startPackage);
		    final Path path = packageAbsolutePath(root, startPackage);
		    ParallelParse parse = new ParallelParse(path, (file, attrs) -> {
		        if (!attrs.isDirectory() && file.toString().endsWith("".java"")) {
		            Path relative = root.relativize(file.getParent());
		            try {
		                tryToParse(relative.toString(), file.getFileName().toString(), parserConfiguration);
		            } catch (IOException e) {
		                Log.error(e);
		            }
		        }
		        return CONTINUE;
		    });
		    ForkJoinPool pool = new ForkJoinPool();
		    pool.invoke(parse);
		    return getCache();
		}"	$indentation$ public $whitespace$ list < parseresult < compilationunit >> $whitespace$ trytoparseparallelized ( string $whitespace$ startpackage ) { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ logpackage ( startpackage ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ packageabsolutepath ( root , $whitespace$ startpackage ) ; $newline$ $indentation$ parallelparse $whitespace$ parse $whitespace$ = $whitespace$ new $whitespace$ parallelparse ( path , $whitespace$ ( file , $whitespace$ attrs ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! attrs . isdirectory ( ) $whitespace$ && $whitespace$ file . tostring ( ) . endswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ path $whitespace$ relative $whitespace$ = $whitespace$ root . relativize ( file . getparent ( ) ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ trytoparse ( relative . tostring ( ) , $whitespace$ file . getfilename ( ) . tostring ( ) , $whitespace$ parserconfiguration ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log . error ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } ) ; $newline$ $indentation$ forkjoinpool $whitespace$ pool $whitespace$ = $whitespace$ new $whitespace$ forkjoinpool ( ) ; $newline$ $indentation$ pool . invoke ( parse ) ; $newline$ $indentation$ return $whitespace$ getcache ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < parseresult < compilationunit >> $whitespace$ trytoparseparallelized ( string $whitespace$ startpackage ) { $newline$ $indentation$ assertnotnull ( startpackage ) ; $newline$ $indentation$ final $whitespace$ path $whitespace$ path $whitespace$ = $whitespace$ packageabsolutepath ( root, $whitespace$ startpackage ) ; $newline$ $indentation$ parallelparse $whitespace$ parse $whitespace$ = $whitespace$ new $whitespace$ parallelparse ( path, $whitespace$ ( file, $whitespace$ attrs ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ (! attrs. isdirectory ( ) $whitespace$ && $whitespace$ file. tostring ( ). endswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ path $whitespace$ relative $whitespace$ = $whitespace$ root. relativize ( file. getparent ( ) ) ; $newline$ $indentation$ trytoparse ( relative. tostring ( ), $whitespace$ file. getfilename ( ). tostring ( ), $whitespace$ parserconfiguration ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ log. error ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ } ) ; $newline$ $indentation$ // $whitespace$ check $whitespace$ all $whitespace$ its $whitespace$ metadata $whitespace$ and $whitespace$ search $whitespace$ its $whitespace$ response. $newline$ $indentation$ j. error ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcache ( ) ; $newline$ $indentation$ }			
setPrinter	549	553	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.6139066219329834	MID	"		public SourceRoot setPrinter(Function<CompilationUnit, String> printer){
		    assertNotNull(printer);
		    this.printer = printer;
		    return this;
		}"	$indentation$ public $whitespace$ sourceroot $whitespace$ setprinter ( function < compilationunit , $whitespace$ string > $whitespace$ printer ) { $newline$ $indentation$ assertnotnull ( printer ) ; $newline$ $indentation$ this . printer $whitespace$ = $whitespace$ printer ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ sourceroot $whitespace$ setprinter ( function < compilationunit, $whitespace$ string > $whitespace$ printer ) { $newline$ $indentation$ assertnotnull ( printer ) ; $newline$ $indentation$ this. printer $whitespace$ = $whitespace$ printer ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
save	462	468	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.6269161105155945	MID	"		private SourceRoot save(CompilationUnit cu, Path path, Charset encoding){
		    assertNotNull(cu);
		    assertNotNull(path);
		    cu.setStorage(path, encoding);
		    cu.getStorage().get().save(printer);
		    return this;
		}"	$indentation$ private $whitespace$ sourceroot $whitespace$ save ( compilationunit $whitespace$ cu , $whitespace$ path $whitespace$ path , $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ assertnotnull ( cu ) ; $newline$ $indentation$ assertnotnull ( path ) ; $newline$ $indentation$ cu . setstorage ( path , $whitespace$ encoding ) ; $newline$ $indentation$ cu . getstorage ( ) . get ( ) . save ( printer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ private $whitespace$ sourceroot $whitespace$ save ( compilationunit $whitespace$ cu, $whitespace$ path $whitespace$ path, $whitespace$ charset $whitespace$ encoding ) { $newline$ $indentation$ assertnotnull ( cu ) ; $newline$ $indentation$ assertnotnull ( path ) ; $newline$ $indentation$ cu. setstorage ( path, $whitespace$ encoding ) ; $newline$ $indentation$ cu. getstorage ( ). get ( ). save ( printer ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
isSensibleDirectoryToEnter	180	191	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceRoot.java	0.7102965116500854	MID	"		 boolean isSensibleDirectoryToEnter(Path dir) throws IOException{
		    final String dirToEnter = dir.getFileName().toString();
		    // Don't enter directories that cannot be packages.
		    final boolean directoryIsAValidJavaIdentifier = JAVA_IDENTIFIER.matcher(dirToEnter).matches();
		    // Don't enter directories that are hidden, assuming that people don't store source files in hidden directories.
		    // But we can enter in root directory even if the root directory is not considered as a valid java identifier
		    if (!root.equals(dir) && (Files.isHidden(dir) || !directoryIsAValidJavaIdentifier)) {
		        Log.trace(""Not processing directory \""%s\"""", () -> dirToEnter);
		        return false;
		    }
		    return true;
		}"	$indentation$ boolean $whitespace$ issensibledirectorytoenter ( path $whitespace$ dir ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ final $whitespace$ string $whitespace$ dirtoenter $whitespace$ = $whitespace$ dir . getfilename ( ) . tostring ( ) ; $newline$ $indentation$ $//·don't·enter·directories·that·cannot·be·packages.$ $newline$ $indentation$ final $whitespace$ boolean $whitespace$ directoryisavalidjavaidentifier $whitespace$ = $whitespace$ java_identifier . matcher ( dirtoenter ) . matches ( ) ; $newline$ $indentation$ $//·don't·enter·directories·that·are·hidden,·assuming·that·people·don't·store·source·files·in·hidden·directories.$ $newline$ $indentation$ $//·but·we·can·enter·in·root·directory·even·if·the·root·directory·is·not·considered·as·a·valid·java·identifier$ $newline$ $indentation$ if $whitespace$ ( ! root . equals ( dir ) $whitespace$ && $whitespace$ ( files . ishidden ( dir ) $whitespace$ || $whitespace$ ! directoryisavalidjavaidentifier ) ) $whitespace$ { $newline$ $indentation$ log . trace ( $string$ % s \ $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ dirtoenter ) ; $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ boolean $whitespace$ issensibledirectorytoenter ( path $whitespace$ dir ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ final $whitespace$ string $whitespace$ dirtoenter $whitespace$ = $whitespace$ dir. getfilename ( ). tostring ( ) ; $newline$ $indentation$ final $whitespace$ boolean $whitespace$ directoryisavalidjavaidentifier $whitespace$ = $whitespace$ java_identifier. matcher ( dirtoenter ). matches ( ) ; $newline$ $indentation$ $indentation$ $whitespace$////////////////////////////////////don't $whitespace$ = $whitespace$ java_identifier. matcher ( dirtoenter ). matches ( ) ; $newline$ $indentation$ $whitespace$// $whitespace$$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ set $whitespace$ the $whitespace$ directory $whitespace$ as $whitespace$ we $whitespace$ have $whitespace$ a $whitespace$ vertex $whitespace$ file $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
parse	84	89	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceZip.java	0.0557681694626808	LOW	"		public List<Pair<Path, ParseResult<CompilationUnit>>> parse() throws IOException{
		    Log.info(""Parsing zip at \""%s\"""", () -> zipPath);
		    List<Pair<Path, ParseResult<CompilationUnit>>> results = new ArrayList<>();
		    parse((path, result) -> results.add(new Pair<>(path, result)));
		    return results;
		}"	$indentation$ public $whitespace$ list < pair < path , $whitespace$ parseresult < compilationunit >> > $whitespace$ parse ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ log . info ( $string$ % s \ $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ zippath ) ; $newline$ $indentation$ list < pair < path , $whitespace$ parseresult < compilationunit >> > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ parse ( ( path , $whitespace$ result ) $whitespace$ - > $whitespace$ results . add ( new $whitespace$ pair < > ( path , $whitespace$ result ) ) ) ; $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < pair < path, $whitespace$ parseresult < compilationunit >> > $whitespace$ parse ( ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ log. info ( $string$ % s \ $string$, $whitespace$ ( ) $whitespace$ - > $whitespace$ zippath ) ; $newline$ $indentation$ pair < path, $whitespace$ parseresult < compilationunit >> > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ parse ( ( path, $whitespace$ result ) $whitespace$ - > $whitespace$ results. add ( new $whitespace$ pair < > ( path, $whitespace$ result ) ) ) ; $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }			
setParserConfiguration	142	146	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/SourceZip.java	0.6081487536430359	MID	"		public SourceZip setParserConfiguration(ParserConfiguration parserConfiguration){
		    assertNotNull(parserConfiguration);
		    this.parserConfiguration = parserConfiguration;
		    return this;
		}"	$indentation$ public $whitespace$ sourcezip $whitespace$ setparserconfiguration ( parserconfiguration $whitespace$ parserconfiguration ) { $newline$ $indentation$ assertnotnull ( parserconfiguration ) ; $newline$ $indentation$ this . parserconfiguration $whitespace$ = $whitespace$ parserconfiguration ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ sourcezip $whitespace$ setparserconfiguration ( parserconfiguration $whitespace$ parserconfiguration ) { $newline$ $indentation$ assertthat ( parserconfiguration ). isempty ( ) ; $newline$ $indentation$ this. parserconfiguration $whitespace$ = $whitespace$ parserconfiguration ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
translate	124	136	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/StringEscapeUtils.java	0.8734900951385498	HIGH	"		private String translate(final CharSequence input){
		    if (input == null) {
		        return null;
		    }
		    try {
		        final StringWriter writer = new StringWriter(input.length() * 2);
		        translate(input, writer);
		        return writer.toString();
		    } catch (final IOException ioe) {
		        // this should never ever happen while writing to a StringWriter
		        throw new RuntimeException(ioe);
		    }
		}"	$indentation$ private $whitespace$ string $whitespace$ translate ( final $whitespace$ charsequence $whitespace$ input ) { $newline$ $indentation$ if $whitespace$ ( input $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ stringwriter $whitespace$ writer $whitespace$ = $whitespace$ new $whitespace$ stringwriter ( input . length ( ) $whitespace$ * $whitespace$ $number$ ) ; $newline$ $indentation$ translate ( input , $whitespace$ writer ) ; $newline$ $indentation$ return $whitespace$ writer . tostring ( ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( final $whitespace$ ioexception $whitespace$ ioe ) $whitespace$ { $newline$ $indentation$ $//·this·should·never·ever·happen·while·writing·to·a·stringwriter$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ioe ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ translate ( final $whitespace$ charsequence $whitespace$ input ) { $newline$ $indentation$ if $whitespace$ ( input $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ final $whitespace$ stringwriter $whitespace$ writer $whitespace$ = $whitespace$ new $whitespace$ stringwriter ( input. length ( ) $whitespace$ * $whitespace$ $number$ ) ; $newline$ $indentation$ translate ( input, $whitespace$ writer ) ; $newline$ $indentation$ return $whitespace$ writer. tostring ( ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( final $whitespace$ ioexception $whitespace$ ioe ) $whitespace$ { $newline$ $indentation$ $//hregisterscreen : : write ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
getPrimitiveTypeDescriptor	62	75	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/TypeUtils.java	0.0713631585240364	LOW	"		public static String getPrimitiveTypeDescriptor(final Class<?> clazz){
		    if (clazz == Void.TYPE || clazz == Void.class) {
		        return new VoidType().toDescriptor();
		    }
		    String className = clazz.getSimpleName();
		    Optional<Primitive> prim = Primitive.byTypeName(className);
		    if (prim.isPresent()) {
		        return prim.get().toDescriptor();
		    }
		    prim = Primitive.byBoxedTypeName(className);
		    return prim.map(pType -> pType.toDescriptor()).orElseThrow(() -> new IllegalArgumentException(String.format(""Unknown primitive type \""%s\"""", className)));
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ getprimitivetypedescriptor ( final $whitespace$ class < ? > $whitespace$ clazz ) { $newline$ $indentation$ if $whitespace$ ( clazz $whitespace$ == $whitespace$ void . type $whitespace$ || $whitespace$ clazz $whitespace$ == $whitespace$ void . class ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ voidtype ( ) . todescriptor ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ clazz . getsimplename ( ) ; $newline$ $indentation$ optional < primitive > $whitespace$ prim $whitespace$ = $whitespace$ primitive . bytypename ( classname ) ; $newline$ $indentation$ if $whitespace$ ( prim . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ prim . get ( ) . todescriptor ( ) ; $newline$ $indentation$ } $newline$ $indentation$ prim $whitespace$ = $whitespace$ primitive . byboxedtypename ( classname ) ; $newline$ $indentation$ return $whitespace$ prim . map ( ptype $whitespace$ - > $whitespace$ ptype . todescriptor ( ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ % s \ $string$ , $whitespace$ classname ) ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ getprimitivetypedescriptor ( final $whitespace$ class <? > $whitespace$ clazz ) { $newline$ $indentation$ if $whitespace$ ( clazz $whitespace$ == $whitespace$ void. type $whitespace$ || $whitespace$ clazz $whitespace$ == $whitespace$ void. class ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ voidtype ( ). todescriptor ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ clazz. getsimplename ( ) ; $newline$ $indentation$ if $whitespace$ ( classname. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ prim. get ( ). todescriptor ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ prim. map ( ptype $whitespace$ - > $whitespace$ ptype. todescriptor ( ) ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$ % s \ $string$, $whitespace$ classname ) ) ) ; $newline$ $indentation$ }			
appendDescriptor	48	60	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/TypeUtils.java	0.2571845054626465	LOW	"		private static void appendDescriptor(final Class<?> clazz, final StringBuilder stringBuilder){
		    Class<?> currentClass = clazz;
		    while (currentClass.isArray()) {
		        stringBuilder.append(""["");
		        currentClass = currentClass.getComponentType();
		    }
		    if (currentClass.isPrimitive()) {
		        String descriptor = getPrimitiveTypeDescriptor(currentClass);
		        stringBuilder.append(descriptor);
		    } else {
		        stringBuilder.append(""L"").append(currentClass.getName().replace(""."", ""/"")).append("";"");
		    }
		}"	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ appenddescriptor ( final $whitespace$ class < ? > $whitespace$ clazz , $whitespace$ final $whitespace$ stringbuilder $whitespace$ stringbuilder ) { $newline$ $indentation$ class < ? > $whitespace$ currentclass $whitespace$ = $whitespace$ clazz ; $newline$ $indentation$ while $whitespace$ ( currentclass . isarray ( ) ) $whitespace$ { $newline$ $indentation$ stringbuilder . append ( $string$ ) ; $newline$ $indentation$ currentclass $whitespace$ = $whitespace$ currentclass . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( currentclass . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ descriptor $whitespace$ = $whitespace$ getprimitivetypedescriptor ( currentclass ) ; $newline$ $indentation$ stringbuilder . append ( descriptor ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ stringbuilder . append ( $string$ ) . append ( currentclass . getname ( ) . replace ( $string$ , $whitespace$ $string$ ) ) . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ void $whitespace$ appenddescriptor ( final $whitespace$ class <? > $whitespace$ clazz, $whitespace$ final $whitespace$ stringbuilder $whitespace$ stringbuilder ) { $newline$ $indentation$ class <? > $whitespace$ currentclass $whitespace$ = $whitespace$ clazz ; $newline$ $indentation$ while $whitespace$ ( currentclass. isarray ( ) ) $whitespace$ { $newline$ $indentation$ stringbuilder. append ( $string$ ) ; $newline$ $indentation$ currentclass $whitespace$ = $whitespace$ currentclass. getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( currentclass. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ stringbuilder. append ( descriptor ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ stringbuilder. append ( $string$ ). append ( currentclass. getname ( ). replace ( $string$, $whitespace$ $string$ ) ). append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
trimTrailingSpaces	309	314	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.6117293834686279	MID	"		public static String trimTrailingSpaces(String line){
		    while (line.length() > 0 && line.charAt(line.length() - 1) <= 0x20) {
		        line = line.substring(0, line.length() - 1);
		    }
		    return line;
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ trimtrailingspaces ( string $whitespace$ line ) { $newline$ $indentation$ while $whitespace$ ( line . length ( ) $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ line . charat ( line . length ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$ <= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ line $whitespace$ = $whitespace$ line . substring ( $number$ , $whitespace$ line . length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ line ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ trimtrailingspaces ( string $whitespace$ line ) { $newline$ $indentation$ while $whitespace$ ( line. length ( ) $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ line. charat ( line. length ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$ <= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ line $whitespace$ = $whitespace$ line. substring ( $number$, $whitespace$ line. length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ line ; $newline$ $indentation$ }			
nextWord	161	167	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.6784176230430603	MID	"		public static String nextWord(String string){
		    int index = 0;
		    while (index < string.length() && !Character.isWhitespace(string.charAt(index))) {
		        index++;
		    }
		    return string.substring(0, index);
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ nextword ( string $whitespace$ string ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ ( index $whitespace$ < $whitespace$ string . length ( ) $whitespace$ && $whitespace$ ! character . iswhitespace ( string . charat ( index ) ) ) $whitespace$ { $newline$ $indentation$ index ++ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string . substring ( $number$ , $whitespace$ index ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ nextword ( string $whitespace$ string ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ while $whitespace$ (! character. isdigit ( string. charat ( index ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ string. substring ( $number$, $whitespace$ index ). trim ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string. substring ( $number$, $whitespace$ index ). trim ( ) ; $newline$ $indentation$ }			
removeFileExtension	299	304	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.6955462098121643	MID	"		public static String removeFileExtension(String filename){
		    int extensionIndex = filename.lastIndexOf(""."");
		    if (extensionIndex == -1)
		        return filename;
		    return filename.substring(0, extensionIndex);
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ removefileextension ( string $whitespace$ filename ) { $newline$ $indentation$ int $whitespace$ extensionindex $whitespace$ = $whitespace$ filename . lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( extensionindex $whitespace$ == $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ filename ; $newline$ $indentation$ return $whitespace$ filename . substring ( $number$ , $whitespace$ extensionindex ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ removefileextension ( string $whitespace$ filename ) { $newline$ $indentation$ int $whitespace$ extensionindex $whitespace$ = $whitespace$ filename. lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( extensionindex $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ filename ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ filename. substring ( $number$, $whitespace$ extensionindex ) ; $newline$ $indentation$ }			
escapeEndOfLines	91	106	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.7100656628608704	MID	"		public static String escapeEndOfLines(String string){
		    StringBuilder escapedString = new StringBuilder();
		    for (char c : string.toCharArray()) {
		        switch(c) {
		            case '\n':
		                escapedString.append(""\\n"");
		                break;
		            case '\r':
		                escapedString.append(""\\r"");
		                break;
		            default:
		                escapedString.append(c);
		        }
		    }
		    return escapedString.toString();
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ escapeendoflines ( string $whitespace$ string ) { $newline$ $indentation$ stringbuilder $whitespace$ escapedstring $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( char $whitespace$ c $whitespace$ : $whitespace$ string . tochararray ( ) ) $whitespace$ { $newline$ $indentation$ switch ( c ) $whitespace$ { $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ escapedstring . append ( $string$ ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ escapedstring . append ( $string$ ) ; $newline$ $indentation$ break ; $newline$ $indentation$ default : $newline$ $indentation$ escapedstring . append ( c ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ escapedstring . tostring ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ escapeendoflines ( string $whitespace$ string ) { $newline$ $indentation$ stringbuilder $whitespace$ escapedstring ; $newline$ $indentation$ if ( string. tochararray ( ) ) $whitespace$ { $newline$ $indentation$ switch $whitespace$ ( c ) $whitespace$ { $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ escapedstring. append ( $string$ ) ; $newline$ $indentation$ break ; $newline$ $indentation$ case $whitespace$ $string$ : $newline$ $indentation$ escapedstring. append ( $string$ ) ; $newline$ $indentation$ break ; $newline$ $indentation$ default : $newline$ $indentation$ escapedstring. append ( c ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ escapedstring. tostring ( ) ; $newline$ $indentation$ }			
removeElementByObjectIdentity	253	259	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.7123944163322449	MID	"		public static void removeElementByObjectIdentity(List<E> list, E o){
		    int index = indexOfElementByObjectIdentity(list, o);
		    if (index == -1) {
		        return;
		    }
		    list.remove(index);
		}"	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ removeelementbyobjectidentity ( list < e > $whitespace$ list , $whitespace$ e $whitespace$ o ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ indexofelementbyobjectidentity ( list , $whitespace$ o ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ list . remove ( index ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ removeelementbyobjectidentity ( list < e > $whitespace$ list, $whitespace$ e $whitespace$ o ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ indexofelementbyobjectidentity ( list, $whitespace$ o ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ list. remove ( index ) ; $newline$ $indentation$ }			
assertNonNegative	74	79	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.8564800024032593	HIGH	"		public static T assertNonNegative(T number){
		    if (number.longValue() < 0) {
		        throw new AssertionError(""A number was unexpectedly negative."");
		    }
		    return number;
		}"	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertnonnegative ( t $whitespace$ number ) { $newline$ $indentation$ if $whitespace$ ( number . longvalue ( ) $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ number ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertnonnegative ( t $whitespace$ number ) { $newline$ $indentation$ if $whitespace$ ( number. longvalue ( ) $whitespace$ < $whitespace$ $number$ ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ return $whitespace$ number ; $newline$ $indentation$ }			
assertPositive	81	86	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.857430100440979	HIGH	"		public static T assertPositive(T number){
		    if (number.longValue() <= 0) {
		        throw new AssertionError(""A number was unexpectedly non-positive."");
		    }
		    return number;
		}"	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertpositive ( t $whitespace$ number ) { $newline$ $indentation$ if $whitespace$ ( number . longvalue ( ) $whitespace$ <= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ number ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertpositive ( t $whitespace$ number ) { $newline$ $indentation$ if $whitespace$ ( number. longvalue ( ) $whitespace$ <= $whitespace$ $number$ ) $whitespace$ return $whitespace$ null ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ return $whitespace$ number ; $newline$ $indentation$ }			
valueIsNullOrEmptyStringOrOptional	222	237	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.8574872612953186	HIGH	"		public static boolean valueIsNullOrEmptyStringOrOptional(Object value){
		    // is null?
		    if (value == null) {
		        return true;
		    }
		    //        // is not Optional?
		    //        if (!(value instanceof Optional)) {
		    //        	return false;
		    //        }
		    //        // is an empty Optional?
		    //		if (!((Optional) value).isPresent()) {
		    //			return true;
		    //		}
		    //        return false;
		    return value instanceof Optional ? !((Optional) value).isPresent() : false;
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ valueisnulloremptystringoroptional ( object $whitespace$ value ) { $newline$ $indentation$ $//·is·null?$ $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//········//·is·not·optional?$ $newline$ $indentation$ $//········if·(!(value·instanceof·optional))·{$ $newline$ $indentation$ $//·········return·false;$ $newline$ $indentation$ $//········}$ $newline$ $indentation$ $//········//·is·an·empty·optional?$ $newline$ $indentation$ $//··if·(!((optional)·value).ispresent())·{$ $newline$ $indentation$ $//···return·true;$ $newline$ $indentation$ $//··}$ $newline$ $indentation$ $//········return·false;$ $newline$ $indentation$ return $whitespace$ value $whitespace$ instanceof $whitespace$ optional $whitespace$ ? $whitespace$ ! ( ( optional ) $whitespace$ value ) . ispresent ( ) $whitespace$ : $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ valueisnulloremptystringoroptional ( object $whitespace$ value ) { $newline$ $indentation$ $//samplesampleis ( ) ; $newline$ $indentation$ return $whitespace$ value $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ true $whitespace$ : $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$/////			
assertNonEmpty	67	72	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.8774549961090088	HIGH	"		public static String assertNonEmpty(String string){
		    if (string == null || string.isEmpty()) {
		        throw new AssertionError(""A string was unexpectedly empty."");
		    }
		    return string;
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ assertnonempty ( string $whitespace$ string ) { $newline$ $indentation$ if $whitespace$ ( string $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ string . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ assertnonempty ( string $whitespace$ string ) { $newline$ $indentation$ if $whitespace$ ( string $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ string. isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ string ; $newline$ $indentation$ }			
assertNotNull	60	65	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/Utils.java	0.9338638186454772	HIGH	"		public static T assertNotNull(T o){
		    if (o == null) {
		        throw new AssertionError(""A reference was unexpectedly null."");
		    }
		    return o;
		}"	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertnotnull ( t $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ o ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ t $whitespace$ assertnotnull ( t $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ assertionerror ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ o ; $newline$ $indentation$ }			
equals	292	298	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java	0.6267811059951782	MID	"		@Override
		public boolean equals(final Object obj){
		    if (obj == null || !(obj instanceof VisitorList.EqualsHashcodeOverridingFacade)) {
		        return false;
		    }
		    return overridden.accept(equalsVisitor, ((EqualsHashcodeOverridingFacade) obj).overridden);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ( obj $whitespace$ instanceof $whitespace$ visitorlist . equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden . accept ( equalsvisitor , $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ) . overridden ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$! ( obj $whitespace$ instanceof $whitespace$ visitorlist. equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden. accept ( equalsvisitor, $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ). overridden ) ; $newline$ $indentation$ }			
retainAll	220	226	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java	0.6817792057991028	MID	"		@Override
		public boolean retainAll(Collection<?> col){
		    int oldSize = size();
		    clear();
		    addAll((Collection<? extends N>) col);
		    return size() != oldSize;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection < ? > $whitespace$ col ) { $newline$ $indentation$ int $whitespace$ oldsize $whitespace$ = $whitespace$ size ( ) ; $newline$ $indentation$ clear ( ) ; $newline$ $indentation$ addall ( ( collection < ? $whitespace$ extends $whitespace$ n > ) $whitespace$ col ) ; $newline$ $indentation$ return $whitespace$ size ( ) $whitespace$ != $whitespace$ oldsize ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection <? > $whitespace$ col ) { $newline$ $indentation$ int $whitespace$ oldsize $whitespace$ = $whitespace$ size ( ) ; $newline$ $indentation$ clear ( ) ; $newline$ $indentation$ addall ( ( collection <? $whitespace$ extends $whitespace$ n > ) $whitespace$ col ) ; $newline$ $indentation$ return $whitespace$ size ( ) $whitespace$!= $whitespace$ oldsize ; $newline$ $indentation$ }			
addAll	62	68	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java	0.8331209421157837	HIGH	"		@Override
		public boolean addAll(Collection<? extends N> col){
		    boolean modified = false;
		    for (N elem : col) if (add(elem))
		        modified = true;
		    return modified;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ addall ( collection < ? $whitespace$ extends $whitespace$ n > $whitespace$ col ) { $newline$ $indentation$ boolean $whitespace$ modified $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( n $whitespace$ elem $whitespace$ : $whitespace$ col ) $whitespace$ if $whitespace$ ( add ( elem ) ) $newline$ $indentation$ modified $whitespace$ = $whitespace$ true ; $newline$ $indentation$ return $whitespace$ modified ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ addall ( collection <? $whitespace$ extends $whitespace$ n > $whitespace$ col ) { $newline$ $indentation$ boolean $whitespace$ modified $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( n $whitespace$ elem $whitespace$ : $whitespace$ col ) $whitespace$ if $whitespace$ ( add ( elem ) ) $whitespace$ { $newline$ $indentation$ modified $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ modified ; $newline$ $indentation$ }			
listIterator	149	200	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java	0.8465450227260589	HIGH	"		@Override
		public ListIterator<N> listIterator(int index){
		    return new ListIterator<N>() {
		
		        final ListIterator<EqualsHashcodeOverridingFacade> itr = innerList.listIterator(index);
		
		        @Override
		        public boolean hasNext() {
		            return itr.hasNext();
		        }
		
		        @Override
		        public N next() {
		            return itr.next().overridden;
		        }
		
		        @Override
		        public void remove() {
		            itr.remove();
		        }
		
		        @Override
		        public void add(N elem) {
		            itr.add(new EqualsHashcodeOverridingFacade((N) elem));
		        }
		
		        @Override
		        public boolean hasPrevious() {
		            return itr.hasPrevious();
		        }
		
		        @Override
		        public int nextIndex() {
		            return itr.nextIndex();
		        }
		
		        @Override
		        public N previous() {
		            return itr.previous().overridden;
		        }
		
		        @Override
		        public int previousIndex() {
		            return itr.previousIndex();
		        }
		
		        @Override
		        public void set(N elem) {
		            itr.set(new EqualsHashcodeOverridingFacade((N) elem));
		        }
		    };
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ listiterator < n > $whitespace$ listiterator ( int $whitespace$ index ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ listiterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ listiterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerlist . listiterator ( index ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . next ( ) . overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ itr . remove ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ add ( n $whitespace$ elem ) $whitespace$ { $newline$ $indentation$ itr . add ( new $whitespace$ equalshashcodeoverridingfacade ( ( n ) $whitespace$ elem ) ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasprevious ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . hasprevious ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ nextindex ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . nextindex ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ previous ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . previous ( ) . overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ previousindex ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . previousindex ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ set ( n $whitespace$ elem ) $whitespace$ { $newline$ $indentation$ itr . set ( new $whitespace$ equalshashcodeoverridingfacade ( ( n ) $whitespace$ elem ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ listiterator < n > $whitespace$ listiterator ( int $whitespace$ index ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ listiterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ listiterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerlist. listiterator ( index ) ; $newline$ $indentation$ return $whitespace$ itr. hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. next ( ). overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ nextindex ( ) $whitespace$ { $newline$ $indentation$			
iterator	116	137	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorList.java	0.8882556259632111	HIGH	"		@Override
		public Iterator<N> iterator(){
		    return new Iterator<N>() {
		
		        final Iterator<EqualsHashcodeOverridingFacade> itr = innerList.iterator();
		
		        @Override
		        public boolean hasNext() {
		            return itr.hasNext();
		        }
		
		        @Override
		        public N next() {
		            return itr.next().overridden;
		        }
		
		        @Override
		        public void remove() {
		            itr.remove();
		        }
		    };
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ iterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerlist . iterator ( ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . next ( ) . overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ itr . remove ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ iterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerlist. iterator ( ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. next ( ). overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ itr. remove ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }			
equals	107	113	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorMap.java	0.6275244951248169	MID	"		@Override
		public boolean equals(final Object obj){
		    if (obj == null || !(obj instanceof VisitorMap.EqualsHashcodeOverridingFacade)) {
		        return false;
		    }
		    return overridden.accept(equalsVisitor, ((EqualsHashcodeOverridingFacade) obj).overridden);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ( obj $whitespace$ instanceof $whitespace$ visitormap . equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden . accept ( equalsvisitor , $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ) . overridden ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$! ( obj $whitespace$ instanceof $whitespace$ visitormap. equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden. accept ( equalsvisitor, $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ). overridden ) ; $newline$ $indentation$ }			
equals	182	188	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorSet.java	0.6275244951248169	MID	"		@Override
		public boolean equals(final Object obj){
		    if (obj == null || !(obj instanceof VisitorSet.EqualsHashcodeOverridingFacade)) {
		        return false;
		    }
		    return overridden.accept(equalsVisitor, ((EqualsHashcodeOverridingFacade) obj).overridden);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ( obj $whitespace$ instanceof $whitespace$ visitorset . equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden . accept ( equalsvisitor , $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ) . overridden ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( final $whitespace$ object $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( obj $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$! ( obj $whitespace$ instanceof $whitespace$ visitorset. equalshashcodeoverridingfacade ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ overridden. accept ( equalsvisitor, $whitespace$ ( ( equalshashcodeoverridingfacade ) $whitespace$ obj ). overridden ) ; $newline$ $indentation$ }			
retainAll	125	131	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorSet.java	0.6817792057991028	MID	"		@Override
		public boolean retainAll(Collection<?> col){
		    int oldSize = size();
		    clear();
		    addAll((Collection<? extends N>) col);
		    return size() != oldSize;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection < ? > $whitespace$ col ) { $newline$ $indentation$ int $whitespace$ oldsize $whitespace$ = $whitespace$ size ( ) ; $newline$ $indentation$ clear ( ) ; $newline$ $indentation$ addall ( ( collection < ? $whitespace$ extends $whitespace$ n > ) $whitespace$ col ) ; $newline$ $indentation$ return $whitespace$ size ( ) $whitespace$ != $whitespace$ oldsize ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ retainall ( collection <? > $whitespace$ col ) { $newline$ $indentation$ int $whitespace$ oldsize $whitespace$ = $whitespace$ size ( ) ; $newline$ $indentation$ clear ( ) ; $newline$ $indentation$ addall ( ( collection <? $whitespace$ extends $whitespace$ n > ) $whitespace$ col ) ; $newline$ $indentation$ return $whitespace$ size ( ) $whitespace$!= $whitespace$ oldsize ; $newline$ $indentation$ }			
addAll	59	65	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorSet.java	0.8331209421157837	HIGH	"		@Override
		public boolean addAll(Collection<? extends N> col){
		    boolean modified = false;
		    for (N elem : col) if (add(elem))
		        modified = true;
		    return modified;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ addall ( collection < ? $whitespace$ extends $whitespace$ n > $whitespace$ col ) { $newline$ $indentation$ boolean $whitespace$ modified $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( n $whitespace$ elem $whitespace$ : $whitespace$ col ) $whitespace$ if $whitespace$ ( add ( elem ) ) $newline$ $indentation$ modified $whitespace$ = $whitespace$ true ; $newline$ $indentation$ return $whitespace$ modified ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ addall ( collection <? $whitespace$ extends $whitespace$ n > $whitespace$ col ) { $newline$ $indentation$ boolean $whitespace$ modified $whitespace$ = $whitespace$ false ; $newline$ $indentation$ for $whitespace$ ( n $whitespace$ elem $whitespace$ : $whitespace$ col ) $whitespace$ if $whitespace$ ( add ( elem ) ) $whitespace$ { $newline$ $indentation$ modified $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ modified ; $newline$ $indentation$ }			
iterator	89	110	javaparser/javaparser-core/src/main/java/com/github/javaparser/utils/VisitorSet.java	0.8887848109006882	HIGH	"		@Override
		public Iterator<N> iterator(){
		    return new Iterator<N>() {
		
		        final Iterator<EqualsHashcodeOverridingFacade> itr = innerSet.iterator();
		
		        @Override
		        public boolean hasNext() {
		            return itr.hasNext();
		        }
		
		        @Override
		        public N next() {
		            return itr.next().overridden;
		        }
		
		        @Override
		        public void remove() {
		            itr.remove();
		        }
		    };
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ iterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerset . iterator ( ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr . next ( ) . overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ itr . remove ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ iterator < n > $whitespace$ iterator ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ iterator < n > ( ) $whitespace$ { $newline$ $indentation$ final $whitespace$ iterator < equalshashcodeoverridingfacade > $whitespace$ itr $whitespace$ = $whitespace$ innerset. iterator ( ) ; $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasnext ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. hasnext ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ n $whitespace$ next ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ itr. next ( ). overridden ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ void $whitespace$ remove ( ) $whitespace$ { $newline$ $indentation$ itr. remove ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } ; $newline$ $indentation$ }			
juggleArrayCreation	340	347	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.0058001116849482	LOW	"		 ArrayCreationExpr juggleArrayCreation(TokenRange range, List<TokenRange> levelRanges, Type type, NodeList<Expression> dimensions, List<NodeList<AnnotationExpr>> arrayAnnotations, ArrayInitializerExpr arrayInitializerExpr){
		    NodeList<ArrayCreationLevel> levels = new NodeList<>();
		    for (int i = 0; i < arrayAnnotations.size(); i++) {
		        levels.add(new ArrayCreationLevel(levelRanges.get(i), dimensions.get(i), arrayAnnotations.get(i)));
		    }
		    return new ArrayCreationExpr(range, type, levels, arrayInitializerExpr);
		}"	$indentation$ arraycreationexpr $whitespace$ jugglearraycreation ( tokenrange $whitespace$ range , $whitespace$ list < tokenrange > $whitespace$ levelranges , $whitespace$ type $whitespace$ type , $whitespace$ nodelist < expression > $whitespace$ dimensions , $whitespace$ list < nodelist < annotationexpr >> $whitespace$ arrayannotations , $whitespace$ arrayinitializerexpr $whitespace$ arrayinitializerexpr ) { $newline$ $indentation$ nodelist < arraycreationlevel > $whitespace$ levels $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arrayannotations . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ levels . add ( new $whitespace$ arraycreationlevel ( levelranges . get ( i ) , $whitespace$ dimensions . get ( i ) , $whitespace$ arrayannotations . get ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraycreationexpr ( range , $whitespace$ type , $whitespace$ levels , $whitespace$ arrayinitializerexpr ) ; $newline$ $indentation$ }	$indentation$ arraycreationexpr $whitespace$ jugglearraycreation ( tokenrange $whitespace$ range, $whitespace$ list < tokenrange > $whitespace$ levelranges, $whitespace$ type $whitespace$ type, $whitespace$ nodelist < expression > $whitespace$ dimensions, $whitespace$ list < nodelist < annotationexpr >> $whitespace$ arrayannotations, $whitespace$ arrayinitializerexpr $whitespace$ arrayinitializerexpr ) { $newline$ $indentation$ nodelist < arraycreationlevel > $whitespace$ levels $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ arrayannotations. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ levels. add ( new $whitespace$ arraycreationlevel ( levelranges. get ( i ), $whitespace$ dimensions. get ( i ), $whitespace$ arrayannotations. get ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraycreationexpr ( range, $whitespace$ type, $whitespace$ levels, $whitespace$ arrayinitializerexpr ) ; $newline$ $indentation$ }			
generateLambda	314	335	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.0058854119852185	LOW	"		 Expression generateLambda(Expression ret, Statement lambdaBody){
		    if (ret instanceof EnclosedExpr) {
		        Expression inner = ((EnclosedExpr) ret).getInner();
		        SimpleName id = ((NameExpr) inner).getName();
		        NodeList<Parameter> params = add(new NodeList<>(), new Parameter(ret.getTokenRange().orElse(null), new NodeList<>(), new NodeList<>(), new UnknownType(), false, new NodeList<>(), id));
		        ret = new LambdaExpr(range(ret, lambdaBody), params, lambdaBody, true);
		    } else if (ret instanceof NameExpr) {
		        SimpleName id = ((NameExpr) ret).getName();
		        NodeList<Parameter> params = add(new NodeList<>(), new Parameter(ret.getTokenRange().orElse(null), new NodeList<>(), new NodeList<>(), new UnknownType(), false, new NodeList<>(), id));
		        ret = new LambdaExpr(range(ret, lambdaBody), params, lambdaBody, false);
		    } else if (ret instanceof LambdaExpr) {
		        ((LambdaExpr) ret).setBody(lambdaBody);
		        propagateRangeGrowthOnRight(ret, lambdaBody);
		    } else if (ret instanceof CastExpr) {
		        CastExpr castExpr = (CastExpr) ret;
		        Expression inner = generateLambda(castExpr.getExpression(), lambdaBody);
		        castExpr.setExpression(inner);
		    } else {
		        addProblem(""Failed to parse lambda expression! Please create an issue at https://github.com/javaparser/javaparser/issues"");
		    }
		    return ret;
		}"	$indentation$ expression $whitespace$ generatelambda ( expression $whitespace$ ret , $whitespace$ statement $whitespace$ lambdabody ) { $newline$ $indentation$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ enclosedexpr ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ inner $whitespace$ = $whitespace$ ( ( enclosedexpr ) $whitespace$ ret ) . getinner ( ) ; $newline$ $indentation$ simplename $whitespace$ id $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ inner ) . getname ( ) ; $newline$ $indentation$ nodelist < parameter > $whitespace$ params $whitespace$ = $whitespace$ add ( new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ parameter ( ret . gettokenrange ( ) . orelse ( null ) , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ unknowntype ( ) , $whitespace$ false , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ id ) ) ; $newline$ $indentation$ ret $whitespace$ = $whitespace$ new $whitespace$ lambdaexpr ( range ( ret , $whitespace$ lambdabody ) , $whitespace$ params , $whitespace$ lambdabody , $whitespace$ true ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ simplename $whitespace$ id $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ ret ) . getname ( ) ; $newline$ $indentation$ nodelist < parameter > $whitespace$ params $whitespace$ = $whitespace$ add ( new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ parameter ( ret . gettokenrange ( ) . orelse ( null ) , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ new $whitespace$ unknowntype ( ) , $whitespace$ false , $whitespace$ new $whitespace$ nodelist < > ( ) , $whitespace$ id ) ) ; $newline$ $indentation$ ret $whitespace$ = $whitespace$ new $whitespace$ lambdaexpr ( range ( ret , $whitespace$ lambdabody ) , $whitespace$ params , $whitespace$ lambdabody , $whitespace$ false ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ ( ( lambdaexpr ) $whitespace$ ret ) . setbody ( lambdabody ) ; $newline$ $indentation$ propagaterangegrowthonright ( ret , $whitespace$ lambdabody ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ castexpr ) $whitespace$ { $newline$ $indentation$ castexpr $whitespace$ castexpr $whitespace$ = $whitespace$ ( castexpr ) $whitespace$ ret ; $newline$ $indentation$ expression $whitespace$ inner $whitespace$ = $whitespace$ generatelambda ( castexpr . getexpression ( ) , $whitespace$ lambdabody ) ; $newline$ $indentation$ castexpr . setexpression ( inner ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ addproblem ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ret ; $newline$ $indentation$ }	$indentation$ expression $whitespace$ generatelambda ( expression $whitespace$ ret, $whitespace$ statement $whitespace$ lambdabody ) { $newline$ $indentation$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ enclosedexpr ) $whitespace$ { $newline$ $indentation$ nodelist < parameter > $whitespace$ params $whitespace$ = $whitespace$ ( ( enclosedexpr ) $whitespace$ ret ). getinner ( ) ; $newline$ $indentation$ simplename $whitespace$ id $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ inner ). getname ( ) ; $newline$ $indentation$ nodelist < parameter > $whitespace$ params $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ), $whitespace$ new $whitespace$ parameter ( ret. gettokenrange ( ). orelse ( null ), $whitespace$ new $whitespace$ nodelist < > ( ), $whitespace$ new $whitespace$ nodelist < > ( ), $whitespace$ new $whitespace$ unknowntype ( ), $whitespace$ false, $whitespace$ new $whitespace$ nodelist < > ( ), $whitespace$ id ) ) ; $newline$ $indentation$ ret $whitespace$ = $whitespace$ new $whitespace$ lambdaexpr ( range ( ret, $whitespace$ lambdabody ), $whitespace$ params, $whitespace$ lambdabody, $whitespace$ true ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ret $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ simplename $whitespace$ id $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ ret ). getname ( ) ; $newline$ $indentation$ nodelist < parameter > $whitespace$ params $whitespace$ = $whitespace$ add ( new $whitespace$ nodelist < > ( ), $whitespace$ new $whitespace$ parameter ( ret. gettokenrange ( ). orelse ( null ), $whitespace$ new $whitespace$ nodelist < >			
makeMessageForParseException	362	412	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.0101586086675524	LOW	"		private String makeMessageForParseException(ParseException exception){
		    final StringBuilder sb = new StringBuilder(""Parse error. Found "");
		    final StringBuilder expected = new StringBuilder();
		    int maxExpectedTokenSequenceLength = 0;
		    TreeSet<String> sortedOptions = new TreeSet<>();
		    for (int i = 0; i < exception.expectedTokenSequences.length; i++) {
		        if (maxExpectedTokenSequenceLength < exception.expectedTokenSequences[i].length) {
		            maxExpectedTokenSequenceLength = exception.expectedTokenSequences[i].length;
		        }
		        for (int j = 0; j < exception.expectedTokenSequences[i].length; j++) {
		            sortedOptions.add(exception.tokenImage[exception.expectedTokenSequences[i][j]]);
		        }
		    }
		    for (String option : sortedOptions) {
		        expected.append("" "").append(option);
		    }
		    Token token = exception.currentToken.next;
		    for (int i = 0; i < maxExpectedTokenSequenceLength; i++) {
		        String tokenText = token.image;
		        String escapedTokenText = ParseException.add_escapes(tokenText);
		        if (i != 0) {
		            sb.append("" "");
		        }
		        if (token.kind == 0) {
		            sb.append(exception.tokenImage[0]);
		            break;
		        }
		        escapedTokenText = ""\"""" + escapedTokenText + ""\"""";
		        String image = exception.tokenImage[token.kind];
		        if (image.equals(escapedTokenText)) {
		            sb.append(image);
		        } else {
		            sb.append("" "").append(escapedTokenText).append("" "").append(image);
		        }
		        token = token.next;
		    }
		    if (exception.expectedTokenSequences.length != 0) {
		        int numExpectedTokens = exception.expectedTokenSequences.length;
		        sb.append("", expected"").append(numExpectedTokens == 1 ? """" : "" one of "").append(expected.toString());
		    }
		    return sb.toString();
		}"	$indentation$ private $whitespace$ string $whitespace$ makemessageforparseexception ( parseexception $whitespace$ exception ) { $newline$ $indentation$ final $whitespace$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( $string$ ) ; $newline$ $indentation$ final $whitespace$ stringbuilder $whitespace$ expected $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ int $whitespace$ maxexpectedtokensequencelength $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ treeset < string > $whitespace$ sortedoptions $whitespace$ = $whitespace$ new $whitespace$ treeset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ exception . expectedtokensequences . length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( maxexpectedtokensequencelength $whitespace$ < $whitespace$ exception . expectedtokensequences [ i ] . length ) $whitespace$ { $newline$ $indentation$ maxexpectedtokensequencelength $whitespace$ = $whitespace$ exception . expectedtokensequences [ i ] . length ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ exception . expectedtokensequences [ i ] . length ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ sortedoptions . add ( exception . tokenimage [ exception . expectedtokensequences [ i ] [ j ] ] ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( string $whitespace$ option $whitespace$ : $whitespace$ sortedoptions ) $whitespace$ { $newline$ $indentation$ expected . append ( $string$ ) . append ( option ) ; $newline$ $indentation$ } $newline$ $indentation$ token $whitespace$ token $whitespace$ = $whitespace$ exception . currenttoken . next ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ maxexpectedtokensequencelength ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ string $whitespace$ tokentext $whitespace$ = $whitespace$ token . image ; $newline$ $indentation$ string $whitespace$ escapedtokentext $whitespace$ = $whitespace$ parseexception . add_escapes ( tokentext ) ; $newline$ $indentation$ if $whitespace$ ( i $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( token . kind $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ sb . append ( exception . tokenimage [ $number$ ] ) ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ escapedtokentext $whitespace$ = $whitespace$ $string$ $string$ \ $string$ ; $newline$ $indentation$ string $whitespace$ image $whitespace$ = $whitespace$ exception . tokenimage [ token . kind ] ; $newline$ $indentation$ if $whitespace$ ( image . equals ( escapedtokentext ) ) $whitespace$ { $newline$ $indentation$ sb . append ( image ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ sb . append ( $string$ ) . append ( escapedtokentext ) . append ( $string$ ) . append ( image ) ; $newline$ $indentation$ } $newline$ $indentation$ token $whitespace$ = $whitespace$ token . next ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( exception . expectedtokensequences . length $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ numexpectedtokens $whitespace$ = $whitespace$ exception . expectedtokensequences . length ; $newline$ $indentation$ sb . append ( $string$ ) . append ( numexpectedtokens $whitespace$ == $whitespace$ $number$ $whitespace$ ? $whitespace$ $string$ $whitespace$ : $whitespace$ $string$ ) . append ( expected . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ sb . tostring ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ makemessageforparseexception ( parseexception $whitespace$ exception ) { $newline$ $indentation$ final $whitespace$ stringbuilder $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ final $whitespace$ stringbuilder $whitespace$ expected $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ final $whitespace$ stringbuilder $whitespace$ expected $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ int $whitespace$ maxexpectedtokensequencelength $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ treeset < string > $whitespace$ sortedoptions $whitespace$ = $whitespace$ new $whitespace$ treeset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ exception. expectedtokensequences. length ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( maxexpectedtokensequencelength $whitespace$ < $whitespace$ exception. expectedtokensequences [ i ]. length ) $whitespace$ { $newline$ $indentation$ maxexpectedtokensequencelength $whitespace$ = $whitespace$ exception. expectedtokensequences [ i ]. length ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ exception. expectedtokensequences [ i ]. length ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ sortedoptions. add ( exception. tokenimage [ exception. expectedtokensequences [ i ] [ j ] ] ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( string $			
juggleArrayType	352	357	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.0891057178378105	LOW	"		 Type juggleArrayType(Type partialType, List<ArrayType.ArrayBracketPair> additionalBrackets){
		    Pair<Type, List<ArrayType.ArrayBracketPair>> partialParts = unwrapArrayTypes(partialType);
		    Type elementType = partialParts.a;
		    List<ArrayType.ArrayBracketPair> leftMostBrackets = partialParts.b;
		    return wrapInArrayTypes(elementType, additionalBrackets, leftMostBrackets).clone();
		}"	$indentation$ type $whitespace$ jugglearraytype ( type $whitespace$ partialtype , $whitespace$ list < arraytype . arraybracketpair > $whitespace$ additionalbrackets ) { $newline$ $indentation$ pair < type , $whitespace$ list < arraytype . arraybracketpair >> $whitespace$ partialparts $whitespace$ = $whitespace$ unwraparraytypes ( partialtype ) ; $newline$ $indentation$ type $whitespace$ elementtype $whitespace$ = $whitespace$ partialparts . a ; $newline$ $indentation$ list < arraytype . arraybracketpair > $whitespace$ leftmostbrackets $whitespace$ = $whitespace$ partialparts . b ; $newline$ $indentation$ return $whitespace$ wrapinarraytypes ( elementtype , $whitespace$ additionalbrackets , $whitespace$ leftmostbrackets ) . clone ( ) ; $newline$ $indentation$ }	$indentation$ type $whitespace$ jugglearraytype ( type $whitespace$ partialtype, $whitespace$ list < arraytype. arraybracketpair > $whitespace$ additionalbrackets ) { $newline$ $indentation$ pair < type, $whitespace$ list < arraytype. arraybracketpair >> $whitespace$ partialparts $whitespace$ = $whitespace$ unwraparraytypes ( partialtype ) ; $newline$ $indentation$ list < arraytype. arraybracketpair > $whitespace$ leftmostbrackets $whitespace$ = $whitespace$ partialparts. b ; $newline$ $indentation$ return $whitespace$ wrapinarraytypes ( elementtype, $whitespace$ additionalbrackets, $whitespace$ leftmostbrackets ). clone ( ) ; $newline$ $indentation$ }			
recoverStatement	211	242	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.1385251730680465	LOW	"		 TokenRange recoverStatement(int recoveryTokenType, int lBraceType, int rBraceType, ParseException p){
		    JavaToken begin = null;
		    if (p.currentToken != null) {
		        begin = token();
		    }
		    int level = 0;
		    Token t;
		    do {
		        Token nextToken = getToken(1);
		        if (nextToken != null && nextToken.kind == rBraceType && level == 0) {
		            TokenRange tokenRange = range(begin, token());
		            problems.add(new Problem(makeMessageForParseException(p), tokenRange, p));
		            return tokenRange;
		        }
		        t = getNextToken();
		        if (t.kind == lBraceType) {
		            level++;
		        } else if (t.kind == rBraceType) {
		            level--;
		        }
		    } while (!(t.kind == recoveryTokenType && level == 0) && t.kind != EOF);
		    JavaToken end = token();
		    TokenRange tokenRange = null;
		    if (begin != null && end != null) {
		        tokenRange = range(begin, end);
		    }
		    problems.add(new Problem(makeMessageForParseException(p), tokenRange, p));
		    return tokenRange;
		}"	$indentation$ tokenrange $whitespace$ recoverstatement ( int $whitespace$ recoverytokentype , $whitespace$ int $whitespace$ lbracetype , $whitespace$ int $whitespace$ rbracetype , $whitespace$ parseexception $whitespace$ p ) { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( p . currenttoken $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ begin $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ level $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ token $whitespace$ t ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ token $whitespace$ nexttoken $whitespace$ = $whitespace$ gettoken ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( nexttoken $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ nexttoken . kind $whitespace$ == $whitespace$ rbracetype $whitespace$ && $whitespace$ level $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ tokenrange $whitespace$ = $whitespace$ range ( begin , $whitespace$ token ( ) ) ; $newline$ $indentation$ problems . add ( new $whitespace$ problem ( makemessageforparseexception ( p ) , $whitespace$ tokenrange , $whitespace$ p ) ) ; $newline$ $indentation$ return $whitespace$ tokenrange ; $newline$ $indentation$ } $newline$ $indentation$ t $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ if $whitespace$ ( t . kind $whitespace$ == $whitespace$ lbracetype ) $whitespace$ { $newline$ $indentation$ level ++ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( t . kind $whitespace$ == $whitespace$ rbracetype ) $whitespace$ { $newline$ $indentation$ level -- ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ while $whitespace$ ( ! ( t . kind $whitespace$ == $whitespace$ recoverytokentype $whitespace$ && $whitespace$ level $whitespace$ == $whitespace$ $number$ ) $whitespace$ && $whitespace$ t . kind $whitespace$ != $whitespace$ eof ) ; $newline$ $indentation$ javatoken $whitespace$ end $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ tokenrange $whitespace$ tokenrange $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( begin $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ end $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ = $whitespace$ range ( begin , $whitespace$ end ) ; $newline$ $indentation$ } $newline$ $indentation$ problems . add ( new $whitespace$ problem ( makemessageforparseexception ( p ) , $whitespace$ tokenrange , $whitespace$ p ) ) ; $newline$ $indentation$ return $whitespace$ tokenrange ; $newline$ $indentation$ }	$indentation$ tokenrange $whitespace$ recoverstatement ( int $whitespace$ recoverytokentype, $whitespace$ int $whitespace$ lbracetype, $whitespace$ int $whitespace$ rbracetype, $whitespace$ parseexception $whitespace$ p ) { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( p. currenttoken $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ begin $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ level $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ token $whitespace$ t ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ token $whitespace$ nexttoken $whitespace$ = $whitespace$ gettoken ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( nexttoken $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ nexttoken. kind $whitespace$ == $whitespace$ rbracetype $whitespace$ && $whitespace$ level $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ tokenrange $whitespace$ = $whitespace$ range ( begin, $whitespace$ token ( ) ) ; $newline$ $indentation$ problems. add ( new $whitespace$ problem ( makemessageforparseexception ( p ), $whitespace$ tokenrange, $whitespace$ p ) ) ; $newline$ $indentation$ return $whitespace$ tokenrange ; $newline$ $indentation$ } $newline$ $indentation$ t $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ if $whitespace$ ( t. kind $whitespace$ == $whitespace$ lbracetype ) $whitespace$ { $newline$ $indentation$ level ++ ; $newline$ $indentation$			
scopeToName	417	428	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.1536848396062851	LOW	"		 Name scopeToName(Expression scope){
		    if (scope.isNameExpr()) {
		        SimpleName simpleName = scope.asNameExpr().getName();
		        return new Name(simpleName.getTokenRange().orElse(null), null, simpleName.getIdentifier());
		    }
		    if (scope.isFieldAccessExpr()) {
		        FieldAccessExpr fieldAccessExpr = scope.asFieldAccessExpr();
		        return new Name(fieldAccessExpr.getTokenRange().orElse(null), scopeToName(fieldAccessExpr.getScope()), fieldAccessExpr.getName().getIdentifier());
		    }
		    throw new IllegalStateException(""Unexpected expression type: "" + scope.getClass().getSimpleName());
		}"	$indentation$ name $whitespace$ scopetoname ( expression $whitespace$ scope ) { $newline$ $indentation$ if $whitespace$ ( scope . isnameexpr ( ) ) $whitespace$ { $newline$ $indentation$ simplename $whitespace$ simplename $whitespace$ = $whitespace$ scope . asnameexpr ( ) . getname ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ name ( simplename . gettokenrange ( ) . orelse ( null ) , $whitespace$ null , $whitespace$ simplename . getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scope . isfieldaccessexpr ( ) ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ scope . asfieldaccessexpr ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ name ( fieldaccessexpr . gettokenrange ( ) . orelse ( null ) , $whitespace$ scopetoname ( fieldaccessexpr . getscope ( ) ) , $whitespace$ fieldaccessexpr . getname ( ) . getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ scope . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ name $whitespace$ scopetoname ( expression $whitespace$ scope ) { $newline$ $indentation$ if $whitespace$ ( scope. isnameexpr ( ) ) $whitespace$ { $newline$ $indentation$ simplename $whitespace$ simplename $whitespace$ = $whitespace$ scope. asnameexpr ( ). getname ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ name ( simplename. gettokenrange ( ). orelse ( null ), $whitespace$ null, $whitespace$ simplename. getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ scope. isfieldaccessexpr ( ) ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ scope. asfieldaccessexpr ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ name ( fieldaccessexpr. gettokenrange ( ). orelse ( null ), $whitespace$ scopetoname ( fieldaccessexpr. getscope ( ) ), $whitespace$ fieldaccessexpr. getname ( ). getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ $whitespace$ + $whitespace$ scope. getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ }			
recover	189	208	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.2790130972862243	LOW	"		 TokenRange recover(int recoveryTokenType, ParseException p){
		    JavaToken begin = null;
		    if (p.currentToken != null) {
		        begin = token();
		    }
		    Token t;
		    do {
		        t = getNextToken();
		    } while (t.kind != recoveryTokenType && t.kind != EOF);
		    JavaToken end = token();
		    TokenRange tokenRange = null;
		    if (begin != null && end != null) {
		        tokenRange = range(begin, end);
		    }
		    problems.add(new Problem(makeMessageForParseException(p), tokenRange, p));
		    return tokenRange;
		}"	$indentation$ tokenrange $whitespace$ recover ( int $whitespace$ recoverytokentype , $whitespace$ parseexception $whitespace$ p ) { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( p . currenttoken $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ begin $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ } $newline$ $indentation$ token $whitespace$ t ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ t $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ ( t . kind $whitespace$ != $whitespace$ recoverytokentype $whitespace$ && $whitespace$ t . kind $whitespace$ != $whitespace$ eof ) ; $newline$ $indentation$ javatoken $whitespace$ end $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ tokenrange $whitespace$ tokenrange $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( begin $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ end $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ = $whitespace$ range ( begin , $whitespace$ end ) ; $newline$ $indentation$ } $newline$ $indentation$ problems . add ( new $whitespace$ problem ( makemessageforparseexception ( p ) , $whitespace$ tokenrange , $whitespace$ p ) ) ; $newline$ $indentation$ return $whitespace$ tokenrange ; $newline$ $indentation$ }	$indentation$ tokenrange $whitespace$ recover ( int $whitespace$ recoverytokentype, $whitespace$ parseexception $whitespace$ p ) { $newline$ $indentation$ javatoken $whitespace$ begin $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( p. currenttoken $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ begin $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ } $newline$ $indentation$ token $whitespace$ t ; $newline$ $indentation$ do $whitespace$ { $newline$ $indentation$ t $whitespace$ = $whitespace$ getnexttoken ( ) ; $newline$ $indentation$ } $whitespace$ while $whitespace$ ( t. kind $whitespace$!= $whitespace$ recoverytokentype $whitespace$ && $whitespace$ t. kind $whitespace$!= $whitespace$ eof ) ; $newline$ $indentation$ javatoken $whitespace$ end $whitespace$ = $whitespace$ token ( ) ; $newline$ $indentation$ tokenrange $whitespace$ tokenrange $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( begin $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ end $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ tokenrange $whitespace$ = $whitespace$ range ( begin, $whitespace$ end ) ; $newline$ $indentation$ } $newline$ $indentation$ problems. add ( new $whitespace$ problem ( makemessageforparseexception ( p ), $whitespace$ tokenrange, $whitespace$ p ) ) ; $newline$ $indentation$ return $whitespace$ tokenrange ; $newline$ $indentation$ }			
add	254	260	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.6245019435882568	MID	"		 NodeList<T> add(NodeList<T> list, T obj){
		    if (list == null) {
		        list = new NodeList<>();
		    }
		    list.add(obj);
		    return list;
		}"	$indentation$ nodelist < t > $whitespace$ add ( nodelist < t > $whitespace$ list , $whitespace$ t $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( list $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ list $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list . add ( obj ) ; $newline$ $indentation$ return $whitespace$ list ; $newline$ $indentation$ }	$indentation$ nodelist < t > $whitespace$ add ( nodelist < t > $whitespace$ list, $whitespace$ t $whitespace$ obj ) { $newline$ $indentation$ if $whitespace$ ( list $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ list $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list. add ( obj ) ; $newline$ $indentation$ return $whitespace$ list ; $newline$ $indentation$ }			
reset	67	71	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.6811643838882446	MID	"		 void reset(Provider provider){
		    ReInit(provider);
		    problems = new ArrayList<>();
		    getTokenSource().reset();
		}"	$indentation$ void $whitespace$ reset ( provider $whitespace$ provider ) { $newline$ $indentation$ reinit ( provider ) ; $newline$ $indentation$ problems $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ gettokensource ( ) . reset ( ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ reset ( provider $whitespace$ provider ) { $newline$ $indentation$ reinit ( provider ) ; $newline$ $indentation$ problems $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ gettokensource ( ). reset ( ) ; $newline$ $indentation$ }			
orIfInvalid	144	154	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.7012732028961182	MID	"		 JavaToken orIfInvalid(JavaToken firstChoice, JavaToken secondChoice){
		    if (storeTokens) {
		        assertNotNull(firstChoice);
		        assertNotNull(secondChoice);
		        if (firstChoice.valid() || secondChoice.invalid()) {
		            return firstChoice;
		        }
		        return secondChoice;
		    }
		    return null;
		}"	$indentation$ javatoken $whitespace$ orifinvalid ( javatoken $whitespace$ firstchoice , $whitespace$ javatoken $whitespace$ secondchoice ) { $newline$ $indentation$ if $whitespace$ ( storetokens ) $whitespace$ { $newline$ $indentation$ assertnotnull ( firstchoice ) ; $newline$ $indentation$ assertnotnull ( secondchoice ) ; $newline$ $indentation$ if $whitespace$ ( firstchoice . valid ( ) $whitespace$ || $whitespace$ secondchoice . invalid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ firstchoice ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ secondchoice ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }	$indentation$ javatoken $whitespace$ orifinvalid ( javatoken $whitespace$ firstchoice, $whitespace$ javatoken $whitespace$ secondchoice ) { $newline$ $indentation$ if $whitespace$ ( storetokens ) $whitespace$ { $newline$ $indentation$ assertnotnull ( firstchoice ) ; $newline$ $indentation$ assertnotnull ( secondchoice ) ; $newline$ $indentation$ if $whitespace$ ( firstchoice. valid ( ) $whitespace$ || $whitespace$ secondchoice. invalid ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ firstchoice ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ secondchoice ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }			
unTripleQuote	434	444	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.8370468616485596	HIGH	"		 String unTripleQuote(String s){
		    int start = 3;
		    // Skip over the first end of line too:
		    if (s.charAt(start) == '\r') {
		        start++;
		    }
		    if (s.charAt(start) == '\n') {
		        start++;
		    }
		    return s.substring(start, s.length() - 3);
		}"	$indentation$ string $whitespace$ untriplequote ( string $whitespace$ s ) { $newline$ $indentation$ int $whitespace$ start $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·skip·over·the·first·end·of·line·too:$ $newline$ $indentation$ if $whitespace$ ( s . charat ( start ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ start ++ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( s . charat ( start ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ start ++ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ s . substring ( start , $whitespace$ s . length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ }	$indentation$ string $whitespace$ untriplequote ( string $whitespace$ s ) { $newline$ $indentation$ int $whitespace$ start $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( s. charat ( start ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ start ++ ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( s. charat ( start ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ start ++ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ s. substring ( start, $whitespace$ s. length ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ }			
tokenRange	94	99	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/GeneratedJavaParserBase.java	0.8610783219337463	HIGH	"		 TokenRange tokenRange(){
		    if (storeTokens) {
		        return new TokenRange(token(), token());
		    }
		    return null;
		}"	$indentation$ tokenrange $whitespace$ tokenrange ( ) { $newline$ $indentation$ if $whitespace$ ( storetokens ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokenrange ( token ( ) , $whitespace$ token ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }	$indentation$ tokenrange $whitespace$ tokenrange ( ) { $newline$ $indentation$ if $whitespace$ ( storetokens ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokenrange ( token ( ), $whitespace$ token ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ tokenrange ( token ( ), $whitespace$ token ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }			
add	48	53	javaparser/javaparser-core/src/main/javacc-support/com/github/javaparser/RangedList.java	0.8528661131858826	HIGH	"		 void add(T t){
		    if (list == null) {
		        list = new NodeList<>();
		    }
		    list.add(t);
		}"	$indentation$ void $whitespace$ add ( t $whitespace$ t ) { $newline$ $indentation$ if $whitespace$ ( list $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ list $whitespace$ = $whitespace$ new $whitespace$ nodelist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list . add ( t ) ; $newline$ $indentation$ }	$indentation$ void $whitespace$ add ( t $whitespace$ t ) { $newline$ $indentation$ if $whitespace$ ( list $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ list. add ( t ) ; $newline$ $indentation$ }			
getType	365	375	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java	0.0971083417534828	LOW	"		@Override
		public ResolvedType getType(){
		    Node parentNode = parameter.getParentNode().get();
		    if (parameter.getType().isUnknownType() && parentNode instanceof LambdaExpr) {
		        Optional<Value> value = JavaParserFactory.getContext(parentNode, typeSolver).solveSymbolAsValue(parameter.getNameAsString());
		        return value.map(v -> v.getType()).orElseThrow(() -> new UnsolvedSymbolException(""We are unable to resolve the parameter declaration corresponding to "" + parameter));
		    }
		    return JavaParserFacade.get(typeSolver).convertToUsage(parameter.getType());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ parameter . getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parameter . gettype ( ) . isunknowntype ( ) $whitespace$ && $whitespace$ parentnode $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ optional < value > $whitespace$ value $whitespace$ = $whitespace$ javaparserfactory . getcontext ( parentnode , $whitespace$ typesolver ) . solvesymbolasvalue ( parameter . getnameasstring ( ) ) ; $newline$ $indentation$ return $whitespace$ value . map ( v $whitespace$ - > $whitespace$ v . gettype ( ) ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ parameter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( parameter . gettype ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ parameter. getparentnode ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ ( parameter. gettype ( ). isunknowntype ( ) $whitespace$ && $whitespace$ parentnode $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ optional < value > $whitespace$ value $whitespace$ = $whitespace$ javaparserfactory. getcontext ( parentnode, $whitespace$ typesolver ). solvesymbolasvalue ( parameter. getnameasstring ( ) ) ; $newline$ $indentation$ return $whitespace$ value. map ( v $whitespace$ - > $whitespace$ v. gettype ( ) ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ parameter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade. get ( typesolver ). converttousage ( parameter. gettype ( ) ) ; $newline$ $indentation$ }			
resolveParameterDeclaration	321	329	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java	0.2062560617923736	LOW	"		private Optional<ResolvedParameterDeclaration> resolveParameterDeclaration(ResolvedMethodLikeDeclaration resolvedMethodLikeDeclaration, Parameter parameter){
		    for (int i = 0; i < resolvedMethodLikeDeclaration.getNumberOfParams(); i++) {
		        if (resolvedMethodLikeDeclaration.getParam(i).getName().equals(parameter.getNameAsString())) {
		            return Optional.of(resolvedMethodLikeDeclaration.getParam(i));
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ private $whitespace$ optional < resolvedparameterdeclaration > $whitespace$ resolveparameterdeclaration ( resolvedmethodlikedeclaration $whitespace$ resolvedmethodlikedeclaration , $whitespace$ parameter $whitespace$ parameter ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resolvedmethodlikedeclaration . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( resolvedmethodlikedeclaration . getparam ( i ) . getname ( ) . equals ( parameter . getnameasstring ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( resolvedmethodlikedeclaration . getparam ( i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < resolvedparameterdeclaration > $whitespace$ resolveparameterdeclaration ( resolvedmethodlikedeclaration $whitespace$ resolvedmethodlikedeclaration, $whitespace$ parameter $whitespace$ parameter ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resolvedmethodlikedeclaration. getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( resolvedmethodlikedeclaration. getparam ( i ). getname ( ). equals ( parameter. getnameasstring ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( resolvedmethodlikedeclaration. getparam ( i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
toResolvedType	391	399	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/JavaSymbolSolver.java	0.2288414388895034	LOW	"		@Override
		public T toResolvedType(Type javaparserType, Class<T> resultClass){
		    ResolvedType resolvedType = JavaParserFacade.get(typeSolver).convertToUsage(javaparserType);
		    if (resultClass.isInstance(resolvedType)) {
		        return resultClass.cast(resolvedType);
		    }
		    throw new UnsupportedOperationException(""Unable to get the resolved type of class "" + resultClass.getSimpleName() + "" from "" + javaparserType);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ t $whitespace$ toresolvedtype ( type $whitespace$ javaparsertype , $whitespace$ class < t > $whitespace$ resultclass ) { $newline$ $indentation$ resolvedtype $whitespace$ resolvedtype $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( javaparsertype ) ; $newline$ $indentation$ if $whitespace$ ( resultclass . isinstance ( resolvedtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resultclass . cast ( resolvedtype ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ resultclass . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ javaparsertype ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ t $whitespace$ toresolvedtype ( type $whitespace$ javaparsertype, $whitespace$ class < t > $whitespace$ resultclass ) { $newline$ $indentation$ return $whitespace$ javaparserfacade. get ( typesolver ). converttousage ( javaparsertype ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ init ( typesolver $whitespace$ type ) { $newline$ $indentation$ resolvedtype $whitespace$ resolvedtype $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). converttousage ( javaparsertype ) ; $newline$ $indentation$ if $whitespace$ ( resultclass. isinstance ( resolvedtype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resultclass. cast ( resolvedtype ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ resultclass. getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ javaparsertype ) ; $newline$ $indentation$ }			
minus	256	265	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/DefaultCacheStats.java	0.0007184722344391	LOW	"		@Override
		public CacheStats minus(CacheStats other){
		    return new DefaultCacheStats(Math.max(0, saturatedSubtract(hitCount, other.hitCount())), Math.max(0, saturatedSubtract(missCount, other.missCount())), Math.max(0, saturatedSubtract(loadSuccessCount, other.loadSuccessCount())), Math.max(0, saturatedSubtract(loadExceptionCount, other.loadExceptionCount())), Math.max(0, saturatedSubtract(totalLoadTime, other.totalLoadTime())), Math.max(0, saturatedSubtract(evictionCount, other.evictionCount())));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ minus ( cachestats $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( math . max ( $number$ , $whitespace$ saturatedsubtract ( hitcount , $whitespace$ other . hitcount ( ) ) ) , $whitespace$ math . max ( $number$ , $whitespace$ saturatedsubtract ( misscount , $whitespace$ other . misscount ( ) ) ) , $whitespace$ math . max ( $number$ , $whitespace$ saturatedsubtract ( loadsuccesscount , $whitespace$ other . loadsuccesscount ( ) ) ) , $whitespace$ math . max ( $number$ , $whitespace$ saturatedsubtract ( loadexceptioncount , $whitespace$ other . loadexceptioncount ( ) ) ) , $whitespace$ math . max ( $number$ , $whitespace$ saturatedsubtract ( totalloadtime , $whitespace$ other . totalloadtime ( ) ) ) , $whitespace$ math . max ( $number$ , $whitespace$ saturatedsubtract ( evictioncount , $whitespace$ other . evictioncount ( ) ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ minus ( cachestats $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( math. max ( $number$, $whitespace$ object. hitcount ( ) ) ), $whitespace$ math. max ( $number$, $whitespace$ object. misscount ( ) ) ), $whitespace$ math. max ( $number$, $whitespace$ object. misscount ( ) ) ), $whitespace$ math. max ( $number$, $whitespace$ $whitespace$ sortestpathtoberemoved ) ), $whitespace$ math. max ( $number$, $whitespace$ object. loadsuccesscount ( ) ) ), $whitespace$ math. max ( $number$, $whitespace$ sortestpathtoberemoved ) ), $whitespace$ math. max ( $number$, $whitespace$ sortsubtract ( loadexceptioncount, $whitespace$ other. totalloadtime ( ) ) ), $whitespace$ math. max ( $number$, $whitespace$ object. totalloadtime ( ) ) ) ) ; $newline$ $indentation$ }			
plus	277	286	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/DefaultCacheStats.java	0.0111592849716544	LOW	"		@Override
		public CacheStats plus(CacheStats other){
		    return new DefaultCacheStats(saturatedAdd(hitCount, other.hitCount()), saturatedAdd(missCount, other.missCount()), saturatedAdd(loadSuccessCount, other.loadSuccessCount()), saturatedAdd(loadExceptionCount, other.loadExceptionCount()), saturatedAdd(totalLoadTime, other.totalLoadTime()), saturatedAdd(evictionCount, other.evictionCount()));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ plus ( cachestats $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( saturatedadd ( hitcount , $whitespace$ other . hitcount ( ) ) , $whitespace$ saturatedadd ( misscount , $whitespace$ other . misscount ( ) ) , $whitespace$ saturatedadd ( loadsuccesscount , $whitespace$ other . loadsuccesscount ( ) ) , $whitespace$ saturatedadd ( loadexceptioncount , $whitespace$ other . loadexceptioncount ( ) ) , $whitespace$ saturatedadd ( totalloadtime , $whitespace$ other . totalloadtime ( ) ) , $whitespace$ saturatedadd ( evictioncount , $whitespace$ other . evictioncount ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ plus ( cachestats $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( cacheadd ( hitcount, $whitespace$ other. hitcount ( ) ), $whitespace$$add ( misscount, $whitespace$ other. misscount ( ) ), $whitespace$$add ( loadsuccesscount, $whitespace$ other. loadsuccesscount ( ) ), $whitespace$ eadd ( loadexceptioncount, $whitespace$ other. loadexceptioncount ( ) ), $whitespace$ $add ( totalloadtime, $whitespace$ other. totalloadtime ( ) ), $whitespace$ $add ( $newline$ $indentation$ other. changecount ( ), $whitespace$ other. headercount ( ) ) ) ; $newline$ $indentation$ }			
toString	308	318	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/DefaultCacheStats.java	0.012904311530292	LOW	"		@Override
		public String toString(){
		    StringBuilder sb = new StringBuilder(this.getClass().getSimpleName()).append("": "");
		    return sb.append(""hitCount"").append(hitCount).append("","").append(""missCount"").append(missCount).append("","").append(""loadSuccessCount"").append(loadSuccessCount).append("","").append(""loadExceptionCount"").append(loadExceptionCount).append("","").append(""totalLoadTime"").append(totalLoadTime).append("","").append(""evictionCount"").append(evictionCount).append("","").toString();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( this . getclass ( ) . getsimplename ( ) ) . append ( $string$ ) ; $newline$ $indentation$ return $whitespace$ sb . append ( $string$ ) . append ( hitcount ) . append ( $string$ ) . append ( $string$ ) . append ( misscount ) . append ( $string$ ) . append ( $string$ ) . append ( loadsuccesscount ) . append ( $string$ ) . append ( $string$ ) . append ( loadexceptioncount ) . append ( $string$ ) . append ( $string$ ) . append ( totalloadtime ) . append ( $string$ ) . append ( $string$ ) . append ( evictioncount ) . append ( $string$ ) . tostring ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ stringbuilder $whitespace$ sb $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( this. getclass ( ). getsimplename ( ) ) ; $newline$ $indentation$ return $whitespace$ sb. append ( $string$ ). append ( hitcount ). append ( $string$ ). append ( $string$ ). append ( misscount ). append ( $string$ ). append ( $string$ ). append ( loadsuccesscount ). append ( $string$ ). append ( $string$ ). append ( loadexceptioncount ). append ( $string$ ). append ( $string$ ). append ( totalloadtime ). append ( $string$ ). append ( $string$ ). append ( $string$ ). append ( $string$ ). append ( evictioncount ). append ( $string$ ). tostring ( ) ; $newline$ $indentation$ }			
equals	294	306	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/DefaultCacheStats.java	0.0358267799019813	LOW	"		@Override
		public boolean equals(@CheckForNull Object object){
		    if (object instanceof CacheStats) {
		        CacheStats other = (CacheStats) object;
		        return hitCount == other.hitCount() && missCount == other.missCount() && loadSuccessCount == other.loadSuccessCount() && loadExceptionCount == other.loadExceptionCount() && totalLoadTime == other.totalLoadTime() && evictionCount == other.evictionCount();
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( @ checkfornull $whitespace$ object $whitespace$ object ) { $newline$ $indentation$ if $whitespace$ ( object $whitespace$ instanceof $whitespace$ cachestats ) $whitespace$ { $newline$ $indentation$ cachestats $whitespace$ other $whitespace$ = $whitespace$ ( cachestats ) $whitespace$ object ; $newline$ $indentation$ return $whitespace$ hitcount $whitespace$ == $whitespace$ other . hitcount ( ) $whitespace$ && $whitespace$ misscount $whitespace$ == $whitespace$ other . misscount ( ) $whitespace$ && $whitespace$ loadsuccesscount $whitespace$ == $whitespace$ other . loadsuccesscount ( ) $whitespace$ && $whitespace$ loadexceptioncount $whitespace$ == $whitespace$ other . loadexceptioncount ( ) $whitespace$ && $whitespace$ totalloadtime $whitespace$ == $whitespace$ other . totalloadtime ( ) $whitespace$ && $whitespace$ evictioncount $whitespace$ == $whitespace$ other . evictioncount ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( @ checkfornull $whitespace$ object $whitespace$ object ) { $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$ object $whitespace$ instanceof $whitespace$ cachestats $whitespace$ && $whitespace$ object $whitespace$ instanceof $whitespace$ cachestats ) ; $newline$ $indentation$ if $whitespace$ ( isequals ) $whitespace$ { $newline$ $indentation$ isequals $whitespace$ = $whitespace$ ( cachestats ) $whitespace$ object ; $newline$ $indentation$ } $newline$ $indentation$ cachestats $whitespace$ other $whitespace$ = $whitespace$ ( cachestats ) $whitespace$ object ; $newline$ $indentation$ return $whitespace$ hitcount $whitespace$ == $whitespace$ other. hitcount ( ) $whitespace$ && $whitespace$ misscount $whitespace$ == $whitespace$ other. misscount ( ) $whitespace$ && $whitespace$ loadsuccesscount $whitespace$ == $whitespace$ other. loadsuccesscount ( ) $whitespace$ && $whitespace$ loadexceptioncount $whitespace$ == $whitespace$ other. loadexceptioncount ( ) $whitespace$ && $whitespace$ totalloadtime $whitespace$ == $whitespace$ other. totalloadtime ( ) $whitespace$ && $whitespace$ evictioncount $whitespace$ == $whitespace$ other. evictioncount ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
totalLoadTime	222	226	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/DefaultCacheStats.java	0.909385085105896	HIGH	"		@Override
		// should return a java.time.Duration
		@SuppressWarnings(""GoodTime"")
		public long totalLoadTime(){
		    return totalLoadTime;
		}"	$indentation$ @ override $newline$ $indentation$ $//·should·return·a·java.time.duration$ $newline$ $indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ long $whitespace$ totalloadtime ( ) { $newline$ $indentation$ return $whitespace$ totalloadtime ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ $////////////////////////////////////shouldshould$ = $whitespace$return ; $newline$ $indentation$ @ suppresswarnings ( $string$ ) $newline$ $indentation$ public $whitespace$ long $whitespace$ totalloadtime ( ) { $newline$ $indentation$ return $whitespace$ totalloadtime ; $newline$ $indentation$ }			
stats	95	100	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/GuavaCache.java	0.2402293384075164	LOW	"		@Override
		public CacheStats stats(){
		    com.google.common.cache.CacheStats stats = guavaCache.stats();
		    return new DefaultCacheStats(stats.hitCount(), stats.missCount(), stats.loadSuccessCount(), stats.loadExceptionCount(), stats.totalLoadTime(), stats.evictionCount());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ stats ( ) { $newline$ $indentation$ com . google . common . cache . cachestats $whitespace$ stats $whitespace$ = $whitespace$ guavacache . stats ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( stats . hitcount ( ) , $whitespace$ stats . misscount ( ) , $whitespace$ stats . loadsuccesscount ( ) , $whitespace$ stats . loadexceptioncount ( ) , $whitespace$ stats . totalloadtime ( ) , $whitespace$ stats . evictioncount ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ cachestats $whitespace$ stats ( ) { $newline$ $indentation$ return $whitespace$ new $whitespace$ defaultcachestats ( stats. hitcount ( ), $whitespace$ stats. misscount ( ), $whitespace$ stats. loadsuccesscount ( ), $whitespace$ stats. loadexceptioncount ( ), $whitespace$ stats. totalloadtime ( ), $whitespace$ stats. evictioncount ( ) ) ; $newline$ $indentation$ }			
get	65	70	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/cache/InMemoryCache.java	0.6277040839195251	MID	"		@Override
		public Optional<V> get(K key){
		    return Optional.ofNullable(mappedValues.get(key));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < v > $whitespace$ get ( k $whitespace$ key ) { $newline$ $indentation$ return $whitespace$ optional . ofnullable ( mappedvalues . get ( key ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < v > $whitespace$ get ( k $whitespace$ key ) { $newline$ $indentation$ return $whitespace$ optional. ofnullable ( mappedvalues. get ( key ) ) ; $newline$ $indentation$ }			
resolveTypeVariables	51	84	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/declarations/common/MethodDeclarationCommonLogic.java	0.0941959097981453	LOW	"		public MethodUsage resolveTypeVariables(Context context, List<ResolvedType> parameterTypes){
		    ResolvedType returnType = replaceTypeParams(methodDeclaration.getReturnType(), context);
		    List<ResolvedType> params = new ArrayList<>();
		    for (int i = 0; i < methodDeclaration.getNumberOfParams(); i++) {
		        ResolvedType replaced = replaceTypeParams(methodDeclaration.getParam(i).getType(), context);
		        params.add(replaced);
		    }
		    // We now look at the type parameter for the method which we can derive from the parameter types
		    // and then we replace them in the return type
		    // Map<TypeParameterDeclaration, Type> determinedTypeParameters = new HashMap<>();
		    InferenceContext inferenceContext = new InferenceContext(typeSolver);
		    for (int i = 0; i < methodDeclaration.getNumberOfParams(); i++) {
		        ResolvedParameterDeclaration formalParamDecl = methodDeclaration.getParam(i);
		        ResolvedType formalParamType = formalParamDecl.getType();
		        // Don't continue if a vararg parameter is reached and there are no arguments left
		        if (formalParamDecl.isVariadic() && parameterTypes.size() < methodDeclaration.getNumberOfParams()) {
		            break;
		        }
		        ResolvedType actualParamType = parameterTypes.get(i);
		        if (formalParamDecl.isVariadic() && !actualParamType.isArray()) {
		            formalParamType = formalParamType.asArrayType().getComponentType();
		        }
		        inferenceContext.addPair(formalParamType, actualParamType);
		    }
		    returnType = inferenceContext.resolve(inferenceContext.addSingle(returnType));
		    return new MethodUsage(methodDeclaration, params, returnType);
		}"	$indentation$ public $whitespace$ methodusage $whitespace$ resolvetypevariables ( context $whitespace$ context , $whitespace$ list < resolvedtype > $whitespace$ parametertypes ) { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ replacetypeparams ( methoddeclaration . getreturntype ( ) , $whitespace$ context ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ params $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ replaced $whitespace$ = $whitespace$ replacetypeparams ( methoddeclaration . getparam ( i ) . gettype ( ) , $whitespace$ context ) ; $newline$ $indentation$ params . add ( replaced ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·we·now·look·at·the·type·parameter·for·the·method·which·we·can·derive·from·the·parameter·types$ $newline$ $indentation$ $//·and·then·we·replace·them·in·the·return·type$ $newline$ $indentation$ $//·map<typeparameterdeclaration,·type>·determinedtypeparameters·=·new·hashmap<>();$ $newline$ $indentation$ inferencecontext $whitespace$ inferencecontext $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedparameterdeclaration $whitespace$ formalparamdecl $whitespace$ = $whitespace$ methoddeclaration . getparam ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ formalparamtype $whitespace$ = $whitespace$ formalparamdecl . gettype ( ) ; $newline$ $indentation$ $//·don't·continue·if·a·vararg·parameter·is·reached·and·there·are·no·arguments·left$ $newline$ $indentation$ if $whitespace$ ( formalparamdecl . isvariadic ( ) $whitespace$ && $whitespace$ parametertypes . size ( ) $whitespace$ < $whitespace$ methoddeclaration . getnumberofparams ( ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ actualparamtype $whitespace$ = $whitespace$ parametertypes . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( formalparamdecl . isvariadic ( ) $whitespace$ && $whitespace$ ! actualparamtype . isarray ( ) ) $whitespace$ { $newline$ $indentation$ formalparamtype $whitespace$ = $whitespace$ formalparamtype . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ inferencecontext . addpair ( formalparamtype , $whitespace$ actualparamtype ) ; $newline$ $indentation$ } $newline$ $indentation$ returntype $whitespace$ = $whitespace$ inferencecontext . resolve ( inferencecontext . addsingle ( returntype ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( methoddeclaration , $whitespace$ params , $whitespace$ returntype ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ methodusage $whitespace$ resolvetypevariables ( context $whitespace$ context, $whitespace$ list < resolvedtype > $whitespace$ parametertypes ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ params $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration. getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ replaced $whitespace$ = $whitespace$ replacetypeparams ( methoddeclaration. getparam ( i ). gettype ( ), $whitespace$ context ) ; $newline$ $indentation$ replaced. add ( replaced ) ; $newline$ $indentation$ } $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ method $whitespace$ returns $whitespace$ the $whitespace$ current $whitespace$ logic $newline$ $indentation$ /////////////////////////////// $newline$ $indentation$ // $whitespace$ token $whitespace$ and $whitespace$ resolvedtype $whitespace$ replaced $whitespace$ = $whitespace$ the $whitespace$ variable $whitespace$ behind $whitespace$ get $whitespace$ 4 $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resolvedtype > $whitespace$ parametertypes $whitespace$ = $whitespace$ $newline$ $indentation$ m_left ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resolvedtype > $whitespace$ parametertypes $whitespace$ = $whitespace$ $newline$ $indentation$ m_right ; $newline			
findRootCause	59	67	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/FailureHandler.java	0.8423586487770081	HIGH	"		protected final E findRootCause(Throwable failure){
		    while (failure != null) {
		        if (isRootCause(failure)) {
		            return (E) failure;
		        }
		        failure = failure.getCause();
		    }
		    return null;
		}"	$indentation$ protected $whitespace$ final $whitespace$ e $whitespace$ findrootcause ( throwable $whitespace$ failure ) { $newline$ $indentation$ while $whitespace$ ( failure $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( isrootcause ( failure ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( e ) $whitespace$ failure ; $newline$ $indentation$ } $newline$ $indentation$ failure $whitespace$ = $whitespace$ failure . getcause ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ final $whitespace$ e $whitespace$ findrootcause ( throwable $whitespace$ failure ) { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ while $whitespace$ ( failure $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( isrootcause ( failure ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( e ) $whitespace$ failure ; $newline$ $indentation$ } $newline$ $indentation$ failure $whitespace$ = $whitespace$ failure. getcause ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }			
toMethodUsage	387	439	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.0085165612399578	LOW	"		protected MethodUsage toMethodUsage(MethodReferenceExpr methodReferenceExpr, List<ResolvedType> paramTypes){
		    Expression scope = methodReferenceExpr.getScope();
		    ResolvedType typeOfScope = getType(methodReferenceExpr.getScope());
		    if (!typeOfScope.isReferenceType()) {
		        throw new UnsupportedOperationException(typeOfScope.getClass().getCanonicalName());
		    }
		    Optional<MethodUsage> result;
		    ResolvedReferenceTypeDeclaration resolvedTypdeDecl = typeOfScope.asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty.""));
		    Set<MethodUsage> allMethods = resolvedTypdeDecl.getAllMethods();
		    if (scope.isTypeExpr()) {
		        // static methods should match all params
		        List<MethodUsage> staticMethodUsages = allMethods.stream().filter(it -> it.getDeclaration().isStatic()).collect(Collectors.toList());
		        result = MethodResolutionLogic.findMostApplicableUsage(staticMethodUsages, methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);
		        if (!paramTypes.isEmpty()) {
		            // instance methods are called on the first param and should match all other params
		            List<MethodUsage> instanceMethodUsages = allMethods.stream().filter(it -> !it.getDeclaration().isStatic()).collect(Collectors.toList());
		            List<ResolvedType> instanceMethodParamTypes = new ArrayList<>(paramTypes);
		            // remove the first one
		            instanceMethodParamTypes.remove(0);
		            Optional<MethodUsage> instanceResult = MethodResolutionLogic.findMostApplicableUsage(instanceMethodUsages, methodReferenceExpr.getIdentifier(), instanceMethodParamTypes, typeSolver);
		            if (result.isPresent() && instanceResult.isPresent()) {
		                throw new MethodAmbiguityException(""Ambiguous method call: cannot find a most applicable method for "" + methodReferenceExpr.getIdentifier());
		            }
		            if (instanceResult.isPresent()) {
		                result = instanceResult;
		            }
		        }
		    } else {
		        result = MethodResolutionLogic.findMostApplicableUsage(new ArrayList<>(allMethods), methodReferenceExpr.getIdentifier(), paramTypes, typeSolver);
		        if (result.isPresent() && result.get().getDeclaration().isStatic()) {
		            throw new RuntimeException(""Invalid static method reference "" + methodReferenceExpr.getIdentifier());
		        }
		    }
		    if (!result.isPresent()) {
		        throw new UnsupportedOperationException();
		    }
		    return result.get();
		}"	$indentation$ protected $whitespace$ methodusage $whitespace$ tomethodusage ( methodreferenceexpr $whitespace$ methodreferenceexpr , $whitespace$ list < resolvedtype > $whitespace$ paramtypes ) { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ methodreferenceexpr . getscope ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ typeofscope $whitespace$ = $whitespace$ gettype ( methodreferenceexpr . getscope ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ! typeofscope . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( typeofscope . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < methodusage > $whitespace$ result ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypdedecl $whitespace$ = $whitespace$ typeofscope . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ; $newline$ $indentation$ set < methodusage > $whitespace$ allmethods $whitespace$ = $whitespace$ resolvedtypdedecl . getallmethods ( ) ; $newline$ $indentation$ if $whitespace$ ( scope . istypeexpr ( ) ) $whitespace$ { $newline$ $indentation$ $//·static·methods·should·match·all·params$ $newline$ $indentation$ list < methodusage > $whitespace$ staticmethodusages $whitespace$ = $whitespace$ allmethods . stream ( ) . filter ( it $whitespace$ - > $whitespace$ it . getdeclaration ( ) . isstatic ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ methodresolutionlogic . findmostapplicableusage ( staticmethodusages , $whitespace$ methodreferenceexpr . getidentifier ( ) , $whitespace$ paramtypes , $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( ! paramtypes . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·instance·methods·are·called·on·the·first·param·and·should·match·all·other·params$ $newline$ $indentation$ list < methodusage > $whitespace$ instancemethodusages $whitespace$ = $whitespace$ allmethods . stream ( ) . filter ( it $whitespace$ - > $whitespace$ ! it . getdeclaration ( ) . isstatic ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ instancemethodparamtypes $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( paramtypes ) ; $newline$ $indentation$ $//·remove·the·first·one$ $newline$ $indentation$ instancemethodparamtypes . remove ( $number$ ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ instanceresult $whitespace$ = $whitespace$ methodresolutionlogic . findmostapplicableusage ( instancemethodusages , $whitespace$ methodreferenceexpr . getidentifier ( ) , $whitespace$ instancemethodparamtypes , $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( result . ispresent ( ) $whitespace$ && $whitespace$ instanceresult . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ methodambiguityexception ( $string$ $whitespace$ + $whitespace$ methodreferenceexpr . getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( instanceresult . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ instanceresult ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ result $whitespace$ = $whitespace$ methodresolutionlogic . findmostapplicableusage ( new $whitespace$ arraylist < > ( allmethods ) , $whitespace$ methodreferenceexpr . getidentifier ( ) , $whitespace$ paramtypes , $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( result . ispresent ( ) $whitespace$ && $whitespace$ result . get ( ) . getdeclaration ( ) . isstatic ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ methodreferenceexpr . getidentifier ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! result . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result . get ( ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ methodusage $whitespace$ tomethodusage ( methodreferenceexpr $whitespace$ methodreferenceexpr, $whitespace$ list < resolvedtype > $whitespace$ paramtypes ) { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ methodreferenceexpr. getscope ( ) ; $newline$ $indentation$ if $whitespace$ (! typeofscope. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( typeofscope. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < methodusage > $whitespace$ result ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypdedecl $whitespace$ = $whitespace$ typeofscope. asreferencetype ( ). gettypedeclaration ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ; $newline$ $indentation$ set < methodusage > $whitespace$ allmethods $whitespace$ = $whitespace$ resolvedtypdedecl. getallmethods ( ) ; $newline$ $indentation$ if $whitespace$ ( scope. istypeexpr ( ) ) $whitespace$ { $newline$ $indentation$ $////g$staticchestationmethods = $whitespace$ allmethods. stream ( ). filter ( it $whitespace$ - > $whitespace$ it. getdeclaration ( ). isstatic ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ methodresolutionlogic. findmostapplicableusage ( staticmethodusages, $whitespace$			
solve	149	189	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.0218167137354612	LOW	"		public SymbolReference<ResolvedConstructorDeclaration> solve(ExplicitConstructorInvocationStmt explicitConstructorInvocationStmt, boolean solveLambdas){
		    // Constructor invocation must exist within a class (not interface).
		    Optional<ClassOrInterfaceDeclaration> optAncestorClassOrInterfaceNode = explicitConstructorInvocationStmt.findAncestor(ClassOrInterfaceDeclaration.class);
		    if (!optAncestorClassOrInterfaceNode.isPresent()) {
		        return unsolved();
		    }
		    ClassOrInterfaceDeclaration classOrInterfaceNode = optAncestorClassOrInterfaceNode.get();
		    ResolvedReferenceTypeDeclaration resolvedClassNode = classOrInterfaceNode.resolve();
		    if (!resolvedClassNode.isClass()) {
		        throw new IllegalStateException(""Expected to be a class -- cannot call this() or super() within an interface."");
		    }
		    ResolvedTypeDeclaration typeDecl = null;
		    if (explicitConstructorInvocationStmt.isThis()) {
		        // this()
		        typeDecl = resolvedClassNode.asReferenceType();
		    } else {
		        // super()
		        Optional<ResolvedReferenceType> superClass = resolvedClassNode.asClass().getSuperClass();
		        if (superClass.isPresent() && superClass.get().getTypeDeclaration().isPresent()) {
		            typeDecl = superClass.get().getTypeDeclaration().get();
		        }
		    }
		    if (typeDecl == null) {
		        return unsolved();
		    }
		    // Solve each of the arguments being passed into this constructor invocation.
		    List<ResolvedType> argumentTypes = new LinkedList<>();
		    List<LambdaArgumentTypePlaceholder> placeholders = new LinkedList<>();
		    solveArguments(explicitConstructorInvocationStmt, explicitConstructorInvocationStmt.getArguments(), solveLambdas, argumentTypes, placeholders);
		    // Determine which constructor is referred to, and return it.
		    SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) typeDecl).getConstructors(), argumentTypes, typeSolver);
		    for (LambdaArgumentTypePlaceholder placeholder : placeholders) {
		        placeholder.setMethod(res);
		    }
		    return res;
		}"	$indentation$ public $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ solve ( explicitconstructorinvocationstmt $whitespace$ explicitconstructorinvocationstmt , $whitespace$ boolean $whitespace$ solvelambdas ) { $newline$ $indentation$ $//·constructor·invocation·must·exist·within·a·class·(not·interface).$ $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ optancestorclassorinterfacenode $whitespace$ = $whitespace$ explicitconstructorinvocationstmt . findancestor ( classorinterfacedeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( ! optancestorclassorinterfacenode . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ classorinterfacedeclaration $whitespace$ classorinterfacenode $whitespace$ = $whitespace$ optancestorclassorinterfacenode . get ( ) ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedclassnode $whitespace$ = $whitespace$ classorinterfacenode . resolve ( ) ; $newline$ $indentation$ if $whitespace$ ( ! resolvedclassnode . isclass ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ typedecl $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( explicitconstructorinvocationstmt . isthis ( ) ) $whitespace$ { $newline$ $indentation$ $//·this()$ $newline$ $indentation$ typedecl $whitespace$ = $whitespace$ resolvedclassnode . asreferencetype ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·super()$ $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ superclass $whitespace$ = $whitespace$ resolvedclassnode . asclass ( ) . getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( superclass . ispresent ( ) $whitespace$ && $whitespace$ superclass . get ( ) . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ typedecl $whitespace$ = $whitespace$ superclass . get ( ) . gettypedeclaration ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typedecl $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·solve·each·of·the·arguments·being·passed·into·this·constructor·invocation.$ $newline$ $indentation$ list < resolvedtype > $whitespace$ argumenttypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ list < lambdaargumenttypeplaceholder > $whitespace$ placeholders $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ solvearguments ( explicitconstructorinvocationstmt , $whitespace$ explicitconstructorinvocationstmt . getarguments ( ) , $whitespace$ solvelambdas , $whitespace$ argumenttypes , $whitespace$ placeholders ) ; $newline$ $indentation$ $//·determine·which·constructor·is·referred·to,·and·return·it.$ $newline$ $indentation$ symbolreference < resolvedconstructordeclaration > $whitespace$ res $whitespace$ = $whitespace$ constructorresolutionlogic . findmostapplicable ( ( ( resolvedclassdeclaration ) $whitespace$ typedecl ) . getconstructors ( ) , $whitespace$ argumenttypes , $whitespace$ typesolver ) ; $newline$ $indentation$ for $whitespace$ ( lambdaargumenttypeplaceholder $whitespace$ placeholder $whitespace$ : $whitespace$ placeholders ) $whitespace$ { $newline$ $indentation$ placeholder . setmethod ( res ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ public $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ solve ( explicitconstructorinvocationstmt $whitespace$ explicitconstructorinvocationstmt, $whitespace$ boolean $whitespace$ solvelambdas ) { $newline$ $indentation$ $indentation$ $whitespace$ return $whitespace$! optancestorclassorinterfacenode $whitespace$ = $whitespace$ explicitconstructorinvocationstmt. findancestor ( classorinterfacedeclaration. class ) ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ jorinterfacedeclaration $whitespace$ classorinterfacenode $whitespace$ = $whitespace$ optancestorclassorinterfacenode. get ( ) ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedclassnode $whitespace$ = $whitespace$ classorinterfacenode. resolve ( ) ; $newline$ $indentation$ if $whitespace$ (! resolvedclassnode. isclass ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ typedecl $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( explicitconstructorinvocationstmt. isthis ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ = $whitespace$ resolvedclassnode. asreferencetype ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ optional <			
solveArguments	241	262	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.0511859282851219	LOW	"		private void solveArguments(Node node, NodeList<Expression> args, boolean solveLambdas, List<ResolvedType> argumentTypes, List<LambdaArgumentTypePlaceholder> placeholders){
		    int i = 0;
		    for (Expression parameterValue : args) {
		        while (parameterValue instanceof EnclosedExpr) {
		            parameterValue = ((EnclosedExpr) parameterValue).getInner();
		        }
		        if (parameterValue.isLambdaExpr() || parameterValue.isMethodReferenceExpr()) {
		            LambdaArgumentTypePlaceholder placeholder = new LambdaArgumentTypePlaceholder(i);
		            argumentTypes.add(placeholder);
		            placeholders.add(placeholder);
		        } else {
		            try {
		                argumentTypes.add(JavaParserFacade.get(typeSolver).getType(parameterValue, solveLambdas));
		            } catch (Exception e) {
		                throw failureHandler.handle(e, String.format(""Unable to calculate the type of a parameter of a method call. Method call: %s, Parameter: %s"", node, parameterValue));
		            }
		        }
		        i++;
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ solvearguments ( node $whitespace$ node , $whitespace$ nodelist < expression > $whitespace$ args , $whitespace$ boolean $whitespace$ solvelambdas , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes , $whitespace$ list < lambdaargumenttypeplaceholder > $whitespace$ placeholders ) { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ parametervalue $whitespace$ : $whitespace$ args ) $whitespace$ { $newline$ $indentation$ while $whitespace$ ( parametervalue $whitespace$ instanceof $whitespace$ enclosedexpr ) $whitespace$ { $newline$ $indentation$ parametervalue $whitespace$ = $whitespace$ ( ( enclosedexpr ) $whitespace$ parametervalue ) . getinner ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parametervalue . islambdaexpr ( ) $whitespace$ || $whitespace$ parametervalue . ismethodreferenceexpr ( ) ) $whitespace$ { $newline$ $indentation$ lambdaargumenttypeplaceholder $whitespace$ placeholder $whitespace$ = $whitespace$ new $whitespace$ lambdaargumenttypeplaceholder ( i ) ; $newline$ $indentation$ argumenttypes . add ( placeholder ) ; $newline$ $indentation$ placeholders . add ( placeholder ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ argumenttypes . add ( javaparserfacade . get ( typesolver ) . gettype ( parametervalue , $whitespace$ solvelambdas ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ failurehandler . handle ( e , $whitespace$ string . format ( $string$ , $whitespace$ node , $whitespace$ parametervalue ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ solvearguments ( node $whitespace$ node, $whitespace$ nodelist < expression > $whitespace$ args, $whitespace$ boolean $whitespace$ solvelambdas, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes, $whitespace$ list < lambdaargumenttypeplaceholder > $whitespace$ placeholders ) { $newline$ $indentation$ int $whitespace$ _loadtime $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ parametervalue $whitespace$ : $whitespace$ args ) $whitespace$ { $newline$ $indentation$ while $whitespace$ ( parametervalue $whitespace$ instanceof $whitespace$ enclosedexpr ) $whitespace$ { $newline$ $indentation$ parametervalue $whitespace$ = $whitespace$ ( ( enclosedexpr ) $whitespace$ parametervalue ). getinner ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parametervalue. islambdaexpr ( ) $whitespace$ || $whitespace$ parametervalue. ismethodreferenceexpr ( ) ) $whitespace$ { $newline$ $indentation$ lambdaargumenttypeplaceholder $whitespace$ placeholder $whitespace$ = $whitespace$ new $whitespace$ lambdaargumenttypeplaceholder ( _loadtime ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ argumenttypes. add ( javaparserfacade. get ( typesolver ). gettype ( parametervalue, $whitespace$ solvelambdas ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ failurehandler. handle ( e, $whitespace$ string. format ( $string$, $whitespace$ node, $whitespace$ parametervalue ) ) ; $newline$ $indentation$			
solveMethodAsUsage	634	654	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.0513481013476848	LOW	"		public MethodUsage solveMethodAsUsage(MethodCallExpr call){
		    List<ResolvedType> params = new ArrayList<>();
		    if (call.getArguments() != null) {
		        for (Expression param : call.getArguments()) {
		            //getTypeConcrete(Node node, boolean solveLambdas)
		            try {
		                params.add(getType(param, false));
		            } catch (Exception e) {
		                throw failureHandler.handle(e, String.format(""Error calculating the type of parameter %s of method call %s"", param, call));
		            }
		            //params.add(getTypeConcrete(param, false));
		        }
		    }
		    Context context = JavaParserFactory.getContext(call, typeSolver);
		    Optional<MethodUsage> methodUsage = context.solveMethodAsUsage(call.getName().getId(), params);
		    if (!methodUsage.isPresent()) {
		        throw new UnsolvedSymbolException(""Method '"" + call.getName() + ""' cannot be resolved in context "" + call + "" (line: "" + call.getRange().map(r -> """" + r.begin.line).orElse(""??"") + "") "" + context + "". Parameter types: "" + params);
		    }
		    return methodUsage.get();
		}"	$indentation$ public $whitespace$ methodusage $whitespace$ solvemethodasusage ( methodcallexpr $whitespace$ call ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ params $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( call . getarguments ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ param $whitespace$ : $whitespace$ call . getarguments ( ) ) $whitespace$ { $newline$ $indentation$ $//gettypeconcrete(node·node,·boolean·solvelambdas)$ $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ params . add ( gettype ( param , $whitespace$ false ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ failurehandler . handle ( e , $whitespace$ string . format ( $string$ , $whitespace$ param , $whitespace$ call ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//params.add(gettypeconcrete(param,·false));$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ context $whitespace$ = $whitespace$ javaparserfactory . getcontext ( call , $whitespace$ typesolver ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ methodusage $whitespace$ = $whitespace$ context . solvemethodasusage ( call . getname ( ) . getid ( ) , $whitespace$ params ) ; $newline$ $indentation$ if $whitespace$ ( ! methodusage . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ call . getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ call $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ call . getrange ( ) . map ( r $whitespace$ - > $whitespace$ $string$ $whitespace$ + $whitespace$ r . begin . line ) . orelse ( $string$ ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ context $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ params ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage . get ( ) ; $newline$ $indentation$ }	"$indentation$ public $whitespace$ methodusage $whitespace$ solvemethodasusage ( methodcallexpr $whitespace$ call ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ params $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( call. getarguments ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ param $whitespace$ : $whitespace$ call. getarguments ( ) ) $whitespace$ { $newline$ $indentation$ $//gettypeconcrete(nodenode, $whitespace$$ = $whitespace$ gettype()+"""" $whitespace$ call $whitespace$ : $whitespace$ call. solvemethodasusage ( call. getname ( ). getid ( ), $whitespace$ params ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ context $whitespace$ = $whitespace$ javaparserfactory. getcontext ( call, $whitespace$ typesolver ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ methodusage $whitespace$ = $whitespace$ context. solvemethodasusage ( call. getname ( ). getid ( ), $whitespace$ params ) ; $newline$ $indentation$ if $whitespace$ (! methodusage. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ call"			
getType	329	344	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.2090063393115997	LOW	"		public ResolvedType getType(Node node){
		    try {
		        return getType(node, true);
		    } catch (UnsolvedSymbolException e) {
		        if (node instanceof NameExpr) {
		            NameExpr nameExpr = (NameExpr) node;
		            SymbolReference<ResolvedTypeDeclaration> typeDeclaration = JavaParserFactory.getContext(node, typeSolver).solveType(nameExpr.getNameAsString());
		            if (typeDeclaration.isSolved() && typeDeclaration.getCorrespondingDeclaration() instanceof ResolvedReferenceTypeDeclaration) {
		                ResolvedReferenceTypeDeclaration resolvedReferenceTypeDeclaration = (ResolvedReferenceTypeDeclaration) typeDeclaration.getCorrespondingDeclaration();
		                return ReferenceTypeImpl.undeterminedParameters(resolvedReferenceTypeDeclaration);
		            }
		        }
		        throw failureHandler.handle(e);
		    }
		}"	$indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( node $whitespace$ node ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ gettype ( node , $whitespace$ true ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ nameexpr $whitespace$ nameexpr $whitespace$ = $whitespace$ ( nameexpr ) $whitespace$ node ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ typedeclaration $whitespace$ = $whitespace$ javaparserfactory . getcontext ( node , $whitespace$ typesolver ) . solvetype ( nameexpr . getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( typedeclaration . issolved ( ) $whitespace$ && $whitespace$ typedeclaration . getcorrespondingdeclaration ( ) $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedreferencetypedeclaration $whitespace$ = $whitespace$ ( resolvedreferencetypedeclaration ) $whitespace$ typedeclaration . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ return $whitespace$ referencetypeimpl . undeterminedparameters ( resolvedreferencetypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ failurehandler . handle ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( node $whitespace$ node ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ gettype ( node, $whitespace$ true ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ nameexpr $whitespace$ nameexpr $whitespace$ = $whitespace$ ( nameexpr ) $whitespace$ node ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ typedeclaration $whitespace$ = $whitespace$ javaparserfactory. getcontext ( node, $whitespace$ typesolver ). solvetype ( nameexpr. getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( typedeclaration. issolved ( ) $whitespace$ && $whitespace$ typedeclaration. getcorrespondingdeclaration ( ) $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nodetypeimpl. undeterminedparameters ( resolvedreferencetypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ failurehandler. handle ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
forEachStmtWithVariableDeclarator	613	624	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.2712447941303253	LOW	"		private Optional<ForEachStmt> forEachStmtWithVariableDeclarator(VariableDeclarator variableDeclarator){
		    Optional<Node> node = variableDeclarator.getParentNode();
		    if (!node.isPresent() || !(node.get() instanceof VariableDeclarationExpr)) {
		        return Optional.empty();
		    }
		    node = node.get().getParentNode();
		    if (!node.isPresent() || !(node.get() instanceof ForEachStmt)) {
		        return Optional.empty();
		    }
		    return Optional.of((ForEachStmt) node.get());
		}"	$indentation$ private $whitespace$ optional < foreachstmt > $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ optional < node > $whitespace$ node $whitespace$ = $whitespace$ variabledeclarator . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! node . ispresent ( ) $whitespace$ || $whitespace$ ! ( node . get ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ = $whitespace$ node . get ( ) . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! node . ispresent ( ) $whitespace$ || $whitespace$ ! ( node . get ( ) $whitespace$ instanceof $whitespace$ foreachstmt ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( ( foreachstmt ) $whitespace$ node . get ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < foreachstmt > $whitespace$ foreachstmtwithvariabledeclarator ( variabledeclarator $whitespace$ variabledeclarator ) { $newline$ $indentation$ optional < node > $whitespace$ node $whitespace$ = $whitespace$ variabledeclarator. getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! node. ispresent ( ) $whitespace$ || $whitespace$! ( node. get ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ = $whitespace$ node. get ( ). getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! node. ispresent ( ) $whitespace$ || $whitespace$! ( node. get ( ) $whitespace$ instanceof $whitespace$ foreachstmt ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( ( foreachstmt ) $whitespace$ node. get ( ) ) ; $newline$ $indentation$ }			
getBinaryTypeConcrete	441	484	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.6293256878852844	MID	"		protected ResolvedType getBinaryTypeConcrete(Node left, Node right, boolean solveLambdas, BinaryExpr.Operator operator){
		    ResolvedType leftType = getTypeConcrete(left, solveLambdas);
		    ResolvedType rightType = getTypeConcrete(right, solveLambdas);
		    // JLS 15.18.1. String Concatenation Operator +
		    // If only one operand expression is of type String, then string conversion (§5.1.11) is performed on the other
		    // operand to produce a string at run time.
		    //
		    // The result of string concatenation is a reference to a String object that is the concatenation of the two
		    // operand strings. The characters of the left-hand operand precede the characters of the right-hand operand in
		    // the newly created string.
		    if (operator == BinaryExpr.Operator.PLUS) {
		        boolean isLeftString = leftType.isReferenceType() && leftType.asReferenceType().getQualifiedName().equals(JAVA_LANG_STRING);
		        boolean isRightString = rightType.isReferenceType() && rightType.asReferenceType().getQualifiedName().equals(JAVA_LANG_STRING);
		        if (isLeftString || isRightString) {
		            return isLeftString ? leftType : rightType;
		        }
		    }
		    // JLS 5.6.2. Binary Numeric Promotion
		    //
		    // Widening primitive conversion (§5.1.2) is applied to convert either or both operands as specified by the
		    // following rules:
		    //
		    // * If either operand is of type double, the other is converted to double.
		    // * Otherwise, if either operand is of type float, the other is converted to float.
		    // * Otherwise, if either operand is of type long, the other is converted to long.
		    // * Otherwise, both operands are converted to type int.
		    boolean isLeftNumeric = leftType.isPrimitive() && leftType.asPrimitive().isNumeric();
		    boolean isRightNumeric = rightType.isPrimitive() && rightType.asPrimitive().isNumeric();
		    if (isLeftNumeric && isRightNumeric) {
		        return leftType.asPrimitive().bnp(rightType.asPrimitive());
		    }
		    if (rightType.isAssignableBy(leftType)) {
		        return rightType;
		    }
		    return leftType;
		}"	$indentation$ protected $whitespace$ resolvedtype $whitespace$ getbinarytypeconcrete ( node $whitespace$ left , $whitespace$ node $whitespace$ right , $whitespace$ boolean $whitespace$ solvelambdas , $whitespace$ binaryexpr . operator $whitespace$ operator ) { $newline$ $indentation$ resolvedtype $whitespace$ lefttype $whitespace$ = $whitespace$ gettypeconcrete ( left , $whitespace$ solvelambdas ) ; $newline$ $indentation$ resolvedtype $whitespace$ righttype $whitespace$ = $whitespace$ gettypeconcrete ( right , $whitespace$ solvelambdas ) ; $newline$ $indentation$ $//·jls·15.18.1.·string·concatenation·operator·+$ $newline$ $indentation$ $//·if·only·one·operand·expression·is·of·type·string,·then·string·conversion·(§5.1.11)·is·performed·on·the·other$ $newline$ $indentation$ $//·operand·to·produce·a·string·at·run·time.$ $newline$ $indentation$ // $newline$ $indentation$ $//·the·result·of·string·concatenation·is·a·reference·to·a·string·object·that·is·the·concatenation·of·the·two$ $newline$ $indentation$ $//·operand·strings.·the·characters·of·the·left-hand·operand·precede·the·characters·of·the·right-hand·operand·in$ $newline$ $indentation$ $//·the·newly·created·string.$ $newline$ $indentation$ if $whitespace$ ( operator $whitespace$ == $whitespace$ binaryexpr . operator . plus ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ isleftstring $whitespace$ = $whitespace$ lefttype . isreferencetype ( ) $whitespace$ && $whitespace$ lefttype . asreferencetype ( ) . getqualifiedname ( ) . equals ( java_lang_string ) ; $newline$ $indentation$ boolean $whitespace$ isrightstring $whitespace$ = $whitespace$ righttype . isreferencetype ( ) $whitespace$ && $whitespace$ righttype . asreferencetype ( ) . getqualifiedname ( ) . equals ( java_lang_string ) ; $newline$ $indentation$ if $whitespace$ ( isleftstring $whitespace$ || $whitespace$ isrightstring ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isleftstring $whitespace$ ? $whitespace$ lefttype $whitespace$ : $whitespace$ righttype ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·jls·5.6.2.·binary·numeric·promotion$ $newline$ $indentation$ // $newline$ $indentation$ $//·widening·primitive·conversion·(§5.1.2)·is·applied·to·convert·either·or·both·operands·as·specified·by·the$ $newline$ $indentation$ $//·following·rules:$ $newline$ $indentation$ // $newline$ $indentation$ $//·*·if·either·operand·is·of·type·double,·the·other·is·converted·to·double.$ $newline$ $indentation$ $//·*·otherwise,·if·either·operand·is·of·type·float,·the·other·is·converted·to·float.$ $newline$ $indentation$ $//·*·otherwise,·if·either·operand·is·of·type·long,·the·other·is·converted·to·long.$ $newline$ $indentation$ $//·*·otherwise,·both·operands·are·converted·to·type·int.$ $newline$ $indentation$ boolean $whitespace$ isleftnumeric $whitespace$ = $whitespace$ lefttype . isprimitive ( ) $whitespace$ && $whitespace$ lefttype . asprimitive ( ) . isnumeric ( ) ; $newline$ $indentation$ boolean $whitespace$ isrightnumeric $whitespace$ = $whitespace$ righttype . isprimitive ( ) $whitespace$ && $whitespace$ righttype . asprimitive ( ) . isnumeric ( ) ; $newline$ $indentation$ if $whitespace$ ( isleftnumeric $whitespace$ && $whitespace$ isrightnumeric ) $whitespace$ { $newline$ $indentation$ return $whitespace$ lefttype . asprimitive ( ) . bnp ( righttype . asprimitive ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( righttype . isassignableby ( lefttype ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ righttype ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ lefttype ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ resolvedtype $whitespace$ getbinarytypeconcrete ( node $whitespace$ left, $whitespace$ node $whitespace$ right, $whitespace$ boolean $whitespace$ solvelambdas, $whitespace$ binaryexpr. operator $whitespace$ operator ) { $newline$ $indentation$ resolvedtype $whitespace$ lefttype $whitespace$ = $whitespace$ gettypeconcrete ( left, $whitespace$ solvelambdas ) ; $newline$ $indentation$ resolvedtype $whitespace$ righttype $whitespace$ = $whitespace$ gettypeconcrete ( right, $whitespace$ solvelambdas ) ; $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace			
findContainingTypeDecl	509	517	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.6340929865837097	MID	"		protected TypeDeclaration<?> findContainingTypeDecl(Node node){
		    Node parent = node;
		    while (true) {
		        parent = demandParentNode(parent);
		        if (parent instanceof TypeDeclaration) {
		            return (TypeDeclaration<?>) parent;
		        }
		    }
		}"	$indentation$ protected $whitespace$ typedeclaration < ? > $whitespace$ findcontainingtypedecl ( node $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ typedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( typedeclaration < ? > ) $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ typedeclaration <? > $whitespace$ findcontainingtypedecl ( node $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ while $whitespace$ ( parent $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ typedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( typedeclaration <? > ) $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }			
findContainingTypeDeclOrObjectCreationExpr	545	562	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFacade.java	0.6895972490310669	MID	"		protected Node findContainingTypeDeclOrObjectCreationExpr(Node node){
		    Node parent = node;
		    boolean detachFlag = false;
		    while (true) {
		        parent = demandParentNode(parent);
		        if (parent instanceof BodyDeclaration) {
		            if (parent instanceof TypeDeclaration) {
		                return parent;
		            }
		            detachFlag = true;
		        }
		        if (parent instanceof ObjectCreationExpr) {
		            if (detachFlag) {
		                return parent;
		            }
		        }
		    }
		}"	$indentation$ protected $whitespace$ node $whitespace$ findcontainingtypedeclorobjectcreationexpr ( node $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ boolean $whitespace$ detachflag $whitespace$ = $whitespace$ false ; $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ bodydeclaration ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ typedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ detachflag $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( detachflag ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ protected $whitespace$ node $whitespace$ findcontainingtypedeclorobjectcreationexpr ( node $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ node ; $newline$ $indentation$ while $whitespace$ ( true ) $whitespace$ { $newline$ $indentation$ parent $whitespace$ = $whitespace$ demandparentnode ( parent ) ; $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ bodydeclaration ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ typedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ detachflag $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parent $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( detachflag ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parent ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }			
getSymbolDeclarator	161	184	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFactory.java	0.2341887950897216	LOW	"		public static SymbolDeclarator getSymbolDeclarator(Node node, TypeSolver typeSolver){
		    if (node instanceof FieldDeclaration) {
		        return new FieldSymbolDeclarator((FieldDeclaration) node, typeSolver);
		    }
		    if (node instanceof Parameter) {
		        return new ParameterSymbolDeclarator((Parameter) node, typeSolver);
		    }
		    if (node instanceof PatternExpr) {
		        return new PatternSymbolDeclarator((PatternExpr) node, typeSolver);
		    }
		    if (node instanceof ExpressionStmt) {
		        ExpressionStmt expressionStmt = (ExpressionStmt) node;
		        if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {
		            return new VariableSymbolDeclarator((VariableDeclarationExpr) (expressionStmt.getExpression()), typeSolver);
		        }
		        return new NoSymbolDeclarator<>(expressionStmt, typeSolver);
		    }
		    if (node instanceof ForEachStmt) {
		        ForEachStmt foreachStmt = (ForEachStmt) node;
		        return new VariableSymbolDeclarator(foreachStmt.getVariable(), typeSolver);
		    }
		    return new NoSymbolDeclarator<>(node, typeSolver);
		}"	$indentation$ public $whitespace$ static $whitespace$ symboldeclarator $whitespace$ getsymboldeclarator ( node $whitespace$ node , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fielddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ fieldsymboldeclarator ( ( fielddeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ parametersymboldeclarator ( ( parameter ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ patternexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ patternsymboldeclarator ( ( patternexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ expressionstmt ) $whitespace$ { $newline$ $indentation$ expressionstmt $whitespace$ expressionstmt $whitespace$ = $whitespace$ ( expressionstmt ) $whitespace$ node ; $newline$ $indentation$ if $whitespace$ ( expressionstmt . getexpression ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ variablesymboldeclarator ( ( variabledeclarationexpr ) $whitespace$ ( expressionstmt . getexpression ( ) ) , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ nosymboldeclarator < > ( expressionstmt , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ foreachstmt ) $whitespace$ { $newline$ $indentation$ foreachstmt $whitespace$ foreachstmt $whitespace$ = $whitespace$ ( foreachstmt ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ new $whitespace$ variablesymboldeclarator ( foreachstmt . getvariable ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ nosymboldeclarator < > ( node , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ symboldeclarator $whitespace$ getsymboldeclarator ( node $whitespace$ node, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fielddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ fieldsymboldeclarator ( ( fielddeclaration ) $whitespace$ node, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ parametersymboldeclarator ( ( parameter ) $whitespace$ node, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ patternexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ patternsymboldeclarator ( ( patternexpr ) $whitespace$ node, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ nosymboldeclarator < > ( expressionstmt, $whitespace$ variabledeclarationexpr ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ void $whitespace$ nosymboldeclarator < expressionstmt > $whitespace$ getsymboldeclarator ( node $whitespace$ node, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ expressionstmt ) $whitespace$ { $newline$ $indentation$ expressionstmt $whitespace$ expressionstmt $whitespace$ = $whitespace$ ( expressionstmt ) $whitespace$ node ; $newline$ $indentation$ if $whitespace$ ( expressionstmt. getexpression ( ) $whitespace$			
getContext	43	159	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/JavaParserFactory.java	0.2712835371494293	LOW	"		public static Context getContext(Node node, TypeSolver typeSolver){
		    if (node == null) {
		        throw new NullPointerException(""Node should not be null"");
		    }
		    if (node instanceof ArrayAccessExpr) {
		        return new ArrayAccessExprContext((ArrayAccessExpr) node, typeSolver);
		    }
		    if (node instanceof AnnotationDeclaration) {
		        return new AnnotationDeclarationContext((AnnotationDeclaration) node, typeSolver);
		    }
		    if (node instanceof BinaryExpr) {
		        return new BinaryExprContext((BinaryExpr) node, typeSolver);
		    }
		    if (node instanceof BlockStmt) {
		        return new BlockStmtContext((BlockStmt) node, typeSolver);
		    }
		    if (node instanceof CompilationUnit) {
		        return new CompilationUnitContext((CompilationUnit) node, typeSolver);
		    }
		    if (node instanceof EnclosedExpr) {
		        return new EnclosedExprContext((EnclosedExpr) node, typeSolver);
		    }
		    if (node instanceof ForEachStmt) {
		        return new ForEachStatementContext((ForEachStmt) node, typeSolver);
		    }
		    if (node instanceof ForStmt) {
		        return new ForStatementContext((ForStmt) node, typeSolver);
		    }
		    if (node instanceof IfStmt) {
		        return new IfStatementContext((IfStmt) node, typeSolver);
		    }
		    if (node instanceof InstanceOfExpr) {
		        return new InstanceOfExprContext((InstanceOfExpr) node, typeSolver);
		    }
		    if (node instanceof LambdaExpr) {
		        return new LambdaExprContext((LambdaExpr) node, typeSolver);
		    }
		    if (node instanceof MethodDeclaration) {
		        return new MethodContext((MethodDeclaration) node, typeSolver);
		    }
		    if (node instanceof ConstructorDeclaration) {
		        return new ConstructorContext((ConstructorDeclaration) node, typeSolver);
		    }
		    if (node instanceof ClassOrInterfaceDeclaration) {
		        return new ClassOrInterfaceDeclarationContext((ClassOrInterfaceDeclaration) node, typeSolver);
		    }
		    if (node instanceof MethodCallExpr) {
		        return new MethodCallExprContext((MethodCallExpr) node, typeSolver);
		    }
		    if (node instanceof MethodReferenceExpr) {
		        return new MethodReferenceExprContext((MethodReferenceExpr) node, typeSolver);
		    }
		    if (node instanceof EnumDeclaration) {
		        return new EnumDeclarationContext((EnumDeclaration) node, typeSolver);
		    }
		    if (node instanceof FieldAccessExpr) {
		        return new FieldAccessContext((FieldAccessExpr) node, typeSolver);
		    }
		    if (node instanceof SwitchEntry) {
		        return new SwitchEntryContext((SwitchEntry) node, typeSolver);
		    }
		    if (node instanceof TryStmt) {
		        return new TryWithResourceContext((TryStmt) node, typeSolver);
		    }
		    if (node instanceof Statement) {
		        return new StatementContext<>((Statement) node, typeSolver);
		    }
		    if (node instanceof CatchClause) {
		        return new CatchClauseContext((CatchClause) node, typeSolver);
		    }
		    if (node instanceof UnaryExpr) {
		        return new UnaryExprContext((UnaryExpr) node, typeSolver);
		    }
		    if (node instanceof VariableDeclarator) {
		        return new VariableDeclaratorContext((VariableDeclarator) node, typeSolver);
		    }
		    if (node instanceof VariableDeclarationExpr) {
		        return new VariableDeclarationExprContext((VariableDeclarationExpr) node, typeSolver);
		    }
		    if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {
		        return new AnonymousClassDeclarationContext((ObjectCreationExpr) node, typeSolver);
		    }
		    if (node instanceof ObjectCreationExpr) {
		        return new ObjectCreationContext((ObjectCreationExpr) node, typeSolver);
		    }
		    if (node instanceof NameExpr) {
		        // to resolve a name when in a fieldAccess context, we can go up until we get a node other than FieldAccessExpr,
		        // in order to prevent a infinite loop if the name is the same as the field (ie x.x, x.y.x, or x.y.z.x)
		        if (node.getParentNode().isPresent() && node.getParentNode().get() instanceof FieldAccessExpr) {
		            Node ancestor = node.getParentNode().get();
		            while (ancestor.getParentNode().isPresent()) {
		                ancestor = ancestor.getParentNode().get();
		                if (!(ancestor instanceof FieldAccessExpr)) {
		                    break;
		                }
		            }
		            return getContext(ancestor, typeSolver);
		        }
		        if (node.getParentNode().isPresent() && node.getParentNode().get() instanceof ObjectCreationExpr && node.getParentNode().get().getParentNode().isPresent()) {
		            return getContext(node.getParentNode().get().getParentNode().get(), typeSolver);
		        }
		    }
		    final Node parentNode = demandParentNode(node);
		    if (node instanceof ClassOrInterfaceType && parentNode instanceof ClassOrInterfaceDeclaration) {
		        ClassOrInterfaceDeclaration parentDeclaration = (ClassOrInterfaceDeclaration) parentNode;
		        if (parentDeclaration.getImplementedTypes().contains(node) || parentDeclaration.getExtendedTypes().contains(node)) {
		            // When resolving names in implements and extends the body of the declaration
		            // should not be searched so use limited context.
		            return new ClassOrInterfaceDeclarationExtendsContext(parentDeclaration, typeSolver);
		        }
		    }
		    return getContext(parentNode, typeSolver);
		}"	$indentation$ public $whitespace$ static $whitespace$ context $whitespace$ getcontext ( node $whitespace$ node , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nullpointerexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ arrayaccessexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arrayaccessexprcontext ( ( arrayaccessexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ annotationdeclarationcontext ( ( annotationdeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ binaryexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ binaryexprcontext ( ( binaryexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ blockstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ blockstmtcontext ( ( blockstmt ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ compilationunit ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ compilationunitcontext ( ( compilationunit ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ enclosedexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ enclosedexprcontext ( ( enclosedexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ foreachstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ foreachstatementcontext ( ( foreachstmt ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ forstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ forstatementcontext ( ( forstmt ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ ifstatementcontext ( ( ifstmt ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ instanceofexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ instanceofexprcontext ( ( instanceofexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ lambdaexprcontext ( ( lambdaexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ methodcontext ( ( methoddeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ constructordeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ constructorcontext ( ( constructordeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ classorinterfacedeclarationcontext ( ( classorinterfacedeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ methodcallexprcontext ( ( methodcallexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ methodreferenceexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ methodreferenceexprcontext ( ( methodreferenceexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ enumdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ enumdeclarationcontext ( ( enumdeclaration ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ fieldaccesscontext ( ( fieldaccessexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ switchentry ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ switchentrycontext ( ( switchentry ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ trystmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ trywithresourcecontext ( ( trystmt ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ statement ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ statementcontext < > ( ( statement ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ catchclause ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ catchclausecontext ( ( catchclause ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ unaryexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ unaryexprcontext ( ( unaryexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ variabledeclaratorcontext ( ( variabledeclarator ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ variabledeclarationexprcontext ( ( variabledeclarationexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ objectcreationexpr $whitespace$ && $whitespace$ ( ( objectcreationexpr ) $whitespace$ node ) . getanonymousclassbody ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ anonymousclassdeclarationcontext ( ( objectcreationexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ objectcreationcontext ( ( objectcreationexpr ) $whitespace$ node , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ $//·to·resolve·a·name·when·in·a·fieldaccess·context,·we·can·go·up·until·we·get·a·node·other·than·fieldaccessexpr,$ $newline$ $indentation$ $//·in·order·to·prevent·a·infinite·loop·if·the·name·is·the·same·as·the·field·(ie·x.x,·x.y.x,·or·x.y.z.x)$ $newline$ $indentation$ if $whitespace$ ( node . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ node . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ node $whitespace$ ancestor $whitespace$ = $whitespace$ node . getparentnode ( ) . get ( ) ; $newline$ $indentation$ while $whitespace$ ( ancestor . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ ancestor $whitespace$ = $whitespace$ ancestor . getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( ancestor $whitespace$ instanceof $whitespace$ fieldaccessexpr ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ancestor , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ node . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ objectcreationexpr $whitespace$ && $whitespace$ node . getparentnode ( ) . get ( ) . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getcontext ( node . getparentnode ( ) . get ( ) . getparentnode ( ) . get ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( node ) ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ classorinterfacetype $whitespace$ && $whitespace$ parentnode $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ classorinterfacedeclaration $whitespace$ parentdeclaration $whitespace$ = $whitespace$ ( classorinterfacedeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ if $whitespace$ ( parentdeclaration . getimplementedtypes ( ) . contains ( node ) $whitespace$ || $whitespace$ parentdeclaration . getextendedtypes ( ) . contains ( node ) ) $whitespace$ { $newline$ $indentation$ $//·when·resolving·names·in·implements·and·extends·the·body·of·the·declaration$ $newline$ $indentation$ $//·should·not·be·searched·so·use·limited·context.$ $newline$ $indentation$ return $whitespace$ new $whitespace$ classorinterfacedeclarationextendscontext ( parentdeclaration , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( parentnode , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ context $whitespace$ getcontext ( node $whitespace$ node, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ nullpointerexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ arrayaccessexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arrayaccessexprcontext ( ( arrayaccessexpr ) $whitespace$ node, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ annotationdeclarationcontext ( ( annotationdeclaration ) $whitespace$ node, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ compilationunit ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ compilationunitcontext ( ( compilationunit )			
resolveLambda	519	583	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java	0.0058610150590538	LOW	"		private ResolvedType resolveLambda(LambdaExpr node, ResolvedType result){
		    // We need to replace the type variables
		    Context ctx = JavaParserFactory.getContext(node, typeSolver);
		    result = result.solveGenericTypes(ctx);
		    //We should find out which is the functional method (e.g., apply) and replace the params of the
		    //solveLambdas with it, to derive so the values. We should also consider the value returned by the
		    //lambdas
		    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(result);
		    if (functionalMethod.isPresent()) {
		        LambdaExpr lambdaExpr = node;
		        InferenceContext lambdaCtx = new InferenceContext(typeSolver);
		        InferenceContext funcInterfaceCtx = new InferenceContext(typeSolver);
		        // At this point parameterType
		        // if Function<T=? super Stream.T, ? extends map.R>
		        // we should replace Stream.T
		        ResolvedType functionalInterfaceType = ReferenceTypeImpl.undeterminedParameters(functionalMethod.get().getDeclaration().declaringType());
		        lambdaCtx.addPair(result, functionalInterfaceType);
		        ResolvedType actualType;
		        if (lambdaExpr.getBody() instanceof ExpressionStmt) {
		            actualType = facade.getType(((ExpressionStmt) lambdaExpr.getBody()).getExpression());
		        } else if (lambdaExpr.getBody() instanceof BlockStmt) {
		            BlockStmt blockStmt = (BlockStmt) lambdaExpr.getBody();
		            // Get all the return statements in the lambda block
		            List<ReturnStmt> returnStmts = blockStmt.findAll(ReturnStmt.class);
		            if (returnStmts.size() > 0) {
		                Set<ResolvedType> resolvedTypes = returnStmts.stream().map(returnStmt -> returnStmt.getExpression().map(e -> facade.getType(e)).orElse(ResolvedVoidType.INSTANCE)).collect(Collectors.toSet());
		                actualType = LeastUpperBoundLogic.of().lub(resolvedTypes);
		            } else {
		                actualType = ResolvedVoidType.INSTANCE;
		            }
		        } else {
		            throw new UnsupportedOperationException(""Cannot resolve the type of lambda expression body "" + lambdaExpr.getBody());
		        }
		        ResolvedType formalType = functionalMethod.get().returnType();
		        // Infer the functional interfaces' return vs actual type
		        funcInterfaceCtx.addPair(formalType, actualType);
		        // Substitute to obtain a new type
		        ResolvedType functionalTypeWithReturn = funcInterfaceCtx.resolve(funcInterfaceCtx.addSingle(functionalInterfaceType));
		        // if the functional method returns void anyway
		        // we don't need to bother inferring types
		        if (!(formalType instanceof ResolvedVoidType)) {
		            lambdaCtx.addPair(result, functionalTypeWithReturn);
		            result = lambdaCtx.resolve(lambdaCtx.addSingle(result));
		        }
		    }
		    return result;
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ resolvelambda ( lambdaexpr $whitespace$ node , $whitespace$ resolvedtype $whitespace$ result ) { $newline$ $indentation$ $//·we·need·to·replace·the·type·variables$ $newline$ $indentation$ context $whitespace$ ctx $whitespace$ = $whitespace$ javaparserfactory . getcontext ( node , $whitespace$ typesolver ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ result . solvegenerictypes ( ctx ) ; $newline$ $indentation$ $//we·should·find·out·which·is·the·functional·method·(e.g.,·apply)·and·replace·the·params·of·the$ $newline$ $indentation$ $//solvelambdas·with·it,·to·derive·so·the·values.·we·should·also·consider·the·value·returned·by·the$ $newline$ $indentation$ //lambdas $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( result ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ lambdaexpr $whitespace$ lambdaexpr $whitespace$ = $whitespace$ node ; $newline$ $indentation$ inferencecontext $whitespace$ lambdactx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ inferencecontext $whitespace$ funcinterfacectx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ $//·at·this·point·parametertype$ $newline$ $indentation$ $//·if·function<t=?·super·stream.t,·?·extends·map.r>$ $newline$ $indentation$ $//·we·should·replace·stream.t$ $newline$ $indentation$ resolvedtype $whitespace$ functionalinterfacetype $whitespace$ = $whitespace$ referencetypeimpl . undeterminedparameters ( functionalmethod . get ( ) . getdeclaration ( ) . declaringtype ( ) ) ; $newline$ $indentation$ lambdactx . addpair ( result , $whitespace$ functionalinterfacetype ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualtype ; $newline$ $indentation$ if $whitespace$ ( lambdaexpr . getbody ( ) $whitespace$ instanceof $whitespace$ expressionstmt ) $whitespace$ { $newline$ $indentation$ actualtype $whitespace$ = $whitespace$ facade . gettype ( ( ( expressionstmt ) $whitespace$ lambdaexpr . getbody ( ) ) . getexpression ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdaexpr . getbody ( ) $whitespace$ instanceof $whitespace$ blockstmt ) $whitespace$ { $newline$ $indentation$ blockstmt $whitespace$ blockstmt $whitespace$ = $whitespace$ ( blockstmt ) $whitespace$ lambdaexpr . getbody ( ) ; $newline$ $indentation$ $//·get·all·the·return·statements·in·the·lambda·block$ $newline$ $indentation$ list < returnstmt > $whitespace$ returnstmts $whitespace$ = $whitespace$ blockstmt . findall ( returnstmt . class ) ; $newline$ $indentation$ if $whitespace$ ( returnstmts . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ set < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ returnstmts . stream ( ) . map ( returnstmt $whitespace$ - > $whitespace$ returnstmt . getexpression ( ) . map ( e $whitespace$ - > $whitespace$ facade . gettype ( e ) ) . orelse ( resolvedvoidtype . instance ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ actualtype $whitespace$ = $whitespace$ leastupperboundlogic . of ( ) . lub ( resolvedtypes ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ actualtype $whitespace$ = $whitespace$ resolvedvoidtype . instance ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ lambdaexpr . getbody ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ functionalmethod . get ( ) . returntype ( ) ; $newline$ $indentation$ $//·infer·the·functional·interfaces'·return·vs·actual·type$ $newline$ $indentation$ funcinterfacectx . addpair ( formaltype , $whitespace$ actualtype ) ; $newline$ $indentation$ $//·substitute·to·obtain·a·new·type$ $newline$ $indentation$ resolvedtype $whitespace$ functionaltypewithreturn $whitespace$ = $whitespace$ funcinterfacectx . resolve ( funcinterfacectx . addsingle ( functionalinterfacetype ) ) ; $newline$ $indentation$ $//·if·the·functional·method·returns·void·anyway$ $newline$ $indentation$ $//·we·don't·need·to·bother·inferring·types$ $newline$ $indentation$ if $whitespace$ ( ! ( formaltype $whitespace$ instanceof $whitespace$ resolvedvoidtype ) ) $whitespace$ { $newline$ $indentation$ lambdactx . addpair ( result , $whitespace$ functionaltypewithreturn ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ lambdactx . resolve ( lambdactx . addsingle ( result ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ resolvelambda ( lambdaexpr $whitespace$ node, $whitespace$ resolvedtype $whitespace$ result ) { $newline$ $indentation$ $//space$ + $whitespace$ javaparserfactory. getcontext ( node, $whitespace$ typesolver ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ result. solvegenerictypes ( ctx ) ; $newline$ $indentation$ $//weation$ $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ inferencecontext $whitespace$ funcinterfacectx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ //lambdas $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic. getfunctionalmethod ( result ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ lambdaexpr $whitespace$ lambdaexpr $whitespace$ = $whitespace$ node ; $newline$ $indentation$ inferencecontext $whitespace$ lambdactx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ inferencecontext $whitespace$ funcinterfacectx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ //lambdas $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic. getfunctionalmethod ( result ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ lambdaexpr $whitespace$ lambdaexpr $whitespace$ = $whitespace$ node ; $newline$ $indentation$ inferencecontext $whitespace$ lambdactx $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ //			
solveDotExpressionType	214	227	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java	0.2414569109678268	LOW	"		private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node){
		    // Fields and internal type declarations cannot have the same name.
		    if (parentType.isEnum() && parentType.asEnum().hasEnumConstant(node.getName().getId())) {
		        return parentType.asEnum().getEnumConstant(node.getName().getId()).getType();
		    }
		    if (parentType.hasField(node.getName().getId())) {
		        return parentType.getField(node.getName().getId()).getType();
		    }
		    if (parentType.hasInternalType(node.getName().getId())) {
		        return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()));
		    }
		    throw new UnsolvedSymbolException(node.getName().getId());
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ solvedotexpressiontype ( resolvedreferencetypedeclaration $whitespace$ parenttype , $whitespace$ fieldaccessexpr $whitespace$ node ) { $newline$ $indentation$ $//·fields·and·internal·type·declarations·cannot·have·the·same·name.$ $newline$ $indentation$ if $whitespace$ ( parenttype . isenum ( ) $whitespace$ && $whitespace$ parenttype . asenum ( ) . hasenumconstant ( node . getname ( ) . getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parenttype . asenum ( ) . getenumconstant ( node . getname ( ) . getid ( ) ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parenttype . hasfield ( node . getname ( ) . getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parenttype . getfield ( node . getname ( ) . getid ( ) ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parenttype . hasinternaltype ( node . getname ( ) . getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( parenttype . getinternaltype ( node . getname ( ) . getid ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( node . getname ( ) . getid ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ solvedotexpressiontype ( resolvedreferencetypedeclaration $whitespace$ parenttype, $whitespace$ fieldaccessexpr $whitespace$ node ) { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ parenttype. isenum ( ) $whitespace$ && $whitespace$ parenttype. asenum ( ). hasenumconstant ( node. getname ( ). getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parenttype. asenum ( ). getenumconstant ( node. getname ( ). getid ( ) ). gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parenttype. hasfield ( node. getname ( ). getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parenttype. getfield ( node. getname ( ). getid ( ) ). gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parenttype. hasinternaltype ( node. getname ( ). getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( parenttype. getinternaltype ( node. getname ( ). getid ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( node. getname ( ). getid ( ) ) ; $newline$ $indentation$ }			
getParamPos	656	663	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/TypeExtractor.java	0.6692405343055725	MID	"		private static int getParamPos(Expression node){
		    Node parentNode = demandParentNode(node, IS_NOT_ENCLOSED_EXPR);
		    if (parentNode instanceof MethodCallExpr) {
		        MethodCallExpr call = (MethodCallExpr) parentNode;
		        return call.getArgumentPosition(node, EXCLUDE_ENCLOSED_EXPR);
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ getparampos ( expression $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( node , $whitespace$ is_not_enclosed_expr ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ call $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ return $whitespace$ call . getargumentposition ( node , $whitespace$ exclude_enclosed_expr ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ int $whitespace$ getparampos ( expression $whitespace$ node ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( node, $whitespace$ is_not_enclosed_expr ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ call $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ return $whitespace$ call. getargumentposition ( node, $whitespace$ exclude_enclosed_expr ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
findTypeDeclarations	180	261	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.0019048764370381	LOW	"		protected Collection<ResolvedReferenceTypeDeclaration> findTypeDeclarations(Optional<Expression> optScope){
		    if (optScope.isPresent()) {
		        Expression scope = optScope.get();
		        ResolvedType typeOfScope;
		        try {
		            typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);
		        } catch (Exception e) {
		            // If the scope corresponds to a type we should treat it differently
		            if (scope instanceof FieldAccessExpr) {
		                FieldAccessExpr scopeName = (FieldAccessExpr) scope;
		                if (this.solveType(scopeName.toString()).isSolved()) {
		                    return Collections.emptyList();
		                }
		            }
		            throw new UnsolvedSymbolException(scope.toString(), wrappedNode.toString(), e);
		        }
		        if (typeOfScope.isWildcard()) {
		            if (typeOfScope.asWildcard().isExtends() || typeOfScope.asWildcard().isSuper()) {
		                // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		                return singletonList(typeOfScope.asWildcard().getBoundedType().asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")));
		            }
		            return singletonList(typeSolver.getSolvedJavaLangObject());
		        }
		        if (typeOfScope.isArray()) {
		            // method call on array are Object methods
		            return singletonList(typeSolver.getSolvedJavaLangObject());
		        }
		        if (typeOfScope.isTypeVariable()) {
		            Collection<ResolvedReferenceTypeDeclaration> result = new ArrayList<>();
		            for (ResolvedTypeParameterDeclaration.Bound bound : typeOfScope.asTypeParameter().getBounds()) {
		                // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		                result.add(bound.getType().asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")));
		            }
		            return result;
		        }
		        if (typeOfScope.isConstraint()) {
		            // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		            ResolvedType type = typeOfScope.asConstraintType().getBound();
		            if (type.isReferenceType()) {
		                return singletonList(type.asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")));
		            }
		            throw new UnsupportedOperationException(""The type declaration cannot be found on constraint "" + type.describe());
		        }
		        if (typeOfScope.isUnionType()) {
		            return typeOfScope.asUnionType().getCommonAncestor().flatMap(ResolvedReferenceType::getTypeDeclaration).map(Collections::singletonList).orElseThrow(() -> new UnsolvedSymbolException(""No common ancestor available for UnionType"" + typeOfScope.describe()));
		        }
		        // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		        return singletonList(typeOfScope.asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")));
		    }
		    ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);
		    // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		    return singletonList(typeOfScope.asReferenceType().getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")));
		}"	$indentation$ protected $whitespace$ collection < resolvedreferencetypedeclaration > $whitespace$ findtypedeclarations ( optional < expression > $whitespace$ optscope ) { $newline$ $indentation$ if $whitespace$ ( optscope . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ optscope . get ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ typeofscope ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ typeofscope $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettype ( scope ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·if·the·scope·corresponds·to·a·type·we·should·treat·it·differently$ $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ scopename $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ scope ; $newline$ $indentation$ if $whitespace$ ( this . solvetype ( scopename . tostring ( ) ) . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( scope . tostring ( ) , $whitespace$ wrappednode . tostring ( ) , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeofscope . aswildcard ( ) . isextends ( ) $whitespace$ || $whitespace$ typeofscope . aswildcard ( ) . issuper ( ) ) $whitespace$ { $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ return $whitespace$ singletonlist ( typeofscope . aswildcard ( ) . getboundedtype ( ) . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ singletonlist ( typesolver . getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . isarray ( ) ) $whitespace$ { $newline$ $indentation$ $//·method·call·on·array·are·object·methods$ $newline$ $indentation$ return $whitespace$ singletonlist ( typesolver . getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ collection < resolvedreferencetypedeclaration > $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration . bound $whitespace$ bound $whitespace$ : $whitespace$ typeofscope . astypeparameter ( ) . getbounds ( ) ) $whitespace$ { $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ result . add ( bound . gettype ( ) . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ typeofscope . asconstrainttype ( ) . getbound ( ) ; $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ singletonlist ( type . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type . describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . isuniontype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeofscope . asuniontype ( ) . getcommonancestor ( ) . flatmap ( resolvedreferencetype : : gettypedeclaration ) . map ( collections : : singletonlist ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ typeofscope . describe ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ return $whitespace$ singletonlist ( typeofscope . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ typeofscope $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettypeofthisin ( wrappednode ) ; $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ return $whitespace$ singletonlist ( typeofscope . asreferencetype ( ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ collection < resolvedreferencetypedeclaration > $whitespace$ findtypedeclarations ( optional < expression > $whitespace$ optscope ) { $newline$ $indentation$ if $whitespace$ ( optscope. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optscope. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ typeofscope ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ typeofscope $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). gettype ( scope ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////if $whitespace$ the $whitespace$ method $whitespace$ is $whitespace$ set $whitespace$ and $whitespace$ clear $whitespace$ our $whitespace$ generation $whitespace$ after $whitespace$ the $whitespace$ same $whitespace$ parameters $whitespace$ when $whitespace$ this $whitespace$ function $whitespace$ is $whitespace$ not $whitespace$ found $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ scopename $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ scope ; $newline$ $indentation$ if $whitespace$ ( this. solvetype ( scopename. tostring ( ) ). issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( scope. tostring ( ), $whitespace$ wrappednode. tostring ( ), $whitespace$ e ) ; $newline$ $indentation$ } $newline$			
solveWithAsValue	173	178	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.0964643880724906	LOW	"		protected Optional<Value> solveWithAsValue(SymbolDeclarator symbolDeclarator, String name){
		    return symbolDeclarator.getSymbolDeclarations().stream().filter(d -> d.getName().equals(name)).map(Value::from).findFirst();
		}"	$indentation$ protected $whitespace$ optional < value > $whitespace$ solvewithasvalue ( symboldeclarator $whitespace$ symboldeclarator , $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ return $whitespace$ symboldeclarator . getsymboldeclarations ( ) . stream ( ) . filter ( d $whitespace$ - > $whitespace$ d . getname ( ) . equals ( name ) ) . map ( value : : from ) . findfirst ( ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ optional < value > $whitespace$ solvewithasvalue ( symboldeclarator $whitespace$ symboldeclarator, $whitespace$ string $whitespace$ name ) { $newline$ $indentation$ return $whitespace$ symboldeclarator. getsymboldeclarations ( ). stream ( ). filter ( d $whitespace$ - > $whitespace$ d. getname ( ). equals ( name ) ). map ( value : : from ). findfirst ( ) ; $newline$ $indentation$ }			
solveMethodAsUsage	267	283	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.1267897635698318	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes){
		    SymbolReference<ResolvedMethodDeclaration> methodSolved = solveMethod(name, argumentsTypes, false);
		    if (methodSolved.isSolved()) {
		        ResolvedMethodDeclaration methodDeclaration = methodSolved.getCorrespondingDeclaration();
		        if (!(methodDeclaration instanceof TypeVariableResolutionCapability)) {
		            throw new UnsupportedOperationException(String.format(""Resolved method declarations must implement %s."", TypeVariableResolutionCapability.class.getName()));
		        }
		        MethodUsage methodUsage = ((TypeVariableResolutionCapability) methodDeclaration).resolveTypeVariables(this, argumentsTypes);
		        return Optional.of(methodUsage);
		    }
		    return Optional.empty();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ methodsolved $whitespace$ = $whitespace$ solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( methodsolved . issolved ( ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ methodsolved . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( methoddeclaration $whitespace$ instanceof $whitespace$ typevariableresolutioncapability ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ typevariableresolutioncapability . class . getname ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ ( ( typevariableresolutioncapability ) $whitespace$ methoddeclaration ) . resolvetypevariables ( this , $whitespace$ argumentstypes ) ; $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ methodsolved $whitespace$ = $whitespace$ solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( methodsolved. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ uncheckedcastformattedname $whitespace$ : $whitespace$ methodsolved. getcorrespondingdeclaration ( ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ ( ( typevariableresolutioncapability ) $whitespace$ methoddeclaration ). resolvetypevariables ( this, $whitespace$ argumentstypes ) ; $newline$ $indentation$ return $whitespace$ optional. of ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
getParent	100	129	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.178593024611473	LOW	"		@Override
		public final Optional<Context> getParent(){
		    Node parentNode = wrappedNode.getParentNode().orElse(null);
		    // Resolution of the scope of the method call expression is delegated to parent
		    // context.
		    if (parentNode instanceof MethodCallExpr) {
		        MethodCallExpr parentCall = (MethodCallExpr) parentNode;
		        boolean found = parentCall.getArguments().contains(wrappedNode);
		        if (found) {
		            Node notMethod = parentNode;
		            while (notMethod instanceof MethodCallExpr) {
		                notMethod = demandParentNode(notMethod);
		            }
		            return Optional.of(JavaParserFactory.getContext(notMethod, typeSolver));
		        }
		    }
		    Node notMethodNode = parentNode;
		    // To avoid loops JP must ensure that the scope of the parent context
		    // is not the same as the current node.
		    while (notMethodNode instanceof MethodCallExpr || notMethodNode instanceof FieldAccessExpr || (notMethodNode != null && notMethodNode.hasScope() && getScope(notMethodNode).equals(wrappedNode))) {
		        notMethodNode = notMethodNode.getParentNode().orElse(null);
		    }
		    if (notMethodNode == null) {
		        return Optional.empty();
		    }
		    Context parentContext = JavaParserFactory.getContext(notMethodNode, typeSolver);
		    return Optional.of(parentContext);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < context > $whitespace$ getparent ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ wrappednode . getparentnode ( ) . orelse ( null ) ; $newline$ $indentation$ $//·resolution·of·the·scope·of·the·method·call·expression·is·delegated·to·parent$ $newline$ $indentation$ $//·context.$ $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ parentcall $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ boolean $whitespace$ found $whitespace$ = $whitespace$ parentcall . getarguments ( ) . contains ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( found ) $whitespace$ { $newline$ $indentation$ node $whitespace$ notmethod $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ while $whitespace$ ( notmethod $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ notmethod $whitespace$ = $whitespace$ demandparentnode ( notmethod ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( javaparserfactory . getcontext ( notmethod , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ notmethodnode $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ $//·to·avoid·loops·jp·must·ensure·that·the·scope·of·the·parent·context$ $newline$ $indentation$ $//·is·not·the·same·as·the·current·node.$ $newline$ $indentation$ while $whitespace$ ( notmethodnode $whitespace$ instanceof $whitespace$ methodcallexpr $whitespace$ || $whitespace$ notmethodnode $whitespace$ instanceof $whitespace$ fieldaccessexpr $whitespace$ || $whitespace$ ( notmethodnode $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ notmethodnode . hasscope ( ) $whitespace$ && $whitespace$ getscope ( notmethodnode ) . equals ( wrappednode ) ) ) $whitespace$ { $newline$ $indentation$ notmethodnode $whitespace$ = $whitespace$ notmethodnode . getparentnode ( ) . orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( notmethodnode $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( notmethodnode , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ optional . of ( parentcontext ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < context > $whitespace$ getparent ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ wrappednode. getparentnode ( ). orelse ( null ) ; $newline$ $indentation$ $//// $newline$ $indentation$ return $whitespace$ parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ parentcall $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ boolean $whitespace$ found $whitespace$ = $whitespace$ parentcall. getarguments ( ). contains ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( found ) $whitespace$ { $newline$ $indentation$ node $whitespace$ notmethod $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ while $whitespace$ ( notmethod $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ notmethod $whitespace$ = $whitespace$ demandparentnode ( notmethod ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( javaparserfactory. getcontext ( notmethod, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ notmethodnode $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$ $whitespace$// $whitespace$to $whitespace$ = $whitespace$ parentnode ; $newline$ $indentation$			
solveSymbolInParentContext	137	167	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.2091536074876785	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbolInParentContext(String name){
		    Optional<Context> optionalParentContext = getParent();
		    if (!optionalParentContext.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    // First check if there are any pattern expressions available to this node.
		    Context parentContext = optionalParentContext.get();
		    if (parentContext instanceof BinaryExprContext || parentContext instanceof IfStatementContext) {
		        List<PatternExpr> patternExprs = parentContext.patternExprsExposedToChild(this.getWrappedNode());
		        Optional<PatternExpr> localResolutionResults = patternExprs.stream().filter(vd -> vd.getNameAsString().equals(name)).findFirst();
		        if (localResolutionResults.isPresent()) {
		            if (patternExprs.size() == 1) {
		                JavaParserPatternDeclaration decl = JavaParserSymbolDeclaration.patternVar(localResolutionResults.get(), typeSolver);
		                return SymbolReference.solved(decl);
		            }
		            if (patternExprs.size() > 1) {
		                throw new IllegalStateException(""Unexpectedly more than one reference in scope"");
		            }
		        }
		    }
		    // Delegate solving to the parent context.
		    return parentContext.solveSymbol(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolinparentcontext ( string $whitespace$ name ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentcontext . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·first·check·if·there·are·any·pattern·expressions·available·to·this·node.$ $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ optionalparentcontext . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parentcontext $whitespace$ instanceof $whitespace$ binaryexprcontext $whitespace$ || $whitespace$ parentcontext $whitespace$ instanceof $whitespace$ ifstatementcontext ) $whitespace$ { $newline$ $indentation$ list < patternexpr > $whitespace$ patternexprs $whitespace$ = $whitespace$ parentcontext . patternexprsexposedtochild ( this . getwrappednode ( ) ) ; $newline$ $indentation$ optional < patternexpr > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ patternexprs . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getnameasstring ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( patternexprs . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ javaparsersymboldeclaration . patternvar ( localresolutionresults . get ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ symbolreference . solved ( decl ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( patternexprs . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·delegate·solving·to·the·parent·context.$ $newline$ $indentation$ return $whitespace$ parentcontext . solvesymbol ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolinparentcontext ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! optionalparentcontext. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentcontext $whitespace$ instanceof $whitespace$ binaryexprcontext $whitespace$ || $whitespace$ parentcontext $whitespace$ instanceof $whitespace$ ifstatementcontext ) $whitespace$ { $newline$ $indentation$ list < patternexpr > $whitespace$ patternexprs $whitespace$ = $whitespace$ parentcontext. patternexprsexposedtochild ( this. getwrappednode ( ) ) ; $newline$ $indentation$ optional < patternexpr > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ patternexprs. stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( patternexprs. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ javaparser			
equals	85	93	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractJavaParserContext.java	0.2870679199695587	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    AbstractJavaParserContext<?> that = (AbstractJavaParserContext<?>) o;
		    return wrappedNode != null ? wrappedNode.equals(that.wrappedNode) : that.wrappedNode == null;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ that $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ wrappednode . equals ( that . wrappednode ) $whitespace$ : $whitespace$ that . wrappednode $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ other ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ other. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ that $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ other ; $newline$ $indentation$ return $whitespace$ wrappednode $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ wrappednode. equals ( that. wrappednode ) $whitespace$ : $whitespace$ that. wrappednode $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }			
solveType	99	124	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java	0.1584734320640564	LOW	"		@Override
		public final SymbolReference<ResolvedTypeDeclaration> solveType(String name, List<ResolvedType> typeArguments){
		    // TODO: Is null check required?
		    if (wrappedNode.getTypeParameters() != null) {
		        for (TypeParameter tp : wrappedNode.getTypeParameters()) {
		            if (tp.getName().getId().equals(name)) {
		                return SymbolReference.solved(new JavaParserTypeParameter(tp, typeSolver));
		            }
		        }
		    }
		    // Local types
		    List<TypeDeclaration> localTypes = wrappedNode.findAll(TypeDeclaration.class);
		    for (TypeDeclaration<?> localType : localTypes) {
		        if (localType.getName().getId().equals(name)) {
		            return SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(localType));
		        }
		        if (name.startsWith(String.format(""%s."", localType.getName()))) {
		            return JavaParserFactory.getContext(localType, typeSolver).solveType(name.substring(localType.getName().getId().length() + 1));
		        }
		    }
		    return solveTypeInParentContext(name, typeArguments);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ $//·todo:·is·null·check·required?$ $newline$ $indentation$ if $whitespace$ ( wrappednode . gettypeparameters ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ tp $whitespace$ : $whitespace$ wrappednode . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tp . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparsertypeparameter ( tp , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·local·types$ $newline$ $indentation$ list < typedeclaration > $whitespace$ localtypes $whitespace$ = $whitespace$ wrappednode . findall ( typedeclaration . class ) ; $newline$ $indentation$ for $whitespace$ ( typedeclaration < ? > $whitespace$ localtype $whitespace$ : $whitespace$ localtypes ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( localtype . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( typesolver ) . gettypedeclaration ( localtype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . startswith ( string . format ( $string$ , $whitespace$ localtype . getname ( ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( localtype , $whitespace$ typesolver ) . solvetype ( name . substring ( localtype . getname ( ) . getid ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvetypeinparentcontext ( name , $whitespace$ typearguments ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ $indentation$ $whitespace$ = $whitespace$ wrappednode. gettypeparameters ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappednode. gettypeparameters ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ tp $whitespace$ : $whitespace$ wrappednode. gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tp. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javaparsertypeparameter ( tp, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $newline$ $indentation$ list < typedeclaration > $whitespace$ localtypes $whitespace$ = $whitespace$ wrappednode. findall ( typedeclaration. class ) ; $newline$ $indentation$ for $whitespace$ ( typedeclaration <? > $whitespace$ localtype $whitespace$ : $whitespace$ localtypes ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( localtype. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( localtype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name. startswith ( string. format ( $string$, $whitespace$ localtype. getname			
solveMethod	126	130	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java	0.2497822940349578	LOW	"		@Override
		public final SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ getorgx ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
solveSymbolAsValue	84	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java	0.6514474749565125	MID	"		@Override
		public final Optional<Value> solveSymbolAsValue(String name){
		    for (Parameter parameter : wrappedNode.getParameters()) {
		        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);
		        Optional<Value> symbolReference = solveWithAsValue(sb, name);
		        if (symbolReference.isPresent()) {
		            // Perform parameter type substitution as needed
		            return symbolReference;
		        }
		    }
		    // if nothing is found we should ask the parent context
		    return solveSymbolAsValueInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ wrappednode . getparameters ( ) ) $whitespace$ { $newline$ $indentation$ symboldeclarator $whitespace$ sb $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( parameter , $whitespace$ typesolver ) ; $newline$ $indentation$ optional < value > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewithasvalue ( sb , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·perform·parameter·type·substitution·as·needed$ $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·parent·context$ $newline$ $indentation$ return $whitespace$ solvesymbolasvalueinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ wrappednode. getparameters ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparserfactory. getsymboldeclarator ( parameter, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < value > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewithasvalue ( sb, $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////performentententententententententententententent ( parent ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$			
solveGenericType	70	82	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AbstractMethodLikeDeclarationContext.java	0.6778122186660767	MID	"		@Override
		public final Optional<ResolvedType> solveGenericType(String name){
		    // First check if the method-like declaration has type parameters defined.
		    // For example: {@code public <T> boolean containsAll(Collection<T> c);}
		    for (TypeParameter tp : wrappedNode.getTypeParameters()) {
		        if (tp.getName().getId().equals(name)) {
		            return Optional.of(new ResolvedTypeVariable(new JavaParserTypeParameter(tp, typeSolver)));
		        }
		    }
		    // If no generic types on the method declaration, continue to solve elsewhere as usual.
		    return solveGenericTypeInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < resolvedtype > $whitespace$ solvegenerictype ( string $whitespace$ name ) { $newline$ $indentation$ $//·first·check·if·the·method-like·declaration·has·type·parameters·defined.$ $newline$ $indentation$ $//·for·example:·{@code·public·<t>·boolean·containsall(collection<t>·c);}$ $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ tp $whitespace$ : $whitespace$ wrappednode . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tp . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ resolvedtypevariable ( new $whitespace$ javaparsertypeparameter ( tp , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·no·generic·types·on·the·method·declaration,·continue·to·solve·elsewhere·as·usual.$ $newline$ $indentation$ return $whitespace$ solvegenerictypeinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ optional < resolvedtype > $whitespace$ solvegenerictype ( string $whitespace$ name ) { $newline$ $indentation$ $whitespace$ this. solvegenerictype $whitespace$ = $whitespace$ $newline$ $indentation$brbration $whitespace$ * $whitespace$ $newline$ $indentation$. and ( ) $newline$ $indentation$. filter ( typeparameter $whitespace$ - > $whitespace$ clazz $whitespace$ : $whitespace$ wrappednode. gettypeparameters ( ) ) $newline$ $indentation$. and ( ) ; $newline$ $indentation$ $newline$ $indentation$ $whitespace$ $newline$ $indentation$. and ( ) $newline$ $indentation$. filter ( typeparameter $whitespace$ - > $whitespace$ clazz. getname ( ). getid ( ) ) $newline$ $indentation$. equals ( name ) ; $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ resolvedtypevariable ( new $whitespace$ javaparsertypeparameter ( tp, $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvegenerictypeinparentcontext ( name ) ; $newline$ $indentation$ }			
solveType	124	197	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnonymousClassDeclarationContext.java	0.0001025076780933	LOW	"		@Override
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name, List<ResolvedType> typeArguments){
		    List<TypeDeclaration> typeDeclarations = myDeclaration.findMembersOfKind(TypeDeclaration.class);
		    Optional<SymbolReference<ResolvedTypeDeclaration>> exactMatch = typeDeclarations.stream().filter(internalType -> internalType.getName().getId().equals(name)).findFirst().map(internalType -> SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(internalType)));
		    if (exactMatch.isPresent()) {
		        return exactMatch.get();
		    }
		    Optional<SymbolReference<ResolvedTypeDeclaration>> recursiveMatch = typeDeclarations.stream().filter(internalType -> name.startsWith(String.format(""%s."", internalType.getName()))).findFirst().map(internalType -> JavaParserFactory.getContext(internalType, typeSolver).solveType(name.substring(internalType.getName().getId().length() + 1)));
		    if (recursiveMatch.isPresent()) {
		        return recursiveMatch.get();
		    }
		    Optional<SymbolReference<ResolvedTypeDeclaration>> typeArgumentsMatch = wrappedNode.getTypeArguments().map(nodes -> ((NodeWithTypeArguments<?>) nodes).getTypeArguments().orElse(new NodeList<>())).orElse(new NodeList<>()).stream().filter(type -> type.toString().equals(name)).findFirst().map(matchingType -> SymbolReference.solved(new JavaParserTypeParameter(new TypeParameter(matchingType.toString()), typeSolver)));
		    if (typeArgumentsMatch.isPresent()) {
		        return typeArgumentsMatch.get();
		    }
		    // Look into extended classes and implemented interfaces
		    for (ResolvedReferenceType ancestor : myDeclaration.getAncestors()) {
		        // look at names of extended classes and implemented interfaces (this may not be important because they are checked in CompilationUnitContext)
		        Optional<ResolvedReferenceTypeDeclaration> optionalTypeDeclaration = ancestor.getTypeDeclaration();
		        if (optionalTypeDeclaration.isPresent()) {
		            ResolvedReferenceTypeDeclaration typeDeclaration = optionalTypeDeclaration.get();
		            if (typeDeclaration.getName().equals(name)) {
		                return SymbolReference.solved(typeDeclaration);
		            }
		            // look into internal types of extended classes and implemented interfaces
		            try {
		                for (ResolvedTypeDeclaration internalTypeDeclaration : typeDeclaration.internalTypes()) {
		                    if (internalTypeDeclaration.getName().equals(name)) {
		                        return SymbolReference.solved(internalTypeDeclaration);
		                    }
		                }
		            } catch (UnsupportedOperationException e) {
		                // just continue using the next ancestor
		            }
		        }
		    }
		    return solveTypeInParentContext(name, typeArguments);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ list < typedeclaration > $whitespace$ typedeclarations $whitespace$ = $whitespace$ mydeclaration . findmembersofkind ( typedeclaration . class ) ; $newline$ $indentation$ optional < symbolreference < resolvedtypedeclaration >> $whitespace$ exactmatch $whitespace$ = $whitespace$ typedeclarations . stream ( ) . filter ( internaltype $whitespace$ - > $whitespace$ internaltype . getname ( ) . getid ( ) . equals ( name ) ) . findfirst ( ) . map ( internaltype $whitespace$ - > $whitespace$ symbolreference . solved ( javaparserfacade . get ( typesolver ) . gettypedeclaration ( internaltype ) ) ) ; $newline$ $indentation$ if $whitespace$ ( exactmatch . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ exactmatch . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < symbolreference < resolvedtypedeclaration >> $whitespace$ recursivematch $whitespace$ = $whitespace$ typedeclarations . stream ( ) . filter ( internaltype $whitespace$ - > $whitespace$ name . startswith ( string . format ( $string$ , $whitespace$ internaltype . getname ( ) ) ) ) . findfirst ( ) . map ( internaltype $whitespace$ - > $whitespace$ javaparserfactory . getcontext ( internaltype , $whitespace$ typesolver ) . solvetype ( name . substring ( internaltype . getname ( ) . getid ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) ) ) ; $newline$ $indentation$ if $whitespace$ ( recursivematch . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ recursivematch . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < symbolreference < resolvedtypedeclaration >> $whitespace$ typeargumentsmatch $whitespace$ = $whitespace$ wrappednode . gettypearguments ( ) . map ( nodes $whitespace$ - > $whitespace$ ( ( nodewithtypearguments < ? > ) $whitespace$ nodes ) . gettypearguments ( ) . orelse ( new $whitespace$ nodelist < > ( ) ) ) . orelse ( new $whitespace$ nodelist < > ( ) ) . stream ( ) . filter ( type $whitespace$ - > $whitespace$ type . tostring ( ) . equals ( name ) ) . findfirst ( ) . map ( matchingtype $whitespace$ - > $whitespace$ symbolreference . solved ( new $whitespace$ javaparsertypeparameter ( new $whitespace$ typeparameter ( matchingtype . tostring ( ) ) , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ if $whitespace$ ( typeargumentsmatch . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeargumentsmatch . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·look·into·extended·classes·and·implemented·interfaces$ $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ mydeclaration . getancestors ( ) ) $whitespace$ { $newline$ $indentation$ $//·look·at·names·of·extended·classes·and·implemented·interfaces·(this·may·not·be·important·because·they·are·checked·in·compilationunitcontext)$ $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionaltypedeclaration $whitespace$ = $whitespace$ ancestor . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( optionaltypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ optionaltypedeclaration . get ( ) ; $newline$ $indentation$ if $whitespace$ ( typedeclaration . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·look·into·internal·types·of·extended·classes·and·implemented·interfaces$ $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypedeclaration $whitespace$ internaltypedeclaration $whitespace$ : $whitespace$ typedeclaration . internaltypes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( internaltypedeclaration . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( internaltypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsupportedoperationexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·just·continue·using·the·next·ancestor$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvetypeinparentcontext ( name , $whitespace$ typearguments ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ list < typedeclaration > $whitespace$ typedeclarations $whitespace$ = $whitespace$ mydeclaration. findmembersofkind ( typedeclaration. class ) ; $newline$ $indentation$ optional < symbolreference < resolvedtypedeclaration >> $whitespace$ exactmatch $whitespace$ = $whitespace$ typedeclarations. stream ( ). filter ( internaltype $whitespace$ - > $whitespace$ internaltype. getname ( ). getid ( ). equals ( name ) ). findfirst ( ). map ( internaltype $whitespace$ - > $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( internaltype ) ) ) ; $newline$ $indentation$ if $whitespace$ ( exactmatch. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ exactmatch. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < symbolreference < resolvedtypedeclaration >> $whitespace$ recursivematch $whitespace$ = $whitespace$ typedeclarations. stream ( ). filter ( internaltype $whitespace$ - > $whitespace$ name. startswith ( string. format ( $string$, $whitespace$ internaltype. getname ( ) ) ) ). findfirst ( ). map ( internaltype $whitespace$ - > $whitespace$ javaparserfactory. getcontext ( internaltype, $whitespace$ typesolver ). solvetype ( name. substring ( internaltype. getname ( ). getid ( ). length ( ) $whitespace$ + $whitespace$ $number$ ) ) ) ; $newline$ $indentation$ if $whitespace$ ( recursivematch. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ recursivematch. get ( ) ; $newline$ $indentation$			
solveMethod	63	122	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/AnonymousClassDeclarationContext.java	0.0160141643136739	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    List<ResolvedMethodDeclaration> candidateMethods = myDeclaration.getDeclaredMethods().stream().filter(m -> m.getName().equals(name) && (!staticOnly || m.isStatic())).collect(Collectors.toList());
		    if (!myDeclaration.isJavaLangObject()) {
		        for (ResolvedReferenceType ancestor : myDeclaration.getAncestors()) {
		            ancestor.getTypeDeclaration().ifPresent(ancestorTypeDeclaration -> {
		                SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(ancestorTypeDeclaration, name, argumentsTypes, staticOnly);
		                // consider methods from superclasses and only default methods from interfaces :
		                // not true, we should keep abstract as a valid candidate
		                // abstract are removed in MethodResolutionLogic.isApplicable is necessary
		                if (res.isSolved()) {
		                    candidateMethods.add(res.getCorrespondingDeclaration());
		                }
		            });
		        }
		    }
		    // We want to avoid infinite recursion when a class is using its own method
		    // see issue #75
		    if (candidateMethods.isEmpty()) {
		        SymbolReference<ResolvedMethodDeclaration> parentSolution = getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveMethod(name, argumentsTypes, staticOnly);
		        if (parentSolution.isSolved()) {
		            candidateMethods.add(parentSolution.getCorrespondingDeclaration());
		        }
		    }
		    // if is interface and candidate method list is empty, we should check the Object Methods
		    if (candidateMethods.isEmpty() && myDeclaration.getSuperTypeDeclaration().isInterface()) {
		        SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(new ReflectionClassDeclaration(Object.class, typeSolver), name, argumentsTypes, false);
		        if (res.isSolved()) {
		            candidateMethods.add(res.getCorrespondingDeclaration());
		        }
		    }
		    return MethodResolutionLogic.findMostApplicable(candidateMethods, name, argumentsTypes, typeSolver);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatemethods $whitespace$ = $whitespace$ mydeclaration . getdeclaredmethods ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( name ) $whitespace$ && $whitespace$ ( ! staticonly $whitespace$ || $whitespace$ m . isstatic ( ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ! mydeclaration . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ mydeclaration . getancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor . gettypedeclaration ( ) . ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ancestortypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ $//·consider·methods·from·superclasses·and·only·default·methods·from·interfaces·:$ $newline$ $indentation$ $//·not·true,·we·should·keep·abstract·as·a·valid·candidate$ $newline$ $indentation$ $//·abstract·are·removed·in·methodresolutionlogic.isapplicable·is·necessary$ $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( res . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·we·want·to·avoid·infinite·recursion·when·a·class·is·using·its·own·method$ $newline$ $indentation$ $//·see·issue·#75$ $newline$ $indentation$ if $whitespace$ ( candidatemethods . isempty ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ parentsolution $whitespace$ = $whitespace$ getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( parentsolution . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( parentsolution . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·is·interface·and·candidate·method·list·is·empty,·we·should·check·the·object·methods$ $newline$ $indentation$ if $whitespace$ ( candidatemethods . isempty ( ) $whitespace$ && $whitespace$ mydeclaration . getsupertypedeclaration ( ) . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( new $whitespace$ reflectionclassdeclaration ( object . class , $whitespace$ typesolver ) , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( res . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicable ( candidatemethods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatemethods $whitespace$ = $whitespace$ mydeclaration. getdeclaredmethods ( ). stream ( ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$ m. getname ( ). equals ( name ) $whitespace$ && $whitespace$ (! staticonly $whitespace$ || $whitespace$ m. isstatic ( ) ) ) $newline$ $indentation$. collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ (! mydeclaration. isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ resolvedreferencetype. getancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor. gettypedeclaration ( ). ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ methodresolutionlogic. solvemethodintype ( ancestortypedeclaration, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ $////g$ = = = =space$ methodresolutionlogic. solvemethodintype ( ancestortypedeclaration, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ $//g$ = $whitespace$ methodresolutionlogic. solvemethodintype ( ancestortypedeclaration, $whitespace$ name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ $whitespace$ }			
patternExprInScope	205	227	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.112603910267353	LOW	"		public Optional<PatternExpr> patternExprInScope(String name){
		    BinaryExpr binaryExpr = wrappedNode;
		    Expression leftBranch = binaryExpr.getLeft();
		    Expression rightBranch = binaryExpr.getRight();
		    List<PatternExpr> patternExprs = patternExprsExposedToDirectParentFromBranch(leftBranch);
		    Optional<PatternExpr> localResolutionResults = patternExprs.stream().filter(vd -> vd.getNameAsString().equals(name)).findFirst();
		    if (localResolutionResults.isPresent()) {
		        return localResolutionResults;
		    }
		    // If we don't find the parameter locally, escalate up the scope hierarchy to see if it is declared there.
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    Context parentContext = getParent().get();
		    return parentContext.patternExprInScope(name);
		}"	$indentation$ public $whitespace$ optional < patternexpr > $whitespace$ patternexprinscope ( string $whitespace$ name ) { $newline$ $indentation$ binaryexpr $whitespace$ binaryexpr $whitespace$ = $whitespace$ wrappednode ; $newline$ $indentation$ expression $whitespace$ leftbranch $whitespace$ = $whitespace$ binaryexpr . getleft ( ) ; $newline$ $indentation$ expression $whitespace$ rightbranch $whitespace$ = $whitespace$ binaryexpr . getright ( ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ patternexprs $whitespace$ = $whitespace$ patternexprsexposedtodirectparentfrombranch ( leftbranch ) ; $newline$ $indentation$ optional < patternexpr > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ patternexprs . stream ( ) . filter ( vd $whitespace$ - > $whitespace$ vd . getnameasstring ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·don't·find·the·parameter·locally,·escalate·up·the·scope·hierarchy·to·see·if·it·is·declared·there.$ $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ return $whitespace$ parentcontext . patternexprinscope ( name ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < patternexpr > $whitespace$ patternexprinscope ( string $whitespace$ name ) { $newline$ $indentation$ binaryexpr $whitespace$ binaryexpr $whitespace$ = $whitespace$ wrappednode ; $newline$ $indentation$ expression $whitespace$ leftbranch $whitespace$ = $whitespace$ binaryexpr. getleft ( ) ; $newline$ $indentation$ expression $whitespace$ rightbranch $whitespace$ = $whitespace$ binaryexpr. getright ( ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ patternexprs $whitespace$ = $whitespace$ patternexprsexposedtodirectparentfrombranch ( leftbranch ) ; $newline$ $indentation$ optional < patternexpr > $whitespace$ localresolutionresults $whitespace$ = $whitespace$ patternexprs. stream ( ). filter ( vd $whitespace$ - > $whitespace$ vd. getnameasstring ( ). equals ( name ) ). findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( localresolutionresults. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ localresolutionresults ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ list $whitespace$ is $whitespace$ different $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ). get ( ) ; $newline$ $			
patternExprsExposedFromChildren	41	95	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.1152092590928077	LOW	"		@Override
		public List<PatternExpr> patternExprsExposedFromChildren(){
		    BinaryExpr binaryExpr = wrappedNode;
		    Expression leftBranch = binaryExpr.getLeft();
		    Expression rightBranch = binaryExpr.getRight();
		    List<PatternExpr> results = new ArrayList<>();
		    if (binaryExpr.getOperator().equals(BinaryExpr.Operator.EQUALS)) {
		        if (rightBranch.isBooleanLiteralExpr()) {
		            if (rightBranch.asBooleanLiteralExpr().getValue() == true) {
		                // ""x"" instanceof String s == true
		                results.addAll(patternExprsExposedToDirectParentFromBranch(leftBranch));
		            } else {
		                // ""x"" instanceof String s == false
		            }
		        } else if (leftBranch.isBooleanLiteralExpr()) {
		            if (leftBranch.asBooleanLiteralExpr().getValue() == true) {
		                // true == ""x"" instanceof String s
		                results.addAll(patternExprsExposedToDirectParentFromBranch(rightBranch));
		            } else {
		                // false == ""x"" instanceof String s
		            }
		        }
		    } else if (binaryExpr.getOperator().equals(BinaryExpr.Operator.NOT_EQUALS)) {
		        if (rightBranch.isBooleanLiteralExpr()) {
		            if (rightBranch.asBooleanLiteralExpr().getValue() == true) {
		                // ""x"" instanceof String s != true
		            } else {
		                // ""x"" instanceof String s != false
		                results.addAll(patternExprsExposedToDirectParentFromBranch(leftBranch));
		            }
		        } else if (leftBranch.isBooleanLiteralExpr()) {
		            if (leftBranch.asBooleanLiteralExpr().getValue() == true) {
		                // true != ""x"" instanceof String s
		            } else {
		                // false != ""x"" instanceof String s
		                results.addAll(patternExprsExposedToDirectParentFromBranch(rightBranch));
		            }
		        }
		        // TODO/FIXME: There are other cases where it may be ambiguously true until runtime e.g. `""x"" instanceof String s == (new Random().nextBoolean())`
		    } else if (binaryExpr.getOperator().equals(BinaryExpr.Operator.AND)) {
		        // ""x"" instanceof String s && s.length() > 0
		        // ""x"" instanceof String s && ""x"" instanceof String s2
		        results.addAll(patternExprsExposedToDirectParentFromBranch(leftBranch));
		        results.addAll(patternExprsExposedToDirectParentFromBranch(rightBranch));
		    } else {
		        return new ArrayList<>();
		    }
		    return results;
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedfromchildren ( ) { $newline$ $indentation$ binaryexpr $whitespace$ binaryexpr $whitespace$ = $whitespace$ wrappednode ; $newline$ $indentation$ expression $whitespace$ leftbranch $whitespace$ = $whitespace$ binaryexpr . getleft ( ) ; $newline$ $indentation$ expression $whitespace$ rightbranch $whitespace$ = $whitespace$ binaryexpr . getright ( ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( binaryexpr . getoperator ( ) . equals ( binaryexpr . operator . equals ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//·""x""·instanceof·string·s·==·true$ $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( leftbranch ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·""x""·instanceof·string·s·==·false$ $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( leftbranch . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( leftbranch . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//·true·==·""x""·instanceof·string·s$ $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( rightbranch ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·false·==·""x""·instanceof·string·s$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( binaryexpr . getoperator ( ) . equals ( binaryexpr . operator . not_equals ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//·""x""·instanceof·string·s·!=·true$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·""x""·instanceof·string·s·!=·false$ $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( leftbranch ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( leftbranch . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( leftbranch . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//·true·!=·""x""·instanceof·string·s$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·false·!=·""x""·instanceof·string·s$ $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( rightbranch ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo/fixme:·there·are·other·cases·where·it·may·be·ambiguously·true·until·runtime·e.g.·`""x""·instanceof·string·s·==·(new·random().nextboolean())`$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( binaryexpr . getoperator ( ) . equals ( binaryexpr . operator . and ) ) $whitespace$ { $newline$ $indentation$ $//·""x""·instanceof·string·s·&&·s.length()·>·0$ $newline$ $indentation$ $//·""x""·instanceof·string·s·&&·""x""·instanceof·string·s2$ $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( leftbranch ) ) ; $newline$ $indentation$ results . addall ( patternexprsexposedtodirectparentfrombranch ( rightbranch ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedfromchildren ( ) { $newline$ $indentation$ binaryexpr $whitespace$ binaryexpr $whitespace$ = $whitespace$ wrappednode ; $newline$ $indentation$ expression $whitespace$ leftbranch $whitespace$ = $whitespace$ binaryexpr. getleft ( ) ; $newline$ $indentation$ expression $whitespace$ rightbranch $whitespace$ = $whitespace$ binaryexpr. getright ( ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( binaryexpr. getoperator ( ). equals ( binaryexpr. operator. equals ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch. isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rightbranch. asbooleanliteralexpr ( ). getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//sample""x"""" $whitespace$ = $whitespace$ leftbranch. asbooleanliteralexpr ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//sample""x"""" $whitespace$ = $whitespace$ leftbranch. asbooleanliteralexpr ( ) ; $newline$ $indentation$ if $whitespace$ ( leftbranch. asbooleanliteralexpr ( ). getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ $//llbranch $whitespace$ = $whitespace$ rightbranch ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( leftbranch. isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( leftbranch. asbooleanliteralexpr ( ). getvalue ("			
negatedPatternExprsExposedToDirectParentFromBranch	173	180	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.2736552357673645	LOW	"		private List<PatternExpr> negatedPatternExprsExposedToDirectParentFromBranch(Expression branch){
		    if (branch.isEnclosedExpr() || branch.isBinaryExpr() || branch.isUnaryExpr() || branch.isInstanceOfExpr()) {
		        Context branchContext = JavaParserFactory.getContext(branch, typeSolver);
		        return branchContext.negatedPatternExprsExposedFromChildren();
		    }
		    return new ArrayList<>();
		}"	$indentation$ private $whitespace$ list < patternexpr > $whitespace$ negatedpatternexprsexposedtodirectparentfrombranch ( expression $whitespace$ branch ) { $newline$ $indentation$ if $whitespace$ ( branch . isenclosedexpr ( ) $whitespace$ || $whitespace$ branch . isbinaryexpr ( ) $whitespace$ || $whitespace$ branch . isunaryexpr ( ) $whitespace$ || $whitespace$ branch . isinstanceofexpr ( ) ) $whitespace$ { $newline$ $indentation$ context $whitespace$ branchcontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( branch , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ branchcontext . negatedpatternexprsexposedfromchildren ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < patternexpr > $whitespace$ 256patternexprsexposedtodirectparentfrombranch ( expression $whitespace$ branch ) { $newline$ $indentation$ if $whitespace$ ( branch. isenclosedexpr ( ) $whitespace$ || $whitespace$ branch. isbinaryexpr ( ) $whitespace$ || $whitespace$ branch. isunaryexpr ( ) $whitespace$ || $whitespace$ branch. isinstanceofexpr ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ branchcontext. getcontext ( branch, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ }			
patternExprsExposedToDirectParentFromBranch	164	171	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.2784981727600097	LOW	"		private List<PatternExpr> patternExprsExposedToDirectParentFromBranch(Expression branch){
		    if (branch.isEnclosedExpr() || branch.isBinaryExpr() || branch.isUnaryExpr() || branch.isInstanceOfExpr()) {
		        Context branchContext = JavaParserFactory.getContext(branch, typeSolver);
		        return branchContext.patternExprsExposedFromChildren();
		    }
		    return new ArrayList<>();
		}"	$indentation$ private $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedtodirectparentfrombranch ( expression $whitespace$ branch ) { $newline$ $indentation$ if $whitespace$ ( branch . isenclosedexpr ( ) $whitespace$ || $whitespace$ branch . isbinaryexpr ( ) $whitespace$ || $whitespace$ branch . isunaryexpr ( ) $whitespace$ || $whitespace$ branch . isinstanceofexpr ( ) ) $whitespace$ { $newline$ $indentation$ context $whitespace$ branchcontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( branch , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ branchcontext . patternexprsexposedfromchildren ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedtodirectparentfrombranch ( expression $whitespace$ branch ) { $newline$ $indentation$ if $whitespace$ ( branch. isenclosedexpr ( ) $whitespace$ || $whitespace$ branch. isbinaryexpr ( ) $whitespace$ || $whitespace$ branch. isunaryexpr ( ) $whitespace$ || $whitespace$ branch. isinstanceofexpr ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ branchcontext. patternexprsexposedfromchildren ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ }			
isDefinitivelyFalse	239	247	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.8739171624183655	HIGH	"		private boolean isDefinitivelyFalse(Expression expression){
		    // TODO: Consider combinations of literal true/false, enclosed expressions, and negations.
		    if (expression.isBooleanLiteralExpr()) {
		        if (expression.asBooleanLiteralExpr().getValue() == false) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isdefinitivelyfalse ( expression $whitespace$ expression ) { $newline$ $indentation$ $//·todo:·consider·combinations·of·literal·true/false,·enclosed·expressions,·and·negations.$ $newline$ $indentation$ if $whitespace$ ( expression . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expression . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ false ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isdefinitivelyfalse ( expression $whitespace$ expression ) { $newline$ $indentation$ $////str = = = expression. isbooleanliteralexpr ( ) ; $newline$ $indentation$ if $whitespace$ ( expression. isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expression. asbooleanliteralexpr ( ). getvalue ( ) $whitespace$ == $whitespace$ false ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
isDefinitivelyTrue	229	237	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BinaryExprContext.java	0.8779290914535522	HIGH	"		private boolean isDefinitivelyTrue(Expression expression){
		    // TODO: Consider combinations of literal true/false, enclosed expressions, and negations.
		    if (expression.isBooleanLiteralExpr()) {
		        if (expression.asBooleanLiteralExpr().getValue() == true) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isdefinitivelytrue ( expression $whitespace$ expression ) { $newline$ $indentation$ $//·todo:·consider·combinations·of·literal·true/false,·enclosed·expressions,·and·negations.$ $newline$ $indentation$ if $whitespace$ ( expression . isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expression . asbooleanliteralexpr ( ) . getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isdefinitivelytrue ( expression $whitespace$ expression ) { $newline$ $indentation$ $////ll $whitespace$ = $whitespace$ expression. isbooleanliteralexpr ( ) ; $newline$ $indentation$ if $whitespace$ ( expression. isbooleanliteralexpr ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( expression. asbooleanliteralexpr ( ). getvalue ( ) $whitespace$ == $whitespace$ true ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
localVariablesExposedToChild	47	58	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java	0.2250613272190094	LOW	"		@Override
		public List<VariableDeclarator> localVariablesExposedToChild(Node child){
		    int position = wrappedNode.getStatements().indexOf(child);
		    if (position == -1) {
		        throw new RuntimeException();
		    }
		    List<VariableDeclarator> variableDeclarators = new LinkedList<>();
		    for (int i = position - 1; i >= 0; i--) {
		        variableDeclarators.addAll(localVariablesDeclaredIn(wrappedNode.getStatement(i)));
		    }
		    return variableDeclarators;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ wrappednode . getstatements ( ) . indexof ( child ) ; $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ position $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ variabledeclarators . addall ( localvariablesdeclaredin ( wrappednode . getstatement ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ variabledeclarators ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ wrappednode. getstatements ( ). indexof ( child ) ; $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ position $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { //iterates $whitespace$ through $whitespace$ vardictionary $newline$ $indentation$ variabledeclarators. addall ( localvariablesdeclaredin ( wrappednode. getstatement ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ //iterates $whitespace$ through $whitespace$ vardictionary $newline$ $indentation$ return $whitespace$ variabledeclarators ; $newline$ $indentation$ }			
localVariablesDeclaredIn	60	71	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java	0.2448486089706421	LOW	"		private List<VariableDeclarator> localVariablesDeclaredIn(Statement statement){
		    if (statement instanceof ExpressionStmt) {
		        ExpressionStmt expressionStmt = (ExpressionStmt) statement;
		        if (expressionStmt.getExpression() instanceof VariableDeclarationExpr) {
		            VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr) expressionStmt.getExpression();
		            List<VariableDeclarator> variableDeclarators = new LinkedList<>();
		            variableDeclarators.addAll(variableDeclarationExpr.getVariables());
		            return variableDeclarators;
		        }
		    }
		    return Collections.emptyList();
		}"	$indentation$ private $whitespace$ list < variabledeclarator > $whitespace$ localvariablesdeclaredin ( statement $whitespace$ statement ) { $newline$ $indentation$ if $whitespace$ ( statement $whitespace$ instanceof $whitespace$ expressionstmt ) $whitespace$ { $newline$ $indentation$ expressionstmt $whitespace$ expressionstmt $whitespace$ = $whitespace$ ( expressionstmt ) $whitespace$ statement ; $newline$ $indentation$ if $whitespace$ ( expressionstmt . getexpression ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ variabledeclarationexpr $whitespace$ variabledeclarationexpr $whitespace$ = $whitespace$ ( variabledeclarationexpr ) $whitespace$ expressionstmt . getexpression ( ) ; $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ variabledeclarators . addall ( variabledeclarationexpr . getvariables ( ) ) ; $newline$ $indentation$ return $whitespace$ variabledeclarators ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < variabledeclarator > $whitespace$ localvariablesdeclaredin ( statement $whitespace$ statement ) { $newline$ $indentation$ if $whitespace$ ( statement $whitespace$ instanceof $whitespace$ expressionstmt ) $whitespace$ { $newline$ $indentation$ expressionstmt $whitespace$ expressionstmt $whitespace$ = $whitespace$ ( expressionstmt ) $whitespace$ statement ; $newline$ $indentation$ if $whitespace$ ( expressionstmt. getexpression ( ) $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ expressionstmt $whitespace$ = $whitespace$ expressionstmt. getexpression ( ) ; $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ variabledeclarationexpr $whitespace$ variabledeclarationexpr $whitespace$ = $whitespace$ ( variabledeclarationexpr ) $whitespace$ expressionstmt. getexpression ( ) ; $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ variabledeclarationexpr. addall ( variabledeclarationexpr. getvariables ( ) ) ; $newline$ $indentation$ return $whitespace$ variabledeclarators ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ }			
solveSymbol	73	107	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/BlockStmtContext.java	0.250309556722641	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name){
		    Optional<Context> optionalParent = getParent();
		    if (!optionalParent.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    if (wrappedNode.getStatements().size() > 0) {
		        // tries to resolve a declaration from local variables defined in child statements
		        // or from parent node context
		        // for example resolve declaration for the MethodCallExpr a.method() in
		        // A a = this;
		        // {
		        //   a.method();
		        // }
		        List<VariableDeclarator> variableDeclarators = new LinkedList<>();
		        // find all variable declarators exposed to child
		        // given that we don't know the statement we are trying to resolve, we look for all variable declarations
		        // defined in the context of the wrapped node whether it is located before or after the statement that interests us
		        // because a variable cannot be (re)defined after having been used
		        wrappedNode.getStatements().getLast().ifPresent(stmt -> variableDeclarators.addAll(localVariablesExposedToChild(stmt)));
		        if (!variableDeclarators.isEmpty()) {
		            // FIXME: Work backwards from the current statement, to only consider declarations prior to this statement.
		            for (VariableDeclarator vd : variableDeclarators) {
		                if (vd.getNameAsString().equals(name)) {
		                    return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(vd, typeSolver));
		                }
		            }
		        }
		    }
		    // Otherwise continue as normal...
		    return solveSymbolInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ optional < context > $whitespace$ optionalparent $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparent . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wrappednode . getstatements ( ) . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·tries·to·resolve·a·declaration·from·local·variables·defined·in·child·statements$ $newline$ $indentation$ $//·or·from·parent·node·context$ $newline$ $indentation$ $//·for·example·resolve·declaration·for·the·methodcallexpr·a.method()·in$ $newline$ $indentation$ $//·a·a·=·this;$ $newline$ $indentation$ $//·{$ $newline$ $indentation$ $//···a.method();$ $newline$ $indentation$ $//·}$ $newline$ $indentation$ list < variabledeclarator > $whitespace$ variabledeclarators $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $//·find·all·variable·declarators·exposed·to·child$ $newline$ $indentation$ $//·given·that·we·don't·know·the·statement·we·are·trying·to·resolve,·we·look·for·all·variable·declarations$ $newline$ $indentation$ $//·defined·in·the·context·of·the·wrapped·node·whether·it·is·located·before·or·after·the·statement·that·interests·us$ $newline$ $indentation$ $//·because·a·variable·cannot·be·(re)defined·after·having·been·used$ $newline$ $indentation$ wrappednode . getstatements ( ) . getlast ( ) . ifpresent ( stmt $whitespace$ - > $whitespace$ variabledeclarators . addall ( localvariablesexposedtochild ( stmt ) ) ) ; $newline$ $indentation$ if $whitespace$ ( ! variabledeclarators . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·fixme:·work·backwards·from·the·current·statement,·to·only·consider·declarations·prior·to·this·statement.$ $newline$ $indentation$ for $whitespace$ ( variabledeclarator $whitespace$ vd $whitespace$ : $whitespace$ variabledeclarators ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( vd . getnameasstring ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparsersymboldeclaration . localvar ( vd , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise·continue·as·normal...$ $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! optionalparent. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wrappednode. getstatements ( ). size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//hh $whitespace$ = $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wrappednode. getstatements ( ). size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//hh $whitespace$ = $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $			
solveMethod	75	79	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CatchClauseContext.java	0.2497822940349578	LOW	"		@Override
		public final SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ final $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ getorgx ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
parametersExposedToChild	86	93	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CatchClauseContext.java	0.6716307997703552	MID	"		@Override
		public List<Parameter> parametersExposedToChild(Node child){
		    // TODO/FIXME: Presumably the parameters must be exposed to all children and their descendants, not just the direct child?
		    if (child == getWrappedNode().getBody()) {
		        return Collections.singletonList(getWrappedNode().getParameter());
		    }
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < parameter > $whitespace$ parametersexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ $//·todo/fixme:·presumably·the·parameters·must·be·exposed·to·all·children·and·their·descendants,·not·just·the·direct·child?$ $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ getwrappednode ( ) . getbody ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections . singletonlist ( getwrappednode ( ) . getparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < parameter > $whitespace$ parametersexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ $whitespace$ parametersexposedtochild $whitespace$ = $whitespace$ getwrappednode ( ) ; $newline$ $indentation$ return $whitespace$ collections. singletonlist ( getwrappednode ( ). getparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ list < parameter > $whitespace$ parametersexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ list $whitespace$ of $whitespace$ parametersexposed $whitespace$ in $whitespace$ the $whitespace$ current $whitespace$ working $whitespace$ directory $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ getwrappednode ( ). getbody ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections. singletonlist ( getwrappednode ( ). getparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections. empty			
fieldsExposedToChild	113	120	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationContext.java	0.0872172936797142	LOW	"		@Override
		public List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child){
		    List<ResolvedFieldDeclaration> fields = new LinkedList<>();
		    fields.addAll(this.wrappedNode.resolve().getDeclaredFields());
		    this.wrappedNode.getExtendedTypes().forEach(i -> fields.addAll(i.resolve().asReferenceType().getAllFieldsVisibleToInheritors()));
		    this.wrappedNode.getImplementedTypes().forEach(i -> fields.addAll(i.resolve().asReferenceType().getAllFieldsVisibleToInheritors()));
		    return fields;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ fieldsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ fields . addall ( this . wrappednode . resolve ( ) . getdeclaredfields ( ) ) ; $newline$ $indentation$ this . wrappednode . getextendedtypes ( ) . foreach ( i $whitespace$ - > $whitespace$ fields . addall ( i . resolve ( ) . asreferencetype ( ) . getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ this . wrappednode . getimplementedtypes ( ) . foreach ( i $whitespace$ - > $whitespace$ fields . addall ( i . resolve ( ) . asreferencetype ( ) . getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ fieldsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ fields. addall ( this. wrappednode. resolve ( ). getdeclaredfields ( ) ) ; $newline$ $indentation$ this. wrappednode. getextendedtypes ( ). foreach ( i $whitespace$ - > $whitespace$ fields. addall ( i. resolve ( ). asreferencetype ( ). getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ this. wrappednode. getimplementedtypes ( ). foreach ( i $whitespace$ - > $whitespace$ fields. addall ( i. resolve ( ). asreferencetype ( ). getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }			
solveGenericType	85	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ClassOrInterfaceDeclarationContext.java	0.6704987287521362	MID	"		@Override
		public Optional<ResolvedType> solveGenericType(String name){
		    // First check if the method-like declaration has type parameters defined.
		    // For example: {@code public <T> boolean containsAll(Collection<T> c);}
		    for (TypeParameter tp : wrappedNode.getTypeParameters()) {
		        if (tp.getName().getId().equals(name)) {
		            return Optional.of(new ResolvedTypeVariable(new JavaParserTypeParameter(tp, typeSolver)));
		        }
		    }
		    // If no generic types on the method declaration, continue to solve as usual.
		    return solveGenericTypeInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedtype > $whitespace$ solvegenerictype ( string $whitespace$ name ) { $newline$ $indentation$ $//·first·check·if·the·method-like·declaration·has·type·parameters·defined.$ $newline$ $indentation$ $//·for·example:·{@code·public·<t>·boolean·containsall(collection<t>·c);}$ $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ tp $whitespace$ : $whitespace$ wrappednode . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tp . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ resolvedtypevariable ( new $whitespace$ javaparsertypeparameter ( tp , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·no·generic·types·on·the·method·declaration,·continue·to·solve·as·usual.$ $newline$ $indentation$ return $whitespace$ solvegenerictypeinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedtype > $whitespace$ solvegenerictype ( string $whitespace$ name ) { $newline$ $indentation$ $whitespace$ this. addimport ( name ) ; $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ tp $whitespace$ : $whitespace$ wrappednode. gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( tp. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ resolvedtypevariable ( new $whitespace$ javaparsertypeparameter ( tp, $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ enabled $whitespace$ if $whitespace$ ( innerutil. isdebugenabled ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ enabledgenerictypeinparentcontext ( name ) ; $newline$ $indentation$ }			
solveType	120	233	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.001122256158851	LOW	"		@Override
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name, List<ResolvedType> typeArguments){
		    if (wrappedNode.getTypes() != null) {
		        // Look for types in this compilation unit. For instance, if the given name is ""A"", there may be a class or
		        // interface in this compilation unit called ""A"".
		        for (TypeDeclaration<?> type : wrappedNode.getTypes()) {
		            if (type.getName().getId().equals(name) || type.getFullyQualifiedName().map(qualified -> qualified.equals(name)).orElse(false)) {
		                if (type instanceof ClassOrInterfaceDeclaration) {
		                    return SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration((ClassOrInterfaceDeclaration) type));
		                }
		                if (type instanceof AnnotationDeclaration) {
		                    return SymbolReference.solved(new JavaParserAnnotationDeclaration((AnnotationDeclaration) type, typeSolver));
		                }
		                if (type instanceof EnumDeclaration) {
		                    return SymbolReference.solved(new JavaParserEnumDeclaration((EnumDeclaration) type, typeSolver));
		                }
		                throw new UnsupportedOperationException(type.getClass().getCanonicalName());
		            }
		        }
		        // Look for member classes/interfaces of types in this compilation unit. For instance, if the given name is
		        // ""A.B"", there may be a class or interface in this compilation unit called ""A"" which has another member
		        // class or interface called ""B"". Since the type that we're looking for can be nested arbitrarily deeply
		        // (""A.B.C.D""), we look for the outermost type (""A"" in the previous example) first, then recursively invoke
		        // this method for the remaining part of the given name.
		        if (name.indexOf('.') > -1) {
		            SymbolReference<ResolvedTypeDeclaration> ref = null;
		            SymbolReference<ResolvedTypeDeclaration> outerMostRef = solveType(name.substring(0, name.indexOf(""."")));
		            if (outerMostRef != null && outerMostRef.isSolved() && outerMostRef.getCorrespondingDeclaration() instanceof JavaParserClassDeclaration) {
		                ref = ((JavaParserClassDeclaration) outerMostRef.getCorrespondingDeclaration()).solveType(name.substring(name.indexOf(""."") + 1));
		            } else if (outerMostRef != null && outerMostRef.isSolved() && outerMostRef.getCorrespondingDeclaration() instanceof JavaParserInterfaceDeclaration) {
		                ref = ((JavaParserInterfaceDeclaration) outerMostRef.getCorrespondingDeclaration()).solveType(name.substring(name.indexOf(""."") + 1));
		            }
		            if (ref != null && ref.isSolved()) {
		                return ref;
		            }
		        }
		    }
		    // Inspect imports for matches, prior to inspecting other classes within the package (per issue #1526)
		    int dotPos = name.indexOf('.');
		    String prefix = null;
		    if (dotPos > -1) {
		        prefix = name.substring(0, dotPos);
		    }
		    // look into single type imports
		    for (ImportDeclaration importDecl : wrappedNode.getImports()) {
		        if (!importDecl.isAsterisk()) {
		            String qName = importDecl.getNameAsString();
		            boolean defaultPackage = !importDecl.getName().getQualifier().isPresent();
		            boolean found = !defaultPackage && importDecl.getName().getIdentifier().equals(name);
		            if (!found && prefix != null) {
		                found = qName.endsWith(""."" + prefix);
		                if (found) {
		                    qName = qName + name.substring(dotPos);
		                }
		            }
		            if (found) {
		                SymbolReference<ResolvedReferenceTypeDeclaration> ref = typeSolver.tryToSolveType(qName);
		                if (ref != null && ref.isSolved()) {
		                    return SymbolReference.adapt(ref, ResolvedTypeDeclaration.class);
		                }
		            }
		        }
		    }
		    // Look in current package
		    if (this.wrappedNode.getPackageDeclaration().isPresent()) {
		        String qName = this.wrappedNode.getPackageDeclaration().get().getNameAsString() + ""."" + name;
		        SymbolReference<ResolvedReferenceTypeDeclaration> ref = typeSolver.tryToSolveType(qName);
		        if (ref != null && ref.isSolved()) {
		            return SymbolReference.adapt(ref, ResolvedTypeDeclaration.class);
		        }
		    } else {
		        // look for classes in the default package
		        String qName = name;
		        SymbolReference<ResolvedReferenceTypeDeclaration> ref = typeSolver.tryToSolveType(qName);
		        if (ref != null && ref.isSolved()) {
		            return SymbolReference.adapt(ref, ResolvedTypeDeclaration.class);
		        }
		    }
		    // look into asterisk imports on demand
		    for (ImportDeclaration importDecl : wrappedNode.getImports()) {
		        if (importDecl.isAsterisk()) {
		            String qName = importDecl.getNameAsString() + ""."" + name;
		            SymbolReference<ResolvedReferenceTypeDeclaration> ref = typeSolver.tryToSolveType(qName);
		            if (ref != null && ref.isSolved()) {
		                return SymbolReference.adapt(ref, ResolvedTypeDeclaration.class);
		            }
		        }
		    }
		    // Look in the java.lang package
		    SymbolReference<ResolvedReferenceTypeDeclaration> ref = typeSolver.tryToSolveType(DEFAULT_PACKAGE + ""."" + name);
		    if (ref != null && ref.isSolved()) {
		        return SymbolReference.adapt(ref, ResolvedTypeDeclaration.class);
		    }
		    if (isQualifiedName(name)) {
		        return SymbolReference.adapt(typeSolver.tryToSolveType(name), ResolvedTypeDeclaration.class);
		    }
		    return SymbolReference.unsolved();
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . gettypes ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·look·for·types·in·this·compilation·unit.·for·instance,·if·the·given·name·is·""a"",·there·may·be·a·class·or$ $newline$ $indentation$ $//·interface·in·this·compilation·unit·called·""a"".$ $newline$ $indentation$ for $whitespace$ ( typedeclaration < ? > $whitespace$ type $whitespace$ : $whitespace$ wrappednode . gettypes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type . getname ( ) . getid ( ) . equals ( name ) $whitespace$ || $whitespace$ type . getfullyqualifiedname ( ) . map ( qualified $whitespace$ - > $whitespace$ qualified . equals ( name ) ) . orelse ( false ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( typesolver ) . gettypedeclaration ( ( classorinterfacedeclaration ) $whitespace$ type ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserannotationdeclaration ( ( annotationdeclaration ) $whitespace$ type , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ enumdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserenumdeclaration ( ( enumdeclaration ) $whitespace$ type , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·look·for·member·classes/interfaces·of·types·in·this·compilation·unit.·for·instance,·if·the·given·name·is$ $newline$ $indentation$ $//·""a.b"",·there·may·be·a·class·or·interface·in·this·compilation·unit·called·""a""·which·has·another·member$ $newline$ $indentation$ $//·class·or·interface·called·""b"".·since·the·type·that·we're·looking·for·can·be·nested·arbitrarily·deeply$ $newline$ $indentation$ $//·(""a.b.c.d""),·we·look·for·the·outermost·type·(""a""·in·the·previous·example)·first,·then·recursively·invoke$ $newline$ $indentation$ $//·this·method·for·the·remaining·part·of·the·given·name.$ $newline$ $indentation$ if $whitespace$ ( name . indexof ( $string$ ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ null ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ outermostref $whitespace$ = $whitespace$ solvetype ( name . substring ( $number$ , $whitespace$ name . indexof ( $string$ ) ) ) ; $newline$ $indentation$ if $whitespace$ ( outermostref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ outermostref . issolved ( ) $whitespace$ && $whitespace$ outermostref . getcorrespondingdeclaration ( ) $whitespace$ instanceof $whitespace$ javaparserclassdeclaration ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ ( ( javaparserclassdeclaration ) $whitespace$ outermostref . getcorrespondingdeclaration ( ) ) . solvetype ( name . substring ( name . indexof ( $string$ ) $whitespace$ + $whitespace$ $number$ ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( outermostref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ outermostref . issolved ( ) $whitespace$ && $whitespace$ outermostref . getcorrespondingdeclaration ( ) $whitespace$ instanceof $whitespace$ javaparserinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ ( ( javaparserinterfacedeclaration ) $whitespace$ outermostref . getcorrespondingdeclaration ( ) ) . solvetype ( name . substring ( name . indexof ( $string$ ) $whitespace$ + $whitespace$ $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·inspect·imports·for·matches,·prior·to·inspecting·other·classes·within·the·package·(per·issue·#1526)$ $newline$ $indentation$ int $whitespace$ dotpos $whitespace$ = $whitespace$ name . indexof ( $string$ ) ; $newline$ $indentation$ string $whitespace$ prefix $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( dotpos $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ prefix $whitespace$ = $whitespace$ name . substring ( $number$ , $whitespace$ dotpos ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·look·into·single·type·imports$ $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdecl $whitespace$ : $whitespace$ wrappednode . getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! importdecl . isasterisk ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ importdecl . getnameasstring ( ) ; $newline$ $indentation$ boolean $whitespace$ defaultpackage $whitespace$ = $whitespace$ ! importdecl . getname ( ) . getqualifier ( ) . ispresent ( ) ; $newline$ $indentation$ boolean $whitespace$ found $whitespace$ = $whitespace$ ! defaultpackage $whitespace$ && $whitespace$ importdecl . getname ( ) . getidentifier ( ) . equals ( name ) ; $newline$ $indentation$ if $whitespace$ ( ! found $whitespace$ && $whitespace$ prefix $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ found $whitespace$ = $whitespace$ qname . endswith ( $string$ $whitespace$ + $whitespace$ prefix ) ; $newline$ $indentation$ if $whitespace$ ( found ) $whitespace$ { $newline$ $indentation$ qname $whitespace$ = $whitespace$ qname $whitespace$ + $whitespace$ name . substring ( dotpos ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( found ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( qname ) ; $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( ref , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·look·in·current·package$ $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getpackagedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ this . wrappednode . getpackagedeclaration ( ) . get ( ) . getnameasstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( qname ) ; $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( ref , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·look·for·classes·in·the·default·package$ $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ name ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( qname ) ; $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( ref , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·look·into·asterisk·imports·on·demand$ $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdecl $whitespace$ : $whitespace$ wrappednode . getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdecl . isasterisk ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ importdecl . getnameasstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( qname ) ; $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( ref , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·look·in·the·java.lang·package$ $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( default_package $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( ref , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( isqualifiedname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . adapt ( typesolver . trytosolvetype ( name ) , $whitespace$ resolvedtypedeclaration . class ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. gettypes ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( ( classorinterfacedeclaration ) $whitespace$ type ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( ( classorinterfacedeclaration ) $whitespace$ type ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javaparserannotationdeclaration ( ( annotationdeclaration )			
solveMethod	262	301	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.0105143478140234	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    for (ImportDeclaration importDecl : wrappedNode.getImports()) {
		        if (importDecl.isStatic()) {
		            if (importDecl.isAsterisk()) {
		                String importString = importDecl.getNameAsString();
		                if (this.wrappedNode.getPackageDeclaration().isPresent() && this.wrappedNode.getPackageDeclaration().get().getName().getIdentifier().equals(packageName(importString)) && this.wrappedNode.getTypes().stream().anyMatch(it -> it.getName().getIdentifier().equals(toSimpleName(importString)))) {
		                    // We are using a static import on a type defined in this file. It means the value was not found at
		                    // a lower level so this will fail
		                    return SymbolReference.unsolved();
		                }
		                ResolvedTypeDeclaration ref = typeSolver.solveType(importString);
		                // avoid infinite recursion
		                if (!isAncestorOf(ref)) {
		                    SymbolReference<ResolvedMethodDeclaration> method = MethodResolutionLogic.solveMethodInType(ref, name, argumentsTypes, true);
		                    if (method.isSolved()) {
		                        return method;
		                    }
		                }
		            } else {
		                String qName = importDecl.getNameAsString();
		                if (qName.equals(name) || qName.endsWith(""."" + name)) {
		                    String typeName = getType(qName);
		                    ResolvedTypeDeclaration ref = typeSolver.solveType(typeName);
		                    SymbolReference<ResolvedMethodDeclaration> method = MethodResolutionLogic.solveMethodInType(ref, name, argumentsTypes, true);
		                    if (method.isSolved()) {
		                        return method;
		                    }
		                    return SymbolReference.unsolved();
		                }
		            }
		        }
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdecl $whitespace$ : $whitespace$ wrappednode . getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdecl . isstatic ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdecl . isasterisk ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ importstring $whitespace$ = $whitespace$ importdecl . getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getpackagedeclaration ( ) . ispresent ( ) $whitespace$ && $whitespace$ this . wrappednode . getpackagedeclaration ( ) . get ( ) . getname ( ) . getidentifier ( ) . equals ( packagename ( importstring ) ) $whitespace$ && $whitespace$ this . wrappednode . gettypes ( ) . stream ( ) . anymatch ( it $whitespace$ - > $whitespace$ it . getname ( ) . getidentifier ( ) . equals ( tosimplename ( importstring ) ) ) ) $whitespace$ { $newline$ $indentation$ $//·we·are·using·a·static·import·on·a·type·defined·in·this·file.·it·means·the·value·was·not·found·at$ $newline$ $indentation$ $//·a·lower·level·so·this·will·fail$ $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ ref $whitespace$ = $whitespace$ typesolver . solvetype ( importstring ) ; $newline$ $indentation$ $//·avoid·infinite·recursion$ $newline$ $indentation$ if $whitespace$ ( ! isancestorof ( ref ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ method $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ref , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ true ) ; $newline$ $indentation$ if $whitespace$ ( method . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ method ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ string $whitespace$ qname $whitespace$ = $whitespace$ importdecl . getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( qname . equals ( name ) $whitespace$ || $whitespace$ qname . endswith ( $string$ $whitespace$ + $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ gettype ( qname ) ; $newline$ $indentation$ resolvedtypedeclaration $whitespace$ ref $whitespace$ = $whitespace$ typesolver . solvetype ( typename ) ; $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ method $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ref , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ true ) ; $newline$ $indentation$ if $whitespace$ ( method . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ method ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ wrappednode. getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdeclaration. isstatic ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ importstring $whitespace$ = $whitespace$ importdeclaration. getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ ( this. wrappednode. getpackagedeclaration ( ). ispresent ( ) $whitespace$ && $whitespace$ this. wrappednode. getpackagedeclaration ( ). get ( ). getname ( ). getidentifier ( ). equals ( packagename ( importstring ) ) $whitespace$ && $whitespace$ this. wrappednode. gettypes ( ). stream ( ). anymatch ( it $whitespace$ - > $whitespace$ it. getname ( ). getidentifier ( ). equals ( tosimplename ( importstring ) ) ) ) $whitespace$ { $newline$ $indentation$ $//h$ we $whitespace$ - > $whitespace$ it. getname ( ). getidentifier ( ). equals ( tosimplename ( importstring ) ) ; $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypedeclaration $whitespace$ ref			
fieldsExposedToChild	303	319	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.0106219863519072	LOW	"		@Override
		public List<ResolvedFieldDeclaration> fieldsExposedToChild(Node child){
		    List<ResolvedFieldDeclaration> res = new LinkedList<>();
		    // Consider the static imports for static fields
		    for (ImportDeclaration importDeclaration : wrappedNode.getImports()) {
		        if (importDeclaration.isStatic()) {
		            Name typeNameAsNode = importDeclaration.isAsterisk() ? importDeclaration.getName() : importDeclaration.getName().getQualifier().get();
		            String typeName = typeNameAsNode.asString();
		            ResolvedReferenceTypeDeclaration typeDeclaration = typeSolver.solveType(typeName);
		            res.addAll(typeDeclaration.getAllFields().stream().filter(f -> f.isStatic()).filter(f -> importDeclaration.isAsterisk() || importDeclaration.getName().getIdentifier().equals(f.getName())).collect(Collectors.toList()));
		        }
		    }
		    return res;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ fieldsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $//·consider·the·static·imports·for·static·fields$ $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ wrappednode . getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdeclaration . isstatic ( ) ) $whitespace$ { $newline$ $indentation$ name $whitespace$ typenameasnode $whitespace$ = $whitespace$ importdeclaration . isasterisk ( ) $whitespace$ ? $whitespace$ importdeclaration . getname ( ) $whitespace$ : $whitespace$ importdeclaration . getname ( ) . getqualifier ( ) . get ( ) ; $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ typenameasnode . asstring ( ) ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( typename ) ; $newline$ $indentation$ res . addall ( typedeclaration . getallfields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . isstatic ( ) ) . filter ( f $whitespace$ - > $whitespace$ importdeclaration . isasterisk ( ) $whitespace$ || $whitespace$ importdeclaration . getname ( ) . getidentifier ( ) . equals ( f . getname ( ) ) ) . collect ( collectors . tolist ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ fieldsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $//////lation $newline$ $indentation$ for $whitespace$ ( importdeclaration $whitespace$ importdeclaration $whitespace$ : $whitespace$ wrappednode. getimports ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( importdeclaration. isstatic ( ) ) $whitespace$ { $newline$ $indentation$ name $whitespace$ typenameasnode $whitespace$ = $whitespace$ importdeclaration. isasterisk ( ) $whitespace$? $whitespace$ importdeclaration. getname ( ) $whitespace$ : $whitespace$ importdeclaration. getname ( ). getqualifier ( ). get ( ) ; $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ typenameasnode. asstring ( ) ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype ( typename ) ; $newline$ $indentation$ if $whitespace$ ( actionslist. size ( ) $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ val $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype ( typename ) ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return			
qName	235	240	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.638275146484375	MID	"		private String qName(ClassOrInterfaceType type){
		    if (type.getScope().isPresent()) {
		        return qName(type.getScope().get()) + ""."" + type.getName().getId();
		    }
		    return type.getName().getId();
		}"	$indentation$ private $whitespace$ string $whitespace$ qname ( classorinterfacetype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type . getscope ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qname ( type . getscope ( ) . get ( ) ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type . getname ( ) . getid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type . getname ( ) . getid ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ qname ( classorinterfacetype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type. getscope ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qname ( type. getscope ( ). get ( ) ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type. getname ( ). getid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type. getname ( ). getid ( ) ; $newline$ $indentation$ }			
getMember	334	341	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.6961545944213867	MID	"		private String getMember(String qName){
		    int index = qName.lastIndexOf('.');
		    if (index == -1) {
		        throw new UnsupportedOperationException();
		    }
		    String memberName = qName.substring(index + 1);
		    return memberName;
		}"	$indentation$ private $whitespace$ string $whitespace$ getmember ( string $whitespace$ qname ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ qname . lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ membername $whitespace$ = $whitespace$ qname . substring ( index $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ membername ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ getmember ( string $whitespace$ qname ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ qname. lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ membername $whitespace$ = $whitespace$ qname. substring ( index $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ return $whitespace$ membername ; $newline$ $indentation$ }			
getType	325	332	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/CompilationUnitContext.java	0.7338249087333679	MID	"		private String getType(String qName){
		    int index = qName.lastIndexOf('.');
		    if (index == -1) {
		        throw new UnsupportedOperationException();
		    }
		    String typeName = qName.substring(0, index);
		    return typeName;
		}"	$indentation$ private $whitespace$ string $whitespace$ gettype ( string $whitespace$ qname ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ qname . lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ qname . substring ( $number$ , $whitespace$ index ) ; $newline$ $indentation$ return $whitespace$ typename ; $newline$ $indentation$ }	$indentation$ private $whitespace$ string $whitespace$ gettype ( string $whitespace$ qname ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ qname. lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( index $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ qname. substring ( $number$, $whitespace$ index ) ; $newline$ $indentation$ return $whitespace$ typename ; $newline$ $indentation$ }			
solveMethodAsUsage	42	51	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ContextHelper.java	0.0372050628066062	LOW	"		public static Optional<MethodUsage> solveMethodAsUsage(ResolvedTypeDeclaration typeDeclaration, String name, List<ResolvedType> argumentsTypes, Context invokationContext, List<ResolvedType> typeParameters){
		    if (typeDeclaration instanceof MethodUsageResolutionCapability) {
		        return ((MethodUsageResolutionCapability) typeDeclaration).solveMethodAsUsage(name, argumentsTypes, invokationContext, typeParameters);
		    }
		    throw new UnsupportedOperationException(typeDeclaration.toString());
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( resolvedtypedeclaration $whitespace$ typedeclaration , $whitespace$ string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ methodusageresolutioncapability ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( methodusageresolutioncapability ) $whitespace$ typedeclaration ) . solvemethodasusage ( name , $whitespace$ argumentstypes , $whitespace$ invokationcontext , $whitespace$ typeparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( typedeclaration . tostring ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( resolvedtypedeclaration $whitespace$ typedeclaration, $whitespace$ string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ methodusageresolutioncapability ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( methodusageresolutioncapability ) $whitespace$ typedeclaration ). solvemethodasusage ( name, $whitespace$ argumentstypes, $whitespace$ invokationcontext, $whitespace$ typeparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( typedeclaration. tostring ( ) ) ; $newline$ $indentation$ }			
patternExprsExposedFromChildren	39	58	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/EnclosedExprContext.java	0.6106670498847961	MID	"		@Override
		public List<PatternExpr> patternExprsExposedFromChildren(){
		    List<PatternExpr> results = new ArrayList<>();
		    /*
		         * Test for an assignment expression
		         * Example:
		         *     while ((numChars = reader.read(buffer, 0, buffer.length)) > 0) {
		         *         result.append(buffer, 0, numChars);
		         *     }
		         */
		    if (!wrappedNode.getInner().isAssignExpr()) {
		        // Propagate any pattern expressions ""up"" without modification
		        Context innerContext = JavaParserFactory.getContext(wrappedNode.getInner(), typeSolver);
		        if (!this.equals(innerContext)) {
		            results = new ArrayList<>(innerContext.patternExprsExposedFromChildren());
		        }
		    }
		    return results;
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedfromchildren ( ) { $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $/*············*·test·for·an·assignment·expression············*·example:············*·····while·((numchars·=·reader.read(buffer,·0,·buffer.length))·>·0)·{············*·········result.append(buffer,·0,·numchars);············*·····}············*/$ $newline$ $indentation$ if $whitespace$ ( ! wrappednode . getinner ( ) . isassignexpr ( ) ) $whitespace$ { $newline$ $indentation$ $//·propagate·any·pattern·expressions·""up""·without·modification$ $newline$ $indentation$ context $whitespace$ innercontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( wrappednode . getinner ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( ! this . equals ( innercontext ) ) $whitespace$ { $newline$ $indentation$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( innercontext . patternexprsexposedfromchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedfromchildren ( ) { $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $/*ation$ method $whitespace$ parent $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $newline$ $indentation$ $whitespace$ e $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ (! wrappednode. getinner ( ). isassignexpr ( ) ) $whitespace$ { $newline$ $indentation$ $newline$ $indentation$ $whitespace$//4 $whitespace$ = $whitespace$ javaparserfactory. getcontext ( wrappednode. getinner ( ), $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ (! this. equals ( innercontext ) ) $whitespace$ { $newline$ $indentation$ results $whitespace$			
solveField	118	133	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java	0.0476663000881671	LOW	"		public SymbolReference<ResolvedValueDeclaration> solveField(String name){
		    Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(Optional.of(wrappedNode.getScope()));
		    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {
		        if (rrtd.isEnum()) {
		            Optional<ResolvedEnumConstantDeclaration> enumConstant = rrtd.asEnum().getEnumConstants().stream().filter(c -> c.getName().equals(name)).findFirst();
		            if (enumConstant.isPresent()) {
		                return SymbolReference.solved(enumConstant.get());
		            }
		        }
		        try {
		            return SymbolReference.solved(rrtd.getField(wrappedNode.getName().getId()));
		        } catch (Throwable t) {
		        }
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ public $whitespace$ symbolreference < resolvedvaluedeclaration > $whitespace$ solvefield ( string $whitespace$ name ) { $newline$ $indentation$ collection < resolvedreferencetypedeclaration > $whitespace$ rrtds $whitespace$ = $whitespace$ findtypedeclarations ( optional . of ( wrappednode . getscope ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetypedeclaration $whitespace$ rrtd $whitespace$ : $whitespace$ rrtds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rrtd . isenum ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedenumconstantdeclaration > $whitespace$ enumconstant $whitespace$ = $whitespace$ rrtd . asenum ( ) . getenumconstants ( ) . stream ( ) . filter ( c $whitespace$ - > $whitespace$ c . getname ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( enumconstant . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( enumconstant . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( rrtd . getfield ( wrappednode . getname ( ) . getid ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( throwable $whitespace$ t ) $whitespace$ { $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ symbolreference < resolvedvaluedeclaration > $whitespace$ solvefield ( string $whitespace$ name ) { $newline$ $indentation$ collection < resolvedreferencetypedeclaration > $whitespace$ rrtds $whitespace$ = $whitespace$ findtypedeclarations ( optional. of ( wrappednode. getscope ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetypedeclaration $whitespace$ rrtd $whitespace$ : $whitespace$ rrtds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rrtd. isenum ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( enumconstant. get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( rrtd. getfield ( wrappednode. getname ( ). getid ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( throwable $whitespace$ t ) $whitespace$ { $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ }			
solveSymbol	55	69	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java	0.1885365843772888	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name){
		    if (wrappedNode.getName().toString().equals(name)) {
		        if (wrappedNode.getScope() instanceof ThisExpr) {
		            ResolvedType typeOfThis = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);
		            if (typeOfThis.asReferenceType().getTypeDeclaration().isPresent()) {
		                return new SymbolSolver(typeSolver).solveSymbolInType(typeOfThis.asReferenceType().getTypeDeclaration().get(), name);
		            }
		        }
		    }
		    return JavaParserFactory.getContext(demandParentNode(wrappedNode), typeSolver).solveSymbol(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . getname ( ) . tostring ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wrappednode . getscope ( ) $whitespace$ instanceof $whitespace$ thisexpr ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ typeofthis $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettypeofthisin ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( typeofthis . asreferencetype ( ) . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvesymbolintype ( typeofthis . asreferencetype ( ) . gettypedeclaration ( ) . get ( ) , $whitespace$ name ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( demandparentnode ( wrappednode ) , $whitespace$ typesolver ) . solvesymbol ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. getname ( ). tostring ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ). solvesymbolintype ( typeofthis. asreferencetype ( ). gettypedeclaration ( ). get ( ), $whitespace$ name ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfactory. getcontext ( demandparentnode ( wrappednode ), $whitespace$ typesolver ). solvesymbol ( name ) ; $newline$ $indentation$ }			
solveSymbolAsValue	81	98	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/FieldAccessContext.java	0.2560971081256866	LOW	"		@Override
		public Optional<Value> solveSymbolAsValue(String name){
		    Expression scope = wrappedNode.getScope();
		    if (wrappedNode.getName().toString().equals(name)) {
		        ResolvedType typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);
		        if (typeOfScope.isArray() && ARRAY_LENGTH_FIELD_NAME.equals(name)) {
		            return Optional.of(new Value(ResolvedPrimitiveType.INT, ARRAY_LENGTH_FIELD_NAME));
		        }
		        if (typeOfScope.isReferenceType()) {
		            return solveSymbolAsValue(name, typeOfScope.asReferenceType());
		        }
		        if (typeOfScope.isConstraint()) {
		            return solveSymbolAsValue(name, typeOfScope.asConstraintType().getBound().asReferenceType());
		        }
		        return Optional.empty();
		    }
		    return solveSymbolAsValueInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ wrappednode . getscope ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappednode . getname ( ) . tostring ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ typeofscope $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettype ( scope ) ; $newline$ $indentation$ if $whitespace$ ( typeofscope . isarray ( ) $whitespace$ && $whitespace$ array_length_field_name . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ value ( resolvedprimitivetype . int , $whitespace$ array_length_field_name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolasvalue ( name , $whitespace$ typeofscope . asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope . isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolasvalue ( name , $whitespace$ typeofscope . asconstrainttype ( ) . getbound ( ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvesymbolasvalueinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ wrappednode. getscope ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappednode. getname ( ). tostring ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ typeofscope $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). gettype ( scope ) ; $newline$ $indentation$ if $whitespace$ ( typeofscope. isarray ( ) $whitespace$ && $whitespace$ array_length_field_name. equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ value ( resolvedprimitivetype. int, $whitespace$ array_length_field_name ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolasvalue ( name, $whitespace$ typeofscope. asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeofscope. isconstraint ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolasvalue ( name, $whitespace$ typeofscope. asconstrainttype ( ). getbound ( ). asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvesymbolasvalueinparentcontext ( name ) ; $newline$ $indentation$ }			
solveSymbol	46	59	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForEachStatementContext.java	0.1518395245075225	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name){
		    if (wrappedNode.getVariable().getVariables().size() != 1) {
		        throw new IllegalStateException();
		    }
		    VariableDeclarator variableDeclarator = wrappedNode.getVariable().getVariables().get(0);
		    if (variableDeclarator.getName().getId().equals(name)) {
		        return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator, typeSolver));
		    }
		    if (demandParentNode(wrappedNode) instanceof BlockStmt) {
		        return StatementContext.solveInBlock(name, typeSolver, wrappedNode);
		    }
		    return solveSymbolInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . getvariable ( ) . getvariables ( ) . size ( ) $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ wrappednode . getvariable ( ) . getvariables ( ) . get ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( variabledeclarator . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparsersymboldeclaration . localvar ( variabledeclarator , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ blockstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ statementcontext . solveinblock ( name , $whitespace$ typesolver , $whitespace$ wrappednode ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. getvariable ( ). getvariables ( ). size ( ) $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ wrappednode. getvariable ( ). getvariables ( ). get ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( variabledeclarator. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparsersymboldeclaration. localvar ( variabledeclarator, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ blockstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ statementcontext. solveinblock ( name, $whitespace$ typesolver, $whitespace$ wrappednode ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }			
solveMethod	61	65	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForEachStatementContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
solveMethod	68	72	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForStatementContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
solveSymbol	47	66	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/ForStatementContext.java	0.2856951653957367	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name){
		    for (Expression expression : wrappedNode.getInitialization()) {
		        if (expression instanceof VariableDeclarationExpr) {
		            VariableDeclarationExpr variableDeclarationExpr = (VariableDeclarationExpr) expression;
		            for (VariableDeclarator variableDeclarator : variableDeclarationExpr.getVariables()) {
		                if (variableDeclarator.getName().getId().equals(name)) {
		                    return SymbolReference.solved(JavaParserSymbolDeclaration.localVar(variableDeclarator, typeSolver));
		                }
		            }
		        } else if (!(expression instanceof AssignExpr || expression instanceof MethodCallExpr || expression instanceof UnaryExpr)) {
		            throw new UnsupportedOperationException(expression.getClass().getCanonicalName());
		        }
		    }
		    if (demandParentNode(wrappedNode) instanceof NodeWithStatements) {
		        return StatementContext.solveInBlock(name, typeSolver, wrappedNode);
		    }
		    return solveSymbolInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ expression $whitespace$ : $whitespace$ wrappednode . getinitialization ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ variabledeclarationexpr $whitespace$ variabledeclarationexpr $whitespace$ = $whitespace$ ( variabledeclarationexpr ) $whitespace$ expression ; $newline$ $indentation$ for $whitespace$ ( variabledeclarator $whitespace$ variabledeclarator $whitespace$ : $whitespace$ variabledeclarationexpr . getvariables ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( variabledeclarator . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparsersymboldeclaration . localvar ( variabledeclarator , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( ! ( expression $whitespace$ instanceof $whitespace$ assignexpr $whitespace$ || $whitespace$ expression $whitespace$ instanceof $whitespace$ methodcallexpr $whitespace$ || $whitespace$ expression $whitespace$ instanceof $whitespace$ unaryexpr ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( expression . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ nodewithstatements ) $whitespace$ { $newline$ $indentation$ return $whitespace$ statementcontext . solveinblock ( name , $whitespace$ typesolver , $whitespace$ wrappednode ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ expression $whitespace$ : $whitespace$ wrappednode. getinitialization ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expression $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ variabledeclarationexpr $whitespace$ variabledeclarationexpr $whitespace$ = $whitespace$ ( variabledeclarationexpr ) $whitespace$ expression ; $newline$ $indentation$ for $whitespace$ ( variabledeclarator $whitespace$ variabledeclarator $whitespace$ : $whitespace$ variabledeclarationexpr. getvariables ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( variabledeclarator. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparsersymboldeclaration. localvar ( variabledeclarator, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ (! ( expression $whitespace$ instanceof $whitespace$ assignexpr $whitespace$ || $whitespace$ expression $whitespace$ instanceof $whitespace$ methodcallexpr $whitespace$ || $whitespace$ expression $whitespace$ instanceof $whitespace$ unaryexpr ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( expression. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ nodewithstatements )			
nodeContextIsChainedIfElseIf	78	82	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java	0.0545690469443798	LOW	"		public boolean nodeContextIsChainedIfElseIf(Context parentContext){
		    return parentContext instanceof AbstractJavaParserContext && ((AbstractJavaParserContext<?>) this).getWrappedNode() instanceof IfStmt && ((AbstractJavaParserContext<?>) parentContext).getWrappedNode() instanceof IfStmt;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextischainedifelseif ( context $whitespace$ parentcontext ) { $newline$ $indentation$ return $whitespace$ parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext $whitespace$ && $whitespace$ ( ( abstractjavaparsercontext < ? > ) $whitespace$ this ) . getwrappednode ( ) $whitespace$ instanceof $whitespace$ ifstmt $whitespace$ && $whitespace$ ( ( abstractjavaparsercontext < ? > ) $whitespace$ parentcontext ) . getwrappednode ( ) $whitespace$ instanceof $whitespace$ ifstmt ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextischainedifelseif ( context $whitespace$ parentcontext ) { $newline$ $indentation$ return $whitespace$ parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext $whitespace$ && $whitespace$ ( ( abstractjavaparsercontext <? > ) $whitespace$ this ). getwrappednode ( ) $whitespace$ instanceof $whitespace$ ifstmt $whitespace$ && $whitespace$ ( ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ). getwrappednode ( ) $whitespace$ instanceof $whitespace$ ifstmt ; $newline$ $indentation$ }			
nodeContextIsConditionOfIfStmt	159	182	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java	0.2094415575265884	LOW	"		public boolean nodeContextIsConditionOfIfStmt(Context parentContext){
		    if (!(parentContext instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    if (!(this instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    AbstractJavaParserContext<?> abstractContext = (AbstractJavaParserContext<?>) this;
		    AbstractJavaParserContext<?> abstractParentContext = (AbstractJavaParserContext<?>) parentContext;
		    Node wrappedNode = abstractContext.getWrappedNode();
		    Node wrappedParentNode = abstractParentContext.getWrappedNode();
		    if (wrappedParentNode instanceof IfStmt) {
		        IfStmt parentIfStmt = (IfStmt) wrappedParentNode;
		        boolean currentNodeIsCondition = parentIfStmt.getCondition() == wrappedNode;
		        if (currentNodeIsCondition) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisconditionofifstmt ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ ( ! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ parentcontext ; $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ abstractcontext . getwrappednode ( ) ; $newline$ $indentation$ node $whitespace$ wrappedparentnode $whitespace$ = $whitespace$ abstractparentcontext . getwrappednode ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ ifstmt $whitespace$ parentifstmt $whitespace$ = $whitespace$ ( ifstmt ) $whitespace$ wrappedparentnode ; $newline$ $indentation$ boolean $whitespace$ currentnodeiscondition $whitespace$ = $whitespace$ parentifstmt . getcondition ( ) $whitespace$ == $whitespace$ wrappednode ; $newline$ $indentation$ if $whitespace$ ( currentnodeiscondition ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisconditionofifstmt ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ (! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$			
nodeContextIsThenOfIfStmt	133	156	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java	0.2268360257148742	LOW	"		public boolean nodeContextIsThenOfIfStmt(Context parentContext){
		    if (!(parentContext instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    if (!(this instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    AbstractJavaParserContext<?> abstractContext = (AbstractJavaParserContext<?>) this;
		    AbstractJavaParserContext<?> abstractParentContext = (AbstractJavaParserContext<?>) parentContext;
		    Node wrappedNode = abstractContext.getWrappedNode();
		    Node wrappedParentNode = abstractParentContext.getWrappedNode();
		    if (wrappedParentNode instanceof IfStmt) {
		        IfStmt parentIfStmt = (IfStmt) wrappedParentNode;
		        boolean currentNodeIsAnElseBlock = parentIfStmt.getThenStmt() == wrappedNode;
		        if (currentNodeIsAnElseBlock) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisthenofifstmt ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ ( ! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ parentcontext ; $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ abstractcontext . getwrappednode ( ) ; $newline$ $indentation$ node $whitespace$ wrappedparentnode $whitespace$ = $whitespace$ abstractparentcontext . getwrappednode ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ ifstmt $whitespace$ parentifstmt $whitespace$ = $whitespace$ ( ifstmt ) $whitespace$ wrappedparentnode ; $newline$ $indentation$ boolean $whitespace$ currentnodeisanelseblock $whitespace$ = $whitespace$ parentifstmt . getthenstmt ( ) $whitespace$ == $whitespace$ wrappednode ; $newline$ $indentation$ if $whitespace$ ( currentnodeisanelseblock ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisthenofifstmt ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ (! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ abstractparentcontext. getwrappednode ( ) ; $newline$ $indentation$ node $whitespace$ wrappedparentnode $whitespace$ = $whitespace$ abstractparentcontext. getwrappednode ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ node $whitespace$ wrappedparentnode $whitespace$ = $whitespace$ abstractparentcontext. getwrappednode ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation			
patternExprsExposedToChild	42	62	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java	0.272726833820343	LOW	"		@Override
		public List<PatternExpr> patternExprsExposedToChild(Node child){
		    Expression condition = wrappedNode.getCondition();
		    Context conditionContext = JavaParserFactory.getContext(condition, typeSolver);
		    List<PatternExpr> results = new ArrayList<>();
		    boolean givenNodeIsWithinThenStatement = wrappedNode.getThenStmt().containsWithinRange(child);
		    if (givenNodeIsWithinThenStatement) {
		        results.addAll(conditionContext.patternExprsExposedFromChildren());
		    }
		    wrappedNode.getElseStmt().ifPresent(elseStatement -> {
		        boolean givenNodeIsWithinElseStatement = elseStatement.containsWithinRange(child);
		        if (givenNodeIsWithinElseStatement) {
		            results.addAll(conditionContext.negatedPatternExprsExposedFromChildren());
		        }
		    });
		    return results;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ expression $whitespace$ condition $whitespace$ = $whitespace$ wrappednode . getcondition ( ) ; $newline$ $indentation$ context $whitespace$ conditioncontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( condition , $whitespace$ typesolver ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ boolean $whitespace$ givennodeiswithinthenstatement $whitespace$ = $whitespace$ wrappednode . getthenstmt ( ) . containswithinrange ( child ) ; $newline$ $indentation$ if $whitespace$ ( givennodeiswithinthenstatement ) $whitespace$ { $newline$ $indentation$ results . addall ( conditioncontext . patternexprsexposedfromchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ wrappednode . getelsestmt ( ) . ifpresent ( elsestatement $whitespace$ - > $whitespace$ { $newline$ $indentation$ boolean $whitespace$ givennodeiswithinelsestatement $whitespace$ = $whitespace$ elsestatement . containswithinrange ( child ) ; $newline$ $indentation$ if $whitespace$ ( givennodeiswithinelsestatement ) $whitespace$ { $newline$ $indentation$ results . addall ( conditioncontext . negatedpatternexprsexposedfromchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ patternexprsexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ expression $whitespace$ condition $whitespace$ = $whitespace$ wrappednode. getcondition ( ) ; $newline$ $indentation$ context $whitespace$ conditioncontext $whitespace$ = $whitespace$ javaparserfactory. getcontext ( condition, $whitespace$ typesolver ) ; $newline$ $indentation$ list < patternexpr > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ boolean $whitespace$ givennodeiswithinthenstatement $whitespace$ = $whitespace$ wrappednode. getthenstmt ( ). containswithinrange ( child ) ; $newline$ $indentation$ if $whitespace$ ( givennodeiswithinthenstatement ) $whitespace$ { $newline$ $indentation$ results. addall ( conditioncontext. patternexprsexposedfromchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ wrappednode. getelsestmt ( ). ifpresent ( elsestatement $whitespace$ - > $whitespace$ { $newline$ $indentation$ boolean $whitespace$ givennodeiswithinelsestatement $whitespace$ = $whitespace$ elsestatement. containswithinrange ( child ) ; $newline$ $indentation$ if $whitespace$ ( givennodeiswithinelsestatement ) $whitespace$ { $newline$ $indentation$ results. addall ( conditioncontext.特patternexprsexposedfromchildren ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }			
nodeContextIsImmediateChildElse	95	120	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/IfStatementContext.java	0.2867820262908935	LOW	"		public boolean nodeContextIsImmediateChildElse(Context parentContext){
		    if (!(parentContext instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    if (!(this instanceof AbstractJavaParserContext)) {
		        return false;
		    }
		    AbstractJavaParserContext<?> abstractContext = (AbstractJavaParserContext<?>) this;
		    AbstractJavaParserContext<?> abstractParentContext = (AbstractJavaParserContext<?>) parentContext;
		    Node wrappedNode = abstractContext.getWrappedNode();
		    Node wrappedParentNode = abstractParentContext.getWrappedNode();
		    if (wrappedParentNode instanceof IfStmt) {
		        IfStmt parentIfStmt = (IfStmt) wrappedParentNode;
		        if (parentIfStmt.getElseStmt().isPresent()) {
		            boolean currentNodeIsAnElseBlock = parentIfStmt.getElseStmt().get() == wrappedNode;
		            if (currentNodeIsAnElseBlock) {
		                return true;
		            }
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisimmediatechildelse ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ ( ! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext < ? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext < ? > ) $whitespace$ parentcontext ; $newline$ $indentation$ node $whitespace$ wrappednode $whitespace$ = $whitespace$ abstractcontext . getwrappednode ( ) ; $newline$ $indentation$ node $whitespace$ wrappedparentnode $whitespace$ = $whitespace$ abstractparentcontext . getwrappednode ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ ifstmt $whitespace$ parentifstmt $whitespace$ = $whitespace$ ( ifstmt ) $whitespace$ wrappedparentnode ; $newline$ $indentation$ if $whitespace$ ( parentifstmt . getelsestmt ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ currentnodeisanelseblock $whitespace$ = $whitespace$ parentifstmt . getelsestmt ( ) . get ( ) $whitespace$ == $whitespace$ wrappednode ; $newline$ $indentation$ if $whitespace$ ( currentnodeisanelseblock ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ nodecontextisimmediatechildelse ( context $whitespace$ parentcontext ) { $newline$ $indentation$ if $whitespace$ (! ( parentcontext $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( this $whitespace$ instanceof $whitespace$ abstractjavaparsercontext ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ this ; $newline$ $indentation$ abstractjavaparsercontext <? > $whitespace$ abstractparentcontext $whitespace$ = $whitespace$ ( abstractjavaparsercontext <? > ) $whitespace$ parentcontext ; $newline$ $indentation$ if $whitespace$ ( wrappedparentnode $whitespace$ instanceof $whitespace$ ifstmt ) $whitespace$ { $newline$ $indentation$ ifstmt $whitespace$ parentifstmt $whitespace$ = $whitespace$ ( ifstmt ) $whitespace$ wrappedparentnode ; $newline$ $indentation$ if $whitespace$ ( parentifstmt. getelsestmt ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ currentnodeisanelseblock $whitespace$ = $whitespace$ parentifstmt. getelsestmt ( ). get ( ) $whitespace$ == $whitespace$ wrappednode ; $newline$ $indentation$ if $whitespace$ ( currentnodeisanelseblock ) $whitespace$ { $newline$ $indentation$			
solveSymbol	45	73	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/InstanceOfExprContext.java	0.2873187661170959	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name){
		    Optional<PatternExpr> optionalPatternExpr = wrappedNode.getPattern();
		    if (optionalPatternExpr.isPresent()) {
		        if (optionalPatternExpr.get().getNameAsString().equals(name)) {
		            JavaParserPatternDeclaration decl = JavaParserSymbolDeclaration.patternVar(optionalPatternExpr.get(), typeSolver);
		            return SymbolReference.solved(decl);
		        }
		    }
		    Optional<Context> optionalParentContext = getParent();
		    if (!optionalParentContext.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    Context parentContext = optionalParentContext.get();
		    if (parentContext instanceof BinaryExprContext) {
		        Optional<PatternExpr> optionalPatternExpr1 = parentContext.patternExprInScope(name);
		        if (optionalPatternExpr1.isPresent()) {
		            JavaParserPatternDeclaration decl = JavaParserSymbolDeclaration.patternVar(optionalPatternExpr1.get(), typeSolver);
		            return SymbolReference.solved(decl);
		        }
		    }
		    // TODO: Also consider unary expr context
		    // if nothing is found we should ask the parent context
		    return solveSymbolInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ optional < patternexpr > $whitespace$ optionalpatternexpr $whitespace$ = $whitespace$ wrappednode . getpattern ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr . get ( ) . getnameasstring ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ javaparsersymboldeclaration . patternvar ( optionalpatternexpr . get ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ symbolreference . solved ( decl ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ optional < context > $whitespace$ optionalparentcontext $whitespace$ = $whitespace$ getparent ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentcontext . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ optionalparentcontext . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parentcontext $whitespace$ instanceof $whitespace$ binaryexprcontext ) $whitespace$ { $newline$ $indentation$ optional < patternexpr > $whitespace$ optionalpatternexpr1 $whitespace$ = $whitespace$ parentcontext . patternexprinscope ( name ) ; $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr1 . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ javaparsersymboldeclaration . patternvar ( optionalpatternexpr1 . get ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ symbolreference . solved ( decl ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo:·also·consider·unary·expr·context$ $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·parent·context$ $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name ) { $newline$ $indentation$ optional < patternexpr > $whitespace$ optionalpatternexpr $whitespace$ = $whitespace$ wrappednode. getpattern ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optionalpatternexpr. get ( ). getnameasstring ( ). equals ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr. get ( ). getnameasstring ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ javaparsersymboldeclaration. patternvar ( optionalpatternexpr. get ( ), $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( optionalpatternexpr1. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ javaparserpatterndeclaration $whitespace$ decl $whitespace$ = $whitespace$ optionalparentcontext. get ( ) ;			
solveType	78	150	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java	0.0033149861264973	LOW	"		public SymbolReference<ResolvedTypeDeclaration> solveType(String name, List<ResolvedType> typeArguments){
		    if (this.wrappedNode.getName().getId().equals(name)) {
		        return SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(wrappedNode));
		    }
		    // Internal classes
		    for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {
		        if (member.isTypeDeclaration()) {
		            TypeDeclaration<?> internalType = member.asTypeDeclaration();
		            if (internalType.getName().getId().equals(name) && compareTypeParameters(internalType, typeArguments)) {
		                return SymbolReference.solved(JavaParserFacade.get(typeSolver).getTypeDeclaration(internalType));
		            }
		            if (name.startsWith(wrappedNode.getName().getId() + ""."" + internalType.getName().getId())) {
		                return JavaParserFactory.getContext(internalType, typeSolver).solveType(name.substring(wrappedNode.getName().getId().length() + 1), typeArguments);
		            }
		            if (name.startsWith(internalType.getName().getId() + ""."")) {
		                return JavaParserFactory.getContext(internalType, typeSolver).solveType(name.substring(internalType.getName().getId().length() + 1), typeArguments);
		            }
		        }
		    }
		    // Before checking the ancestors of the node,
		    // it is necessary to check that the name to be resolved is not declared in the compilation unit.
		    // An example is provided in the issue https://github.com/javaparser/javaparser/issues/3214
		    SymbolReference<ResolvedTypeDeclaration> symbolRef = context.getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(name, typeArguments);
		    if (symbolRef.isSolved())
		        return symbolRef;
		    // Check if is a type parameter
		    if (wrappedNode instanceof NodeWithTypeParameters) {
		        NodeWithTypeParameters<?> nodeWithTypeParameters = (NodeWithTypeParameters<?>) wrappedNode;
		        for (TypeParameter astTpRaw : nodeWithTypeParameters.getTypeParameters()) {
		            if (astTpRaw.getName().getId().equals(name)) {
		                return SymbolReference.solved(new JavaParserTypeParameter(astTpRaw, typeSolver));
		            }
		        }
		    }
		    // Check if the node implements other types
		    if (wrappedNode instanceof NodeWithImplements) {
		        NodeWithImplements<?> nodeWithImplements = (NodeWithImplements<?>) wrappedNode;
		        for (ClassOrInterfaceType implementedType : nodeWithImplements.getImplementedTypes()) {
		            if (implementedType.getName().getId().equals(name)) {
		                return context.getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(implementedType.getNameWithScope(), typeArguments);
		            }
		        }
		    }
		    // Check if the node extends other types
		    if (wrappedNode instanceof NodeWithExtends) {
		        NodeWithExtends<?> nodeWithExtends = (NodeWithExtends<?>) wrappedNode;
		        for (ClassOrInterfaceType extendedType : nodeWithExtends.getExtendedTypes()) {
		            if (extendedType.getName().getId().equals(name) && compareTypeArguments(extendedType, typeArguments)) {
		                return context.getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(extendedType.getNameWithScope(), typeArguments);
		            }
		        }
		    }
		    // Looking at extended classes and implemented interfaces
		    String typeName = isCompositeName(name) ? innerMostPartOfName(name) : name;
		    ResolvedTypeDeclaration type = checkAncestorsForType(typeName, this.typeDeclaration);
		    if (type != null) {
		        return SymbolReference.solved(type);
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( typesolver ) . gettypedeclaration ( wrappednode ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·internal·classes$ $newline$ $indentation$ for $whitespace$ ( bodydeclaration < ? > $whitespace$ member $whitespace$ : $whitespace$ this . wrappednode . getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member . istypedeclaration ( ) ) $whitespace$ { $newline$ $indentation$ typedeclaration < ? > $whitespace$ internaltype $whitespace$ = $whitespace$ member . astypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( internaltype . getname ( ) . getid ( ) . equals ( name ) $whitespace$ && $whitespace$ comparetypeparameters ( internaltype , $whitespace$ typearguments ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( typesolver ) . gettypedeclaration ( internaltype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . startswith ( wrappednode . getname ( ) . getid ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ internaltype . getname ( ) . getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( internaltype , $whitespace$ typesolver ) . solvetype ( name . substring ( wrappednode . getname ( ) . getid ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) , $whitespace$ typearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . startswith ( internaltype . getname ( ) . getid ( ) $whitespace$ + $whitespace$ $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( internaltype , $whitespace$ typesolver ) . solvetype ( name . substring ( internaltype . getname ( ) . getid ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) , $whitespace$ typearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·before·checking·the·ancestors·of·the·node,$ $newline$ $indentation$ $//·it·is·necessary·to·check·that·the·name·to·be·resolved·is·not·declared·in·the·compilation·unit.$ $newline$ $indentation$ $//·an·example·is·provided·in·the·issue·https://github.com/javaparser/javaparser/issues/3214$ $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ symbolref $whitespace$ = $whitespace$ context . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( name , $whitespace$ typearguments ) ; $newline$ $indentation$ if $whitespace$ ( symbolref . issolved ( ) ) $newline$ $indentation$ return $whitespace$ symbolref ; $newline$ $indentation$ $//·check·if·is·a·type·parameter$ $newline$ $indentation$ if $whitespace$ ( wrappednode $whitespace$ instanceof $whitespace$ nodewithtypeparameters ) $whitespace$ { $newline$ $indentation$ nodewithtypeparameters < ? > $whitespace$ nodewithtypeparameters $whitespace$ = $whitespace$ ( nodewithtypeparameters < ? > ) $whitespace$ wrappednode ; $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ asttpraw $whitespace$ : $whitespace$ nodewithtypeparameters . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( asttpraw . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparsertypeparameter ( asttpraw , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·check·if·the·node·implements·other·types$ $newline$ $indentation$ if $whitespace$ ( wrappednode $whitespace$ instanceof $whitespace$ nodewithimplements ) $whitespace$ { $newline$ $indentation$ nodewithimplements < ? > $whitespace$ nodewithimplements $whitespace$ = $whitespace$ ( nodewithimplements < ? > ) $whitespace$ wrappednode ; $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ implementedtype $whitespace$ : $whitespace$ nodewithimplements . getimplementedtypes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( implementedtype . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ context . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( implementedtype . getnamewithscope ( ) , $whitespace$ typearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·check·if·the·node·extends·other·types$ $newline$ $indentation$ if $whitespace$ ( wrappednode $whitespace$ instanceof $whitespace$ nodewithextends ) $whitespace$ { $newline$ $indentation$ nodewithextends < ? > $whitespace$ nodewithextends $whitespace$ = $whitespace$ ( nodewithextends < ? > ) $whitespace$ wrappednode ; $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ extendedtype $whitespace$ : $whitespace$ nodewithextends . getextendedtypes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( extendedtype . getname ( ) . getid ( ) . equals ( name ) $whitespace$ && $whitespace$ comparetypearguments ( extendedtype , $whitespace$ typearguments ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ context . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( extendedtype . getnamewithscope ( ) , $whitespace$ typearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·looking·at·extended·classes·and·implemented·interfaces$ $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ iscompositename ( name ) $whitespace$ ? $whitespace$ innermostpartofname ( name ) $whitespace$ : $whitespace$ name ; $newline$ $indentation$ resolvedtypedeclaration $whitespace$ type $whitespace$ = $whitespace$ checkancestorsfortype ( typename , $whitespace$ this . typedeclaration ) ; $newline$ $indentation$ if $whitespace$ ( type $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( type ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ typearguments ) { $newline$ $indentation$ if $whitespace$ ( this. wrappednode. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( wrappednode ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////internal $whitespace$ $newline$ $indentation$ for $whitespace$ ( bodydeclaration <? > $whitespace$ member $whitespace$ : $whitespace$ this. wrappednode. getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member. istypedeclaration ( ) ) $whitespace$ { $newline$ $indentation$ typedeclaration <? > $whitespace$ internaltype $whitespace$ = $whitespace$ member. astypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( internaltype. getname ( ). getid ( ). equals ( name ) $whitespace$ && $whitespace$ comparetypeparameters ( internaltype, $whitespace$ typearguments ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javaparserfacade. get ( typesolver ). gettypedeclaration ( internaltype ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name. startswith ( wrappednode. getname ( ). getid ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ internaltype. getname ( ). getid ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ javaparserfactory. getcontext ( internaltype, $whitespace$ typesolver ). solvetype ( name. substring ( wrappednode. getname ( ). getid (			
solveMethod	232	286	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java	0.0067664678208529	LOW	"		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // Begin by locating methods declared ""here""
		    List<ResolvedMethodDeclaration> candidateMethods = typeDeclaration.getDeclaredMethods().stream().filter(m -> m.getName().equals(name)).filter(m -> !staticOnly || m.isStatic()).collect(Collectors.toList());
		    // Next, consider methods declared within ancestors.
		    // Note that we only consider ancestors when we are not currently at java.lang.Object (avoiding infinite recursion).
		    if (!typeDeclaration.isJavaLangObject()) {
		        for (ResolvedReferenceType ancestor : typeDeclaration.getAncestors(true)) {
		            Optional<ResolvedReferenceTypeDeclaration> ancestorTypeDeclaration = ancestor.getTypeDeclaration();
		            // Avoid recursion on self
		            if (ancestor.getTypeDeclaration().isPresent() && typeDeclaration != ancestorTypeDeclaration.get()) {
		                // Consider methods declared on self
		                candidateMethods.addAll(ancestor.getAllMethodsVisibleToInheritors().stream().filter(m -> m.getName().equals(name)).collect(Collectors.toList()));
		                // consider methods from superclasses and only default methods from interfaces :
		                // not true, we should keep abstract as a valid candidate
		                // abstract are removed in MethodResolutionLogic.isApplicable is necessary
		                SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(ancestorTypeDeclaration.get(), name, argumentsTypes, staticOnly);
		                if (res.isSolved()) {
		                    candidateMethods.add(res.getCorrespondingDeclaration());
		                }
		            }
		        }
		    }
		    // If we haven't located any candidates that are declared on this type or its ancestors, consider the parent context.
		    // This is relevant e.g. with nested classes.
		    // Note that we want to avoid infinite recursion when a class is using its own method - see issue #75
		    if (candidateMethods.isEmpty()) {
		        SymbolReference<ResolvedMethodDeclaration> parentSolution = context.getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveMethod(name, argumentsTypes, staticOnly);
		        if (parentSolution.isSolved()) {
		            candidateMethods.add(parentSolution.getCorrespondingDeclaration());
		        }
		    }
		    // if is interface and candidate method list is empty, we should check the Object Methods
		    if (candidateMethods.isEmpty() && typeDeclaration.isInterface()) {
		        SymbolReference<ResolvedMethodDeclaration> res = MethodResolutionLogic.solveMethodInType(typeSolver.getSolvedJavaLangObject(), name, argumentsTypes, false);
		        if (res.isSolved()) {
		            candidateMethods.add(res.getCorrespondingDeclaration());
		        }
		    }
		    return MethodResolutionLogic.findMostApplicable(candidateMethods, name, argumentsTypes, typeSolver);
		}"	"$indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·begin·by·locating·methods·declared·""here""$ $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatemethods $whitespace$ = $whitespace$ typedeclaration . getdeclaredmethods ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( name ) ) . filter ( m $whitespace$ - > $whitespace$ ! staticonly $whitespace$ || $whitespace$ m . isstatic ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·next,·consider·methods·declared·within·ancestors.$ $newline$ $indentation$ $//·note·that·we·only·consider·ancestors·when·we·are·not·currently·at·java.lang.object·(avoiding·infinite·recursion).$ $newline$ $indentation$ if $whitespace$ ( ! typedeclaration . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration . getancestors ( true ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ ancestortypedeclaration $whitespace$ = $whitespace$ ancestor . gettypedeclaration ( ) ; $newline$ $indentation$ $//·avoid·recursion·on·self$ $newline$ $indentation$ if $whitespace$ ( ancestor . gettypedeclaration ( ) . ispresent ( ) $whitespace$ && $whitespace$ typedeclaration $whitespace$ != $whitespace$ ancestortypedeclaration . get ( ) ) $whitespace$ { $newline$ $indentation$ $//·consider·methods·declared·on·self$ $newline$ $indentation$ candidatemethods . addall ( ancestor . getallmethodsvisibletoinheritors ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( name ) ) . collect ( collectors . tolist ( ) ) ) ; $newline$ $indentation$ $//·consider·methods·from·superclasses·and·only·default·methods·from·interfaces·:$ $newline$ $indentation$ $//·not·true,·we·should·keep·abstract·as·a·valid·candidate$ $newline$ $indentation$ $//·abstract·are·removed·in·methodresolutionlogic.isapplicable·is·necessary$ $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ancestortypedeclaration . get ( ) , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( res . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·we·haven't·located·any·candidates·that·are·declared·on·this·type·or·its·ancestors,·consider·the·parent·context.$ $newline$ $indentation$ $//·this·is·relevant·e.g.·with·nested·classes.$ $newline$ $indentation$ $//·note·that·we·want·to·avoid·infinite·recursion·when·a·class·is·using·its·own·method·-·see·issue·#75$ $newline$ $indentation$ if $whitespace$ ( candidatemethods . isempty ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ parentsolution $whitespace$ = $whitespace$ context . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( parentsolution . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( parentsolution . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·is·interface·and·candidate·method·list·is·empty,·we·should·check·the·object·methods$ $newline$ $indentation$ if $whitespace$ ( candidatemethods . isempty ( ) $whitespace$ && $whitespace$ typedeclaration . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ res $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( typesolver . getsolvedjavalangobject ( ) , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( res . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatemethods . add ( res . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicable ( candidatemethods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//ascii $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatemethods $whitespace$ = $whitespace$ typedeclaration. getdeclaredmethods ( ). stream ( ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$ m. getname ( ). equals ( name ) ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$! staticonly $whitespace$ || $whitespace$ m. isstatic ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ // $whitespace$ ---------- $whitespace$ experiment: $whitespace$ return $whitespace$ typedeclaration $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatemethods $whitespace$ = $whitespace$ typedeclaration. getdeclaredmethods ( ). stream ( ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$! typedeclaration. getancestors ( true ) ) $newline$ $indentation$. filter ( m $whitespace$ - > $whitespace$! staticonly $whitespace$ || $whitespace$ m. isstatic ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ // $whitespace$ ---------- $whitespace$ experiment: $whitespace$ return $whitespace$ typedeclaration $newline$ $indentation$ if $whitespace$ (! typedeclaration. isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration. getancestors ( true ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetype			
compareTypeParameters	183	188	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java	0.2179490178823471	LOW	"		private boolean compareTypeParameters(TypeDeclaration<?> typeDeclaration, List<ResolvedType> resolvedTypeArguments){
		    if (typeDeclaration instanceof NodeWithTypeParameters) {
		        return compareTypeParameters((NodeWithTypeParameters<?>) typeDeclaration, resolvedTypeArguments);
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ comparetypeparameters ( typedeclaration < ? > $whitespace$ typedeclaration , $whitespace$ list < resolvedtype > $whitespace$ resolvedtypearguments ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ nodewithtypeparameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ comparetypeparameters ( ( nodewithtypeparameters < ? > ) $whitespace$ typedeclaration , $whitespace$ resolvedtypearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ comparetypeparameters ( typedeclaration <? > $whitespace$ typedeclaration, $whitespace$ list < resolvedtype > $whitespace$ resolvedtypearguments ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ nodewithtypeparameters ) $whitespace$ { $newline$ $indentation$ return $whitespace$ comparetypeparameters ( ( nodewithtypeparameters <? > ) $whitespace$ typedeclaration, $whitespace$ resolvedtypearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
solveConstructor	288	293	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java	0.233495220541954	LOW	"		public SymbolReference<ResolvedConstructorDeclaration> solveConstructor(List<ResolvedType> argumentsTypes){
		    if (typeDeclaration instanceof ResolvedClassDeclaration) {
		        return ConstructorResolutionLogic.findMostApplicable(typeDeclaration.getConstructors(), argumentsTypes, typeSolver);
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ public $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ solveconstructor ( list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ resolvedclassdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ constructorresolutionlogic . findmostapplicable ( typedeclaration . getconstructors ( ) , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ symbolreference < resolvedconstructordeclaration > $whitespace$ solveconstructor ( list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ if $whitespace$ ( typedeclaration $whitespace$ instanceof $whitespace$ resolvedclassdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ constructorresolutionlogic. findmostapplicable ( typedeclaration. getconstructors ( ), $whitespace$ argumentstypes, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ }			
compareTypes	164	172	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/JavaParserTypeDeclarationAdapter.java	0.6163055896759033	MID	"		private boolean compareTypes(List<? extends Type> types, List<ResolvedType> resolvedTypeArguments){
		    // If the user want's to solve the type without having prior knowledge of the type arguments.
		    if (resolvedTypeArguments == null) {
		        return true;
		    }
		    return types.size() == resolvedTypeArguments.size();
		}"	$indentation$ private $whitespace$ boolean $whitespace$ comparetypes ( list < ? $whitespace$ extends $whitespace$ type > $whitespace$ types , $whitespace$ list < resolvedtype > $whitespace$ resolvedtypearguments ) { $newline$ $indentation$ $//·if·the·user·want's·to·solve·the·type·without·having·prior·knowledge·of·the·type·arguments.$ $newline$ $indentation$ if $whitespace$ ( resolvedtypearguments $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ types . size ( ) $whitespace$ == $whitespace$ resolvedtypearguments . size ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ comparetypes ( list <? $whitespace$ extends $whitespace$ type > $whitespace$ types, $whitespace$ list < resolvedtype > $whitespace$ resolvedtypearguments ) { $newline$ $indentation$ $//asciiasciiascii $if $whitespace$ if $whitespace$ ( resolvedtypearguments $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ types. size ( ) $whitespace$ == $whitespace$ resolvedtypearguments. size ( ) ; $newline$ $indentation$ }			
solveSymbolAsValue	63	205	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java	1.858095311035868e-05	LOW	"		@Override
		public Optional<Value> solveSymbolAsValue(String name){
		    int index = -1;
		    for (Parameter parameter : wrappedNode.getParameters()) {
		        index++;
		        SymbolDeclarator sb = JavaParserFactory.getSymbolDeclarator(parameter, typeSolver);
		        for (ResolvedValueDeclaration decl : sb.getSymbolDeclarations()) {
		            if (decl.getName().equals(name)) {
		                Node parentNode = demandParentNode(wrappedNode, IS_NOT_ENCLOSED_EXPR);
		                if (parentNode instanceof MethodCallExpr) {
		                    MethodCallExpr methodCallExpr = (MethodCallExpr) parentNode;
		                    MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);
		                    int i = methodCallExpr.getArgumentPosition(wrappedNode, EXCLUDE_ENCLOSED_EXPR);
		                    ResolvedType lambdaType = methodUsage.getParamTypes().get(i);
		                    // Get the functional method in order for us to resolve it's type arguments properly
		                    Optional<MethodUsage> functionalMethodOpt = FunctionalInterfaceLogic.getFunctionalMethod(lambdaType);
		                    if (functionalMethodOpt.isPresent()) {
		                        MethodUsage functionalMethod = functionalMethodOpt.get();
		                        InferenceContext inferenceContext = new InferenceContext(typeSolver);
		                        // Resolve each type variable of the lambda, and use this later to infer the type of each
		                        // implicit parameter
		                        lambdaType.asReferenceType().getTypeDeclaration().ifPresent(typeDeclaration -> {
		                            inferenceContext.addPair(lambdaType, new ReferenceTypeImpl(typeDeclaration));
		                        });
		                        // Find the position of this lambda argument
		                        boolean found = false;
		                        int lambdaParamIndex;
		                        for (lambdaParamIndex = 0; lambdaParamIndex < wrappedNode.getParameters().size(); lambdaParamIndex++) {
		                            if (wrappedNode.getParameter(lambdaParamIndex).getName().getIdentifier().equals(name)) {
		                                found = true;
		                                break;
		                            }
		                        }
		                        if (!found) {
		                            return Optional.empty();
		                        }
		                        // Now resolve the argument type using the inference context
		                        ResolvedType argType = inferenceContext.resolve(inferenceContext.addSingle(functionalMethod.getParamType(lambdaParamIndex)));
		                        ResolvedLambdaConstraintType conType;
		                        if (argType.isWildcard()) {
		                            conType = ResolvedLambdaConstraintType.bound(argType.asWildcard().getBoundedType());
		                        } else {
		                            conType = ResolvedLambdaConstraintType.bound(argType);
		                        }
		                        Value value = new Value(conType, name);
		                        return Optional.of(value);
		                    }
		                    return Optional.empty();
		                }
		                if (parentNode instanceof VariableDeclarator) {
		                    VariableDeclarator variableDeclarator = (VariableDeclarator) parentNode;
		                    ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(variableDeclarator.getType());
		                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);
		                    if (functionalMethod.isPresent()) {
		                        ResolvedType lambdaType = functionalMethod.get().getParamType(index);
		                        // Replace parameter from declarator
		                        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		                        if (lambdaType.isReferenceType()) {
		                            for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {
		                                if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {
		                                    ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);
		                                    lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);
		                                }
		                            }
		                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {
		                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());
		                        }
		                        Value value = new Value(lambdaType, name);
		                        return Optional.of(value);
		                    }
		                    throw new UnsupportedOperationException(""functional method is not present in variable declarator"");
		                }
		                if (parentNode instanceof ReturnStmt) {
		                    ReturnStmt returnStmt = (ReturnStmt) parentNode;
		                    Optional<MethodDeclaration> optDeclaration = returnStmt.findAncestor(MethodDeclaration.class);
		                    if (optDeclaration.isPresent()) {
		                        ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(optDeclaration.get().asMethodDeclaration().getType());
		                        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);
		                        if (functionalMethod.isPresent()) {
		                            ResolvedType lambdaType = functionalMethod.get().getParamType(index);
		                            // Replace parameter from declarator
		                            Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		                            if (lambdaType.isReferenceType()) {
		                                for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {
		                                    if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {
		                                        ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);
		                                        lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);
		                                    }
		                                }
		                            } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {
		                                lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());
		                            }
		                            Value value = new Value(lambdaType, name);
		                            return Optional.of(value);
		                        }
		                        throw new UnsupportedOperationException(""functional method is not present in return statement"");
		                    }
		                }
		                if (parentNode instanceof CastExpr) {
		                    CastExpr castExpr = (CastExpr) parentNode;
		                    ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(castExpr.getType());
		                    Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);
		                    if (functionalMethod.isPresent()) {
		                        ResolvedType lambdaType = functionalMethod.get().getParamType(index);
		                        // Replace parameter from declarator
		                        Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		                        if (lambdaType.isReferenceType()) {
		                            for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {
		                                if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {
		                                    ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);
		                                    lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);
		                                }
		                            }
		                        } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {
		                            lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());
		                        }
		                        Value value = new Value(lambdaType, name);
		                        return Optional.of(value);
		                    }
		                    throw new UnsupportedOperationException(""functional method is not present in cast expression"");
		                }
		                throw new UnsupportedOperationException(""Unknown node type: "" + parentNode.getClass().getSimpleName());
		            }
		        }
		    }
		    // if nothing is found we should ask the parent context
		    return solveSymbolAsValueInParentContext(name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ wrappednode . getparameters ( ) ) $whitespace$ { $newline$ $indentation$ index ++ ; $newline$ $indentation$ symboldeclarator $whitespace$ sb $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( parameter , $whitespace$ typesolver ) ; $newline$ $indentation$ for $whitespace$ ( resolvedvaluedeclaration $whitespace$ decl $whitespace$ : $whitespace$ sb . getsymboldeclarations ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( decl . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( wrappednode , $whitespace$ is_not_enclosed_expr ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ methodcallexpr $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . solvemethodasusage ( methodcallexpr ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ methodcallexpr . getargumentposition ( wrappednode , $whitespace$ exclude_enclosed_expr ) ; $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ methodusage . getparamtypes ( ) . get ( i ) ; $newline$ $indentation$ $//·get·the·functional·method·in·order·for·us·to·resolve·it's·type·arguments·properly$ $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethodopt $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( lambdatype ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethodopt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalmethodopt . get ( ) ; $newline$ $indentation$ inferencecontext $whitespace$ inferencecontext $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ $//·resolve·each·type·variable·of·the·lambda,·and·use·this·later·to·infer·the·type·of·each$ $newline$ $indentation$ $//·implicit·parameter$ $newline$ $indentation$ lambdatype . asreferencetype ( ) . gettypedeclaration ( ) . ifpresent ( typedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ inferencecontext . addpair ( lambdatype , $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ $//·find·the·position·of·this·lambda·argument$ $newline$ $indentation$ boolean $whitespace$ found $whitespace$ = $whitespace$ false ; $newline$ $indentation$ int $whitespace$ lambdaparamindex ; $newline$ $indentation$ for $whitespace$ ( lambdaparamindex $whitespace$ = $whitespace$ $number$ ; $whitespace$ lambdaparamindex $whitespace$ < $whitespace$ wrappednode . getparameters ( ) . size ( ) ; $whitespace$ lambdaparamindex ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wrappednode . getparameter ( lambdaparamindex ) . getname ( ) . getidentifier ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ found $whitespace$ = $whitespace$ true ; $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! found ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·now·resolve·the·argument·type·using·the·inference·context$ $newline$ $indentation$ resolvedtype $whitespace$ argtype $whitespace$ = $whitespace$ inferencecontext . resolve ( inferencecontext . addsingle ( functionalmethod . getparamtype ( lambdaparamindex ) ) ) ; $newline$ $indentation$ resolvedlambdaconstrainttype $whitespace$ contype ; $newline$ $indentation$ if $whitespace$ ( argtype . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ contype $whitespace$ = $whitespace$ resolvedlambdaconstrainttype . bound ( argtype . aswildcard ( ) . getboundedtype ( ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ contype $whitespace$ = $whitespace$ resolvedlambdaconstrainttype . bound ( argtype ) ; $newline$ $indentation$ } $newline$ $indentation$ value $whitespace$ value $whitespace$ = $whitespace$ new $whitespace$ value ( contype , $whitespace$ name ) ; $newline$ $indentation$ return $whitespace$ optional . of ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ ( variabledeclarator ) $whitespace$ parentnode ; $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( variabledeclarator . gettype ( ) ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( t ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ functionalmethod . get ( ) . getparamtype ( index ) ; $newline$ $indentation$ $//·replace·parameter·from·declarator$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( lambdatype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . utils . pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ lambdatype . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . b . istypevariable ( ) $whitespace$ && $whitespace$ entry . b . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ot $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( entry . a ) ; $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ lambdatype . replacetypevariables ( entry . a , $whitespace$ ot , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdatype . istypevariable ( ) $whitespace$ && $whitespace$ lambdatype . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( lambdatype . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ value $whitespace$ value $whitespace$ = $whitespace$ new $whitespace$ value ( lambdatype , $whitespace$ name ) ; $newline$ $indentation$ return $whitespace$ optional . of ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ returnstmt ) $whitespace$ { $newline$ $indentation$ returnstmt $whitespace$ returnstmt $whitespace$ = $whitespace$ ( returnstmt ) $whitespace$ parentnode ; $newline$ $indentation$ optional < methoddeclaration > $whitespace$ optdeclaration $whitespace$ = $whitespace$ returnstmt . findancestor ( methoddeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( optdeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( optdeclaration . get ( ) . asmethoddeclaration ( ) . gettype ( ) ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( t ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ functionalmethod . get ( ) . getparamtype ( index ) ; $newline$ $indentation$ $//·replace·parameter·from·declarator$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( lambdatype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . utils . pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ lambdatype . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . b . istypevariable ( ) $whitespace$ && $whitespace$ entry . b . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ot $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( entry . a ) ; $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ lambdatype . replacetypevariables ( entry . a , $whitespace$ ot , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdatype . istypevariable ( ) $whitespace$ && $whitespace$ lambdatype . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( lambdatype . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ value $whitespace$ value $whitespace$ = $whitespace$ new $whitespace$ value ( lambdatype , $whitespace$ name ) ; $newline$ $indentation$ return $whitespace$ optional . of ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ castexpr ) $whitespace$ { $newline$ $indentation$ castexpr $whitespace$ castexpr $whitespace$ = $whitespace$ ( castexpr ) $whitespace$ parentnode ; $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( castexpr . gettype ( ) ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( t ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ functionalmethod . get ( ) . getparamtype ( index ) ; $newline$ $indentation$ $//·replace·parameter·from·declarator$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( lambdatype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . utils . pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ lambdatype . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . b . istypevariable ( ) $whitespace$ && $whitespace$ entry . b . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ot $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( entry . a ) ; $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ lambdatype . replacetypevariables ( entry . a , $whitespace$ ot , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdatype . istypevariable ( ) $whitespace$ && $whitespace$ lambdatype . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( lambdatype . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ value $whitespace$ value $whitespace$ = $whitespace$ new $whitespace$ value ( lambdatype , $whitespace$ name ) ; $newline$ $indentation$ return $whitespace$ optional . of ( value ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ parentnode . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·parent·context$ $newline$ $indentation$ return $whitespace$ solvesymbolasvalueinparentcontext ( name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ int $whitespace$ index $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( parameter $whitespace$ parameter $whitespace$ : $whitespace$ wrappednode. getparameters ( ) ) $whitespace$ { $newline$ $indentation$ index ++ ; $newline$ $indentation$ symboldeclarator $whitespace$ sb $whitespace$ = $whitespace$ javaparserfactory. getsymboldeclarator ( parameter, $whitespace$ typesolver ) ; $newline$ $indentation$ for $whitespace$ ( resolvedvaluedeclaration $whitespace$ decl $whitespace$ : $whitespace$ sb. getsymboldeclarations ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( decl. getname ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( wrappednode, $whitespace$ is_not_enclosed_expr ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ methodcallexpr $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ parentnode ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). solvemethodasusage ( methodcallexpr ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ methodcallexpr. getargumentposition ( wrappednode, $whitespace$ exclude_enclosed_expr ) ; $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ methodusage. getparamtypes ( ). get ( i ) ; $newline$ $indentation$ $//q			
solveMethod	221	225	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/LambdaExprContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
inferTypes	237	329	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0001273230882361	LOW	"		private void inferTypes(ResolvedType source, ResolvedType target, Map<ResolvedTypeParameterDeclaration, ResolvedType> mappings){
		    if (source.equals(target)) {
		        return;
		    }
		    if (source.isReferenceType() && target.isReferenceType()) {
		        ResolvedReferenceType sourceRefType = source.asReferenceType();
		        ResolvedReferenceType targetRefType = target.asReferenceType();
		        if (sourceRefType.getQualifiedName().equals(targetRefType.getQualifiedName())) {
		            if (!sourceRefType.isRawType() && !targetRefType.isRawType()) {
		                for (int i = 0; i < sourceRefType.typeParametersValues().size(); i++) {
		                    inferTypes(sourceRefType.typeParametersValues().get(i), targetRefType.typeParametersValues().get(i), mappings);
		                }
		            }
		        }
		        return;
		    }
		    if (source.isReferenceType() && target.isWildcard()) {
		        if (target.asWildcard().isBounded()) {
		            inferTypes(source, target.asWildcard().getBoundedType(), mappings);
		            return;
		        }
		        return;
		    }
		    if (source.isWildcard() && target.isWildcard()) {
		        if (source.asWildcard().isBounded() && target.asWildcard().isBounded()) {
		            inferTypes(source.asWildcard().getBoundedType(), target.asWildcard().getBoundedType(), mappings);
		        }
		        return;
		    }
		    if (source.isReferenceType() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isWildcard() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isArray() && target.isArray()) {
		        ResolvedType sourceComponentType = source.asArrayType().getComponentType();
		        ResolvedType targetComponentType = target.asArrayType().getComponentType();
		        inferTypes(sourceComponentType, targetComponentType, mappings);
		        return;
		    }
		    if (source.isArray() && target.isWildcard()) {
		        if (target.asWildcard().isBounded()) {
		            inferTypes(source, target.asWildcard().getBoundedType(), mappings);
		            return;
		        }
		        return;
		    }
		    if (source.isArray() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isWildcard() && target.isReferenceType()) {
		        if (source.asWildcard().isBounded()) {
		            inferTypes(source.asWildcard().getBoundedType(), target, mappings);
		        }
		        return;
		    }
		    if (source.isConstraint() && target.isReferenceType()) {
		        inferTypes(source.asConstraintType().getBound(), target, mappings);
		        return;
		    }
		    if (source.isConstraint() && target.isTypeVariable()) {
		        inferTypes(source.asConstraintType().getBound(), target, mappings);
		        return;
		    }
		    if (source.isTypeVariable() && target.isTypeVariable()) {
		        mappings.put(target.asTypeParameter(), source);
		        return;
		    }
		    if (source.isTypeVariable()) {
		        inferTypes(target, source, mappings);
		        return;
		    }
		    if (source.isPrimitive() || target.isPrimitive()) {
		        return;
		    }
		    if (source.isNull()) {
		        return;
		    }
		    if (target.isReferenceType()) {
		        ResolvedReferenceType formalTypeAsReference = target.asReferenceType();
		        if (formalTypeAsReference.isJavaLangObject()) {
		            return;
		        }
		    }
		    throw new RuntimeException(source.describe() + "" "" + target.describe());
		}"	$indentation$ private $whitespace$ void $whitespace$ infertypes ( resolvedtype $whitespace$ source , $whitespace$ resolvedtype $whitespace$ target , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ mappings ) { $newline$ $indentation$ if $whitespace$ ( source . equals ( target ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ sourcereftype $whitespace$ = $whitespace$ source . asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ targetreftype $whitespace$ = $whitespace$ target . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( sourcereftype . getqualifiedname ( ) . equals ( targetreftype . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! sourcereftype . israwtype ( ) $whitespace$ && $whitespace$ ! targetreftype . israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ sourcereftype . typeparametersvalues ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ infertypes ( sourcereftype . typeparametersvalues ( ) . get ( i ) , $whitespace$ targetreftype . typeparametersvalues ( ) . get ( i ) , $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( target . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source , $whitespace$ target . aswildcard ( ) . getboundedtype ( ) , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( source . aswildcard ( ) . isbounded ( ) $whitespace$ && $whitespace$ target . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source . aswildcard ( ) . getboundedtype ( ) , $whitespace$ target . aswildcard ( ) . getboundedtype ( ) , $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isreferencetype ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isarray ( ) $whitespace$ && $whitespace$ target . isarray ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ sourcecomponenttype $whitespace$ = $whitespace$ source . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ targetcomponenttype $whitespace$ = $whitespace$ target . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ infertypes ( sourcecomponenttype , $whitespace$ targetcomponenttype , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isarray ( ) $whitespace$ && $whitespace$ target . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( target . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source , $whitespace$ target . aswildcard ( ) . getboundedtype ( ) , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isarray ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . iswildcard ( ) $whitespace$ && $whitespace$ target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( source . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source . aswildcard ( ) . getboundedtype ( ) , $whitespace$ target , $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isconstraint ( ) $whitespace$ && $whitespace$ target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source . asconstrainttype ( ) . getbound ( ) , $whitespace$ target , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isconstraint ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( source . asconstrainttype ( ) . getbound ( ) , $whitespace$ target , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . istypevariable ( ) $whitespace$ && $whitespace$ target . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ mappings . put ( target . astypeparameter ( ) , $whitespace$ source ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ infertypes ( target , $whitespace$ source , $whitespace$ mappings ) ; $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isprimitive ( ) $whitespace$ || $whitespace$ target . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source . isnull ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( target . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ formaltypeasreference $whitespace$ = $whitespace$ target . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( formaltypeasreference . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( source . describe ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ target . describe ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ infertypes ( resolvedtype $whitespace$ source, $whitespace$ resolvedtype $whitespace$ target, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ mappings ) { $newline$ $indentation$ if $whitespace$ ( source. equals ( target ) ) $whitespace$ { $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( source. isreferencetype ( ) $whitespace$ && $whitespace$ target. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ sourcereftype $whitespace$ = $whitespace$ source. asreferencetype ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ targetreftype $whitespace$ = $whitespace$ target. asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( sourcereftype. getqualifiedname ( ). equals ( targetreftype. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! sourcereftype. israwtype ( ) $whitespace$ && $whitespace$! targetreftype. israwtype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ sourcereftype. typeparametersvalues ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ infertypes ( sourcereftype. typeparametersvalues ( ). get ( i ), $whitespace$ targetreftype. typeparametersvalues ( ). get ( i ), $whitespace$ mappings ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return ; $newline$ $indentation$ } $newline$ $indentation$			
resolveMethodTypeParameters	331	412	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.000617163896095	LOW	"		private MethodUsage resolveMethodTypeParameters(MethodUsage methodUsage, List<ResolvedType> actualParamTypes){
		    Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters = new HashMap<>();
		    if (methodUsage.getDeclaration().hasVariadicParameter()) {
		        if (actualParamTypes.size() == methodUsage.getDeclaration().getNumberOfParams()) {
		            // the varargs parameter is an Array, so extract the inner type
		            ResolvedType expectedType = methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();
		            // the varargs corresponding type can be either T or Array<T>
		            // for example
		            // Arrays.aslist(int[]{1}) must returns List<int[]>
		            // but Arrays.aslist(String[]{""""}) must returns List<String>
		            // Arrays.asList() accept generic type T. Since Java generics work only on
		            // reference types (object types), not on primitives, and int[] is an object
		            // then Arrays.aslist(int[]{1}) returns List<int[]>
		            ResolvedType lastActualParamType = actualParamTypes.get(actualParamTypes.size() - 1);
		            ResolvedType actualType = lastActualParamType;
		            if (lastActualParamType.isArray()) {
		                ResolvedType componentType = lastActualParamType.asArrayType().getComponentType();
		                // in cases where, the expected type is assignable by the actual reference type of the array
		                // (Files.newInputStream(path, options) and options is a variadic argument of type OpenOption)
		                // or the expected type is a generic type (Arrays.asList(T... a)) and the component type of the array type is a reference type
		                // or the expected type is not a generic (IntStream.of(int... values)) and the component type is not a reference type
		                // then the actual type is the component type (in the example above 'int')
		                if ((componentType.isReferenceType() && ResolvedTypeVariable.class.isInstance(expectedType)) || (!componentType.isReferenceType() && !ResolvedTypeVariable.class.isInstance(expectedType)) || (componentType.isReferenceType() && expectedType.isAssignableBy(componentType))) {
		                    actualType = lastActualParamType.asArrayType().getComponentType();
		                }
		            }
		            if (!expectedType.isAssignableBy(actualType)) {
		                for (ResolvedTypeParameterDeclaration tp : methodUsage.getDeclaration().getTypeParameters()) {
		                    expectedType = MethodResolutionLogic.replaceTypeParam(expectedType, tp, typeSolver);
		                }
		            }
		            if (!expectedType.isAssignableBy(actualType)) {
		                // ok, then it needs to be wrapped
		                throw new UnsupportedOperationException(String.format(""Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s"", expectedType, actualType, methodUsage.getDeclaration(), methodUsage));
		            }
		            // match only the varargs type
		            matchTypeParameters(expectedType, actualType, matchedTypeParameters);
		        } else if (methodUsage.getDeclaration().getNumberOfParams() == 1) {
		            // In this case the method declares only one parameter which is a variadic parameter.
		            // At this stage we can consider that the actual parameters all have the same type.
		            ResolvedType expectedType = methodUsage.getDeclaration().getLastParam().getType().asArrayType().getComponentType();
		            // the varargs corresponding type can not be an Array<T> because of the assumption
		            //                ResolvedType actualType = new ResolvedArrayType(actualParamTypes.get(actualParamTypes.size() - 1));
		            ResolvedType actualType = actualParamTypes.get(actualParamTypes.size() - 1);
		            if (!expectedType.isAssignableBy(actualType)) {
		                throw new UnsupportedOperationException(String.format(""Unable to resolve the type typeParametersValues in a MethodUsage. Expected type: %s, Actual type: %s. Method Declaration: %s. MethodUsage: %s"", expectedType, actualType, methodUsage.getDeclaration(), methodUsage));
		            }
		            matchTypeParameters(expectedType, actualType, matchedTypeParameters);
		            return replaceTypeParameter(methodUsage, matchedTypeParameters);
		        } else {
		            return methodUsage;
		        }
		    }
		    int until = methodUsage.getDeclaration().hasVariadicParameter() ? actualParamTypes.size() - 1 : actualParamTypes.size();
		    for (int i = 0; i < until; i++) {
		        ResolvedType expectedType = methodUsage.getParamType(i);
		        ResolvedType actualType = actualParamTypes.get(i);
		        matchTypeParameters(expectedType, actualType, matchedTypeParameters);
		    }
		    methodUsage = replaceTypeParameter(methodUsage, matchedTypeParameters);
		    return methodUsage;
		}"	"$indentation$ private $whitespace$ methodusage $whitespace$ resolvemethodtypeparameters ( methodusage $whitespace$ methodusage , $whitespace$ list < resolvedtype > $whitespace$ actualparamtypes ) { $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( methodusage . getdeclaration ( ) . hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualparamtypes . size ( ) $whitespace$ == $whitespace$ methodusage . getdeclaration ( ) . getnumberofparams ( ) ) $whitespace$ { $newline$ $indentation$ $//·the·varargs·parameter·is·an·array,·so·extract·the·inner·type$ $newline$ $indentation$ resolvedtype $whitespace$ expectedtype $whitespace$ = $whitespace$ methodusage . getdeclaration ( ) . getlastparam ( ) . gettype ( ) . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ $//·the·varargs·corresponding·type·can·be·either·t·or·array<t>$ $newline$ $indentation$ $//·for·example$ $newline$ $indentation$ $//·arrays.aslist(int[]{1})·must·returns·list<int[]>$ $newline$ $indentation$ $//·but·arrays.aslist(string[]{""""})·must·returns·list<string>$ $newline$ $indentation$ $//·arrays.aslist()·accept·generic·type·t.·since·java·generics·work·only·on$ $newline$ $indentation$ $//·reference·types·(object·types),·not·on·primitives,·and·int[]·is·an·object$ $newline$ $indentation$ $//·then·arrays.aslist(int[]{1})·returns·list<int[]>$ $newline$ $indentation$ resolvedtype $whitespace$ lastactualparamtype $whitespace$ = $whitespace$ actualparamtypes . get ( actualparamtypes . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualtype $whitespace$ = $whitespace$ lastactualparamtype ; $newline$ $indentation$ if $whitespace$ ( lastactualparamtype . isarray ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ componenttype $whitespace$ = $whitespace$ lastactualparamtype . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ $//·in·cases·where,·the·expected·type·is·assignable·by·the·actual·reference·type·of·the·array$ $newline$ $indentation$ $//·(files.newinputstream(path,·options)·and·options·is·a·variadic·argument·of·type·openoption)$ $newline$ $indentation$ $//·or·the·expected·type·is·a·generic·type·(arrays.aslist(t...·a))·and·the·component·type·of·the·array·type·is·a·reference·type$ $newline$ $indentation$ $//·or·the·expected·type·is·not·a·generic·(intstream.of(int...·values))·and·the·component·type·is·not·a·reference·type$ $newline$ $indentation$ $//·then·the·actual·type·is·the·component·type·(in·the·example·above·'int')$ $newline$ $indentation$ if $whitespace$ ( ( componenttype . isreferencetype ( ) $whitespace$ && $whitespace$ resolvedtypevariable . class . isinstance ( expectedtype ) ) $whitespace$ || $whitespace$ ( ! componenttype . isreferencetype ( ) $whitespace$ && $whitespace$ ! resolvedtypevariable . class . isinstance ( expectedtype ) ) $whitespace$ || $whitespace$ ( componenttype . isreferencetype ( ) $whitespace$ && $whitespace$ expectedtype . isassignableby ( componenttype ) ) ) $whitespace$ { $newline$ $indentation$ actualtype $whitespace$ = $whitespace$ lastactualparamtype . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ methodusage . getdeclaration ( ) . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ expectedtype $whitespace$ = $whitespace$ methodresolutionlogic . replacetypeparam ( expectedtype , $whitespace$ tp , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ $//·ok,·then·it·needs·to·be·wrapped$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ expectedtype , $whitespace$ actualtype , $whitespace$ methodusage . getdeclaration ( ) , $whitespace$ methodusage ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·match·only·the·varargs·type$ $newline$ $indentation$ matchtypeparameters ( expectedtype , $whitespace$ actualtype , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( methodusage . getdeclaration ( ) . getnumberofparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ $//·in·this·case·the·method·declares·only·one·parameter·which·is·a·variadic·parameter.$ $newline$ $indentation$ $//·at·this·stage·we·can·consider·that·the·actual·parameters·all·have·the·same·type.$ $newline$ $indentation$ resolvedtype $whitespace$ expectedtype $whitespace$ = $whitespace$ methodusage . getdeclaration ( ) . getlastparam ( ) . gettype ( ) . asarraytype ( ) . getcomponenttype ( ) ; $newline$ $indentation$ $//·the·varargs·corresponding·type·can·not·be·an·array<t>·because·of·the·assumption$ $newline$ $indentation$ $//················resolvedtype·actualtype·=·new·resolvedarraytype(actualparamtypes.get(actualparamtypes.size()·-·1));$ $newline$ $indentation$ resolvedtype $whitespace$ actualtype $whitespace$ = $whitespace$ actualparamtypes . get ( actualparamtypes . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ if $whitespace$ ( ! expectedtype . isassignableby ( actualtype ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ expectedtype , $whitespace$ actualtype , $whitespace$ methodusage . getdeclaration ( ) , $whitespace$ methodusage ) ) ; $newline$ $indentation$ } $newline$ $indentation$ matchtypeparameters ( expectedtype , $whitespace$ actualtype , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ return $whitespace$ replacetypeparameter ( methodusage , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ until $whitespace$ = $whitespace$ methodusage . getdeclaration ( ) . hasvariadicparameter ( ) $whitespace$ ? $whitespace$ actualparamtypes . size ( ) $whitespace$ - $whitespace$ $number$ $whitespace$ : $whitespace$ actualparamtypes . size ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ until ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ expectedtype $whitespace$ = $whitespace$ methodusage . getparamtype ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ actualtype $whitespace$ = $whitespace$ actualparamtypes . get ( i ) ; $newline$ $indentation$ matchtypeparameters ( expectedtype , $whitespace$ actualtype , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ replacetypeparameter ( methodusage , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ methodusage $whitespace$ resolvemethodtypeparameters ( methodusage $whitespace$ methodusage, $whitespace$ list < resolvedtype > $whitespace$ actualparamtypes ) { $newline$ $indentation$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( methodusage. getdeclaration ( ). hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( actualparamtypes. size ( ) $whitespace$ == $whitespace$ methodusage. getdeclaration ( ). getnumberofparams ( ) ) $whitespace$ { $newline$ $indentation$ $//g$the $whitespace$ methodusage $whitespace$ = $whitespace$ methodusage. getdeclaration ( ). getlastparam ( ). gettype ( ). asarraytype ( ). getcomponenttype ( ) ; $newline$ $indentation$ // $whitespace$ no $whitespace$ test $whitespace$ -- $whitespace$ // $whitespace$ we $whitespace$ have $whitespace$ a $whitespace$ property $whitespace$ of $whitespace$ the $whitespace$ methodusage $whitespace$ and $whitespace$ that $whitespace$ its $whitespace$ values $whitespace$ can $whitespace$ be $whitespace$ used $newline$ $indentation$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $white			
findResolvedTypesByTypeVariable	471	476	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0026781682390719	LOW	"		private Set<ResolvedType> findResolvedTypesByTypeVariable(String typeVariableName, Map<ResolvedTypeParameterDeclaration, ResolvedType> typeParameters){
		    return typeParameters.keySet().stream().filter(resolvedTypeParameterDeclaration -> resolvedTypeParameterDeclaration.getName().equals(typeVariableName)).map(resolvedTypeParameterDeclaration -> typeParameters.get(resolvedTypeParameterDeclaration)).collect(Collectors.toSet());
		}"	$indentation$ private $whitespace$ set < resolvedtype > $whitespace$ findresolvedtypesbytypevariable ( string $whitespace$ typevariablename , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ typeparameters . keyset ( ) . stream ( ) . filter ( resolvedtypeparameterdeclaration $whitespace$ - > $whitespace$ resolvedtypeparameterdeclaration . getname ( ) . equals ( typevariablename ) ) . map ( resolvedtypeparameterdeclaration $whitespace$ - > $whitespace$ typeparameters . get ( resolvedtypeparameterdeclaration ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ set < resolvedtype > $whitespace$ findresolvedtypesbytypevariable ( string $whitespace$ typevariablename, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ typeparameters. keyset ( ). stream ( ) $newline$ $indentation$. filter ( resolvedtypeparameterdeclaration $whitespace$ - > $whitespace$ resolvedtypeparameterdeclaration. getname ( ). equals ( typevariablename ) ) $newline$ $indentation$. map ( resolvedtypeparameterdeclaration $whitespace$ - > $whitespace$ typeparameters. get ( resolvedtypeparameterdeclaration ) ) $newline$ $indentation$. collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
matchTypeParameters	494	539	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.041947703808546	LOW	"		private void matchTypeParameters(ResolvedType expectedType, ResolvedType actualType, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters){
		    if (expectedType.isTypeVariable()) {
		        ResolvedType type = actualType;
		        // in case of primitive type, the expected type must be compared with the boxed type of the actual type
		        if (type.isPrimitive()) {
		            ResolvedReferenceTypeDeclaration resolvedTypedeclaration = typeSolver.solveType(type.asPrimitive().getBoxTypeQName());
		            type = new ReferenceTypeImpl(resolvedTypedeclaration);
		        }
		        /*
		             * ""a value of the null type (the null reference is the only such value) may be assigned to any reference type, resulting in a null reference of that type""
		             * https://docs.oracle.com/javase/specs/jls/se15/html/jls-5.html#jls-5.2
		             */
		        if (type.isNull()) {
		            ResolvedReferenceTypeDeclaration resolvedTypedeclaration = typeSolver.getSolvedJavaLangObject();
		            type = new ReferenceTypeImpl(resolvedTypedeclaration);
		        }
		        if (!type.isTypeVariable() && !type.isReferenceType() && !type.isArray()) {
		            throw new UnsupportedOperationException(type.getClass().getCanonicalName());
		        }
		        matchedTypeParameters.put(expectedType.asTypeParameter(), type);
		    } else if (expectedType.isArray()) {
		        // Issue 2258 : NullType must not fail this search
		        if (!(actualType.isArray() || actualType.isNull())) {
		            throw new UnsupportedOperationException(actualType.getClass().getCanonicalName());
		        }
		        matchTypeParameters(expectedType.asArrayType().getComponentType(), actualType.isNull() ? actualType : actualType.asArrayType().getComponentType(), matchedTypeParameters);
		    } else if (expectedType.isReferenceType()) {
		        // avoid cases where the actual type has no type parameters but the expected one has. Such as: ""classX extends classY<Integer>""
		        if (actualType.isReferenceType() && actualType.asReferenceType().typeParametersValues().size() > 0) {
		            int i = 0;
		            for (ResolvedType tp : expectedType.asReferenceType().typeParametersValues()) {
		                matchTypeParameters(tp, actualType.asReferenceType().typeParametersValues().get(i), matchedTypeParameters);
		                i++;
		            }
		        }
		    } else if (expectedType.isPrimitive()) {
		        // nothing to do
		    } else if (expectedType.isWildcard()) {
		        // nothing to do
		    } else {
		        throw new UnsupportedOperationException(expectedType.getClass().getCanonicalName());
		    }
		}"	"$indentation$ private $whitespace$ void $whitespace$ matchtypeparameters ( resolvedtype $whitespace$ expectedtype , $whitespace$ resolvedtype $whitespace$ actualtype , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters ) { $newline$ $indentation$ if $whitespace$ ( expectedtype . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ actualtype ; $newline$ $indentation$ $//·in·case·of·primitive·type,·the·expected·type·must·be·compared·with·the·boxed·type·of·the·actual·type$ $newline$ $indentation$ if $whitespace$ ( type . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( type . asprimitive ( ) . getboxtypeqname ( ) ) ; $newline$ $indentation$ type $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( resolvedtypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ $/*················*·""a·value·of·the·null·type·(the·null·reference·is·the·only·such·value)·may·be·assigned·to·any·reference·type,·resulting·in·a·null·reference·of·that·type""················*·https://docs.oracle.com/javase/specs/jls/se15/html/jls-5.html#jls-5.2················*/$ $newline$ $indentation$ if $whitespace$ ( type . isnull ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ resolvedtypedeclaration $whitespace$ = $whitespace$ typesolver . getsolvedjavalangobject ( ) ; $newline$ $indentation$ type $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( resolvedtypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! type . istypevariable ( ) $whitespace$ && $whitespace$ ! type . isreferencetype ( ) $whitespace$ && $whitespace$ ! type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ matchedtypeparameters . put ( expectedtype . astypeparameter ( ) , $whitespace$ type ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( expectedtype . isarray ( ) ) $whitespace$ { $newline$ $indentation$ $//·issue·2258·:·nulltype·must·not·fail·this·search$ $newline$ $indentation$ if $whitespace$ ( ! ( actualtype . isarray ( ) $whitespace$ || $whitespace$ actualtype . isnull ( ) ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( actualtype . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ matchtypeparameters ( expectedtype . asarraytype ( ) . getcomponenttype ( ) , $whitespace$ actualtype . isnull ( ) $whitespace$ ? $whitespace$ actualtype $whitespace$ : $whitespace$ actualtype . asarraytype ( ) . getcomponenttype ( ) , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( expectedtype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ $//·avoid·cases·where·the·actual·type·has·no·type·parameters·but·the·expected·one·has.·such·as:·""classx·extends·classy<integer>""$ $newline$ $indentation$ if $whitespace$ ( actualtype . isreferencetype ( ) $whitespace$ && $whitespace$ actualtype . asreferencetype ( ) . typeparametersvalues ( ) . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ tp $whitespace$ : $whitespace$ expectedtype . asreferencetype ( ) . typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ matchtypeparameters ( tp , $whitespace$ actualtype . asreferencetype ( ) . typeparametersvalues ( ) . get ( i ) , $whitespace$ matchedtypeparameters ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( expectedtype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( expectedtype . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ $//·nothing·to·do$ $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( expectedtype . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }"	$indentation$ private $whitespace$ void $whitespace$ matchtypeparameters ( resolvedtype $whitespace$ expectedtype, $whitespace$ resolvedtype $whitespace$ actualtype, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters ) { $newline$ $indentation$ if $whitespace$ ( expectedtype. istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ actualtype ; $newline$ $indentation$ $////g$ = $whitespace$$ getapptype ( type, $whitespace$ actualtype ) ; $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ ( type. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ = $whitespace$ typesolver. solvetype ( type. asprimitive ( ). getboxtypeqname ( ) ) ; $newline$ $indentation$ type $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( resolvedtypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ resolvedreferencetypedeclaration $whitespace$ = $whitespace$ typesolver. solvetype ( type. asprimitive ( ). getboxtypeqname ( ) ) ; $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ ( type. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ = $			
solveMethodAsUsage	79	123	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0756203010678291	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes){
		    ResolvedType typeOfScope;
		    if (wrappedNode.hasScope()) {
		        Expression scope = wrappedNode.getScope().get();
		        // Consider static method calls
		        if (scope instanceof NameExpr) {
		            String className = ((NameExpr) scope).getName().getId();
		            SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);
		            if (ref.isSolved()) {
		                SymbolReference<ResolvedMethodDeclaration> m = MethodResolutionLogic.solveMethodInType(ref.getCorrespondingDeclaration(), name, argumentsTypes);
		                if (m.isSolved()) {
		                    MethodUsage methodUsage = new MethodUsage(m.getCorrespondingDeclaration());
		                    methodUsage = resolveMethodTypeParametersFromExplicitList(typeSolver, methodUsage);
		                    methodUsage = resolveMethodTypeParameters(methodUsage, argumentsTypes);
		                    return Optional.of(methodUsage);
		                }
		                throw new UnsolvedSymbolException(ref.getCorrespondingDeclaration().toString(), ""Method '"" + name + ""' with parameterTypes "" + argumentsTypes);
		            }
		        }
		        // Scope is present -- search/solve within that type
		        typeOfScope = JavaParserFacade.get(typeSolver).getType(scope);
		    } else {
		        // Scope not present -- search/solve within itself.
		        typeOfScope = JavaParserFacade.get(typeSolver).getTypeOfThisIn(wrappedNode);
		    }
		    // we can replace the parameter types from the scope into the typeParametersValues
		    Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		    for (int i = 0; i < argumentsTypes.size(); i++) {
		        // by replacing types I can also find new equivalences
		        // for example if I replace T=U with String because I know that T=String I can derive that also U equal String
		        ResolvedType originalArgumentType = argumentsTypes.get(i);
		        ResolvedType updatedArgumentType = usingParameterTypesFromScope(typeOfScope, originalArgumentType, inferredTypes);
		        argumentsTypes.set(i, updatedArgumentType);
		    }
		    for (int i = 0; i < argumentsTypes.size(); i++) {
		        ResolvedType updatedArgumentType = applyInferredTypes(argumentsTypes.get(i), inferredTypes);
		        argumentsTypes.set(i, updatedArgumentType);
		    }
		    return solveMethodAsUsage(typeOfScope, name, argumentsTypes, this);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ resolvedtype $whitespace$ typeofscope ; $newline$ $indentation$ if $whitespace$ ( wrappednode . hasscope ( ) ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ wrappednode . getscope ( ) . get ( ) ; $newline$ $indentation$ $//·consider·static·method·calls$ $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ scope ) . getname ( ) . getid ( ) ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvetype ( classname ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ m $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ref . getcorrespondingdeclaration ( ) , $whitespace$ name , $whitespace$ argumentstypes ) ; $newline$ $indentation$ if $whitespace$ ( m . issolved ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( m . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ resolvemethodtypeparametersfromexplicitlist ( typesolver , $whitespace$ methodusage ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ resolvemethodtypeparameters ( methodusage , $whitespace$ argumentstypes ) ; $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( ref . getcorrespondingdeclaration ( ) . tostring ( ) , $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ argumentstypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·scope·is·present·--·search/solve·within·that·type$ $newline$ $indentation$ typeofscope $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettype ( scope ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·scope·not·present·--·search/solve·within·itself.$ $newline$ $indentation$ typeofscope $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettypeofthisin ( wrappednode ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·we·can·replace·the·parameter·types·from·the·scope·into·the·typeparametersvalues$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ argumentstypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ $//·by·replacing·types·i·can·also·find·new·equivalences$ $newline$ $indentation$ $//·for·example·if·i·replace·t=u·with·string·because·i·know·that·t=string·i·can·derive·that·also·u·equal·string$ $newline$ $indentation$ resolvedtype $whitespace$ originalargumenttype $whitespace$ = $whitespace$ argumentstypes . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ updatedargumenttype $whitespace$ = $whitespace$ usingparametertypesfromscope ( typeofscope , $whitespace$ originalargumenttype , $whitespace$ inferredtypes ) ; $newline$ $indentation$ argumentstypes . set ( i , $whitespace$ updatedargumenttype ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ argumentstypes . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ updatedargumenttype $whitespace$ = $whitespace$ applyinferredtypes ( argumentstypes . get ( i ) , $whitespace$ inferredtypes ) ; $newline$ $indentation$ argumentstypes . set ( i , $whitespace$ updatedargumenttype ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ solvemethodasusage ( typeofscope , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ this ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. hasscope ( ) ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ scope $whitespace$ = $whitespace$ wrappednode. getscope ( ). get ( ) ; $newline$ $indentation$ $//// ; $newline$ $indentation$ if $whitespace$ ( scope $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ( ( nameexpr ) $whitespace$ scope ). getname ( ). getid ( ) ; $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvetype ( classname ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ m $whitespace$ = $whitespace$ methodresolutionlogic. solvemethodintype ( ref. getcorrespondingdeclaration ( ), $whitespace$ name, $whitespace$ argumentstypes ) ; $newline$ $indentation$ if $whitespace$ ( m. issolved ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( m. getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ resolvemethodtypeparametersfromexplicitlist ( typesolver, $whitespace$ methodusage ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$			
groupResolvedTypeByTypeVariable	455	466	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0825150683522224	LOW	"		private Map<String, Set<ResolvedType>> groupResolvedTypeByTypeVariable(Map<ResolvedTypeParameterDeclaration, ResolvedType> typeParameters){
		    Map<String, Set<ResolvedType>> resolvedTypesByTypeVariable = new HashMap<>();
		    for (ResolvedTypeParameterDeclaration tp : typeParameters.keySet()) {
		        String typeParameterName = tp.getName();
		        boolean alreadyCollected = resolvedTypesByTypeVariable.keySet().contains(typeParameterName);
		        if (!alreadyCollected) {
		            Set<ResolvedType> resolvedTypes = findResolvedTypesByTypeVariable(typeParameterName, typeParameters);
		            resolvedTypesByTypeVariable.put(typeParameterName, resolvedTypes);
		        }
		    }
		    return resolvedTypesByTypeVariable;
		}"	$indentation$ private $whitespace$ map < string , $whitespace$ set < resolvedtype >> $whitespace$ groupresolvedtypebytypevariable ( map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ map < string , $whitespace$ set < resolvedtype >> $whitespace$ resolvedtypesbytypevariable $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparameters . keyset ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ typeparametername $whitespace$ = $whitespace$ tp . getname ( ) ; $newline$ $indentation$ boolean $whitespace$ alreadycollected $whitespace$ = $whitespace$ resolvedtypesbytypevariable . keyset ( ) . contains ( typeparametername ) ; $newline$ $indentation$ if $whitespace$ ( ! alreadycollected ) $whitespace$ { $newline$ $indentation$ set < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ findresolvedtypesbytypevariable ( typeparametername , $whitespace$ typeparameters ) ; $newline$ $indentation$ resolvedtypesbytypevariable . put ( typeparametername , $whitespace$ resolvedtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedtypesbytypevariable ; $newline$ $indentation$ }	$indentation$ private $whitespace$ map < string, $whitespace$ set < resolvedtype >> $whitespace$ groupresolvedtypebytypevariable ( map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ map < string, $whitespace$ set < resolvedtype >> $whitespace$ resolvedtypesbytypevariable $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparameters. keyset ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ typeparametername $whitespace$ = $whitespace$ tp. getname ( ) ; $newline$ $indentation$ boolean $whitespace$ alreadycollected $whitespace$ = $whitespace$ resolvedtypesbytypevariable. keyset ( ). contains ( typeparametername ) ; $newline$ $indentation$ if $whitespace$ (! alreadycollected ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ set < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ findresolvedtypesbytypevariable ( typeparametername, $whitespace$ typeparameters ) ; $newline$ $indentation$ resolvedtypesbytypevariable. put ( typeparametername, $whitespace$ resolvedtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedtypesbytypevariable ; $newline$ $indentation$ }			
usingParameterTypesFromScope	602	611	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0860029906034469	LOW	"		private ResolvedType usingParameterTypesFromScope(ResolvedType scope, ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    if (type.isReferenceType()) {
		        for (Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : type.asReferenceType().getTypeParametersMap()) {
		            if (entry.a.declaredOnType() && scope.isReferenceType() && scope.asReferenceType().getGenericParameterByName(entry.a.getName()).isPresent()) {
		                type = type.replaceTypeVariables(entry.a, scope.asReferenceType().getGenericParameterByName(entry.a.getName()).get(), inferredTypes);
		            }
		        }
		    }
		    return type;
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ usingparametertypesfromscope ( resolvedtype $whitespace$ scope , $whitespace$ resolvedtype $whitespace$ type , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ type . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . a . declaredontype ( ) $whitespace$ && $whitespace$ scope . isreferencetype ( ) $whitespace$ && $whitespace$ scope . asreferencetype ( ) . getgenericparameterbyname ( entry . a . getname ( ) ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type . replacetypevariables ( entry . a , $whitespace$ scope . asreferencetype ( ) . getgenericparameterbyname ( entry . a . getname ( ) ) . get ( ) , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ usingparametertypesfromscope ( resolvedtype $whitespace$ scope, $whitespace$ resolvedtype $whitespace$ type, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ if $whitespace$ ( type. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( pair < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ type. asreferencetype ( ). gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry. a. declaredontype ( ) $whitespace$ && $whitespace$ scope. isreferencetype ( ) $whitespace$ && $whitespace$ scope. asreferencetype ( ). getgenericparameterbyname ( entry. a. getname ( ) ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type. replacetypevariables ( entry. a, $whitespace$ scope. asreferencetype ( ). getgenericparameterbyname ( entry. a. getname ( ) ). get ( ), $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
resolveMethodTypeParametersFromExplicitList	125	141	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.0990315750241279	LOW	"		private MethodUsage resolveMethodTypeParametersFromExplicitList(TypeSolver typeSolver, MethodUsage methodUsage){
		    if (wrappedNode.getTypeArguments().isPresent()) {
		        final List<ResolvedType> typeArguments = new ArrayList<>();
		        for (com.github.javaparser.ast.type.Type ty : wrappedNode.getTypeArguments().get()) {
		            typeArguments.add(JavaParserFacade.get(typeSolver).convertToUsage(ty));
		        }
		        List<ResolvedTypeParameterDeclaration> tyParamDecls = methodUsage.getDeclaration().getTypeParameters();
		        if (tyParamDecls.size() == typeArguments.size()) {
		            for (int i = 0; i < tyParamDecls.size(); i++) {
		                methodUsage = methodUsage.replaceTypeParameter(tyParamDecls.get(i), typeArguments.get(i));
		            }
		        }
		    }
		    return methodUsage;
		}"	$indentation$ private $whitespace$ methodusage $whitespace$ resolvemethodtypeparametersfromexplicitlist ( typesolver $whitespace$ typesolver , $whitespace$ methodusage $whitespace$ methodusage ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . gettypearguments ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ final $whitespace$ list < resolvedtype > $whitespace$ typearguments $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . ast . type . type $whitespace$ ty $whitespace$ : $whitespace$ wrappednode . gettypearguments ( ) . get ( ) ) $whitespace$ { $newline$ $indentation$ typearguments . add ( javaparserfacade . get ( typesolver ) . converttousage ( ty ) ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typaramdecls $whitespace$ = $whitespace$ methodusage . getdeclaration ( ) . gettypeparameters ( ) ; $newline$ $indentation$ if $whitespace$ ( typaramdecls . size ( ) $whitespace$ == $whitespace$ typearguments . size ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typaramdecls . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( typaramdecls . get ( i ) , $whitespace$ typearguments . get ( i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }	$indentation$ private $whitespace$ methodusage $whitespace$ resolvemethodtypeparametersfromexplicitlist ( typesolver $whitespace$ typesolver, $whitespace$ methodusage $whitespace$ methodusage ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. gettypearguments ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ list < resolvedtype > $whitespace$ typearguments $whitespace$ = $whitespace$ methodusage. getdeclaration ( ). gettypeparameters ( ) ; $newline$ $indentation$ if $whitespace$ ( typearguments. size ( ) $whitespace$ == $whitespace$ typearguments. size ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typaramdecls. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage. replacetypeparameter ( typaramdecls. get ( i ), $whitespace$ typearguments. get ( i ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }			
convertTypesParameters	437	447	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.1071133092045784	LOW	"		private void convertTypesParameters(Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters, Map<String, ResolvedType> reducedResolvedTypesByTypeVariable){
		    for (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {
		        String typeParameterName = tp.getName();
		        boolean replacement = reducedResolvedTypesByTypeVariable.keySet().contains(typeParameterName);
		        if (replacement) {
		            matchedTypeParameters.put(tp, reducedResolvedTypesByTypeVariable.get(typeParameterName));
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ converttypesparameters ( map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters , $whitespace$ map < string , $whitespace$ resolvedtype > $whitespace$ reducedresolvedtypesbytypevariable ) { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ matchedtypeparameters . keyset ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ typeparametername $whitespace$ = $whitespace$ tp . getname ( ) ; $newline$ $indentation$ boolean $whitespace$ replacement $whitespace$ = $whitespace$ reducedresolvedtypesbytypevariable . keyset ( ) . contains ( typeparametername ) ; $newline$ $indentation$ if $whitespace$ ( replacement ) $whitespace$ { $newline$ $indentation$ matchedtypeparameters . put ( tp , $whitespace$ reducedresolvedtypesbytypevariable . get ( typeparametername ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ converttypesparameters ( map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters, $whitespace$ map < string, $whitespace$ resolvedtype > $whitespace$ reducedresolvedtypesbytypevariable ) { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ matchedtypeparameters. keyset ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ typeparametername $whitespace$ = $whitespace$ tp. getname ( ) ; $newline$ $indentation$ boolean $whitespace$ replacement $whitespace$ = $whitespace$ reducedresolvedtypesbytypevariable. keyset ( ). contains ( typeparametername ) ; $newline$ $indentation$ return $whitespace$ replacement ; $newline$ $indentation$ } $newline$ $indentation$ }			
reduceResolvedTypesByTypeVariable	481	488	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.1359950602054596	LOW	"		private Map<String, ResolvedType> reduceResolvedTypesByTypeVariable(Map<String, Set<ResolvedType>> typeParameters){
		    Map<String, ResolvedType> reducedResolvedTypesList = new HashMap<>();
		    for (String typeParameterName : typeParameters.keySet()) {
		        ResolvedType type = reduceResolvedTypesWithLub(typeParameters.get(typeParameterName));
		        reducedResolvedTypesList.put(typeParameterName, type);
		    }
		    return reducedResolvedTypesList;
		}"	$indentation$ private $whitespace$ map < string , $whitespace$ resolvedtype > $whitespace$ reduceresolvedtypesbytypevariable ( map < string , $whitespace$ set < resolvedtype >> $whitespace$ typeparameters ) { $newline$ $indentation$ map < string , $whitespace$ resolvedtype > $whitespace$ reducedresolvedtypeslist $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ typeparametername $whitespace$ : $whitespace$ typeparameters . keyset ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ reduceresolvedtypeswithlub ( typeparameters . get ( typeparametername ) ) ; $newline$ $indentation$ reducedresolvedtypeslist . put ( typeparametername , $whitespace$ type ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ reducedresolvedtypeslist ; $newline$ $indentation$ }	$indentation$ private $whitespace$ map < string, $whitespace$ resolvedtype > $whitespace$ reduceresolvedtypesbytypevariable ( map < string, $whitespace$ set < resolvedtype >> $whitespace$ typeparameters ) { $newline$ $indentation$ map < string, $whitespace$ resolvedtype > $whitespace$ reducedresolvedtypeslist $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ typeparametername $whitespace$ : $whitespace$ typeparameters. keyset ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ reduceresolvedtypeswithlub ( typeparameters. get ( typeparametername ) ) ; $newline$ $indentation$ reducedresolvedtypeslist. put ( typeparametername, $whitespace$ type ) ; $newline$ $indentation$ return $whitespace$ reducedresolvedtypeslist ; $newline$ $indentation$ }			
replaceTypeParameter	419	432	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.1475784182548523	LOW	"		private MethodUsage replaceTypeParameter(MethodUsage methodUsage, Map<ResolvedTypeParameterDeclaration, ResolvedType> matchedTypeParameters){
		    // first group all resolved types by type variable
		    Map<String, Set<ResolvedType>> resolvedTypesByTypeVariable = groupResolvedTypeByTypeVariable(matchedTypeParameters);
		    // then reduce the list of resolved types with the least upper bound logic
		    Map<String, ResolvedType> reducedResolvedTypesByTypeVariable = reduceResolvedTypesByTypeVariable(resolvedTypesByTypeVariable);
		    // then replace resolved type by the reduced type for each type variable
		    convertTypesParameters(matchedTypeParameters, reducedResolvedTypesByTypeVariable);
		    // finally replace type parameters
		    for (ResolvedTypeParameterDeclaration tp : matchedTypeParameters.keySet()) {
		        methodUsage = methodUsage.replaceTypeParameter(tp, matchedTypeParameters.get(tp));
		    }
		    return methodUsage;
		}"	$indentation$ private $whitespace$ methodusage $whitespace$ replacetypeparameter ( methodusage $whitespace$ methodusage , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters ) { $newline$ $indentation$ $//·first·group·all·resolved·types·by·type·variable$ $newline$ $indentation$ map < string , $whitespace$ set < resolvedtype >> $whitespace$ resolvedtypesbytypevariable $whitespace$ = $whitespace$ groupresolvedtypebytypevariable ( matchedtypeparameters ) ; $newline$ $indentation$ $//·then·reduce·the·list·of·resolved·types·with·the·least·upper·bound·logic$ $newline$ $indentation$ map < string , $whitespace$ resolvedtype > $whitespace$ reducedresolvedtypesbytypevariable $whitespace$ = $whitespace$ reduceresolvedtypesbytypevariable ( resolvedtypesbytypevariable ) ; $newline$ $indentation$ $//·then·replace·resolved·type·by·the·reduced·type·for·each·type·variable$ $newline$ $indentation$ converttypesparameters ( matchedtypeparameters , $whitespace$ reducedresolvedtypesbytypevariable ) ; $newline$ $indentation$ $//·finally·replace·type·parameters$ $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ matchedtypeparameters . keyset ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( tp , $whitespace$ matchedtypeparameters . get ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }	$indentation$ private $whitespace$ methodusage $whitespace$ replacetypeparameter ( methodusage $whitespace$ methodusage, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ matchedtypeparameters ) { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ groupresolvedtypebytypevariable $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ groupresolvedtypebytypevariable $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ resolvedtype $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ methodusage $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ resolvedtype $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ methodusage $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ abstractdata ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ matchedtypeparameters. keyset ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage. replacetypeparameter ( tp, $whitespace$ matchedtypeparameters. get ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }			
applyInferredTypes	613	618	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodCallExprContext.java	0.2887788414955139	LOW	"		private ResolvedType applyInferredTypes(ResolvedType type, Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes){
		    for (ResolvedTypeParameterDeclaration tp : inferredTypes.keySet()) {
		        type = type.replaceTypeVariables(tp, inferredTypes.get(tp), inferredTypes);
		    }
		    return type;
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ applyinferredtypes ( resolvedtype $whitespace$ type , $whitespace$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ inferredtypes . keyset ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type . replacetypevariables ( tp , $whitespace$ inferredtypes . get ( tp ) , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ applyinferredtypes ( resolvedtype $whitespace$ type, $whitespace$ map < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype > $whitespace$ inferredtypes ) { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ inferredtypes. keyset ( ) ) $whitespace$ { $newline$ $indentation$ type $whitespace$ = $whitespace$ type. replacetypevariables ( tp, $whitespace$ inferredtypes. get ( tp ), $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type ; $newline$ $indentation$ }			
parametersExposedToChild	46	53	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodContext.java	0.6031186580657959	MID	"		@Override
		public List<Parameter> parametersExposedToChild(Node child){
		    // TODO/FIXME: Presumably the parameters must be exposed to all children and their descendants, not just the direct child?
		    if (wrappedNode.getBody().isPresent() && child == wrappedNode.getBody().get()) {
		        return wrappedNode.getParameters();
		    }
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < parameter > $whitespace$ parametersexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ $//·todo/fixme:·presumably·the·parameters·must·be·exposed·to·all·children·and·their·descendants,·not·just·the·direct·child?$ $newline$ $indentation$ if $whitespace$ ( wrappednode . getbody ( ) . ispresent ( ) $whitespace$ && $whitespace$ child $whitespace$ == $whitespace$ wrappednode . getbody ( ) . get ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode . getparameters ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < parameter > $whitespace$ parametersexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ $indentation$ $whitespace$ parametersexposedtochild $whitespace$ = $whitespace$ child. getchild ( ) ; $newline$ $indentation$ $indentation$ $whitespace$ isfieldinterface $whitespace$ = $whitespace$ parametersexposedtochild ( child ) ; $newline$ $indentation$ $whitespace$ isfieldinterface $whitespace$ = $whitespace$ znode ( child ) ; $newline$ $indentation$ if $whitespace$ ( isfieldinterface ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parametersexposedtochild ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ }			
inferArgumentTypes	99	188	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodReferenceExprContext.java	0.0002644114720169	LOW	"		private List<ResolvedType> inferArgumentTypes(){
		    if (demandParentNode(wrappedNode) instanceof MethodCallExpr) {
		        MethodCallExpr methodCallExpr = (MethodCallExpr) demandParentNode(wrappedNode);
		        MethodUsage methodUsage = JavaParserFacade.get(typeSolver).solveMethodAsUsage(methodCallExpr);
		        int pos = methodCallExpr.getArgumentPosition(wrappedNode);
		        ResolvedMethodDeclaration rmd = methodUsage.getDeclaration();
		        // Since variable parameters are represented by an array, in case we deal with
		        // the variadic parameter we have to take into account the base type of the
		        // array.
		        ResolvedType lambdaType = (rmd.hasVariadicParameter() && pos >= rmd.getNumberOfParams() - 1) ? rmd.getLastParam().getType().asArrayType().getComponentType() : methodUsage.getParamType(pos);
		        return resolveLambdaTypes(lambdaType);
		    }
		    if (demandParentNode(wrappedNode) instanceof ObjectCreationExpr) {
		        ObjectCreationExpr objectCreationExpr = (ObjectCreationExpr) demandParentNode(wrappedNode);
		        ResolvedConstructorDeclaration rcd = JavaParserFacade.get(typeSolver).solve(objectCreationExpr).getCorrespondingDeclaration();
		        int pos = objectCreationExpr.getArgumentPosition(wrappedNode);
		        // Since variable parameters are represented by an array, in case we deal with
		        // the variadic parameter we have to take into account the base type of the
		        // array.
		        ResolvedType lambdaType = (rcd.hasVariadicParameter() && pos >= rcd.getNumberOfParams() - 1) ? rcd.getLastParam().getType().asArrayType().getComponentType() : rcd.getParam(pos).getType();
		        return resolveLambdaTypes(lambdaType);
		    }
		    if (demandParentNode(wrappedNode) instanceof VariableDeclarator) {
		        VariableDeclarator variableDeclarator = (VariableDeclarator) demandParentNode(wrappedNode);
		        ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(variableDeclarator.getType());
		        Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);
		        if (functionalMethod.isPresent()) {
		            List<ResolvedType> resolvedTypes = new ArrayList<>();
		            for (ResolvedType lambdaType : functionalMethod.get().getParamTypes()) {
		                // Replace parameter from declarator
		                Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		                if (lambdaType.isReferenceType()) {
		                    for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {
		                        if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {
		                            ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);
		                            lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);
		                        }
		                    }
		                } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {
		                    lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());
		                }
		                resolvedTypes.add(lambdaType);
		            }
		            return resolvedTypes;
		        }
		        throw new UnsupportedOperationException();
		    }
		    if (demandParentNode(wrappedNode) instanceof ReturnStmt) {
		        ReturnStmt returnStmt = (ReturnStmt) demandParentNode(wrappedNode);
		        Optional<MethodDeclaration> optDeclaration = returnStmt.findAncestor(MethodDeclaration.class);
		        if (optDeclaration.isPresent()) {
		            ResolvedType t = JavaParserFacade.get(typeSolver).convertToUsage(optDeclaration.get().asMethodDeclaration().getType());
		            Optional<MethodUsage> functionalMethod = FunctionalInterfaceLogic.getFunctionalMethod(t);
		            if (functionalMethod.isPresent()) {
		                List<ResolvedType> resolvedTypes = new ArrayList<>();
		                for (ResolvedType lambdaType : functionalMethod.get().getParamTypes()) {
		                    // Replace parameter from declarator
		                    Map<ResolvedTypeParameterDeclaration, ResolvedType> inferredTypes = new HashMap<>();
		                    if (lambdaType.isReferenceType()) {
		                        for (com.github.javaparser.utils.Pair<ResolvedTypeParameterDeclaration, ResolvedType> entry : lambdaType.asReferenceType().getTypeParametersMap()) {
		                            if (entry.b.isTypeVariable() && entry.b.asTypeParameter().declaredOnType()) {
		                                ResolvedType ot = t.asReferenceType().typeParametersMap().getValue(entry.a);
		                                lambdaType = lambdaType.replaceTypeVariables(entry.a, ot, inferredTypes);
		                            }
		                        }
		                    } else if (lambdaType.isTypeVariable() && lambdaType.asTypeParameter().declaredOnType()) {
		                        lambdaType = t.asReferenceType().typeParametersMap().getValue(lambdaType.asTypeParameter());
		                    }
		                    resolvedTypes.add(lambdaType);
		                }
		                return resolvedTypes;
		            }
		            throw new UnsupportedOperationException();
		        }
		        throw new UnsupportedOperationException();
		    }
		    throw new UnsupportedOperationException();
		}"	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ inferargumenttypes ( ) { $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ methodcallexpr $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . solvemethodasusage ( methodcallexpr ) ; $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ methodcallexpr . getargumentposition ( wrappednode ) ; $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ rmd $whitespace$ = $whitespace$ methodusage . getdeclaration ( ) ; $newline$ $indentation$ $//·since·variable·parameters·are·represented·by·an·array,·in·case·we·deal·with$ $newline$ $indentation$ $//·the·variadic·parameter·we·have·to·take·into·account·the·base·type·of·the$ $newline$ $indentation$ $//·array.$ $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ ( rmd . hasvariadicparameter ( ) $whitespace$ && $whitespace$ pos $whitespace$ >= $whitespace$ rmd . getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$ ? $whitespace$ rmd . getlastparam ( ) . gettype ( ) . asarraytype ( ) . getcomponenttype ( ) $whitespace$ : $whitespace$ methodusage . getparamtype ( pos ) ; $newline$ $indentation$ return $whitespace$ resolvelambdatypes ( lambdatype ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ objectcreationexpr $whitespace$ objectcreationexpr $whitespace$ = $whitespace$ ( objectcreationexpr ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ resolvedconstructordeclaration $whitespace$ rcd $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . solve ( objectcreationexpr ) . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ objectcreationexpr . getargumentposition ( wrappednode ) ; $newline$ $indentation$ $//·since·variable·parameters·are·represented·by·an·array,·in·case·we·deal·with$ $newline$ $indentation$ $//·the·variadic·parameter·we·have·to·take·into·account·the·base·type·of·the$ $newline$ $indentation$ $//·array.$ $newline$ $indentation$ resolvedtype $whitespace$ lambdatype $whitespace$ = $whitespace$ ( rcd . hasvariadicparameter ( ) $whitespace$ && $whitespace$ pos $whitespace$ >= $whitespace$ rcd . getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$ ? $whitespace$ rcd . getlastparam ( ) . gettype ( ) . asarraytype ( ) . getcomponenttype ( ) $whitespace$ : $whitespace$ rcd . getparam ( pos ) . gettype ( ) ; $newline$ $indentation$ return $whitespace$ resolvelambdatypes ( lambdatype ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ variabledeclarator ) $whitespace$ { $newline$ $indentation$ variabledeclarator $whitespace$ variabledeclarator $whitespace$ = $whitespace$ ( variabledeclarator ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( variabledeclarator . gettype ( ) ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( t ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ list < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ lambdatype $whitespace$ : $whitespace$ functionalmethod . get ( ) . getparamtypes ( ) ) $whitespace$ { $newline$ $indentation$ $//·replace·parameter·from·declarator$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( lambdatype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . utils . pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ lambdatype . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . b . istypevariable ( ) $whitespace$ && $whitespace$ entry . b . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ot $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( entry . a ) ; $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ lambdatype . replacetypevariables ( entry . a , $whitespace$ ot , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdatype . istypevariable ( ) $whitespace$ && $whitespace$ lambdatype . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( lambdatype . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypes . add ( lambdatype ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedtypes ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ returnstmt ) $whitespace$ { $newline$ $indentation$ returnstmt $whitespace$ returnstmt $whitespace$ = $whitespace$ ( returnstmt ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ optional < methoddeclaration > $whitespace$ optdeclaration $whitespace$ = $whitespace$ returnstmt . findancestor ( methoddeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( optdeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . converttousage ( optdeclaration . get ( ) . asmethoddeclaration ( ) . gettype ( ) ) ; $newline$ $indentation$ optional < methodusage > $whitespace$ functionalmethod $whitespace$ = $whitespace$ functionalinterfacelogic . getfunctionalmethod ( t ) ; $newline$ $indentation$ if $whitespace$ ( functionalmethod . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ list < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ lambdatype $whitespace$ : $whitespace$ functionalmethod . get ( ) . getparamtypes ( ) ) $whitespace$ { $newline$ $indentation$ $//·replace·parameter·from·declarator$ $newline$ $indentation$ map < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ inferredtypes $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ if $whitespace$ ( lambdatype . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . utils . pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype > $whitespace$ entry $whitespace$ : $whitespace$ lambdatype . asreferencetype ( ) . gettypeparametersmap ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( entry . b . istypevariable ( ) $whitespace$ && $whitespace$ entry . b . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ot $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( entry . a ) ; $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ lambdatype . replacetypevariables ( entry . a , $whitespace$ ot , $whitespace$ inferredtypes ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( lambdatype . istypevariable ( ) $whitespace$ && $whitespace$ lambdatype . astypeparameter ( ) . declaredontype ( ) ) $whitespace$ { $newline$ $indentation$ lambdatype $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersmap ( ) . getvalue ( lambdatype . astypeparameter ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypes . add ( lambdatype ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedtypes ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ inferargumenttypes ( ) { $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ methodcallexpr ) $whitespace$ { $newline$ $indentation$ methodcallexpr $whitespace$ methodcallexpr $whitespace$ = $whitespace$ ( methodcallexpr ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). solvemethodasusage ( methodcallexpr ) ; $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ methodcallexpr. getargumentposition ( wrappednode ) ; $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ rmd $whitespace$ = $whitespace$ methodusage. getdeclaration ( ) ; $newline$ $indentation$ $whitespace$////////////////////////////////////since $whitespace$ = $whitespace$ methodusage. getdeclaration ( ) ; $newline$ $indentation$ $whitespace$// $whitespace$ = $whitespace$ ( rmd. hasvariadicparameter ( ) $whitespace$ && $whitespace$ pos $whitespace$ >= $whitespace$ rmd. getnumberofparams ( ) $whitespace$ - $whitespace$ $number$ ) $whitespace$? $whitespace$ rmd. getlastparam ( ). gettype ( ). asarraytype ( ). getcomponenttype ( ) $whitespace$ : $whitespace$ methodusage. getparamtype ( pos ) ; $newline$ $indentation$ return $whitespace$ resolvelambdatypes ( lambdatype ) ; $newline$ $indentation$			
solveMethod	63	93	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/MethodReferenceExprContext.java	0.2394434213638305	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    if (""new"".equals(name)) {
		        throw new UnsupportedOperationException(""Constructor calls not yet resolvable"");
		    }
		    argumentsTypes.addAll(inferArgumentTypes());
		    Collection<ResolvedReferenceTypeDeclaration> rrtds = findTypeDeclarations(Optional.of(wrappedNode.getScope()));
		    if (rrtds.isEmpty()) {
		        // if the bounds of a type parameter are empty, then the bound is implicitly ""extends Object""
		        // we don't make this _ex_plicit in the data representation because that would affect codegen
		        // and make everything generate like <T extends Object> instead of <T>
		        // https://github.com/javaparser/javaparser/issues/2044
		        rrtds = Collections.singleton(typeSolver.getSolvedJavaLangObject());
		    }
		    for (ResolvedReferenceTypeDeclaration rrtd : rrtds) {
		        SymbolReference<ResolvedMethodDeclaration> firstResAttempt = MethodResolutionLogic.solveMethodInType(rrtd, name, argumentsTypes, false);
		        if (firstResAttempt.isSolved()) {
		            return firstResAttempt;
		        }
		        SymbolReference<ResolvedMethodDeclaration> secondResAttempt = MethodResolutionLogic.solveMethodInType(rrtd, name, Collections.emptyList(), false);
		        if (secondResAttempt.isSolved()) {
		            return secondResAttempt;
		        }
		    }
		    return SymbolReference.unsolved();
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( name ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ argumentstypes . addall ( inferargumenttypes ( ) ) ; $newline$ $indentation$ collection < resolvedreferencetypedeclaration > $whitespace$ rrtds $whitespace$ = $whitespace$ findtypedeclarations ( optional . of ( wrappednode . getscope ( ) ) ) ; $newline$ $indentation$ if $whitespace$ ( rrtds . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·the·bounds·of·a·type·parameter·are·empty,·then·the·bound·is·implicitly·""extends·object""$ $newline$ $indentation$ $//·we·don't·make·this·_ex_plicit·in·the·data·representation·because·that·would·affect·codegen$ $newline$ $indentation$ $//·and·make·everything·generate·like·<t·extends·object>·instead·of·<t>$ $newline$ $indentation$ $//·https://github.com/javaparser/javaparser/issues/2044$ $newline$ $indentation$ rrtds $whitespace$ = $whitespace$ collections . singleton ( typesolver . getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetypedeclaration $whitespace$ rrtd $whitespace$ : $whitespace$ rrtds ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ firstresattempt $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( rrtd , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( firstresattempt . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ firstresattempt ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ secondresattempt $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( rrtd , $whitespace$ name , $whitespace$ collections . emptylist ( ) , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( secondresattempt . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ secondresattempt ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ if $whitespace$ ( $string$. equals ( name ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ argumentstypes. addall ( inferargumenttypes ( ) ) ; $newline$ $indentation$ collection < resolvedreferencetypedeclaration > $whitespace$ rrtds $whitespace$ = $whitespace$ findtypedeclarations ( optional. of ( wrappednode. getscope ( ) ) ) ; $newline$ $indentation$ if $whitespace$ ( rrtds. isempty ( ) ) $whitespace$ { $newline$ $indentation$ $////g$if $whitespace$ = $whitespace$ findtypedeclarations ( optional. of ( wrappednode. getscope ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ else $whitespace$ { $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ if $whitespace$ there $whitespace$ is $whitespace$ a $whitespace$ correct $whitespace$ cors $whitespace$ request $whitespace$ $newline$ $indentation$ boolean $whitespace			
solveSymbol	203	313	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.0130231967195868	LOW	"		private SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, boolean iterateAdjacentStmts){
		    /*
		         * If we're in a variable declaration line.
		         * Example: {@code double a=0, b=a;}
		         * Example: {@code a instanceof String s;}
		         */
		    SymbolDeclarator symbolDeclarator = JavaParserFactory.getSymbolDeclarator(wrappedNode, typeSolver);
		    SymbolReference<? extends ResolvedValueDeclaration> symbolReference = solveWith(symbolDeclarator, name);
		    if (symbolReference.isSolved()) {
		        return symbolReference;
		    }
		    /*
		         * If we're in a statement that contains a pattern expression.
		         * Example: {@code double x = a instanceof String s;}
		         */
		    List<PatternExpr> patternExprs = patternExprsExposedFromChildren();
		    for (int i = 0; i < patternExprs.size(); i++) {
		        PatternExpr patternExpr = patternExprs.get(i);
		        if (patternExpr.getNameAsString().equals(name)) {
		            return SymbolReference.solved(JavaParserSymbolDeclaration.patternVar(patternExpr, typeSolver));
		        }
		    }
		    Optional<Node> optionalParentNode = wrappedNode.getParentNode();
		    if (!optionalParentNode.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    Node parentOfWrappedNode = optionalParentNode.get();
		    if (parentOfWrappedNode instanceof MethodDeclaration) {
		        return solveSymbolInParentContext(name);
		    }
		    if (parentOfWrappedNode instanceof ConstructorDeclaration) {
		        return solveSymbolInParentContext(name);
		    }
		    if (parentOfWrappedNode instanceof LambdaExpr) {
		        return solveSymbolInParentContext(name);
		    }
		    if (parentOfWrappedNode instanceof NodeWithStatements) {
		        // If we choose to not solve adjacent statements abort the solution process here.
		        // In the calling context (the context that calls this) we will attempt to
		        // resolve all prior adjacent statements, and then the common parent as the fallback.
		        // Then the common parent will check all of its prior adjacent statements, etc.
		        // Further below is a more detailed explanation for why we may want to disable this visitation of adjacent statements
		        // to prevent revisiting the same contexts over and over again.
		        if (!iterateAdjacentStmts) {
		            return SymbolReference.unsolved();
		        }
		        NodeWithStatements<?> nodeWithStmt = (NodeWithStatements<?>) parentOfWrappedNode;
		        // Assuming the wrapped node exists within the parent's collection of statements...
		        int position = nodeWithStmt.getStatements().indexOf(wrappedNode);
		        if (position == -1) {
		            throw new IllegalStateException(""This node is not a statement within the current NodeWithStatements"");
		        }
		        // Start at the current node and work backwards...
		        ListIterator<Statement> statementListIterator = nodeWithStmt.getStatements().listIterator(position);
		        while (statementListIterator.hasPrevious()) {
		            Context prevContext = JavaParserFactory.getContext(statementListIterator.previous(), typeSolver);
		            if (prevContext instanceof BlockStmtContext) {
		                // Issue #3631
		                // We have an explicit check for ""BlockStmtContext"" to avoid resolving the variable x with the
		                // declaration defined in the block preceding the use of the variable
		                // For example consider the following:
		                //
		                // int x = 0;
		                // void method() {
		                // {
		                // var x = 1;
		                // System.out.println(x); // prints 1
		                // }
		                // System.out.println(x); // prints 0
		                // }
		                continue;
		            }
		            if (prevContext instanceof StatementContext) {
		                // We have an explicit check for ""StatementContext"" to prevent a factorial increase of visited statements.
		                //
		                // For example consider the following:
		                //   String a = ""a"";
		                //   String b = ""b"";
		                //   String c = get();
		                //
		                // If we simply call ""prevContext.solveSymbol(name)"" we will call the current method with the adjacent statement ""prevContext"".
		                // Then ""prevContext"" will look at its previous adjacent statement. And so on and so forth.
		                // When there are no more previous statements in this chain of method calls, we come back to here...
		                // Then we look at the next ""prevContext"" which causes the entire process to start again.
		                // This is how we get a factorial increase in calls to ""solveSymbol"".
		                //
		                // So what we do instead with this check is we pass in a flag to say ""Do not look at previous adjacent statements"".
		                // Since each visited ""prevContext"" does not look at its adjacent statements we only visit each statement once in this while loop.
		                symbolReference = ((StatementContext<?>) prevContext).solveSymbol(name, false);
		            } else {
		                symbolReference = prevContext.solveSymbol(name);
		            }
		            if (symbolReference.isSolved()) {
		                return symbolReference;
		            }
		        }
		    }
		    // If nothing is found, attempt to solve within the parent context
		    return solveSymbolInParentContext(name);
		}"	"$indentation$ private $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name , $whitespace$ boolean $whitespace$ iterateadjacentstmts ) { $newline$ $indentation$ $/*············*·if·we're·in·a·variable·declaration·line.············*·example:·{@code·double·a=0,·b=a;}············*·example:·{@code·a·instanceof·string·s;}············*/$ $newline$ $indentation$ symboldeclarator $whitespace$ symboldeclarator $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( wrappednode , $whitespace$ typesolver ) ; $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewith ( symboldeclarator , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ $/*············*·if·we're·in·a·statement·that·contains·a·pattern·expression.············*·example:·{@code·double·x·=·a·instanceof·string·s;}············*/$ $newline$ $indentation$ list < patternexpr > $whitespace$ patternexprs $whitespace$ = $whitespace$ patternexprsexposedfromchildren ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ patternexprs . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ patternexpr $whitespace$ patternexpr $whitespace$ = $whitespace$ patternexprs . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( patternexpr . getnameasstring ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparsersymboldeclaration . patternvar ( patternexpr , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ optional < node > $whitespace$ optionalparentnode $whitespace$ = $whitespace$ wrappednode . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentnode . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ constructordeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) $whitespace$ { $newline$ $indentation$ $//·if·we·choose·to·not·solve·adjacent·statements·abort·the·solution·process·here.$ $newline$ $indentation$ $//·in·the·calling·context·(the·context·that·calls·this)·we·will·attempt·to$ $newline$ $indentation$ $//·resolve·all·prior·adjacent·statements,·and·then·the·common·parent·as·the·fallback.$ $newline$ $indentation$ $//·then·the·common·parent·will·check·all·of·its·prior·adjacent·statements,·etc.$ $newline$ $indentation$ $//·further·below·is·a·more·detailed·explanation·for·why·we·may·want·to·disable·this·visitation·of·adjacent·statements$ $newline$ $indentation$ $//·to·prevent·revisiting·the·same·contexts·over·and·over·again.$ $newline$ $indentation$ if $whitespace$ ( ! iterateadjacentstmts ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements < ? > $whitespace$ nodewithstmt $whitespace$ = $whitespace$ ( nodewithstatements < ? > ) $whitespace$ parentofwrappednode ; $newline$ $indentation$ $//·assuming·the·wrapped·node·exists·within·the·parent's·collection·of·statements...$ $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ nodewithstmt . getstatements ( ) . indexof ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·start·at·the·current·node·and·work·backwards...$ $newline$ $indentation$ listiterator < statement > $whitespace$ statementlistiterator $whitespace$ = $whitespace$ nodewithstmt . getstatements ( ) . listiterator ( position ) ; $newline$ $indentation$ while $whitespace$ ( statementlistiterator . hasprevious ( ) ) $whitespace$ { $newline$ $indentation$ context $whitespace$ prevcontext $whitespace$ = $whitespace$ javaparserfactory . getcontext ( statementlistiterator . previous ( ) , $whitespace$ typesolver ) ; $newline$ $indentation$ if $whitespace$ ( prevcontext $whitespace$ instanceof $whitespace$ blockstmtcontext ) $whitespace$ { $newline$ $indentation$ $//·issue·#3631$ $newline$ $indentation$ $//·we·have·an·explicit·check·for·""blockstmtcontext""·to·avoid·resolving·the·variable·x·with·the$ $newline$ $indentation$ $//·declaration·defined·in·the·block·preceding·the·use·of·the·variable$ $newline$ $indentation$ $//·for·example·consider·the·following:$ $newline$ $indentation$ // $newline$ $indentation$ $//·int·x·=·0;$ $newline$ $indentation$ $//·void·method()·{$ $newline$ $indentation$ $//·{$ $newline$ $indentation$ $//·var·x·=·1;$ $newline$ $indentation$ $//·system.out.println(x);·//·prints·1$ $newline$ $indentation$ $//·}$ $newline$ $indentation$ $//·system.out.println(x);·//·prints·0$ $newline$ $indentation$ $//·}$ $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( prevcontext $whitespace$ instanceof $whitespace$ statementcontext ) $whitespace$ { $newline$ $indentation$ $//·we·have·an·explicit·check·for·""statementcontext""·to·prevent·a·factorial·increase·of·visited·statements.$ $newline$ $indentation$ // $newline$ $indentation$ $//·for·example·consider·the·following:$ $newline$ $indentation$ $//···string·a·=·""a"";$ $newline$ $indentation$ $//···string·b·=·""b"";$ $newline$ $indentation$ $//···string·c·=·get();$ $newline$ $indentation$ // $newline$ $indentation$ $//·if·we·simply·call·""prevcontext.solvesymbol(name)""·we·will·call·the·current·method·with·the·adjacent·statement·""prevcontext"".$ $newline$ $indentation$ $//·then·""prevcontext""·will·look·at·its·previous·adjacent·statement.·and·so·on·and·so·forth.$ $newline$ $indentation$ $//·when·there·are·no·more·previous·statements·in·this·chain·of·method·calls,·we·come·back·to·here...$ $newline$ $indentation$ $//·then·we·look·at·the·next·""prevcontext""·which·causes·the·entire·process·to·start·again.$ $newline$ $indentation$ $//·this·is·how·we·get·a·factorial·increase·in·calls·to·""solvesymbol"".$ $newline$ $indentation$ // $newline$ $indentation$ $//·so·what·we·do·instead·with·this·check·is·we·pass·in·a·flag·to·say·""do·not·look·at·previous·adjacent·statements"".$ $newline$ $indentation$ $//·since·each·visited·""prevcontext""·does·not·look·at·its·adjacent·statements·we·only·visit·each·statement·once·in·this·while·loop.$ $newline$ $indentation$ symbolreference $whitespace$ = $whitespace$ ( ( statementcontext < ? > ) $whitespace$ prevcontext ) . solvesymbol ( name , $whitespace$ false ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ symbolreference $whitespace$ = $whitespace$ prevcontext . solvesymbol ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( symbolreference . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found,·attempt·to·solve·within·the·parent·context$ $newline$ $indentation$ return $whitespace$ solvesymbolinparentcontext ( name ) ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name, $whitespace$ boolean $whitespace$ iterateadjacentstmts ) { $newline$ $indentation$ $/* $whitespace$ = $whitespace$ sizespace$ of $whitespace$ parsers $newline$ $indentation$. getsymboldeclarator ( wrappednode, $whitespace$ typesolver ) ; $newline$ $indentation$ node $whitespace$ = $whitespace$ new $whitespace$ node ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ $/* $whitespace$ = $whitespace$$$clenode ( $newline$ $indentation$ javaparserfactory. getsymboldeclarator ( wrappednode, $whitespace$ typesolver ) ; $newline$ $indentation$ ///* $newline$ $indentation$ $/* $whitespace$ = $whitespace$$ rhsreference $whitespace$ = $whitespace$ gettarget( ( typesolver ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ $/* ; $newline$ $indentation$ } $newline$ $indentation$			
solveSymbolAsValue	122	181	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.0375029630959034	LOW	"		@Override
		public Optional<Value> solveSymbolAsValue(String name){
		    // if we're in a multiple Variable declaration line (for ex: double a=0, b=a;)
		    SymbolDeclarator symbolDeclarator = JavaParserFactory.getSymbolDeclarator(wrappedNode, typeSolver);
		    Optional<Value> symbolReference = solveWithAsValue(symbolDeclarator, name);
		    if (symbolReference.isPresent()) {
		        return symbolReference;
		    }
		    // If there is no parent
		    if (!getParent().isPresent()) {
		        return Optional.empty();
		    }
		    Context parentContext = getParent().get();
		    Optional<Node> optionalParentNode = wrappedNode.getParentNode();
		    if (!optionalParentNode.isPresent()) {
		        return Optional.empty();
		    }
		    Node parentOfWrappedNode = optionalParentNode.get();
		    if (parentOfWrappedNode instanceof MethodDeclaration) {
		        return parentContext.solveSymbolAsValue(name);
		    }
		    if (parentOfWrappedNode instanceof LambdaExpr) {
		        return parentContext.solveSymbolAsValue(name);
		    }
		    if (!(parentOfWrappedNode instanceof NodeWithStatements)) {
		        return parentContext.solveSymbolAsValue(name);
		    }
		    NodeWithStatements<?> nodeWithStmt = (NodeWithStatements<?>) parentOfWrappedNode;
		    int position = -1;
		    // Get the position of the wrapped node.
		    for (int i = 0; i < nodeWithStmt.getStatements().size(); i++) {
		        if (nodeWithStmt.getStatements().get(i).equals(wrappedNode)) {
		            position = i;
		        }
		    }
		    if (position == -1) {
		        throw new RuntimeException();
		    }
		    // Working backwards from the node, try to solve the symbol. This limits the scope to declarations that appear prior to usage.
		    for (int statementIndex = position - 1; statementIndex >= 0; statementIndex--) {
		        Statement statement = nodeWithStmt.getStatements().get(statementIndex);
		        symbolDeclarator = JavaParserFactory.getSymbolDeclarator(statement, typeSolver);
		        symbolReference = solveWithAsValue(symbolDeclarator, name);
		        if (symbolReference.isPresent()) {
		            return symbolReference;
		        }
		    }
		    // If nothing is found we should ask the grand parent context.
		    return parentContext.getParent().map(context -> context.solveSymbolAsValue(name)).orElse(Optional.empty());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ $//·if·we're·in·a·multiple·variable·declaration·line·(for·ex:·double·a=0,·b=a;)$ $newline$ $indentation$ symboldeclarator $whitespace$ symboldeclarator $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( wrappednode , $whitespace$ typesolver ) ; $newline$ $indentation$ optional < value > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewithasvalue ( symboldeclarator , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·there·is·no·parent$ $newline$ $indentation$ if $whitespace$ ( ! getparent ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ context $whitespace$ parentcontext $whitespace$ = $whitespace$ getparent ( ) . get ( ) ; $newline$ $indentation$ optional < node > $whitespace$ optionalparentnode $whitespace$ = $whitespace$ wrappednode . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentnode . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode . get ( ) ; $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ methoddeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentcontext . solvesymbolasvalue ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentofwrappednode $whitespace$ instanceof $whitespace$ lambdaexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentcontext . solvesymbolasvalue ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentcontext . solvesymbolasvalue ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements < ? > $whitespace$ nodewithstmt $whitespace$ = $whitespace$ ( nodewithstatements < ? > ) $whitespace$ parentofwrappednode ; $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·get·the·position·of·the·wrapped·node.$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ nodewithstmt . getstatements ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nodewithstmt . getstatements ( ) . get ( i ) . equals ( wrappednode ) ) $whitespace$ { $newline$ $indentation$ position $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·working·backwards·from·the·node,·try·to·solve·the·symbol.·this·limits·the·scope·to·declarations·that·appear·prior·to·usage.$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ statementindex $whitespace$ = $whitespace$ position $whitespace$ - $whitespace$ $number$ ; $whitespace$ statementindex $whitespace$ >= $whitespace$ $number$ ; $whitespace$ statementindex -- ) $whitespace$ { $newline$ $indentation$ statement $whitespace$ statement $whitespace$ = $whitespace$ nodewithstmt . getstatements ( ) . get ( statementindex ) ; $newline$ $indentation$ symboldeclarator $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( statement , $whitespace$ typesolver ) ; $newline$ $indentation$ symbolreference $whitespace$ = $whitespace$ solvewithasvalue ( symboldeclarator , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·grand·parent·context.$ $newline$ $indentation$ return $whitespace$ parentcontext . getparent ( ) . map ( context $whitespace$ - > $whitespace$ context . solvesymbolasvalue ( name ) ) . orelse ( optional . empty ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ $whitespace$ return $whitespace$ optionalparent ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < value > $whitespace$ solvesymbolasvalue ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( symbolreference. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ val $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewithasvalue ( symboldeclarator, $whitespace$ name ) ; $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode. get ( ) ; $newline$ $indentation$ if $whitespace$ (			
solveInBlockAsValue	89	120	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.0607320852577686	LOW	"		public static Optional<Value> solveInBlockAsValue(String name, TypeSolver typeSolver, Statement stmt){
		    Optional<Node> optionalParentNode = stmt.getParentNode();
		    if (!optionalParentNode.isPresent()) {
		        return Optional.empty();
		    }
		    Node parentOfWrappedNode = optionalParentNode.get();
		    if (!(parentOfWrappedNode instanceof NodeWithStatements)) {
		        throw new IllegalArgumentException();
		    }
		    NodeWithStatements<?> blockStmt = (NodeWithStatements<?>) parentOfWrappedNode;
		    int position = -1;
		    for (int i = 0; i < blockStmt.getStatements().size(); i++) {
		        if (blockStmt.getStatements().get(i).equals(stmt)) {
		            position = i;
		        }
		    }
		    if (position == -1) {
		        throw new RuntimeException();
		    }
		    for (int i = position - 1; i >= 0; i--) {
		        SymbolDeclarator symbolDeclarator = JavaParserFactory.getSymbolDeclarator(blockStmt.getStatements().get(i), typeSolver);
		        SymbolReference<? extends ResolvedValueDeclaration> symbolReference = solveWith(symbolDeclarator, name);
		        if (symbolReference.isSolved()) {
		            return Optional.of(Value.from(symbolReference.getCorrespondingDeclaration()));
		        }
		    }
		    // if nothing is found we should ask the parent context
		    return JavaParserFactory.getContext(parentOfWrappedNode, typeSolver).solveSymbolAsValue(name);
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < value > $whitespace$ solveinblockasvalue ( string $whitespace$ name , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ statement $whitespace$ stmt ) { $newline$ $indentation$ optional < node > $whitespace$ optionalparentnode $whitespace$ = $whitespace$ stmt . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentnode . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements < ? > $whitespace$ blockstmt $whitespace$ = $whitespace$ ( nodewithstatements < ? > ) $whitespace$ parentofwrappednode ; $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ blockstmt . getstatements ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( blockstmt . getstatements ( ) . get ( i ) . equals ( stmt ) ) $whitespace$ { $newline$ $indentation$ position $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ position $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ symboldeclarator $whitespace$ symboldeclarator $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( blockstmt . getstatements ( ) . get ( i ) , $whitespace$ typesolver ) ; $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewith ( symboldeclarator , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( value . from ( symbolreference . getcorrespondingdeclaration ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·parent·context$ $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( parentofwrappednode , $whitespace$ typesolver ) . solvesymbolasvalue ( name ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < value > $whitespace$ solveinblockasvalue ( string $whitespace$ name, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ statement $whitespace$ stmt ) { $newline$ $indentation$ optional < node > $whitespace$ optionalparentnode $whitespace$ = $whitespace$ stmt. getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! optionalparentnode. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements <? > $whitespace$ blockstmt $whitespace$ = $whitespace$ optionalparentnode. get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements <? > $whitespace$ blockstmt $whitespace$ = $whitespace$ optionalparentnode. get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ position $whitespace$ position $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ blockstmt. getstatements ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( blockstmt. getstatements ( ). get ( i ). equals ( stmt ) ) $whitespace$ { $newline$ $indentation$ position $whitespace$ = $whitespace$ i ; $newline			
solveInBlock	56	87	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.0697947219014167	LOW	"		public static SymbolReference<? extends ResolvedValueDeclaration> solveInBlock(String name, TypeSolver typeSolver, Statement stmt){
		    Optional<Node> optionalParentNode = stmt.getParentNode();
		    if (!optionalParentNode.isPresent()) {
		        return SymbolReference.unsolved();
		    }
		    Node parentOfWrappedNode = optionalParentNode.get();
		    if (!(parentOfWrappedNode instanceof NodeWithStatements)) {
		        throw new IllegalArgumentException();
		    }
		    NodeWithStatements<?> blockStmt = (NodeWithStatements<?>) parentOfWrappedNode;
		    int position = -1;
		    for (int i = 0; i < blockStmt.getStatements().size(); i++) {
		        if (blockStmt.getStatements().get(i).equals(stmt)) {
		            position = i;
		        }
		    }
		    if (position == -1) {
		        throw new RuntimeException();
		    }
		    for (int i = position - 1; i >= 0; i--) {
		        SymbolDeclarator symbolDeclarator = JavaParserFactory.getSymbolDeclarator(blockStmt.getStatements().get(i), typeSolver);
		        SymbolReference<? extends ResolvedValueDeclaration> symbolReference = solveWith(symbolDeclarator, name);
		        if (symbolReference.isSolved()) {
		            return symbolReference;
		        }
		    }
		    // if nothing is found we should ask the parent context
		    return JavaParserFactory.getContext(parentOfWrappedNode, typeSolver).solveSymbol(name);
		}"	$indentation$ public $whitespace$ static $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solveinblock ( string $whitespace$ name , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ statement $whitespace$ stmt ) { $newline$ $indentation$ optional < node > $whitespace$ optionalparentnode $whitespace$ = $whitespace$ stmt . getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( ! optionalparentnode . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode . get ( ) ; $newline$ $indentation$ if $whitespace$ ( ! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements < ? > $whitespace$ blockstmt $whitespace$ = $whitespace$ ( nodewithstatements < ? > ) $whitespace$ parentofwrappednode ; $newline$ $indentation$ int $whitespace$ position $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ blockstmt . getstatements ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( blockstmt . getstatements ( ) . get ( i ) . equals ( stmt ) ) $whitespace$ { $newline$ $indentation$ position $whitespace$ = $whitespace$ i ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( position $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ position $whitespace$ - $whitespace$ $number$ ; $whitespace$ i $whitespace$ >= $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ symboldeclarator $whitespace$ symboldeclarator $whitespace$ = $whitespace$ javaparserfactory . getsymboldeclarator ( blockstmt . getstatements ( ) . get ( i ) , $whitespace$ typesolver ) ; $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ symbolreference $whitespace$ = $whitespace$ solvewith ( symboldeclarator , $whitespace$ name ) ; $newline$ $indentation$ if $whitespace$ ( symbolreference . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·nothing·is·found·we·should·ask·the·parent·context$ $newline$ $indentation$ return $whitespace$ javaparserfactory . getcontext ( parentofwrappednode , $whitespace$ typesolver ) . solvesymbol ( name ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solveinblock ( string $whitespace$ name, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ statement $whitespace$ stmt ) { $newline$ $indentation$ node $whitespace$ parentofwrappednode $whitespace$ = $whitespace$ optionalparentnode. getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements <? > $whitespace$ blockstmt $whitespace$ = $whitespace$ optionalparentnode. get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ nodewithstatements <? > $whitespace$ blockstmt $whitespace$ = $whitespace$ optionalparentnode. get ( ) ; $newline$ $indentation$ if $whitespace$ (! ( parentofwrappednode $whitespace$ instanceof $whitespace$ nodewithstatements ) ) $whitespace$ { $newline$ $indentation$ break ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$			
solveMethod	315	319	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
negatedPatternExprsExposedFromChildren	329	333	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/StatementContext.java	0.731635570526123	MID	"		@Override
		public List<PatternExpr> negatedPatternExprsExposedFromChildren(){
		    // Statements never make pattern expressions available.
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ negatedpatternexprsexposedfromchildren ( ) { $newline$ $indentation$ $//·statements·never·make·pattern·expressions·available.$ $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ 256patternexprsexposedfromchildren ( ) { $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ }			
solveMethod	95	99	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/SwitchEntryContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
localVariablesExposedToChild	96	118	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/TryWithResourceContext.java	0.0150753213092684	LOW	"		@Override
		public List<VariableDeclarator> localVariablesExposedToChild(Node child){
		    NodeList<Expression> resources = wrappedNode.getResources();
		    for (int i = 0; i < resources.size(); i++) {
		        if (child == resources.get(i)) {
		            return resources.subList(0, i).stream().map(e -> e instanceof VariableDeclarationExpr ? ((VariableDeclarationExpr) e).getVariables() : Collections.<VariableDeclarator>emptyList()).flatMap(List::stream).collect(Collectors.toList());
		        }
		    }
		    if (child == wrappedNode.getTryBlock()) {
		        List<VariableDeclarator> res = new LinkedList<>();
		        for (Expression expr : resources) {
		            if (expr instanceof VariableDeclarationExpr) {
		                res.addAll(((VariableDeclarationExpr) expr).getVariables());
		            }
		        }
		        return res;
		    }
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ nodelist < expression > $whitespace$ resources $whitespace$ = $whitespace$ wrappednode . getresources ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resources . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ resources . get ( i ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resources . sublist ( $number$ , $whitespace$ i ) . stream ( ) . map ( e $whitespace$ - > $whitespace$ e $whitespace$ instanceof $whitespace$ variabledeclarationexpr $whitespace$ ? $whitespace$ ( ( variabledeclarationexpr ) $whitespace$ e ) . getvariables ( ) $whitespace$ : $whitespace$ collections . < variabledeclarator > emptylist ( ) ) . flatmap ( list : : stream ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ wrappednode . gettryblock ( ) ) $whitespace$ { $newline$ $indentation$ list < variabledeclarator > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ expr $whitespace$ : $whitespace$ resources ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expr $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ res . addall ( ( ( variabledeclarationexpr ) $whitespace$ expr ) . getvariables ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ nodelist < expression > $whitespace$ resources $whitespace$ = $whitespace$ wrappednode. getresources ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ resources. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ resources. get ( i ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resources. sublist ( $number$, $whitespace$ i ). stream ( ). map ( e $whitespace$ - > $whitespace$ e $whitespace$ instanceof $whitespace$ variabledeclarationexpr $whitespace$? $whitespace$ ( ( variabledeclarationexpr ) $whitespace$ e ). getvariables ( ) $whitespace$ : $whitespace$ collections. < variabledeclarator > emptylist ( ) ). flatmap ( list : : stream ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ wrappednode. gettryblock ( ) ) $whitespace$ { $newline$ $indentation$ list < variabledeclarator > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( expression $whitespace$ expr $whitespace$ : $whitespace$ resources ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( expr $whitespace$ instanceof $whitespace$ variabledeclarationexpr ) $whitespace$ { $newline$ $indentation$ res. addall ( ( ( variabledeclarationexpr ) $whitespace$			
solveMethod	90	94	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/TryWithResourceContext.java	0.2477172017097473	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    // TODO: Document why staticOnly is forced to be false.
		    return solveMethodInParentContext(name, argumentsTypes, false);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $//·todo:·document·why·staticonly·is·forced·to·be·false.$ $newline$ $indentation$ return $whitespace$ solvemethodinparentcontext ( name , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ $indentation$ $whitespace$//trimoffalphareference $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ $indentation$ $whitespace$ 50% $whitespace$ = $whitespace$border ( ) $newline$ $indentation$. withclasses ( $string$ ) $newline$ $indentation$. return $whitespace$ solvemethodinparentcontext ( name, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ }			
localVariablesExposedToChild	58	67	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclarationExprContext.java	0.6223286986351013	MID	"		@Override
		public List<VariableDeclarator> localVariablesExposedToChild(Node child){
		    for (int i = 0; i < wrappedNode.getVariables().size(); i++) {
		        if (child == wrappedNode.getVariable(i)) {
		            return wrappedNode.getVariables().subList(0, i);
		        }
		    }
		    // TODO: Consider pattern exprs
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ wrappednode . getvariables ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ wrappednode . getvariable ( i ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode . getvariables ( ) . sublist ( $number$ , $whitespace$ i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo:·consider·pattern·exprs$ $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < variabledeclarator > $whitespace$ localvariablesexposedtochild ( node $whitespace$ child ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ wrappednode. getvariables ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( child $whitespace$ == $whitespace$ wrappednode. getvariable ( i ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode. getvariables ( ). sublist ( $number$, $whitespace$ i ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//////////////////////////////////todo: $whitespace$ methodreferencereference $whitespace$ harmonizer $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ }			
negatedPatternExprsExposedFromChildren	56	60	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/contexts/VariableDeclaratorContext.java	0.736255407333374	MID	"		@Override
		public List<PatternExpr> negatedPatternExprsExposedFromChildren(){
		    // Variable declarators never make pattern expressions available.
		    return Collections.emptyList();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$ negatedpatternexprsexposedfromchildren ( ) { $newline$ $indentation$ $//·variable·declarators·never·make·pattern·expressions·available.$ $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < patternexpr > $whitespace$先patternexprsexposedfromchildren ( ) { $newline$ $indentation$ $whitespace$//samplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesamplesample			
getConstructors	115	127	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java	0.0288725029677152	LOW	"		 static List<ResolvedConstructorDeclaration> getConstructors(NodeWithMembers<?> wrappedNode, TypeSolver typeSolver, N container){
		    List<ResolvedConstructorDeclaration> declared = wrappedNode.getConstructors().stream().map(c -> new JavaParserConstructorDeclaration<N>(container, c, typeSolver)).collect(Collectors.toList());
		    if (declared.isEmpty()) {
		        // If there are no constructors insert the default constructor
		        return ImmutableList.of(new DefaultConstructorDeclaration<N>(container));
		    }
		    return declared;
		}"	$indentation$ static $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( nodewithmembers < ? > $whitespace$ wrappednode , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ n $whitespace$ container ) { $newline$ $indentation$ list < resolvedconstructordeclaration > $whitespace$ declared $whitespace$ = $whitespace$ wrappednode . getconstructors ( ) . stream ( ) . map ( c $whitespace$ - > $whitespace$ new $whitespace$ javaparserconstructordeclaration < n > ( container , $whitespace$ c , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( declared . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·there·are·no·constructors·insert·the·default·constructor$ $newline$ $indentation$ return $whitespace$ immutablelist . of ( new $whitespace$ defaultconstructordeclaration < n > ( container ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ declared ; $newline$ $indentation$ }	$indentation$ static $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( nodewithmembers <? > $whitespace$ wrappednode, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ n $whitespace$ container ) { $newline$ $indentation$ list < resolvedconstructordeclaration > $whitespace$ declared $whitespace$ = $whitespace$ wrappednode. getconstructors ( ). stream ( ). map ( c $whitespace$ - > $whitespace$ new $whitespace$ javaparserconstructordeclaration < n > ( container, $whitespace$ c, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ if $whitespace$ ( declared. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ immutablelist. of ( new $whitespace$ defaultconstructordeclaration < n > ( container ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ declared ; $newline$ $indentation$ }			
getClassName	68	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java	0.0832110568881034	LOW	"		 static String getClassName(String base, Node container){
		    if (container instanceof com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) {
		        String b = getClassName(base, container.getParentNode().orElse(null));
		        String cn = ((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) container).getName().getId();
		        if (b.isEmpty()) {
		            return cn;
		        }
		        return b + ""."" + cn;
		    }
		    if (container instanceof com.github.javaparser.ast.body.EnumDeclaration) {
		        String b = getClassName(base, container.getParentNode().orElse(null));
		        String cn = ((com.github.javaparser.ast.body.EnumDeclaration) container).getName().getId();
		        if (b.isEmpty()) {
		            return cn;
		        }
		        return b + ""."" + cn;
		    }
		    if (container instanceof com.github.javaparser.ast.body.AnnotationDeclaration) {
		        String b = getClassName(base, container.getParentNode().orElse(null));
		        String cn = ((com.github.javaparser.ast.body.AnnotationDeclaration) container).getName().getId();
		        if (b.isEmpty()) {
		            return cn;
		        }
		        return b + ""."" + cn;
		    }
		    if (container != null) {
		        return getClassName(base, container.getParentNode().orElse(null));
		    }
		    return base;
		}"	$indentation$ static $whitespace$ string $whitespace$ getclassname ( string $whitespace$ base , $whitespace$ node $whitespace$ container ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ string $whitespace$ b $whitespace$ = $whitespace$ getclassname ( base , $whitespace$ container . getparentnode ( ) . orelse ( null ) ) ; $newline$ $indentation$ string $whitespace$ cn $whitespace$ = $whitespace$ ( ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ container ) . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( b . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ b $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . enumdeclaration ) $whitespace$ { $newline$ $indentation$ string $whitespace$ b $whitespace$ = $whitespace$ getclassname ( base , $whitespace$ container . getparentnode ( ) . orelse ( null ) ) ; $newline$ $indentation$ string $whitespace$ cn $whitespace$ = $whitespace$ ( ( com . github . javaparser . ast . body . enumdeclaration ) $whitespace$ container ) . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( b . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ b $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . annotationdeclaration ) $whitespace$ { $newline$ $indentation$ string $whitespace$ b $whitespace$ = $whitespace$ getclassname ( base , $whitespace$ container . getparentnode ( ) . orelse ( null ) ) ; $newline$ $indentation$ string $whitespace$ cn $whitespace$ = $whitespace$ ( ( com . github . javaparser . ast . body . annotationdeclaration ) $whitespace$ container ) . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( b . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ b $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ cn ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( container $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getclassname ( base , $whitespace$ container . getparentnode ( ) . orelse ( null ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ base ; $newline$ $indentation$ }	$indentation$ static $whitespace$ string $whitespace$ getclassname ( string $whitespace$ base, $whitespace$ node $whitespace$ container ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ string $whitespace$ b $whitespace$ = $whitespace$ getclassname ( base, $whitespace$ container. getparentnode ( ). orelse ( null ) ) ; $newline$ $indentation$ string $whitespace$ context $whitespace$ = $whitespace$ ( ( com. github. javaparser. ast. body. classorinterfacedeclaration ) $whitespace$ container ; $newline$ $indentation$ if $whitespace$ ( context. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ context ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ b $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ context. getparentnode ( ). orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( context. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ context ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ b $whitespace$			
hasDirectlyAnnotation	99	113	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java	0.1670175194740295	LOW	"		 static boolean hasDirectlyAnnotation(NodeWithAnnotations<?> nodeWithAnnotations, TypeSolver typeSolver, String canonicalName){
		    for (AnnotationExpr annotationExpr : nodeWithAnnotations.getAnnotations()) {
		        SymbolReference<ResolvedTypeDeclaration> ref = JavaParserFactory.getContext(annotationExpr, typeSolver).solveType(annotationExpr.getNameAsString());
		        if (ref.isSolved()) {
		            if (ref.getCorrespondingDeclaration().getQualifiedName().equals(canonicalName)) {
		                return true;
		            }
		        } else {
		            throw new UnsolvedSymbolException(annotationExpr.getName().getId());
		        }
		    }
		    return false;
		}"	$indentation$ static $whitespace$ boolean $whitespace$ hasdirectlyannotation ( nodewithannotations < ? > $whitespace$ nodewithannotations , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ string $whitespace$ canonicalname ) { $newline$ $indentation$ for $whitespace$ ( annotationexpr $whitespace$ annotationexpr $whitespace$ : $whitespace$ nodewithannotations . getannotations ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparserfactory . getcontext ( annotationexpr , $whitespace$ typesolver ) . solvetype ( annotationexpr . getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ref . getcorrespondingdeclaration ( ) . getqualifiedname ( ) . equals ( canonicalname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( annotationexpr . getname ( ) . getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ static $whitespace$ boolean $whitespace$ hasdirectlyannotation ( nodewithannotations <? > $whitespace$ nodewithannotations, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ string $whitespace$ canonicalname ) { $newline$ $indentation$ for $whitespace$ ( annotationexpr $whitespace$ annotationexpr $whitespace$ : $whitespace$ nodewithannotations. getannotations ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparserfactory. getcontext ( annotationexpr, $whitespace$ typesolver ). solvetype ( annotationexpr. getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ref. getcorrespondingdeclaration ( ). getqualifiedname ( ). equals ( canonicalname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getPackageName	58	66	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/AstResolutionUtils.java	0.2330972999334335	LOW	"		 static String getPackageName(Node container){
		    String packageName = """";
		    if (container == null)
		        return packageName;
		    Optional<CompilationUnit> cu = container.findCompilationUnit();
		    if (cu.isPresent()) {
		        packageName = cu.get().getPackageDeclaration().map(pd -> pd.getNameAsString()).orElse("""");
		    }
		    return packageName;
		}"	$indentation$ static $whitespace$ string $whitespace$ getpackagename ( node $whitespace$ container ) { $newline$ $indentation$ string $whitespace$ packagename $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( container $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ packagename ; $newline$ $indentation$ optional < compilationunit > $whitespace$ cu $whitespace$ = $whitespace$ container . findcompilationunit ( ) ; $newline$ $indentation$ if $whitespace$ ( cu . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ packagename $whitespace$ = $whitespace$ cu . get ( ) . getpackagedeclaration ( ) . map ( pd $whitespace$ - > $whitespace$ pd . getnameasstring ( ) ) . orelse ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ packagename ; $newline$ $indentation$ }	$indentation$ static $whitespace$ string $whitespace$ getpackagename ( node $whitespace$ container ) { $newline$ $indentation$ string $whitespace$ packagename $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( container $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ packagename ; $newline$ $indentation$ } $newline$ $indentation$ optional < compilationunit > $whitespace$ cu $whitespace$ = $whitespace$ container. findcompilationunit ( ) ; $newline$ $indentation$ if $whitespace$ ( cu. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ packagename $whitespace$ = $whitespace$ cu. get ( ). getpackagedeclaration ( ). map ( pd $whitespace$ - > $whitespace$ pd. getnameasstring ( ) ). orelse ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ packagename ; $newline$ $indentation$ }			
getAnnotationMembers	144	150	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java	0.0302559696137905	LOW	"		@Override
		public List<ResolvedAnnotationMemberDeclaration> getAnnotationMembers(){
		    return wrappedNode.getMembers().stream().filter(m -> m instanceof AnnotationMemberDeclaration).map(m -> new JavaParserAnnotationMemberDeclaration((AnnotationMemberDeclaration) m, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ wrappednode . getmembers ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ m $whitespace$ instanceof $whitespace$ annotationmemberdeclaration ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ javaparserannotationmemberdeclaration ( ( annotationmemberdeclaration ) $whitespace$ m , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ wrappednode. getmembers ( ). stream ( ). filter ( m $whitespace$ - > $whitespace$ m $whitespace$ instanceof $whitespace$ annotationmemberdeclaration ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ javaparserannotationmemberdeclaration ( ( annotationmemberdeclaration ) $whitespace$ m, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getAllFields	65	71	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java	0.0406508222222328	LOW	"		@Override
		public List<ResolvedFieldDeclaration> getAllFields(){
		    return wrappedNode.getFields().stream().flatMap(field -> field.getVariables().stream()).map(var -> new JavaParserFieldDeclaration(var, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ return $whitespace$ wrappednode . getfields ( ) . stream ( ) . flatmap ( field $whitespace$ - > $whitespace$ field . getvariables ( ) . stream ( ) ) . map ( var $whitespace$ - > $whitespace$ new $whitespace$ javaparserfielddeclaration ( var , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ return $whitespace$ wrappednode. getfields ( ). stream ( ). flatmap ( field $whitespace$ - > $whitespace$ field. getvariables ( ). stream ( ) ). map ( var $whitespace$ - > $whitespace$ new $whitespace$ javaparserfielddeclaration ( var, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getDeclaredMethods	73	77	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java	0.654319703578949	MID	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    // TODO #1838
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//·todo·#1838$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//. remove ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
isAssignableBy	79	83	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnnotationDeclaration.java	0.8441368341445923	HIGH	"		@Override
		public boolean isAssignableBy(ResolvedType type){
		    // TODO #1836
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $//·todo·#1836$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $whitespace$ // $whitespace$ the $whitespace$ use $whitespace$ of $whitespace$ the $whitespace$ harmonizer $whitespace$ -> $whitespace$ include $whitespace$ an $whitespace$ solution $whitespace$ is $whitespace$ already $whitespace$ cached $whitespace$ by $whitespace$ right $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
getAllFields	159	194	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.000871913449373	LOW	"		@Override
		public List<ResolvedFieldDeclaration> getAllFields(){
		    List<JavaParserFieldDeclaration> myFields = findMembersOfKind(FieldDeclaration.class).stream().flatMap(field -> field.getVariables().stream().map(variable -> new JavaParserFieldDeclaration(variable, typeSolver))).collect(Collectors.toList());
		    // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		    List<ResolvedFieldDeclaration> superClassFields = getSuperClass().orElseThrow(() -> new RuntimeException(""super class unexpectedly empty"")).getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")).getAllFields();
		    // TODO: Figure out if it is appropriate to remove the orElseThrow() -- if so, how...
		    List<ResolvedFieldDeclaration> interfaceFields = getInterfaces().stream().flatMap(interfaceReferenceType -> interfaceReferenceType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty."")).getAllFields().stream()).collect(Collectors.toList());
		    return ImmutableList.<ResolvedFieldDeclaration>builder().addAll(myFields).addAll(superClassFields).addAll(interfaceFields).build();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ list < javaparserfielddeclaration > $whitespace$ myfields $whitespace$ = $whitespace$ findmembersofkind ( fielddeclaration . class ) . stream ( ) . flatmap ( field $whitespace$ - > $whitespace$ field . getvariables ( ) . stream ( ) . map ( variable $whitespace$ - > $whitespace$ new $whitespace$ javaparserfielddeclaration ( variable , $whitespace$ typesolver ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ superclassfields $whitespace$ = $whitespace$ getsuperclass ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . getallfields ( ) ; $newline$ $indentation$ $//·todo:·figure·out·if·it·is·appropriate·to·remove·the·orelsethrow()·--·if·so,·how...$ $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ interfacefields $whitespace$ = $whitespace$ getinterfaces ( ) . stream ( ) . flatmap ( interfacereferencetype $whitespace$ - > $whitespace$ interfacereferencetype . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . getallfields ( ) . stream ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ immutablelist . < resolvedfielddeclaration > builder ( ) . addall ( myfields ) . addall ( superclassfields ) . addall ( interfacefields ) . build ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ list < javaparserfielddeclaration > $whitespace$ myfields $whitespace$ = $whitespace$ findmembersofkind ( fielddeclaration. class ). stream ( ). flatmap ( field $whitespace$ - > $whitespace$ field. getvariables ( ). stream ( ). map ( variable $whitespace$ - > $whitespace$ new $whitespace$ javaparserfielddeclaration ( variable, $whitespace$ typesolver ) ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ $whitespace$ // $whitespace$ @formatter:off $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ fielddeclaration $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ arrays. stream ( field $whitespace$ - > $whitespace$ new $whitespace$ javaparserfielddeclaration ( variable, $whitespace$ typesolver ) ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ getsuperclass ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). gettypedeclaration ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). getallfields ( ) ; $newline$ $indentation$ $whitespace$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ getsuperclass ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). getallfields ( ) ; $newline$ $indentation$ $whitespace$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $			
getInterfaces	123	131	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.0190428514033556	LOW	"		@Override
		public List<ResolvedReferenceType> getInterfaces(){
		    return superTypeDeclaration.asReferenceType().getAncestors().stream().filter(type -> type.getTypeDeclaration().isPresent()).filter(type -> type.getTypeDeclaration().get().isInterface()).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( ) { $newline$ $indentation$ return $whitespace$ supertypedeclaration . asreferencetype ( ) . getancestors ( ) . stream ( ) . filter ( type $whitespace$ - > $whitespace$ type . gettypedeclaration ( ) . ispresent ( ) ) . filter ( type $whitespace$ - > $whitespace$ type . gettypedeclaration ( ) . get ( ) . isinterface ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( ) { $newline$ $indentation$ return $whitespace$ supertypedeclaration. asreferencetype ( ). getancestors ( ). stream ( ). filter ( type $whitespace$ - > $whitespace$ type. gettypedeclaration ( ). ispresent ( ) ). filter ( type $whitespace$ - > $whitespace$ type. gettypedeclaration ( ). get ( ). isinterface ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
findMembersOfKind	80	91	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.042988296598196	LOW	"		public List<T> findMembersOfKind(final Class<T> memberClass){
		    if (wrappedNode.getAnonymousClassBody().isPresent()) {
		        return wrappedNode.getAnonymousClassBody().get().stream().filter(node -> memberClass.isAssignableFrom(node.getClass())).map(memberClass::cast).collect(Collectors.toList());
		    }
		    return Collections.emptyList();
		}"	$indentation$ public $whitespace$ list < t > $whitespace$ findmembersofkind ( final $whitespace$ class < t > $whitespace$ memberclass ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . getanonymousclassbody ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode . getanonymousclassbody ( ) . get ( ) . stream ( ) . filter ( node $whitespace$ - > $whitespace$ memberclass . isassignablefrom ( node . getclass ( ) ) ) . map ( memberclass : : cast ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < t > $whitespace$ findmembersofkind ( final $whitespace$ class < t > $whitespace$ memberclass ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. getanonymousclassbody ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode. getanonymousclassbody ( ). get ( ). stream ( ). filter ( node $whitespace$ - > $whitespace$ memberclass. isassignablefrom ( node. getclass ( ) ) ). map ( memberclass : : cast ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ }			
solveMethodAsUsage	103	107	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.0531032644212245	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes, Context invocationContext, List<ResolvedType> typeParameters){
		    return getContext().solveMethodAsUsage(name, argumentTypes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes , $whitespace$ context $whitespace$ invocationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethodasusage ( name , $whitespace$ argumenttypes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes, $whitespace$ context $whitespace$ invocationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethodasusage ( name, $whitespace$ argumenttypes ) ; $newline$ $indentation$ }			
internalTypes	239	246	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.0678397342562675	LOW	"		@Override
		public Set<ResolvedReferenceTypeDeclaration> internalTypes(){
		    return findMembersOfKind(TypeDeclaration.class).stream().map(typeMember -> JavaParserFacade.get(typeSolver).getTypeDeclaration(typeMember)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ findmembersofkind ( typedeclaration . class ) . stream ( ) . map ( typemember $whitespace$ - > $whitespace$ javaparserfacade . get ( typesolver ) . gettypedeclaration ( typemember ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ findmembersofkind ( typedeclaration. class ). stream ( ). map ( typemember $whitespace$ - > $whitespace$ javaparserfacade. get ( typesolver ). gettypedeclaration ( typemember ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
getDeclaredMethods	196	203	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.1104461923241615	LOW	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    return findMembersOfKind(MethodDeclaration.class).stream().map(method -> new JavaParserMethodDeclaration(method, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ findmembersofkind ( methoddeclaration . class ) . stream ( ) . map ( method $whitespace$ - > $whitespace$ new $whitespace$ javaparsermethoddeclaration ( method , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ findmembersofkind ( methoddeclaration. class ). stream ( ). map ( method $whitespace$ - > $whitespace$ new $whitespace$ javaparsermethoddeclaration ( method, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
solveMethod	97	101	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserAnonymousClassDeclaration.java	0.1649166047573089	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    return getContext().solveMethod(name, argumentsTypes, staticOnly);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ }			
toReferenceType	462	494	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.0067360107786953	LOW	"		private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType){
		    String className = classOrInterfaceType.getName().getId();
		    if (classOrInterfaceType.getScope().isPresent()) {
		        // look for the qualified name (for example class of type Rectangle2D.Double)
		        className = classOrInterfaceType.getScope().get().toString() + ""."" + className;
		    }
		    SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);
		    // If unable to solve by the class name alone, attempt to qualify it.
		    if (!ref.isSolved()) {
		        Optional<ClassOrInterfaceType> localScope = classOrInterfaceType.getScope();
		        if (localScope.isPresent()) {
		            String localName = localScope.get().getName().getId() + ""."" + classOrInterfaceType.getName().getId();
		            ref = solveType(localName);
		        }
		    }
		    // If still unable to resolve, throw an exception.
		    if (!ref.isSolved()) {
		        throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());
		    }
		    if (!classOrInterfaceType.getTypeArguments().isPresent()) {
		        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType());
		    }
		    List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta))).collect(Collectors.toList());
		    return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters);
		}"	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ classorinterfacetype . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype . getscope ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·look·for·the·qualified·name·(for·example·class·of·type·rectangle2d.double)$ $newline$ $indentation$ classname $whitespace$ = $whitespace$ classorinterfacetype . getscope ( ) . get ( ) . tostring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ classname ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvetype ( classname ) ; $newline$ $indentation$ $//·if·unable·to·solve·by·the·class·name·alone,·attempt·to·qualify·it.$ $newline$ $indentation$ if $whitespace$ ( ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ optional < classorinterfacetype > $whitespace$ localscope $whitespace$ = $whitespace$ classorinterfacetype . getscope ( ) ; $newline$ $indentation$ if $whitespace$ ( localscope . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ localname $whitespace$ = $whitespace$ localscope . get ( ) . getname ( ) . getid ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ classorinterfacetype . getname ( ) . getid ( ) ; $newline$ $indentation$ ref $whitespace$ = $whitespace$ solvetype ( localname ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·still·unable·to·resolve,·throw·an·exception.$ $newline$ $indentation$ if $whitespace$ ( ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( classorinterfacetype . getname ( ) . getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! classorinterfacetype . gettypearguments ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ superclasstypeparameters $whitespace$ = $whitespace$ classorinterfacetype . gettypearguments ( ) . get ( ) . stream ( ) . map ( ta $whitespace$ - > $whitespace$ new $whitespace$ lazytype ( v $whitespace$ - > $whitespace$ javaparserfacade . get ( typesolver ) . convert ( ta , $whitespace$ ta ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) , $whitespace$ superclasstypeparameters ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ classorinterfacetype. getname ( ). getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype. getscope ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//// $newline$ $indentation$look = $whitespace$ classorinterfacetype. getscope ( ). get ( ) ; $newline$ $indentation$ if $whitespace$ ( node $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ optional < classorinterfacetype > $whitespace$ localscope $whitespace$ = $whitespace$ classorinterfacetype. getscope ( ) ; $newline$ $indentation$ if $whitespace$ ( localscope. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ localname $whitespace$ = $whitespace$ localscope. get ( ). getname ( ). getid ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ classorinterfacetype. getname ( ). getid ( ) ; $newline$ $indentation$ ref $whitespace$ = $whitespace$ solve			
solveMethodAsUsage	166	170	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.0531032644212245	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes, Context invocationContext, List<ResolvedType> typeParameters){
		    return getContext().solveMethodAsUsage(name, argumentTypes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes , $whitespace$ context $whitespace$ invocationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethodasusage ( name , $whitespace$ argumenttypes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes, $whitespace$ context $whitespace$ invocationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethodasusage ( name, $whitespace$ argumenttypes ) ; $newline$ $indentation$ }			
solveType	306	324	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.0943957492709159	LOW	"		@Deprecated
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name){
		    if (this.wrappedNode.getName().getId().equals(name)) {
		        return SymbolReference.solved(this);
		    }
		    SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);
		    if (ref.isSolved()) {
		        return ref;
		    }
		    String prefix = wrappedNode.getName().asString() + ""."";
		    if (name.startsWith(prefix) && name.length() > prefix.length()) {
		        return new JavaParserClassDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));
		    }
		    return getContext().getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(name);
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter . solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ prefix $whitespace$ = $whitespace$ wrappednode . getname ( ) . asstring ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( name . startswith ( prefix ) $whitespace$ && $whitespace$ name . length ( ) $whitespace$ > $whitespace$ prefix . length ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserclassdeclaration ( this . wrappednode , $whitespace$ typesolver ) . solvetype ( name . substring ( prefix . length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ) . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( name ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this. wrappednode. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter. solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserclassdeclaration ( this. wrappednode, $whitespace$ typesolver ). solvetype ( name. substring ( prefix. length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ). getparent ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). solvetype ( name ) ; $newline$ $indentation$ }			
getTypeParameters	412	417	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.133947879076004	LOW	"		@Override
		public List<ResolvedTypeParameterDeclaration> getTypeParameters(){
		    return this.wrappedNode.getTypeParameters().stream().map((tp) -> new JavaParserTypeParameter(tp, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ this . wrappednode . gettypeparameters ( ) . stream ( ) . map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javaparsertypeparameter ( tp , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ return $whitespace$ this. wrappednode. gettypeparameters ( ). stream ( ). map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javaparsertypeparameter ( tp, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
solveMethod	326	330	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.1649166047573089	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    return getContext().solveMethod(name, argumentsTypes, staticOnly);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ }			
canBeAssignedTo	263	294	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.2298671007156372	LOW	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    // TODO consider generic types
		    if (this.getQualifiedName().equals(other.getQualifiedName())) {
		        return true;
		    }
		    Optional<ResolvedReferenceType> optionalSuperClass = getSuperClass();
		    if (optionalSuperClass.isPresent()) {
		        Optional<ResolvedReferenceTypeDeclaration> optionalSuperclassTypeDeclaration = optionalSuperClass.get().getTypeDeclaration();
		        if (optionalSuperclassTypeDeclaration.isPresent()) {
		            ResolvedReferenceTypeDeclaration superclassTypeDeclaration = optionalSuperclassTypeDeclaration.get();
		            if (superclassTypeDeclaration != this && superclassTypeDeclaration.isClass()) {
		                if (superclassTypeDeclaration.asClass().canBeAssignedTo(other)) {
		                    return true;
		                }
		            }
		        }
		    }
		    // TODO FIXME: Remove null check -- should be an empty list...
		    if (this.wrappedNode.getImplementedTypes() != null) {
		        for (ClassOrInterfaceType type : wrappedNode.getImplementedTypes()) {
		            ResolvedReferenceTypeDeclaration ancestor = (ResolvedReferenceTypeDeclaration) new SymbolSolver(typeSolver).solveType(type);
		            if (ancestor.canBeAssignedTo(other)) {
		                return true;
		            }
		        }
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ $//·todo·consider·generic·types$ $newline$ $indentation$ if $whitespace$ ( this . getqualifiedname ( ) . equals ( other . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ optionalsuperclass $whitespace$ = $whitespace$ getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalsuperclass . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionalsuperclasstypedeclaration $whitespace$ = $whitespace$ optionalsuperclass . get ( ) . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalsuperclasstypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ superclasstypedeclaration $whitespace$ = $whitespace$ optionalsuperclasstypedeclaration . get ( ) ; $newline$ $indentation$ if $whitespace$ ( superclasstypedeclaration $whitespace$ != $whitespace$ this $whitespace$ && $whitespace$ superclasstypedeclaration . isclass ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( superclasstypedeclaration . asclass ( ) . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo·fixme:·remove·null·check·--·should·be·an·empty·list...$ $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getimplementedtypes ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ type $whitespace$ : $whitespace$ wrappednode . getimplementedtypes ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ ancestor $whitespace$ = $whitespace$ ( resolvedreferencetypedeclaration ) $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvetype ( type ) ; $newline$ $indentation$ if $whitespace$ ( ancestor . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ $indentation$ $whitespace$ = $whitespace$ this. getqualifiedname ( ). equals ( other. getqualifiedname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( this. getqualifiedname ( ). equals ( other. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ optionalsuperclass $whitespace$ = $whitespace$ getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalsuperclass. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionalsuperclasstypedeclaration $whitespace$ = $whitespace$ optionalsuperclass. get ( ). gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalsuperclasstypedeclaration. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( superclasstypedeclaration. asclass ( ). canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $whitespace$ superclasstypedeclaration $whitespace$!= $whitespace$ this $whitespace$ && $whitespace$ superclasstypedeclaration. isclass ( ) $whitespace$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $whitespace$ superclasstypedeclaration. asclass ( ). canbeassignedto ( other ) $whitespace$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $whitespace$ superclasstypedecl			
equals	82	90	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.6532455086708069	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavaParserClassDeclaration that = (JavaParserClassDeclaration) o;
		    return wrappedNode.equals(that.wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javaparserclassdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserclassdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode . equals ( that . wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javaparserclassdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserclassdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode. equals ( that. wrappednode ) ; $newline$ $indentation$ }			
getSuperClass	190	201	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.6545349955558777	MID	"		@Override
		public Optional<ResolvedReferenceType> getSuperClass(){
		    if (isJavaLangObject()) {
		        // If this is java.lang.Object, it has no super class.
		        return Optional.empty();
		    }
		    if (wrappedNode.getExtendedTypes().isEmpty()) {
		        // All objects implicitly extend java.lang.Object -- inject it here (only when this isn't java.lang.Object)
		        return Optional.of(object());
		    }
		    return Optional.of(toReferenceType(wrappedNode.getExtendedTypes().getFirst().get()));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ if $whitespace$ ( isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·this·is·java.lang.object,·it·has·no·super·class.$ $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wrappednode . getextendedtypes ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·all·objects·implicitly·extend·java.lang.object·--·inject·it·here·(only·when·this·isn't·java.lang.object)$ $newline$ $indentation$ return $whitespace$ optional . of ( object ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( toreferencetype ( wrappednode . getextendedtypes ( ) . getfirst ( ) . get ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ if $whitespace$ ( isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wrappednode. getextendedtypes ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wrappednode. getextendedtypes ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//space$ methodreferencetype $whitespace$ = $whitespace$ isjavalangobject ( ) ; $newline$ $indentation$ return $whitespace$ optional. of ( object ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( toreferencetype ( wrappednode. getextendedtypes ( ). getfirst ( ). get ( ) ) ) ; $newline$ $indentation$ }			
getAncestors	337	389	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.8610397577285767	HIGH	"		@Override
		public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList){
		    List<ResolvedReferenceType> ancestors = new ArrayList<>();
		    // We want to avoid infinite recursion in case of Object having Object as ancestor
		    if (this.isJavaLangObject()) {
		        return ancestors;
		    }
		    Optional<String> qualifiedName = wrappedNode.getFullyQualifiedName();
		    if (!qualifiedName.isPresent()) {
		        return ancestors;
		    }
		    try {
		        // If a superclass is found, add it as an ancestor
		        Optional<ResolvedReferenceType> superClass = getSuperClass();
		        if (superClass.isPresent()) {
		            if (isAncestor(superClass.get(), qualifiedName.get())) {
		                ancestors.add(superClass.get());
		            }
		        }
		    } catch (UnsolvedSymbolException e) {
		        // in case we could not resolve the super class, we may still be able to resolve (some of) the
		        // implemented interfaces and so we continue gracefully with an (incomplete) list of ancestors
		        if (!acceptIncompleteList) {
		            // Only throw if an incomplete ancestor list is unacceptable.
		            throw e;
		        }
		    }
		    for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {
		        try {
		            // If an implemented interface is found, add it as an ancestor
		            ResolvedReferenceType rrt = toReferenceType(implemented);
		            if (isAncestor(rrt, qualifiedName.get())) {
		                ancestors.add(rrt);
		            }
		        } catch (UnsolvedSymbolException e) {
		            // in case we could not resolve some implemented interface, we may still be able to resolve the
		            // extended class or (some of) the other implemented interfaces and so we continue gracefully
		            // with an (incomplete) list of ancestors
		            if (!acceptIncompleteList) {
		                // Only throw if an incomplete ancestor list is unacceptable.
		                throw e;
		            }
		        }
		    }
		    return ancestors;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $//·we·want·to·avoid·infinite·recursion·in·case·of·object·having·object·as·ancestor$ $newline$ $indentation$ if $whitespace$ ( this . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ } $newline$ $indentation$ optional < string > $whitespace$ qualifiedname $whitespace$ = $whitespace$ wrappednode . getfullyqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( ! qualifiedname . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $//·if·a·superclass·is·found,·add·it·as·an·ancestor$ $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ superclass $whitespace$ = $whitespace$ getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( superclass . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( isancestor ( superclass . get ( ) , $whitespace$ qualifiedname . get ( ) ) ) $whitespace$ { $newline$ $indentation$ ancestors . add ( superclass . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·in·case·we·could·not·resolve·the·super·class,·we·may·still·be·able·to·resolve·(some·of)·the$ $newline$ $indentation$ $//·implemented·interfaces·and·so·we·continue·gracefully·with·an·(incomplete)·list·of·ancestors$ $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ $//·only·throw·if·an·incomplete·ancestor·list·is·unacceptable.$ $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ implemented $whitespace$ : $whitespace$ wrappednode . getimplementedtypes ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $//·if·an·implemented·interface·is·found,·add·it·as·an·ancestor$ $newline$ $indentation$ resolvedreferencetype $whitespace$ rrt $whitespace$ = $whitespace$ toreferencetype ( implemented ) ; $newline$ $indentation$ if $whitespace$ ( isancestor ( rrt , $whitespace$ qualifiedname . get ( ) ) ) $whitespace$ { $newline$ $indentation$ ancestors . add ( rrt ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·in·case·we·could·not·resolve·some·implemented·interface,·we·may·still·be·able·to·resolve·the$ $newline$ $indentation$ $//·extended·class·or·(some·of)·the·other·implemented·interfaces·and·so·we·continue·gracefully$ $newline$ $indentation$ $//·with·an·(incomplete)·list·of·ancestors$ $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ $//·only·throw·if·an·incomplete·ancestor·list·is·unacceptable.$ $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $////// $newline$ $indentation$ // $whitespace$ the $whitespace$ name $whitespace$ of $whitespace$ the $whitespace$ resolvedreferencetype $whitespace$ for $whitespace$ the $whitespace$ ancestors $whitespace$ values $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $whitespace$// $newline$ $indentation$$superclass $whitespace$ =isspace$ = = $whitespace$ rtnode. getfullyqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ (! qualifiedname. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $whitespace$// $newline$ $indentation$ if $whitespace$ ( isancestor ( superclass. get ( ), $whitespace$ qualifiedname. get ( ) ) ) $whitespace$ { $newline$ $indentation$ ancestors $whitespace$ = $whitespace$ getsuperclass ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ (			
toString	97	102	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserClassDeclaration.java	0.8921048045158386	HIGH	"		@Override
		public String toString(){
		    return ""JavaParserClassDeclaration{"" + ""wrappedNode="" + wrappedNode + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getSpecifiedException	101	109	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserConstructorDeclaration.java	0.2168278396129608	LOW	"		@Override
		public ResolvedType getSpecifiedException(int index){
		    if (index < 0 || index >= getNumberOfSpecifiedExceptions()) {
		        throw new IllegalArgumentException(String.format(""No exception with index %d. Number of exceptions: %d"", index, getNumberOfSpecifiedExceptions()));
		    }
		    return JavaParserFacade.get(typeSolver).convert(wrappedNode.getThrownExceptions().get(index), wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ getnumberofspecifiedexceptions ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ index , $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade . get ( typesolver ) . convert ( wrappednode . getthrownexceptions ( ) . get ( index ) , $whitespace$ wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ getnumberofspecifiedexceptions ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ index, $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade. get ( typesolver ). convert ( wrappednode. getthrownexceptions ( ). get ( index ), $whitespace$ wrappednode ) ; $newline$ $indentation$ }			
toReferenceType	266	283	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.0185939017683267	LOW	"		private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType){
		    String className = classOrInterfaceType.getName().getId();
		    if (classOrInterfaceType.getScope().isPresent()) {
		        // look for the qualified name (for example class of type Rectangle2D.Double)
		        className = classOrInterfaceType.getScope().get().toString() + ""."" + className;
		    }
		    SymbolReference<ResolvedTypeDeclaration> ref = solveType(className);
		    if (!ref.isSolved()) {
		        throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());
		    }
		    if (!classOrInterfaceType.getTypeArguments().isPresent()) {
		        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType());
		    }
		    List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta))).collect(Collectors.toList());
		    return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters);
		}"	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ classorinterfacetype . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype . getscope ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·look·for·the·qualified·name·(for·example·class·of·type·rectangle2d.double)$ $newline$ $indentation$ classname $whitespace$ = $whitespace$ classorinterfacetype . getscope ( ) . get ( ) . tostring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ classname ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvetype ( classname ) ; $newline$ $indentation$ if $whitespace$ ( ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( classorinterfacetype . getname ( ) . getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! classorinterfacetype . gettypearguments ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ superclasstypeparameters $whitespace$ = $whitespace$ classorinterfacetype . gettypearguments ( ) . get ( ) . stream ( ) . map ( ta $whitespace$ - > $whitespace$ new $whitespace$ lazytype ( v $whitespace$ - > $whitespace$ javaparserfacade . get ( typesolver ) . convert ( ta , $whitespace$ ta ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) , $whitespace$ superclasstypeparameters ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ classorinterfacetype. getname ( ). getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype. getscope ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//// $newlook$ $whitespace$ resolvedtypedeclaration $whitespace$ = $whitespace$ solvetype ( classname ) ; $newline$ $indentation$ if $whitespace$ (! ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( classorinterfacetype. getname ( ). getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! classorinterfacetype. gettypearguments ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref. getcorrespondingdeclaration ( ). asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ superclasstypeparameters $whitespace$ = $whitespace$ classorinterfacetype. gettypearguments ( ). get ( ). stream ( ). map ( ta $whitespace$ - > $whitespace$ new $whitespace$ lazytype ( v $whitespace$ - > $whitespace$ java			
solveMethodAsUsage	193	197	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.0531032644212245	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes, Context invokationContext, List<ResolvedType> typeParameters){
		    return getContext().solveMethodAsUsage(name, argumentTypes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethodasusage ( name , $whitespace$ argumenttypes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethodasusage ( name, $whitespace$ argumenttypes ) ; $newline$ $indentation$ }			
getEnumConstants	322	327	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.1200470104813575	LOW	"		@Override
		public List<ResolvedEnumConstantDeclaration> getEnumConstants(){
		    return wrappedNode.getEntries().stream().map(entry -> new JavaParserEnumConstantDeclaration(entry, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ wrappednode . getentries ( ) . stream ( ) . map ( entry $whitespace$ - > $whitespace$ new $whitespace$ javaparserenumconstantdeclaration ( entry , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ wrappednode. getentries ( ). stream ( ). map ( entry $whitespace$ - > $whitespace$ new $whitespace$ javaparserenumconstantdeclaration ( entry, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
solveType	293	306	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.134591519832611	LOW	"		@Deprecated
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name){
		    if (this.wrappedNode.getName().getId().equals(name)) {
		        return SymbolReference.solved(this);
		    }
		    SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);
		    if (ref.isSolved()) {
		        return ref;
		    }
		    return getContext().getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(name);
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter . solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ) . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( name ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this. wrappednode. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter. solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ). getparent ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). solvetype ( name ) ; $newline$ $indentation$ }			
solveMethod	199	212	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.1399286836385727	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    if (""values"".equals(name) && argumentsTypes.isEmpty()) {
		        return SymbolReference.solved(new JavaParserEnumDeclaration.ValuesMethod(this, typeSolver));
		    }
		    if (""valueOf"".equals(name) && argumentsTypes.size() == 1) {
		        ResolvedType argument = argumentsTypes.get(0);
		        if (argument.isReferenceType() && ""java.lang.String"".equals(argument.asReferenceType().getQualifiedName())) {
		            return SymbolReference.solved(new JavaParserEnumDeclaration.ValueOfMethod(this, typeSolver));
		        }
		    }
		    return getContext().solveMethod(name, argumentsTypes, staticOnly);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( name ) $whitespace$ && $whitespace$ argumentstypes . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserenumdeclaration . valuesmethod ( this , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( name ) $whitespace$ && $whitespace$ argumentstypes . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ argument $whitespace$ = $whitespace$ argumentstypes . get ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( argument . isreferencetype ( ) $whitespace$ && $whitespace$ $string$ . equals ( argument . asreferencetype ( ) . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserenumdeclaration . valueofmethod ( this , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ if $whitespace$ ( $string$. equals ( name ) $whitespace$ && $whitespace$ argumentstypes. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javaparserenumdeclaration. valuesmethod ( this, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $string$. equals ( name ) $whitespace$ && $whitespace$ argumentstypes. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ argument $whitespace$ = $whitespace$ argumentstypes. get ( $number$ ) ; $newline$ $indentation$ if $whitespace$ ( argument. isreferencetype ( ) $whitespace$ && $whitespace$ $string$. equals ( argument. asreferencetype ( ). getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javaparserenumdeclaration. valueofmethod ( this, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ }			
getDeclaredMethods	78	87	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.175591766834259	LOW	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    Set<ResolvedMethodDeclaration> methods = new HashSet<>();
		    for (BodyDeclaration<?> member : wrappedNode.getMembers()) {
		        if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {
		            methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));
		        }
		    }
		    return methods;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ set < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( bodydeclaration < ? > $whitespace$ member $whitespace$ : $whitespace$ wrappednode . getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . methoddeclaration ) $whitespace$ { $newline$ $indentation$ methods . add ( new $whitespace$ javaparsermethoddeclaration ( ( com . github . javaparser . ast . body . methoddeclaration ) $whitespace$ member , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methods ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ set < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( bodydeclaration <? > $whitespace$ member $whitespace$ : $whitespace$ wrappednode. getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. methoddeclaration ) $whitespace$ { $newline$ $indentation$ methods. add ( new $whitespace$ javaparsermethoddeclaration ( ( com. github. javaparser. ast. body. methoddeclaration ) $whitespace$ member, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methods ; $newline$ $indentation$ }			
getAllFields	219	231	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.1790089905261993	LOW	"		@Override
		public List<ResolvedFieldDeclaration> getAllFields(){
		    List<ResolvedFieldDeclaration> fields = javaParserTypeAdapter.getFieldsForDeclaredVariables();
		    this.getAncestors().forEach(a -> fields.addAll(a.getAllFieldsVisibleToInheritors()));
		    this.wrappedNode.getMembers().stream().filter(m -> m instanceof FieldDeclaration).forEach(m -> {
		        FieldDeclaration fd = (FieldDeclaration) m;
		        fd.getVariables().forEach(v -> fields.add(new JavaParserFieldDeclaration(v, typeSolver)));
		    });
		    return fields;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ javaparsertypeadapter . getfieldsfordeclaredvariables ( ) ; $newline$ $indentation$ this . getancestors ( ) . foreach ( a $whitespace$ - > $whitespace$ fields . addall ( a . getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ this . wrappednode . getmembers ( ) . stream ( ) . filter ( m $whitespace$ - > $whitespace$ m $whitespace$ instanceof $whitespace$ fielddeclaration ) . foreach ( m $whitespace$ - > $whitespace$ { $newline$ $indentation$ fielddeclaration $whitespace$ fd $whitespace$ = $whitespace$ ( fielddeclaration ) $whitespace$ m ; $newline$ $indentation$ fd . getvariables ( ) . foreach ( v $whitespace$ - > $whitespace$ fields . add ( new $whitespace$ javaparserfielddeclaration ( v , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ javaparsertypeadapter. getfieldsfordeclaredvariables ( ) ; $newline$ $indentation$ this. getancestors ( ). foreach ( a $whitespace$ - > $whitespace$ fields. addall ( a. getallfieldsvisibletoinheritors ( ) ) ) ; $newline$ $indentation$ this. wrappednode. getmembers ( ). stream ( ). filter ( m $whitespace$ - > $whitespace$ m $whitespace$ instanceof $whitespace$ fielddeclaration ). foreach ( m $whitespace$ - > $whitespace$ { $newline$ $indentation$ fielddeclaration $whitespace$ fd $whitespace$ = $whitespace$ ( fielddeclaration ) $whitespace$ m ; $newline$ $indentation$ fd. getvariables ( ). foreach ( v $whitespace$ - > $whitespace$ fields. add ( new $whitespace$ javaparserfielddeclaration ( v, $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }			
getAncestors	233	264	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.2609016597270965	LOW	"		@Override
		public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList){
		    List<ResolvedReferenceType> ancestors = new ArrayList<>();
		    ResolvedReferenceType enumClass = ReflectionFactory.typeUsageFor(Enum.class, typeSolver).asReferenceType();
		    if (enumClass.getTypeDeclaration().isPresent()) {
		        ResolvedTypeParameterDeclaration eTypeParameter = enumClass.getTypeDeclaration().get().getTypeParameters().get(0);
		        enumClass = enumClass.deriveTypeParameters(new ResolvedTypeParametersMap.Builder().setValue(eTypeParameter, new ReferenceTypeImpl(this)).build());
		        ancestors.add(enumClass);
		    } else {
		        // Consider IllegalStateException or similar?
		    }
		    // TODO FIXME: Remove null check -- should be an empty list...
		    if (wrappedNode.getImplementedTypes() != null) {
		        for (ClassOrInterfaceType implementedType : wrappedNode.getImplementedTypes()) {
		            try {
		                ancestors.add(toReferenceType(implementedType));
		            } catch (UnsolvedSymbolException e) {
		                if (!acceptIncompleteList) {
		                    throw e;
		                }
		            }
		        }
		    }
		    return ancestors;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ enumclass $whitespace$ = $whitespace$ reflectionfactory . typeusagefor ( enum . class , $whitespace$ typesolver ) . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( enumclass . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ etypeparameter $whitespace$ = $whitespace$ enumclass . gettypedeclaration ( ) . get ( ) . gettypeparameters ( ) . get ( $number$ ) ; $newline$ $indentation$ enumclass $whitespace$ = $whitespace$ enumclass . derivetypeparameters ( new $whitespace$ resolvedtypeparametersmap . builder ( ) . setvalue ( etypeparameter , $whitespace$ new $whitespace$ referencetypeimpl ( this ) ) . build ( ) ) ; $newline$ $indentation$ ancestors . add ( enumclass ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·consider·illegalstateexception·or·similar?$ $newline$ $indentation$ } $newline$ $indentation$ $//·todo·fixme:·remove·null·check·--·should·be·an·empty·list...$ $newline$ $indentation$ if $whitespace$ ( wrappednode . getimplementedtypes ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ implementedtype $whitespace$ : $whitespace$ wrappednode . getimplementedtypes ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ ancestors . add ( toreferencetype ( implementedtype ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ resolvedreferencetype $whitespace$ enumclass $whitespace$ = $whitespace$ reflectionfactory. typeusagefor ( enum. class, $whitespace$ typesolver ). asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( enumclass. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ etypeparameter $whitespace$ = $whitespace$ enumclass. gettypedeclaration ( ). get ( ). gettypeparameters ( ). get ( $number$ ) ; $newline$ $indentation$ enumclass $whitespace$ = $whitespace$ enumclass. derivetypeparameters ( new $whitespace$ resolvedtypeparametersmap. builder ( ). setvalue ( etypeparameter, $whitespace$ new $whitespace$ referencetypeimpl ( this ) ). build ( ) ) ; $newline$ $indentation$ ancestors. add ( enumclass ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//izationconsider parent $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ enumclass $whitespace$ = $whitespace$ enumclass. derivetypeparameters ( new $whitespace$ resolvedtypeparametersmap. builder ( ). setvalue ( etypeparameter, $whitespace$ new $whitespace$ referencetypeimpl ( this ) ). build ( ) ) ; $newline$ $indentation$ ancestors. add ( enumclass ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $whitespace$//ization $whitespace$ = $whitespace$ future. gettypedeclaration ( ). get			
equals	178	186	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.670082688331604	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavaParserEnumDeclaration that = (JavaParserEnumDeclaration) o;
		    return wrappedNode.equals(that.wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javaparserenumdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserenumdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode . equals ( that . wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javaparserenumdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserenumdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode. equals ( that. wrappednode ) ; $newline$ $indentation$ }			
canBeAssignedTo	118	136	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.7203753590583801	MID	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    String otherName = other.getQualifiedName();
		    // Enums cannot be extended
		    if (otherName.equals(this.getQualifiedName())) {
		        return true;
		    }
		    if (JAVA_LANG_ENUM.equals(otherName)) {
		        return true;
		    }
		    // Enum implements Comparable and Serializable
		    if (otherName.equals(JAVA_LANG_COMPARABLE)) {
		        return true;
		    }
		    if (otherName.equals(JAVA_IO_SERIALIZABLE)) {
		        return true;
		    }
		    return other.isJavaLangObject();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other . getqualifiedname ( ) ; $newline$ $indentation$ $//·enums·cannot·be·extended$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( this . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum . equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·enum·implements·comparable·and·serializable$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_lang_comparable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other . isjavalangobject ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other. getqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( othername. equals ( this. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum. equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////enumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenums ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername. equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other. isjavalangobject ( ) ; $newline$ $indentation$ }			
toString	71	76	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserEnumDeclaration.java	0.8919733762741089	HIGH	"		@Override
		public String toString(){
		    return ""JavaParserEnumDeclaration{"" + ""wrappedNode="" + wrappedNode + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
toReferenceType	386	409	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.0098982639610767	LOW	"		private ResolvedReferenceType toReferenceType(ClassOrInterfaceType classOrInterfaceType){
		    SymbolReference<? extends ResolvedTypeDeclaration> ref = null;
		    String typeName = classOrInterfaceType.getName().getId();
		    if (classOrInterfaceType.getScope().isPresent()) {
		        typeName = classOrInterfaceType.getScope().get().asString() + ""."" + typeName;
		    }
		    if (typeName.indexOf('.') > -1) {
		        ref = typeSolver.tryToSolveType(typeName);
		    }
		    if (ref == null || !ref.isSolved()) {
		        ref = solveType(typeName);
		    }
		    if (!ref.isSolved()) {
		        throw new UnsolvedSymbolException(classOrInterfaceType.getName().getId());
		    }
		    if (!classOrInterfaceType.getTypeArguments().isPresent()) {
		        return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType());
		    }
		    List<ResolvedType> superClassTypeParameters = classOrInterfaceType.getTypeArguments().get().stream().map(ta -> new LazyType(v -> JavaParserFacade.get(typeSolver).convert(ta, ta))).collect(Collectors.toList());
		    return new ReferenceTypeImpl(ref.getCorrespondingDeclaration().asReferenceType(), superClassTypeParameters);
		}"	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ null ; $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ classorinterfacetype . getname ( ) . getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype . getscope ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ typename $whitespace$ = $whitespace$ classorinterfacetype . getscope ( ) . get ( ) . asstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typename ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename . indexof ( $string$ ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ typesolver . trytosolvetype ( typename ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ solvetype ( typename ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( classorinterfacetype . getname ( ) . getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! classorinterfacetype . gettypearguments ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ superclasstypeparameters $whitespace$ = $whitespace$ classorinterfacetype . gettypearguments ( ) . get ( ) . stream ( ) . map ( ta $whitespace$ - > $whitespace$ new $whitespace$ lazytype ( v $whitespace$ - > $whitespace$ javaparserfacade . get ( typesolver ) . convert ( ta , $whitespace$ ta ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( ref . getcorrespondingdeclaration ( ) . asreferencetype ( ) , $whitespace$ superclasstypeparameters ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedreferencetype $whitespace$ toreferencetype ( classorinterfacetype $whitespace$ classorinterfacetype ) { $newline$ $indentation$ symbolreference <? $whitespace$ extends $whitespace$ resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ null ; $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ classorinterfacetype. getname ( ). getid ( ) ; $newline$ $indentation$ if $whitespace$ ( classorinterfacetype. getscope ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ typename $whitespace$ = $whitespace$ classorinterfacetype. getscope ( ). get ( ). asstring ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typename ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typename. indexof ( $string$ ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ typesolver. trytosolvetype ( typename ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ref $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$! ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ ref $whitespace$ = $whitespace$ solvetype ( typename ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( classorinterfacetype. getname ( ). getid ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! classorinterfacetype. gettypearguments ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null			
solveMethodAsUsage	295	299	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.0531032644212245	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentTypes, Context invocationContext, List<ResolvedType> typeParameters){
		    return getContext().solveMethodAsUsage(name, argumentTypes);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumenttypes , $whitespace$ context $whitespace$ invocationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethodasusage ( name , $whitespace$ argumenttypes ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumenttypes, $whitespace$ context $whitespace$ invocationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparameters ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethodasusage ( name, $whitespace$ argumenttypes ) ; $newline$ $indentation$ }			
solveType	269	287	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.0927808731794357	LOW	"		@Deprecated
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name){
		    if (this.wrappedNode.getName().getId().equals(name)) {
		        return SymbolReference.solved(this);
		    }
		    SymbolReference<ResolvedTypeDeclaration> ref = javaParserTypeAdapter.solveType(name);
		    if (ref.isSolved()) {
		        return ref;
		    }
		    String prefix = wrappedNode.getName().asString() + ""."";
		    if (name.startsWith(prefix) && name.length() > prefix.length()) {
		        return new JavaParserInterfaceDeclaration(this.wrappedNode, typeSolver).solveType(name.substring(prefix.length()));
		    }
		    return getContext().getParent().orElseThrow(() -> new RuntimeException(""Parent context unexpectedly empty."")).solveType(name);
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this . wrappednode . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter . solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ prefix $whitespace$ = $whitespace$ wrappednode . getname ( ) . asstring ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( name . startswith ( prefix ) $whitespace$ && $whitespace$ name . length ( ) $whitespace$ > $whitespace$ prefix . length ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserinterfacedeclaration ( this . wrappednode , $whitespace$ typesolver ) . solvetype ( name . substring ( prefix . length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ) . getparent ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) . solvetype ( name ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( this. wrappednode. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( this ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ javaparsertypeadapter. solvetype ( name ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserinterfacedeclaration ( this. wrappednode, $whitespace$ typesolver ). solvetype ( name. substring ( prefix. length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ getcontext ( ). getparent ( ). orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ). solvetype ( name ) ; $newline$ $indentation$ }			
solveMethod	289	293	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.1649166047573089	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    return getContext().solveMethod(name, argumentsTypes, staticOnly);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ) . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ getcontext ( ). solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly ) ; $newline$ $indentation$ }			
getTypeParameters	338	346	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.1651987135410308	LOW	"		@Override
		public List<ResolvedTypeParameterDeclaration> getTypeParameters(){
		    if (this.wrappedNode.getTypeParameters() == null) {
		        return Collections.emptyList();
		    }
		    return this.wrappedNode.getTypeParameters().stream().map((tp) -> new JavaParserTypeParameter(tp, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( this . wrappednode . gettypeparameters ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this . wrappednode . gettypeparameters ( ) . stream ( ) . map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javaparsertypeparameter ( tp , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( this. wrappednode. gettypeparameters ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ this. wrappednode. gettypeparameters ( ). stream ( ). map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javaparsertypeparameter ( tp, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getInterfacesExtended	132	140	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.1687206476926803	LOW	"		@Override
		public List<ResolvedReferenceType> getInterfacesExtended(){
		    List<ResolvedReferenceType> interfaces = new ArrayList<>();
		    for (ClassOrInterfaceType t : wrappedNode.getExtendedTypes()) {
		        interfaces.add(new ReferenceTypeImpl(solveType(t.getName().getId()).getCorrespondingDeclaration().asInterface()));
		    }
		    return interfaces;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfacesextended ( ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ t $whitespace$ : $whitespace$ wrappednode . getextendedtypes ( ) ) $whitespace$ { $newline$ $indentation$ interfaces . add ( new $whitespace$ referencetypeimpl ( solvetype ( t . getname ( ) . getid ( ) ) . getcorrespondingdeclaration ( ) . asinterface ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ interfaces ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfacesextended ( ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ t $whitespace$ : $whitespace$ wrappednode. getextendedtypes ( ) ) $whitespace$ { $newline$ $indentation$ interfaces. add ( new $whitespace$ referencetypeimpl ( solvetype ( t. getname ( ). getid ( ) ). getcorrespondingdeclaration ( ). asinterface ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ interfaces ; $newline$ $indentation$ }			
getDeclaredMethods	70	79	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.175591766834259	LOW	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    Set<ResolvedMethodDeclaration> methods = new HashSet<>();
		    for (BodyDeclaration<?> member : wrappedNode.getMembers()) {
		        if (member instanceof com.github.javaparser.ast.body.MethodDeclaration) {
		            methods.add(new JavaParserMethodDeclaration((com.github.javaparser.ast.body.MethodDeclaration) member, typeSolver));
		        }
		    }
		    return methods;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ set < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( bodydeclaration < ? > $whitespace$ member $whitespace$ : $whitespace$ wrappednode . getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . methoddeclaration ) $whitespace$ { $newline$ $indentation$ methods . add ( new $whitespace$ javaparsermethoddeclaration ( ( com . github . javaparser . ast . body . methoddeclaration ) $whitespace$ member , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methods ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ set < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( bodydeclaration <? > $whitespace$ member $whitespace$ : $whitespace$ wrappednode. getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. methoddeclaration ) $whitespace$ { $newline$ $indentation$ methods. add ( new $whitespace$ javaparsermethoddeclaration ( ( com. github. javaparser. ast. body. methoddeclaration ) $whitespace$ member, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methods ; $newline$ $indentation$ }			
equals	89	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.6201905012130737	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavaParserInterfaceDeclaration that = (JavaParserInterfaceDeclaration) o;
		    return wrappedNode.equals(that.wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javaparserinterfacedeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserinterfacedeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode . equals ( that . wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javaparserinterfacedeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javaparserinterfacedeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode. equals ( that. wrappednode ) ; $newline$ $indentation$ }			
getAncestors	306	336	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.6573097705841064	MID	"		@Override
		public List<ResolvedReferenceType> getAncestors(boolean acceptIncompleteList){
		    List<ResolvedReferenceType> ancestors = new ArrayList<>();
		    if (wrappedNode.getExtendedTypes() != null) {
		        for (ClassOrInterfaceType extended : wrappedNode.getExtendedTypes()) {
		            try {
		                ancestors.add(toReferenceType(extended));
		            } catch (UnsolvedSymbolException e) {
		                if (!acceptIncompleteList) {
		                    // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully
		                    throw e;
		                }
		            }
		        }
		    }
		    // TODO FIXME: Remove null check -- should be an empty list...
		    if (wrappedNode.getImplementedTypes() != null) {
		        for (ClassOrInterfaceType implemented : wrappedNode.getImplementedTypes()) {
		            try {
		                ancestors.add(toReferenceType(implemented));
		            } catch (UnsolvedSymbolException e) {
		                if (!acceptIncompleteList) {
		                    // we only throw an exception if we require a complete list; otherwise, we attempt to continue gracefully
		                    throw e;
		                }
		            }
		        }
		    }
		    return ancestors;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappednode . getextendedtypes ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ extended $whitespace$ : $whitespace$ wrappednode . getextendedtypes ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ ancestors . add ( toreferencetype ( extended ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ $//·we·only·throw·an·exception·if·we·require·a·complete·list;·otherwise,·we·attempt·to·continue·gracefully$ $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·todo·fixme:·remove·null·check·--·should·be·an·empty·list...$ $newline$ $indentation$ if $whitespace$ ( wrappednode . getimplementedtypes ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ implemented $whitespace$ : $whitespace$ wrappednode . getimplementedtypes ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ ancestors . add ( toreferencetype ( implemented ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ $//·we·only·throw·an·exception·if·we·require·a·complete·list;·otherwise,·we·attempt·to·continue·gracefully$ $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ancestors ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getancestors ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( wrappednode. getextendedtypes ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( classorinterfacetype $whitespace$ extended $whitespace$ : $whitespace$ wrappednode. getextendedtypes ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ ancestors. add ( toreferencetype ( extended ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ $//space$$we $whitespace$ = $whitespace$ wrappednode. getimplementedtypes ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ correctindentation ; $newline$ $indentation$ } $newline$ $indentation$			
toString	254	259	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserInterfaceDeclaration.java	0.891785740852356	HIGH	"		@Override
		public String toString(){
		    return ""JavaParserInterfaceDeclaration{"" + ""wrappedNode="" + wrappedNode + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ wrappednode $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getSpecifiedException	159	167	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserMethodDeclaration.java	0.2168278396129608	LOW	"		@Override
		public ResolvedType getSpecifiedException(int index){
		    if (index < 0 || index >= getNumberOfSpecifiedExceptions()) {
		        throw new IllegalArgumentException(String.format(""No exception with index %d. Number of exceptions: %d"", index, getNumberOfSpecifiedExceptions()));
		    }
		    return JavaParserFacade.get(typeSolver).convert(wrappedNode.getThrownExceptions().get(index), wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ getnumberofspecifiedexceptions ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ index , $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade . get ( typesolver ) . convert ( wrappednode . getthrownexceptions ( ) . get ( index ) , $whitespace$ wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ getnumberofspecifiedexceptions ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ index, $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ javaparserfacade. get ( typesolver ). convert ( wrappednode. getthrownexceptions ( ). get ( index ), $whitespace$ wrappednode ) ; $newline$ $indentation$ }			
declaringType	69	79	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserMethodDeclaration.java	0.7172319293022156	MID	"		@Override
		public ResolvedReferenceTypeDeclaration declaringType(){
		    if (demandParentNode(wrappedNode) instanceof ObjectCreationExpr) {
		        ObjectCreationExpr parentNode = (ObjectCreationExpr) demandParentNode(wrappedNode);
		        return new JavaParserAnonymousClassDeclaration(parentNode, typeSolver);
		    }
		    // TODO Fix: to use getSymbolResolver() we have to fix many unit tests
		    // that throw IllegalStateException(""Symbol resolution not configured: to configure consider setting a SymbolResolver in the ParserConfiguration""
		    // return wrappedNode.getSymbolResolver().toTypeDeclaration(wrappedNode);
		    return symbolResolver(typeSolver).toTypeDeclaration(demandParentNode(wrappedNode));
		}"	"$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedreferencetypedeclaration $whitespace$ declaringtype ( ) { $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ objectcreationexpr $whitespace$ parentnode $whitespace$ = $whitespace$ ( objectcreationexpr ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparseranonymousclassdeclaration ( parentnode , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·todo·fix:·to·use·getsymbolresolver()·we·have·to·fix·many·unit·tests$ $newline$ $indentation$ $//·that·throw·illegalstateexception(""symbol·resolution·not·configured:·to·configure·consider·setting·a·symbolresolver·in·the·parserconfiguration""$ $newline$ $indentation$ $//·return·wrappednode.getsymbolresolver().totypedeclaration(wrappednode);$ $newline$ $indentation$ return $whitespace$ symbolresolver ( typesolver ) . totypedeclaration ( demandparentnode ( wrappednode ) ) ; $newline$ $indentation$ }"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedreferencetypedeclaration $whitespace$ declaringtype ( ) { $newline$ $indentation$ if $whitespace$ ( demandparentnode ( wrappednode ) $whitespace$ instanceof $whitespace$ objectcreationexpr ) $whitespace$ { $newline$ $indentation$ objectcreationexpr $whitespace$ parentnode $whitespace$ = $whitespace$ ( objectcreationexpr ) $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparseranonymousclassdeclaration ( parentnode, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ parser: $whitespace$ evolve $whitespace$ into $whitespace$ non-p $newline$ $indentation$ return $whitespace$ symbolresolver ( typesolver ). totypedeclaration ( demandparentnode ( wrappednode ) ) ; $newline$ $indentation$ }			
getType	60	73	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserParameterDeclaration.java	0.2398794293403625	LOW	"		@Override
		public ResolvedType getType(){
		    if (wrappedNode.getType().isUnknownType() && JavaParserFactory.getContext(wrappedNode, typeSolver) instanceof LambdaExprContext) {
		        Optional<Value> value = JavaParserFactory.getContext(wrappedNode, typeSolver).solveSymbolAsValue(wrappedNode.getNameAsString());
		        if (value.isPresent()) {
		            return value.get().getType();
		        }
		    }
		    ResolvedType res = JavaParserFacade.get(typeSolver).convert(wrappedNode.getType(), wrappedNode);
		    if (isVariadic()) {
		        res = new ResolvedArrayType(res);
		    }
		    return res;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ if $whitespace$ ( wrappednode . gettype ( ) . isunknowntype ( ) $whitespace$ && $whitespace$ javaparserfactory . getcontext ( wrappednode , $whitespace$ typesolver ) $whitespace$ instanceof $whitespace$ lambdaexprcontext ) $whitespace$ { $newline$ $indentation$ optional < value > $whitespace$ value $whitespace$ = $whitespace$ javaparserfactory . getcontext ( wrappednode , $whitespace$ typesolver ) . solvesymbolasvalue ( wrappednode . getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( value . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ value . get ( ) . gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ res $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . convert ( wrappednode . gettype ( ) , $whitespace$ wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( isvariadic ( ) ) $whitespace$ { $newline$ $indentation$ res $whitespace$ = $whitespace$ new $whitespace$ resolvedarraytype ( res ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ if $whitespace$ ( wrappednode. gettype ( ). isunknowntype ( ) $whitespace$ && $whitespace$ javaparserfactory. getcontext ( wrappednode, $whitespace$ typesolver ) $whitespace$ instanceof $whitespace$ lambdaexprcontext ) $whitespace$ { $newline$ $indentation$ optional < value > $whitespace$ value $whitespace$ = $whitespace$ javaparserfactory. getcontext ( wrappednode, $whitespace$ typesolver ). solvesymbolasvalue ( wrappednode. getnameasstring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( value. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ value. get ( ). gettype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ res $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). convert ( wrappednode. gettype ( ), $whitespace$ wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( isvariadic ( ) ) $whitespace$ { $newline$ $indentation$ res $whitespace$ = $whitespace$ new $whitespace$ resolvedarraytype ( res ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ }			
getParamPos	57	68	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserSymbolDeclaration.java	0.8292331099510193	HIGH	"		public static int getParamPos(Parameter parameter){
		    int pos = 0;
		    for (Node node : demandParentNode(parameter).getChildNodes()) {
		        if (node == parameter) {
		            return pos;
		        }
		        if (node instanceof Parameter) {
		            pos++;
		        }
		    }
		    return pos;
		}"	$indentation$ public $whitespace$ static $whitespace$ int $whitespace$ getparampos ( parameter $whitespace$ parameter ) { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ node $whitespace$ : $whitespace$ demandparentnode ( parameter ) . getchildnodes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ return $whitespace$ pos ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ pos ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pos ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ int $whitespace$ getparampos ( parameter $whitespace$ parameter ) { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( node $whitespace$ node $whitespace$ : $whitespace$ demandparentnode ( parameter ). getchildnodes ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ == $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ return $whitespace$ pos ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ parameter ) $whitespace$ { $newline$ $indentation$ pos ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pos ; $newline$ $indentation$ }			
solveType	107	156	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java	0.0041662859730422	LOW	"		@Deprecated
		public SymbolReference<ResolvedTypeDeclaration> solveType(String name){
		    if (wrappedNode instanceof NodeWithTypeParameters<?>) {
		        NodeList<TypeParameter> typeParameters = ((NodeWithTypeParameters<?>) wrappedNode).getTypeParameters();
		        for (com.github.javaparser.ast.type.TypeParameter typeParameter : typeParameters) {
		            if (typeParameter.getName().getId().equals(name)) {
		                return SymbolReference.solved(new JavaParserTypeVariableDeclaration(typeParameter, typeSolver));
		            }
		        }
		    }
		    // Member classes & interfaces
		    for (BodyDeclaration<?> member : this.wrappedNode.getMembers()) {
		        if (member instanceof com.github.javaparser.ast.body.TypeDeclaration) {
		            com.github.javaparser.ast.body.TypeDeclaration<?> internalType = (com.github.javaparser.ast.body.TypeDeclaration<?>) member;
		            String prefix = internalType.getName().asString() + ""."";
		            if (internalType.getName().getId().equals(name)) {
		                if (internalType instanceof ClassOrInterfaceDeclaration) {
		                    if (((ClassOrInterfaceDeclaration) internalType).isInterface()) {
		                        return SymbolReference.solved(new JavaParserInterfaceDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver));
		                    }
		                    return SymbolReference.solved(new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver));
		                }
		                if (internalType instanceof EnumDeclaration) {
		                    return SymbolReference.solved(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver));
		                }
		                if (internalType instanceof AnnotationDeclaration) {
		                    return SymbolReference.solved(new JavaParserAnnotationDeclaration((com.github.javaparser.ast.body.AnnotationDeclaration) internalType, typeSolver));
		                }
		                throw new UnsupportedOperationException();
		            }
		            if (name.startsWith(prefix) && name.length() > prefix.length()) {
		                if (internalType instanceof ClassOrInterfaceDeclaration) {
		                    if (((ClassOrInterfaceDeclaration) internalType).isInterface()) {
		                        return new JavaParserInterfaceDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver).solveType(name.substring(prefix.length()));
		                    }
		                    return new JavaParserClassDeclaration((com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) internalType, typeSolver).solveType(name.substring(prefix.length()));
		                }
		                if (internalType instanceof EnumDeclaration) {
		                    return new SymbolSolver(typeSolver).solveTypeInType(new JavaParserEnumDeclaration((com.github.javaparser.ast.body.EnumDeclaration) internalType, typeSolver), name.substring(prefix.length()));
		                }
		                if (internalType instanceof AnnotationDeclaration) {
		                    return SymbolReference.solved(new JavaParserAnnotationDeclaration((com.github.javaparser.ast.body.AnnotationDeclaration) internalType, typeSolver));
		                }
		                throw new UnsupportedOperationException();
		            }
		        }
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode $whitespace$ instanceof $whitespace$ nodewithtypeparameters < ? > ) $whitespace$ { $newline$ $indentation$ nodelist < typeparameter > $whitespace$ typeparameters $whitespace$ = $whitespace$ ( ( nodewithtypeparameters < ? > ) $whitespace$ wrappednode ) . gettypeparameters ( ) ; $newline$ $indentation$ for $whitespace$ ( com . github . javaparser . ast . type . typeparameter $whitespace$ typeparameter $whitespace$ : $whitespace$ typeparameters ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameter . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparsertypevariabledeclaration ( typeparameter , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·member·classes·&·interfaces$ $newline$ $indentation$ for $whitespace$ ( bodydeclaration < ? > $whitespace$ member $whitespace$ : $whitespace$ this . wrappednode . getmembers ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . typedeclaration ) $whitespace$ { $newline$ $indentation$ com . github . javaparser . ast . body . typedeclaration < ? > $whitespace$ internaltype $whitespace$ = $whitespace$ ( com . github . javaparser . ast . body . typedeclaration < ? > ) $whitespace$ member ; $newline$ $indentation$ string $whitespace$ prefix $whitespace$ = $whitespace$ internaltype . getname ( ) . asstring ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( internaltype . getname ( ) . getid ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( classorinterfacedeclaration ) $whitespace$ internaltype ) . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserinterfacedeclaration ( ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserclassdeclaration ( ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ enumdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserenumdeclaration ( ( com . github . javaparser . ast . body . enumdeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserannotationdeclaration ( ( com . github . javaparser . ast . body . annotationdeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . startswith ( prefix ) $whitespace$ && $whitespace$ name . length ( ) $whitespace$ > $whitespace$ prefix . length ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( classorinterfacedeclaration ) $whitespace$ internaltype ) . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserinterfacedeclaration ( ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) . solvetype ( name . substring ( prefix . length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserclassdeclaration ( ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) . solvetype ( name . substring ( prefix . length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ enumdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvetypeintype ( new $whitespace$ javaparserenumdeclaration ( ( com . github . javaparser . ast . body . enumdeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) , $whitespace$ name . substring ( prefix . length ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( internaltype $whitespace$ instanceof $whitespace$ annotationdeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javaparserannotationdeclaration ( ( com . github . javaparser . ast . body . annotationdeclaration ) $whitespace$ internaltype , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedtypedeclaration > $whitespace$ solvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( wrappednode $whitespace$ instanceof $whitespace$ nodewithtypeparameters <? > ) $whitespace$ { $newline$ $indentation$ nodelist < typeparameter > $whitespace$ typeparameters $whitespace$ = $whitespace$ ( ( nodewithtypeparameters <? > ) $whitespace$ wrappednode ). gettypeparameters ( ) ; $newline$ $indentation$ for $whitespace$ ( typeparameter $whitespace$ typeparameter $whitespace$ : $whitespace$ typeparameters ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeparameter. getname ( ). getid ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javaparsertypevariabledeclaration ( typeparameter, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ proposal $newline$ $indentation$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( member $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. typedeclaration ) $whitespace$ { $newline$ $indentation$ com. github. javaparser. ast. body. typedeclaration <? > $whitespace$ internaltype $whitespace$ =			
containerType	158	163	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java	0.0553288608789444	LOW	"		public Optional<ResolvedReferenceTypeDeclaration> containerType(){
		    return wrappedNode.getParentNode().filter(parentNode -> !(parentNode instanceof CompilationUnit)).map(node -> node.getSymbolResolver().toTypeDeclaration(node));
		}"	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ return $whitespace$ wrappednode . getparentnode ( ) . filter ( parentnode $whitespace$ - > $whitespace$ ! ( parentnode $whitespace$ instanceof $whitespace$ compilationunit ) ) . map ( node $whitespace$ - > $whitespace$ node . getsymbolresolver ( ) . totypedeclaration ( node ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ return $whitespace$ wrappednode. getparentnode ( ). filter ( parentnode $whitespace$ - > $whitespace$! ( parentnode $whitespace$ instanceof $whitespace$ compilationunit ) ). map ( node $whitespace$ - > $whitespace$ node. getsymbolresolver ( ). totypedeclaration ( node ) ) ; $newline$ $indentation$ }			
getDeclaredAnnotations	183	187	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeAdapter.java	0.1180967390537262	LOW	"		public Set<ResolvedAnnotationDeclaration> getDeclaredAnnotations(){
		    return wrappedNode.getAnnotations().stream().map(annotation -> annotation.resolve()).collect(Collectors.toSet());
		}"	$indentation$ public $whitespace$ set < resolvedannotationdeclaration > $whitespace$ getdeclaredannotations ( ) { $newline$ $indentation$ return $whitespace$ wrappednode . getannotations ( ) . stream ( ) . map ( annotation $whitespace$ - > $whitespace$ annotation . resolve ( ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ set < resolvedannotationdeclaration > $whitespace$ getdeclaredannotations ( ) { $newline$ $indentation$ return $whitespace$ wrappednode. getannotations ( ). stream ( ). map ( annotation $whitespace$ - > $whitespace$ annotation. resolve ( ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
getContainer	116	137	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeParameter.java	0.0490044392645359	LOW	"		@Override
		public ResolvedTypeParametrizable getContainer(){
		    Node parentNode = demandParentNode(wrappedNode);
		    if (parentNode instanceof com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) {
		        com.github.javaparser.ast.body.ClassOrInterfaceDeclaration jpTypeDeclaration = (com.github.javaparser.ast.body.ClassOrInterfaceDeclaration) parentNode;
		        return JavaParserFacade.get(typeSolver).getTypeDeclaration(jpTypeDeclaration);
		    }
		    if (parentNode instanceof com.github.javaparser.ast.body.ConstructorDeclaration) {
		        com.github.javaparser.ast.body.ConstructorDeclaration jpConstructorDeclaration = (com.github.javaparser.ast.body.ConstructorDeclaration) parentNode;
		        Optional<ClassOrInterfaceDeclaration> jpTypeDeclaration = jpConstructorDeclaration.findAncestor(com.github.javaparser.ast.body.ClassOrInterfaceDeclaration.class);
		        if (jpTypeDeclaration.isPresent()) {
		            ResolvedReferenceTypeDeclaration typeDeclaration = JavaParserFacade.get(typeSolver).getTypeDeclaration(jpTypeDeclaration.get());
		            if (typeDeclaration.isClass()) {
		                return new JavaParserConstructorDeclaration(typeDeclaration.asClass(), jpConstructorDeclaration, typeSolver);
		            }
		        }
		    } else {
		        com.github.javaparser.ast.body.MethodDeclaration jpMethodDeclaration = (com.github.javaparser.ast.body.MethodDeclaration) parentNode;
		        return new JavaParserMethodDeclaration(jpMethodDeclaration, typeSolver);
		    }
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtypeparametrizable $whitespace$ getcontainer ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ com . github . javaparser . ast . body . classorinterfacedeclaration $whitespace$ jptypedeclaration $whitespace$ = $whitespace$ ( com . github . javaparser . ast . body . classorinterfacedeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ return $whitespace$ javaparserfacade . get ( typesolver ) . gettypedeclaration ( jptypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ com . github . javaparser . ast . body . constructordeclaration ) $whitespace$ { $newline$ $indentation$ com . github . javaparser . ast . body . constructordeclaration $whitespace$ jpconstructordeclaration $whitespace$ = $whitespace$ ( com . github . javaparser . ast . body . constructordeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ jptypedeclaration $whitespace$ = $whitespace$ jpconstructordeclaration . findancestor ( com . github . javaparser . ast . body . classorinterfacedeclaration . class ) ; $newline$ $indentation$ if $whitespace$ ( jptypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ javaparserfacade . get ( typesolver ) . gettypedeclaration ( jptypedeclaration . get ( ) ) ; $newline$ $indentation$ if $whitespace$ ( typedeclaration . isclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparserconstructordeclaration ( typedeclaration . asclass ( ) , $whitespace$ jpconstructordeclaration , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ com . github . javaparser . ast . body . methoddeclaration $whitespace$ jpmethoddeclaration $whitespace$ = $whitespace$ ( com . github . javaparser . ast . body . methoddeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javaparsermethoddeclaration ( jpmethoddeclaration , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtypeparametrizable $whitespace$ getcontainer ( ) { $newline$ $indentation$ node $whitespace$ parentnode $whitespace$ = $whitespace$ demandparentnode ( wrappednode ) ; $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. classorinterfacedeclaration ) $whitespace$ { $newline$ $indentation$ com. github. javaparser. ast. body. classorinterfacedeclaration $whitespace$ jptypedeclaration $whitespace$ = $whitespace$ ( com. github. javaparser. ast. body. classorinterfacedeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ return $whitespace$ javaparserfacade. get ( typesolver ). gettypedeclaration ( jptypedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( parentnode $whitespace$ instanceof $whitespace$ com. github. javaparser. ast. body. constructordeclaration ) $whitespace$ { $newline$ $indentation$ com. github. javaparser. ast. body. constructordeclaration $whitespace$ jpconstructordeclaration $whitespace$ = $whitespace$ ( com. github. javaparser. ast. body. constructordeclaration ) $whitespace$ parentnode ; $newline$ $indentation$ optional < classorinterfacedeclaration > $whitespace$ jptypedeclaration $whitespace$ = $whitespace$ jpconstructordeclaration. findancestor ( com. github. javaparser. ast. body. classorinterfacedeclaration. class ) ; $newline$ $indentation$ if $whitespace$ ( jptypedeclaration. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ javaparserfacade. get ( typesolver ). gettypedeclaration ( jptypedeclaration. get ( ) ) ; $newline$ $indentation$ if			
equals	65	73	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeParameter.java	0.6729731559753418	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (!(o instanceof JavaParserTypeParameter))
		        return false;
		    JavaParserTypeParameter that = (JavaParserTypeParameter) o;
		    return wrappedNode != null && wrappedNode.equals(that.wrappedNode);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( ! ( o $whitespace$ instanceof $whitespace$ javaparsertypeparameter ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javaparsertypeparameter $whitespace$ that $whitespace$ = $whitespace$ ( javaparsertypeparameter ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ wrappednode . equals ( that . wrappednode ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( o $whitespace$ instanceof $whitespace$ javaparsertypeparameter ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javaparsertypeparameter $whitespace$ that $whitespace$ = $whitespace$ ( javaparsertypeparameter ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ wrappednode $whitespace$!= $whitespace$ null $whitespace$ && $whitespace$ wrappednode. equals ( that. wrappednode ) ; $newline$ $indentation$ }			
isAssignableBy	92	98	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeVariableDeclaration.java	0.712367594242096	MID	"		@Override
		public boolean isAssignableBy(ResolvedType type){
		    if (type.isTypeVariable()) {
		        throw new UnsupportedOperationException(""Is this type variable declaration assignable by "" + type.describe());
		    }
		    throw new UnsupportedOperationException(""Is this type variable declaration assignable by "" + type);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type . istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type . describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type. istypevariable ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type. describe ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ type ) ; $newline$ $indentation$ }			
toString	77	82	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarations/JavaParserTypeVariableDeclaration.java	0.8665197491645813	HIGH	"		@Override
		public String toString(){
		    return ""JavaParserTypeVariableDeclaration{"" + wrappedNode.getName() + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ wrappednode . getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ wrappednode. getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getSymbolDeclarations	48	69	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javaparsermodel/declarators/VariableSymbolDeclarator.java	0.1292086094617843	LOW	"		@Override
		public List<ResolvedValueDeclaration> getSymbolDeclarations(){
		    List<ResolvedValueDeclaration> variables = wrappedNode.getVariables().stream().map(v -> JavaParserSymbolDeclaration.localVar(v, typeSolver)).collect(Collectors.toCollection(ArrayList::new));
		    //        // FIXME: This returns ALL PatternExpr, regardless of whether it is in scope or not.
		    //        List<JavaParserSymbolDeclaration> patterns = wrappedNode.getVariables()
		    //                .stream()
		    //                .filter(variableDeclarator -> variableDeclarator.getInitializer().isPresent())
		    //                .map(variableDeclarator -> variableDeclarator.getInitializer().get())
		    //                .map(expression -> expression.findAll(PatternExpr.class))
		    //                .flatMap(Collection::stream)
		    //                .map(v -> JavaParserSymbolDeclaration.patternVar(v, typeSolver))
		    //                .collect(Collectors.toCollection(ArrayList::new));
		    List<ResolvedValueDeclaration> all = new ArrayList<>(variables);
		    //        all.addAll(patterns);
		    return all;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedvaluedeclaration > $whitespace$ getsymboldeclarations ( ) { $newline$ $indentation$ list < resolvedvaluedeclaration > $whitespace$ variables $whitespace$ = $whitespace$ wrappednode . getvariables ( ) . stream ( ) . map ( v $whitespace$ - > $whitespace$ javaparsersymboldeclaration . localvar ( v , $whitespace$ typesolver ) ) . collect ( collectors . tocollection ( arraylist : : new ) ) ; $newline$ $indentation$ $//········//·fixme:·this·returns·all·patternexpr,·regardless·of·whether·it·is·in·scope·or·not.$ $newline$ $indentation$ $//········list<javaparsersymboldeclaration>·patterns·=·wrappednode.getvariables()$ $newline$ $indentation$ $//················.stream()$ $newline$ $indentation$ $//················.filter(variabledeclarator·->·variabledeclarator.getinitializer().ispresent())$ $newline$ $indentation$ $//················.map(variabledeclarator·->·variabledeclarator.getinitializer().get())$ $newline$ $indentation$ $//················.map(expression·->·expression.findall(patternexpr.class))$ $newline$ $indentation$ $//················.flatmap(collection::stream)$ $newline$ $indentation$ $//················.map(v·->·javaparsersymboldeclaration.patternvar(v,·typesolver))$ $newline$ $indentation$ $//················.collect(collectors.tocollection(arraylist::new));$ $newline$ $indentation$ list < resolvedvaluedeclaration > $whitespace$ all $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( variables ) ; $newline$ $indentation$ $//········all.addall(patterns);$ $newline$ $indentation$ return $whitespace$ all ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedvaluedeclaration > $whitespace$ getsymboldeclarations ( ) { $newline$ $indentation$ list < resolvedvaluedeclaration > $whitespace$ variables $whitespace$ = $whitespace$ wrappednode. getvariables ( ). stream ( ). map ( v $whitespace$ - > $whitespace$ javaparsersymboldeclaration. localvar ( v, $whitespace$ typesolver ) ). collect ( collectors. tocollection ( arraylist : : new ) ) ; $newline$ $indentation$ $////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ return $whitespace$ wrappednode. getvariables ( ). stream ( ). map ( v $whitespace$ - > $whitespace$ javaparsersymboldeclaration. localvar ( v, $whitespace$ typesolver ) ). collect ( collectors. tocollection ( arraylist : : new ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ harmonizer < resolvedvaluedeclaration > $whitespace$ getvariantcontextforbreaks ( ) $whitespace$ { $newline$ $indentation$ list < resolvedvaluedeclaration > $whitespace$ variables $whitespace$ = $whitespace$ wrappednode. getvariables ( ). stream ( ). map ( v $whitespace$ - > $whitespace$ javaparsersymboldeclaration. localvar ( v, $whitespace$ typesolver ) ). collect ( collectors. tocollection ( arraylist : : new ) ) ; $newline$ $indentation$ $indentation$ $whitespace$//hation$ = = = = = = = $whitespace$ nitro. getvariables ( ). stream ( ). map ( v $whitespace$ - > $whitespace$ javaparsersymboldeclaration. localvar ( v, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ $whitespace$ { $newline$ $indentation$ return $whitespace$ wrappednode. getvariables ( ). stream ( ). map ( v $whitespace$ - > $whitespace$			
getAnnotationMembers	148	153	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java	0.1078236848115921	LOW	"		@Override
		public List<ResolvedAnnotationMemberDeclaration> getAnnotationMembers(){
		    return Stream.of(ctClass.getDeclaredMethods()).map(m -> new JavassistAnnotationMemberDeclaration(m, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ stream . of ( ctclass . getdeclaredmethods ( ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistannotationmemberdeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ stream. of ( ctclass. getdeclaredmethods ( ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistannotationmemberdeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getDeclaredMethods	110	114	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java	0.654319703578949	MID	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    // TODO #1838
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//·todo·#1838$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//. remove ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
toString	48	54	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java	0.660374104976654	MID	"		@Override
		public String toString(){
		    return getClass().getSimpleName() + ""{"" + ""ctClass="" + ctClass.getName() + "", typeSolver="" + typeSolver + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass . getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass. getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
isInheritable	155	162	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java	0.834220290184021	HIGH	"		@Override
		public boolean isInheritable(){
		    try {
		        return ctClass.getAnnotation(Inherited.class) != null;
		    } catch (ClassNotFoundException e) {
		        return false;
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinheritable ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ ctclass . getannotation ( inherited . class ) $whitespace$ != $whitespace$ null ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classnotfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isinheritable ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ ctclass. getannotation ( inherited. class ) $whitespace$!= $whitespace$ null ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classnotfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ }			
isAssignableBy	84	88	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationDeclaration.java	0.8441368341445923	HIGH	"		@Override
		public boolean isAssignableBy(ResolvedType type){
		    // TODO #1836
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $//·todo·#1836$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $whitespace$ // $whitespace$ the $whitespace$ use $whitespace$ of $whitespace$ the $whitespace$ harmonizer $whitespace$ -> $whitespace$ include $whitespace$ an $whitespace$ solution $whitespace$ is $whitespace$ already $whitespace$ cached $whitespace$ by $whitespace$ right $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
getDefaultValue	64	72	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationMemberDeclaration.java	0.1085399016737937	LOW	"		@Override
		public Expression getDefaultValue(){
		    AnnotationDefaultAttribute defaultAttribute = (AnnotationDefaultAttribute) annotationMember.getMethodInfo().getAttribute(AnnotationDefaultAttribute.tag);
		    if (defaultAttribute == null)
		        return null;
		    MemberValue memberValue = defaultAttribute.getDefaultValue();
		    Function<MemberValue, ? extends Expression> fn = memberValueAsExressionConverter.get(memberValue.getClass());
		    if (fn == null)
		        throw new UnsupportedOperationException(String.format(""Obtaining the type of the annotation member %s is not supported yet."", annotationMember.getName()));
		    return fn.apply(memberValue);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ expression $whitespace$ getdefaultvalue ( ) { $newline$ $indentation$ annotationdefaultattribute $whitespace$ defaultattribute $whitespace$ = $whitespace$ ( annotationdefaultattribute ) $whitespace$ annotationmember . getmethodinfo ( ) . getattribute ( annotationdefaultattribute . tag ) ; $newline$ $indentation$ if $whitespace$ ( defaultattribute $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ membervalue $whitespace$ membervalue $whitespace$ = $whitespace$ defaultattribute . getdefaultvalue ( ) ; $newline$ $indentation$ function < membervalue , $whitespace$ ? $whitespace$ extends $whitespace$ expression > $whitespace$ fn $whitespace$ = $whitespace$ membervalueasexressionconverter . get ( membervalue . getclass ( ) ) ; $newline$ $indentation$ if $whitespace$ ( fn $whitespace$ == $whitespace$ null ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ annotationmember . getname ( ) ) ) ; $newline$ $indentation$ return $whitespace$ fn . apply ( membervalue ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ expression $whitespace$ getdefaultvalue ( ) { $newline$ $indentation$ annotationdefaultattribute $whitespace$ defaultattribute $whitespace$ = $whitespace$ ( annotationdefaultattribute ) $whitespace$ annotationmember. getmethodinfo ( ). getattribute ( annotationdefaultattribute. tag ) ; $newline$ $indentation$ if $whitespace$ ( defaultattribute $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ expression $whitespace$ getdefaultvalue ( ) $whitespace$ { $newline$ $indentation$ function < membervalue, $whitespace$? $whitespace$ extends $whitespace$ expression > $whitespace$ fn $whitespace$ = $whitespace$ membervalueasexressionconverter. get ( membervalue. getclass ( ) ) ; $newline$ $indentation$ return $whitespace$ fn. apply ( membervalue ) ; $newline$ $indentation$ }			
getType	74	88	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistAnnotationMemberDeclaration.java	0.250058650970459	LOW	"		@Override
		public ResolvedType getType(){
		    try {
		        String descriptor = annotationMember.getMethodInfo().getDescriptor();
		        SignatureAttribute.MethodSignature signature = SignatureAttribute.toMethodSignature(descriptor);
		        SymbolReference<ResolvedReferenceTypeDeclaration> returnType = typeSolver.tryToSolveType(signature.getReturnType().jvmTypeName());
		        if (returnType.isSolved()) {
		            return new ReferenceTypeImpl(returnType.getCorrespondingDeclaration());
		        }
		    } catch (BadBytecode e) {
		        // We don't expect this to happen, but we handle it anyway.
		        throw new IllegalStateException(""An invalid descriptor was received from JavaAssist."", e);
		    }
		    throw new UnsupportedOperationException(String.format(""Obtaining the type of the annotation member %s is not supported yet."", annotationMember.getLongName()));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ string $whitespace$ descriptor $whitespace$ = $whitespace$ annotationmember . getmethodinfo ( ) . getdescriptor ( ) ; $newline$ $indentation$ signatureattribute . methodsignature $whitespace$ signature $whitespace$ = $whitespace$ signatureattribute . tomethodsignature ( descriptor ) ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ returntype $whitespace$ = $whitespace$ typesolver . trytosolvetype ( signature . getreturntype ( ) . jvmtypename ( ) ) ; $newline$ $indentation$ if $whitespace$ ( returntype . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( returntype . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·we·don't·expect·this·to·happen,·but·we·handle·it·anyway.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ annotationmember . getlongname ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ string $whitespace$ descriptor $whitespace$ = $whitespace$ annotationmember. getmethodinfo ( ). getdescriptor ( ) ; $newline$ $indentation$ signatureattribute. methodsignature $whitespace$ signature $whitespace$ = $whitespace$ signatureattribute. tomethodsignature ( descriptor ) ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ returntype $whitespace$ = $whitespace$ typesolver. trytosolvetype ( signature. getreturntype ( ). jvmtypename ( ) ) ; $newline$ $indentation$ if $whitespace$ ( returntype. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( returntype. getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $////////////////////////////////////we $whitespace$ // $whitespace$ also $whitespace$ get $whitespace$ the $whitespace$ current $whitespace$ post $whitespace$ and $whitespace$ stores $whitespace$ so $whitespace$ that $whitespace$ they $whitespace$ have $whitespace$ been $whitespace$ eliminated $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$, $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string. format ( $string$, $whitespace$ annotationmember. getlongname ( ) ) ) ; $newline$ $indentation$ }			
solveMethodAsUsage	132	137	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.0607743822038173	LOW	"		@Override
		@Deprecated
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils . solvemethodasusage ( name , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils. solvemethodasusage ( name, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ ctclass ) ; $newline$ $indentation$ }			
canBeAssignedTo	196	220	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.1268125921487808	LOW	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    if (other instanceof LambdaArgumentTypePlaceholder) {
		        return isFunctionalInterface();
		    }
		    if (other.getQualifiedName().equals(getQualifiedName())) {
		        return true;
		    }
		    Optional<ResolvedReferenceType> oSuperClass = javassistTypeDeclarationAdapter.getSuperClass();
		    if (oSuperClass.isPresent()) {
		        ResolvedReferenceType superClass = oSuperClass.get();
		        Optional<ResolvedReferenceTypeDeclaration> oDecl = superClass.getTypeDeclaration();
		        if (oDecl.isPresent() && oDecl.get().canBeAssignedTo(other)) {
		            return true;
		        }
		    }
		    for (ResolvedReferenceType interfaze : javassistTypeDeclarationAdapter.getInterfaces()) {
		        if (interfaze.getTypeDeclaration().isPresent() && interfaze.getTypeDeclaration().get().canBeAssignedTo(other)) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . getqualifiedname ( ) . equals ( getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ osuperclass $whitespace$ = $whitespace$ javassisttypedeclarationadapter . getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( osuperclass . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ superclass $whitespace$ = $whitespace$ osuperclass . get ( ) ; $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ odecl $whitespace$ = $whitespace$ superclass . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( odecl . ispresent ( ) $whitespace$ && $whitespace$ odecl . get ( ) . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ interfaze $whitespace$ : $whitespace$ javassisttypedeclarationadapter . getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( interfaze . gettypedeclaration ( ) . ispresent ( ) $whitespace$ && $whitespace$ interfaze . gettypedeclaration ( ) . get ( ) . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other. getqualifiedname ( ). equals ( getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ osuperclass $whitespace$ = $whitespace$ javassisttypedeclarationadapter. getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( osuperclass. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ superclass $whitespace$ = $whitespace$ osuperclass. get ( ) ; $newline$ $indentation$ if $whitespace$ ( $whitespace$ odecl. ispresent ( ) $whitespace$ && $whitespace$ odecl. get ( ). canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( $whitespace$ resolvedreferencetype $whitespace$ e $whitespace$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $whitespace$ edeclaration ( ). ispresent ( ) $whitespace$ && $whitespace$ $whitespace$ e. gettypedeclaration ( ). get ( ). canbeassignedto			
solveMethod	186	190	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.1999197304248809	LOW	"		@Override
		@Deprecated
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    return JavassistUtils.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ javassistutils . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly , $whitespace$ typesolver , $whitespace$ this , $whitespace$ ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ javassistutils. solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly, $whitespace$ typesolver, $whitespace$ this, $whitespace$ ctclass ) ; $newline$ $indentation$ }			
solveSymbol	139	162	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.2594459354877472	LOW	"		@Override
		public SymbolReference<? extends ResolvedValueDeclaration> solveSymbol(String name, TypeSolver typeSolver){
		    for (CtField field : ctClass.getDeclaredFields()) {
		        if (field.getName().equals(name)) {
		            return SymbolReference.solved(new JavassistFieldDeclaration(field, typeSolver));
		        }
		    }
		    final String superclassFQN = getSuperclassFQN();
		    SymbolReference<? extends ResolvedValueDeclaration> ref = solveSymbolForFQN(name, superclassFQN);
		    if (ref.isSolved()) {
		        return ref;
		    }
		    String[] interfaceFQNs = getInterfaceFQNs();
		    for (String interfaceFQN : interfaceFQNs) {
		        SymbolReference<? extends ResolvedValueDeclaration> interfaceRef = solveSymbolForFQN(name, interfaceFQN);
		        if (interfaceRef.isSolved()) {
		            return interfaceRef;
		        }
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ for $whitespace$ ( ctfield $whitespace$ field $whitespace$ : $whitespace$ ctclass . getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( new $whitespace$ javassistfielddeclaration ( field , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ superclassfqn $whitespace$ = $whitespace$ getsuperclassfqn ( ) ; $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvesymbolforfqn ( name , $whitespace$ superclassfqn ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ string [ ] $whitespace$ interfacefqns $whitespace$ = $whitespace$ getinterfacefqns ( ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ interfacefqn $whitespace$ : $whitespace$ interfacefqns ) $whitespace$ { $newline$ $indentation$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ interfaceref $whitespace$ = $whitespace$ solvesymbolforfqn ( name , $whitespace$ interfacefqn ) ; $newline$ $indentation$ if $whitespace$ ( interfaceref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ interfaceref ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbol ( string $whitespace$ name, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ for $whitespace$ ( ctfield $whitespace$ field $whitespace$ : $whitespace$ ctclass. getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field. getname ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( new $whitespace$ javassistfielddeclaration ( field, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ string $whitespace$ superclassfqn $whitespace$ = $whitespace$ getsuperclassfqn ( ) ; $newline$ $indentation$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ ref $whitespace$ = $whitespace$ solvesymbolforfqn ( name, $whitespace$ superclassfqn ) ; $newline$ $indentation$ if $whitespace$ ( ref. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ } $newline$ $indentation$ string [ ] $whitespace$ interfacefqns $whitespace$ = $whitespace$ getinterfacefqns ( ) ; $newline$ $indentation$ for $whitespace$ ( string $whitespace$ interfacefqn $whitespace$ : $whitespace$ interfacefqns ) $whitespace$ { $newline$ $indentation$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ interfaceref $whitespace$ = $whitespace$ solvesymbolforfqn ( name, $whitespace$ interfacefqn ) ; $newline$ $indentation$ if $whitespace$ ( else			
solveSymbolForFQN	164	171	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.285305917263031	LOW	"		private SymbolReference<? extends ResolvedValueDeclaration> solveSymbolForFQN(String symbolName, String fqn){
		    if (fqn == null) {
		        return SymbolReference.unsolved();
		    }
		    ResolvedReferenceTypeDeclaration fqnTypeDeclaration = typeSolver.solveType(fqn);
		    return new SymbolSolver(typeSolver).solveSymbolInType(fqnTypeDeclaration, symbolName);
		}"	$indentation$ private $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname , $whitespace$ string $whitespace$ fqn ) { $newline$ $indentation$ if $whitespace$ ( fqn $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ fqntypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( fqn ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvesymbolintype ( fqntypedeclaration , $whitespace$ symbolname ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname, $whitespace$ string $whitespace$ bond ) { $newline$ $indentation$ if $whitespace$ ( backslash $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$任typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype (先 ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ). solvesymbolintype (任typedeclaration, $whitespace$ symbolname ) ; $newline$ $indentation$ }			
getName	237	241	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.6318783164024353	MID	"		@Override
		public String getName(){
		    String[] nameElements = ctClass.getSimpleName().replace('$', '.').split(""\\."");
		    return nameElements[nameElements.length - 1];
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass . getsimplename ( ) . replace ( $string$ , $whitespace$ $string$ ) . split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements . length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass. getsimplename ( ). replace ( $string$, $whitespace$ $string$ ). split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements. length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }			
equals	98	106	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.692035973072052	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    JavassistClassDeclaration that = (JavassistClassDeclaration) o;
		    return ctClass.equals(that.ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ javassistclassdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javassistclassdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ ctclass . equals ( that . ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ javassistclassdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( javassistclassdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ ctclass. equals ( that. ctclass ) ; $newline$ $indentation$ }			
getClassName	118	125	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.7085241079330444	MID	"		@Override
		public String getClassName(){
		    String className = ctClass.getName().replace('$', '.');
		    if (getPackageName() != null) {
		        return className.substring(getPackageName().length() + 1);
		    }
		    return className;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ctclass . getname ( ) . replace ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ if $whitespace$ ( getpackagename ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classname . substring ( getpackagename ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ classname ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ctclass. getname ( ). replace ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ if $whitespace$ ( getpackagename ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classname. substring ( getpackagename ( ). length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ classname ; $newline$ $indentation$ }			
hasInternalType	320	327	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistClassDeclaration.java	0.8345493078231812	HIGH	"		@Override
		public boolean hasInternalType(String name){
		    /*
		        The name of the ReferenceTypeDeclaration could be composed of the internal class and the outer class, e.g. A$B. That's why we search the internal type in the ending part.
		        In case the name is composed of the internal type only, i.e. f.getName() returns B, it will also works.
		         */
		    return this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*···········the·name·of·the·referencetypedeclaration·could·be·composed·of·the·internal·class·and·the·outer·class,·e.g.·a$b.·that's·why·we·search·the·internal·type·in·the·ending·part.···········in·case·the·name·is·composed·of·the·internal·type·only,·i.e.·f.getname()·returns·b,·it·will·also·works.············*/$ $newline$ $indentation$ return $whitespace$ this . internaltypes ( ) . stream ( ) . anymatch ( f $whitespace$ - > $whitespace$ f . getname ( ) . endswith ( name ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*space$ = $whitespace$$ return $whitespace$ this. internaltypes ( ). stream ( ). anymatch ( f $whitespace$ - > $whitespace$ f. getname ( ). endswith ( name ) ) ; $newline$ $indentation$ }			
toString	49	55	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistConstructorDeclaration.java	0.6219357252120972	MID	"		@Override
		public String toString(){
		    return getClass().getSimpleName() + ""{"" + ""ctConstructor="" + ctConstructor.getName() + "", typeSolver="" + typeSolver + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctconstructor . getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctconstructor. getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
toString	67	73	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumConstantDeclaration.java	0.660374104976654	MID	"		@Override
		public String toString(){
		    return getClass().getSimpleName() + ""{"" + ""ctField="" + ctField.getName() + "", typeSolver="" + typeSolver + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctfield . getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctfield. getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getEnumConstants	243	249	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.0147469192743301	LOW	"		@Override
		public List<ResolvedEnumConstantDeclaration> getEnumConstants(){
		    return Arrays.stream(ctClass.getFields()).filter(f -> (f.getFieldInfo2().getAccessFlags() & AccessFlag.ENUM) != 0).map(f -> new JavassistEnumConstantDeclaration(f, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( ctclass . getfields ( ) ) . filter ( f $whitespace$ - > $whitespace$ ( f . getfieldinfo2 ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . enum ) $whitespace$ != $whitespace$ $number$ ) . map ( f $whitespace$ - > $whitespace$ new $whitespace$ javassistenumconstantdeclaration ( f , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( ctclass. getfields ( ) ). filter ( f $whitespace$ - > $whitespace$ ( f. getfieldinfo2 ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. enum ) $whitespace$!= $whitespace$ $number$ ). map ( f $whitespace$ - > $whitespace$ new $whitespace$ javassistenumconstantdeclaration ( f, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
solveMethodAsUsage	179	183	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.0445191301405429	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils . solvemethodasusage ( name , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils. solvemethodasusage ( name, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ ctclass ) ; $newline$ $indentation$ }			
getField	101	106	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.0832966044545173	LOW	"		@Override
		public ResolvedFieldDeclaration getField(String name){
		    Optional<ResolvedFieldDeclaration> field = javassistTypeDeclarationAdapter.getDeclaredFields().stream().filter(f -> f.getName().equals(name)).findFirst();
		    return field.orElseThrow(() -> new RuntimeException(""Field "" + name + "" does not exist in "" + ctClass.getName() + "".""));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ javassisttypedeclarationadapter . getdeclaredfields ( ) . stream ( ) . filter ( f $whitespace$ - > $whitespace$ f . getname ( ) . equals ( name ) ) . findfirst ( ) ; $newline$ $indentation$ return $whitespace$ field . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass . getname ( ) $whitespace$ + $whitespace$ $string$ ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ optional < resolvedfielddeclaration > $whitespace$ field $whitespace$ = $whitespace$ javassisttypedeclarationadapter. getdeclaredfields ( ). stream ( ) $newline$ $indentation$. filter ( f $whitespace$ - > $whitespace$ f. getname ( ). equals ( name ) ) $newline$ $indentation$. findfirst ( ) ; $newline$ $indentation$ return $whitespace$ field. orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass. getname ( ) $whitespace$ + $whitespace$ $string$ ) ) ; $newline$ $indentation$ }			
solveSymbolForFQN	230	237	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.285305917263031	LOW	"		private SymbolReference<? extends ResolvedValueDeclaration> solveSymbolForFQN(String symbolName, String fqn){
		    if (fqn == null) {
		        return SymbolReference.unsolved();
		    }
		    ResolvedReferenceTypeDeclaration fqnTypeDeclaration = typeSolver.solveType(fqn);
		    return new SymbolSolver(typeSolver).solveSymbolInType(fqnTypeDeclaration, symbolName);
		}"	$indentation$ private $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname , $whitespace$ string $whitespace$ fqn ) { $newline$ $indentation$ if $whitespace$ ( fqn $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ fqntypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( fqn ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvesymbolintype ( fqntypedeclaration , $whitespace$ symbolname ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname, $whitespace$ string $whitespace$ bond ) { $newline$ $indentation$ if $whitespace$ ( backslash $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$任typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype (先 ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ). solvesymbolintype (任typedeclaration, $whitespace$ symbolname ) ; $newline$ $indentation$ }			
getName	158	162	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.6318783164024353	MID	"		@Override
		public String getName(){
		    String[] nameElements = ctClass.getSimpleName().replace('$', '.').split(""\\."");
		    return nameElements[nameElements.length - 1];
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass . getsimplename ( ) . replace ( $string$ , $whitespace$ $string$ ) . split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements . length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass. getsimplename ( ). replace ( $string$, $whitespace$ $string$ ). split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements. length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }			
toString	256	262	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.660374104976654	MID	"		@Override
		public String toString(){
		    return getClass().getSimpleName() + ""{"" + ""ctClass="" + ctClass.getName() + "", typeSolver="" + typeSolver + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass . getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctclass. getname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typesolver $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
canBeAssignedTo	123	141	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.7203753590583801	MID	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    String otherName = other.getQualifiedName();
		    // Enums cannot be extended
		    if (otherName.equals(this.getQualifiedName())) {
		        return true;
		    }
		    if (JAVA_LANG_ENUM.equals(otherName)) {
		        return true;
		    }
		    // Enum implements Comparable and Serializable
		    if (otherName.equals(JAVA_LANG_COMPARABLE)) {
		        return true;
		    }
		    if (otherName.equals(JAVA_IO_SERIALIZABLE)) {
		        return true;
		    }
		    return other.isJavaLangObject();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other . getqualifiedname ( ) ; $newline$ $indentation$ $//·enums·cannot·be·extended$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( this . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum . equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·enum·implements·comparable·and·serializable$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_lang_comparable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other . isjavalangobject ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other. getqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( othername. equals ( this. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum. equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////enumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenums ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername. equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other. isjavalangobject ( ) ; $newline$ $indentation$ }			
hasInternalType	202	209	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistEnumDeclaration.java	0.8345493078231812	HIGH	"		@Override
		public boolean hasInternalType(String name){
		    /*
		        The name of the ReferenceTypeDeclaration could be composed on the internal class and the outer class, e.g. A$B. That's why we search the internal type in the ending part.
		        In case the name is composed of the internal type only, i.e. f.getName() returns B, it will also works.
		         */
		    return this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*···········the·name·of·the·referencetypedeclaration·could·be·composed·on·the·internal·class·and·the·outer·class,·e.g.·a$b.·that's·why·we·search·the·internal·type·in·the·ending·part.···········in·case·the·name·is·composed·of·the·internal·type·only,·i.e.·f.getname()·returns·b,·it·will·also·works.············*/$ $newline$ $indentation$ return $whitespace$ this . internaltypes ( ) . stream ( ) . anymatch ( f $whitespace$ - > $whitespace$ f . getname ( ) . endswith ( name ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*space$ = $whitespace$$ return $whitespace$ this. internaltypes ( ). stream ( ). anymatch ( f $whitespace$ - > $whitespace$ f. getname ( ). endswith ( name ) ) ; $newline$ $indentation$ }			
typeUsageFor	42	63	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFactory.java	0.1870629042387008	LOW	"		public static ResolvedType typeUsageFor(CtClass ctClazz, TypeSolver typeSolver){
		    try {
		        if (ctClazz.isArray()) {
		            return new ResolvedArrayType(typeUsageFor(ctClazz.getComponentType(), typeSolver));
		        }
		        if (ctClazz.isPrimitive()) {
		            if (ctClazz.getName().equals(""void"")) {
		                return ResolvedVoidType.INSTANCE;
		            }
		            return ResolvedPrimitiveType.byName(ctClazz.getName());
		        }
		        if (ctClazz.isInterface()) {
		            return new ReferenceTypeImpl(new JavassistInterfaceDeclaration(ctClazz, typeSolver));
		        }
		        if (ctClazz.isEnum()) {
		            return new ReferenceTypeImpl(new JavassistEnumDeclaration(ctClazz, typeSolver));
		        }
		        return new ReferenceTypeImpl(new JavassistClassDeclaration(ctClazz, typeSolver));
		    } catch (NotFoundException e) {
		        throw new RuntimeException(e);
		    }
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeusagefor ( ctclass $whitespace$ ctclazz , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ctclazz . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( typeusagefor ( ctclazz . getcomponenttype ( ) , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ctclazz . getname ( ) . equals ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedvoidtype . instance ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . byname ( ctclazz . getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz . isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistinterfacedeclaration ( ctclazz , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz . isenum ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistenumdeclaration ( ctclazz , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistclassdeclaration ( ctclazz , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeusagefor ( ctclass $whitespace$ ctclazz, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ctclazz. isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( typeusagefor ( ctclazz. getcomponenttype ( ), $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( ctclazz. getname ( ). equals ( $string$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz. isinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistinterfacedeclaration ( ctclazz, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclazz. isenum ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistinterfacedeclaration ( ctclazz, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistclassdeclaration ( ctclazz, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( exception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ javassistclassdeclaration ( ctclazz, $whitespace$			
modifiersToAccessLevel	81	92	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistFactory.java	0.6368815898895264	MID	"		 static AccessSpecifier modifiersToAccessLevel(final int modifiers){
		    if (Modifier.isPublic(modifiers)) {
		        return AccessSpecifier.PUBLIC;
		    }
		    if (Modifier.isProtected(modifiers)) {
		        return AccessSpecifier.PROTECTED;
		    }
		    if (Modifier.isPrivate(modifiers)) {
		        return AccessSpecifier.PRIVATE;
		    }
		    return AccessSpecifier.NONE;
		}"	$indentation$ static $whitespace$ accessspecifier $whitespace$ modifierstoaccesslevel ( final $whitespace$ int $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifier . ispublic ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . public ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( modifier . isprotected ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . protected ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( modifier . isprivate ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . private ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier . none ; $newline$ $indentation$ }	$indentation$ static $whitespace$ accessspecifier $whitespace$ modifierstoaccesslevel ( final $whitespace$ int $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( recyclerview. ispublic ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. public ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( recyclerview. isprotected ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. protected ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( recyclerview. isprivate ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. private ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier. none ; $newline$ $indentation$ }			
solveMethodAsUsage	98	103	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.0607743822038173	LOW	"		@Override
		@Deprecated
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    return JavassistUtils.solveMethodAsUsage(name, argumentsTypes, typeSolver, invokationContext, typeParameterValues, this, ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils . solvemethodasusage ( name , $whitespace$ argumentstypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ return $whitespace$ javassistutils. solvemethodasusage ( name, $whitespace$ argumentstypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ ctclass ) ; $newline$ $indentation$ }			
getDeclaredMethods	162	167	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.1269308179616928	LOW	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    return Arrays.stream(ctClass.getDeclaredMethods()).map(m -> new JavassistMethodDeclaration(m, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( ctclass . getdeclaredmethods ( ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistmethoddeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( ctclass. getdeclaredmethods ( ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistmethoddeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
canBeAssignedTo	126	155	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.157156229019165	LOW	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    if (other.isJavaLangObject()) {
		        // Everything can be assigned to {@code java.lang.Object}
		        return true;
		    }
		    if (other instanceof LambdaArgumentTypePlaceholder) {
		        return isFunctionalInterface();
		    }
		    if (other.getQualifiedName().equals(getQualifiedName())) {
		        return true;
		    }
		    Optional<ResolvedReferenceType> oSuperClass = javassistTypeDeclarationAdapter.getSuperClass();
		    if (oSuperClass.isPresent()) {
		        ResolvedReferenceType superClass = oSuperClass.get();
		        Optional<ResolvedReferenceTypeDeclaration> oDecl = superClass.getTypeDeclaration();
		        if (oDecl.isPresent() && oDecl.get().canBeAssignedTo(other)) {
		            return true;
		        }
		    }
		    for (ResolvedReferenceType interfaze : javassistTypeDeclarationAdapter.getInterfaces()) {
		        if (interfaze.getTypeDeclaration().isPresent() && interfaze.getTypeDeclaration().get().canBeAssignedTo(other)) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other . isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ $//·everything·can·be·assigned·to·{@code·java.lang.object}$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other . getqualifiedname ( ) . equals ( getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ osuperclass $whitespace$ = $whitespace$ javassisttypedeclarationadapter . getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( osuperclass . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ superclass $whitespace$ = $whitespace$ osuperclass . get ( ) ; $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ odecl $whitespace$ = $whitespace$ superclass . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( odecl . ispresent ( ) $whitespace$ && $whitespace$ odecl . get ( ) . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ interfaze $whitespace$ : $whitespace$ javassisttypedeclarationadapter . getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( interfaze . gettypedeclaration ( ) . ispresent ( ) $whitespace$ && $whitespace$ interfaze . gettypedeclaration ( ) . get ( ) . canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ if $whitespace$ ( other. isjavalangobject ( ) ) $whitespace$ { $newline$ $indentation$ $// $newline$ $indentation$ // $whitespace$ if $whitespace$ the $whitespace$ other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder $whitespace$ && $whitespace$ isfunctionalinterface ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( other. getqualifiedname ( ). equals ( getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ osuperclass $whitespace$ = $whitespace$ javassisttypedeclarationadapter. getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( osuperclass. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetype $whitespace$ superclass $whitespace$ = $whitespace$ osuperclass. get ( ) ; $newline$ $indentation$ if $whitespace$ ( $whitespace$ osuperclass. ispresent ( ) $whitespace$ && $whitespace$ odecl. get ( ). canbeassignedto ( other ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ optional < resolvedreferencetype > $whitespace$ osuperclass $whitespace$ = $whitespace$ javassisttypedeclaration			
solveMethod	105	109	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.1999197304248809	LOW	"		@Override
		@Deprecated
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    return JavassistUtils.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, ctClass);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ javassistutils . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly , $whitespace$ typesolver , $whitespace$ this , $whitespace$ ctclass ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ javassistutils. solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly, $whitespace$ typesolver, $whitespace$ this, $whitespace$ ctclass ) ; $newline$ $indentation$ }			
solveSymbolForFQN	222	229	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.285305917263031	LOW	"		private SymbolReference<? extends ResolvedValueDeclaration> solveSymbolForFQN(String symbolName, String fqn){
		    if (fqn == null) {
		        return SymbolReference.unsolved();
		    }
		    ResolvedReferenceTypeDeclaration fqnTypeDeclaration = typeSolver.solveType(fqn);
		    return new SymbolSolver(typeSolver).solveSymbolInType(fqnTypeDeclaration, symbolName);
		}"	$indentation$ private $whitespace$ symbolreference < ? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname , $whitespace$ string $whitespace$ fqn ) { $newline$ $indentation$ if $whitespace$ ( fqn $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ fqntypedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( fqn ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ) . solvesymbolintype ( fqntypedeclaration , $whitespace$ symbolname ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ symbolreference <? $whitespace$ extends $whitespace$ resolvedvaluedeclaration > $whitespace$ solvesymbolforfqn ( string $whitespace$ symbolname, $whitespace$ string $whitespace$ bond ) { $newline$ $indentation$ if $whitespace$ ( backslash $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$任typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype (先 ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ symbolsolver ( typesolver ). solvesymbolintype (任typedeclaration, $whitespace$ symbolname ) ; $newline$ $indentation$ }			
getName	182	186	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.6318783164024353	MID	"		@Override
		public String getName(){
		    String[] nameElements = ctClass.getSimpleName().replace('$', '.').split(""\\."");
		    return nameElements[nameElements.length - 1];
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass . getsimplename ( ) . replace ( $string$ , $whitespace$ $string$ ) . split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements . length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getname ( ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ ctclass. getsimplename ( ). replace ( $string$, $whitespace$ $string$ ). split ( $string$ ) ; $newline$ $indentation$ return $whitespace$ nameelements [ nameelements. length $whitespace$ - $whitespace$ $number$ ] ; $newline$ $indentation$ }			
getClassName	84	91	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.7085241079330444	MID	"		@Override
		public String getClassName(){
		    String className = ctClass.getName().replace('$', '.');
		    if (getPackageName() != null) {
		        return className.substring(getPackageName().length() + 1);
		    }
		    return className;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ctclass . getname ( ) . replace ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ if $whitespace$ ( getpackagename ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classname . substring ( getpackagename ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ classname ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ classname $whitespace$ = $whitespace$ ctclass. getname ( ). replace ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ if $whitespace$ ( getpackagename ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classname. substring ( getpackagename ( ). length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ classname ; $newline$ $indentation$ }			
hasInternalType	257	264	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistInterfaceDeclaration.java	0.8345493078231812	HIGH	"		@Override
		public boolean hasInternalType(String name){
		    /*
		        The name of the ReferenceTypeDeclaration could be composed on the internal class and the outer class, e.g. A$B. That's why we search the internal type in the ending part.
		        In case the name is composed of the internal type only, i.e. f.getName() returns B, it will also works.
		         */
		    return this.internalTypes().stream().anyMatch(f -> f.getName().endsWith(name));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*···········the·name·of·the·referencetypedeclaration·could·be·composed·on·the·internal·class·and·the·outer·class,·e.g.·a$b.·that's·why·we·search·the·internal·type·in·the·ending·part.···········in·case·the·name·is·composed·of·the·internal·type·only,·i.e.·f.getname()·returns·b,·it·will·also·works.············*/$ $newline$ $indentation$ return $whitespace$ this . internaltypes ( ) . stream ( ) . anymatch ( f $whitespace$ - > $whitespace$ f . getname ( ) . endswith ( name ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ hasinternaltype ( string $whitespace$ name ) { $newline$ $indentation$ $/*space$ = $whitespace$$ return $whitespace$ this. internaltypes ( ). stream ( ). anymatch ( f $whitespace$ - > $whitespace$ f. getname ( ). endswith ( name ) ) ; $newline$ $indentation$ }			
toString	65	70	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodDeclaration.java	0.9055373668670654	HIGH	"		@Override
		public String toString(){
		    return ""JavassistMethodDeclaration{"" + ""ctMethod="" + ctMethod + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctmethod $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ ctmethod $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getTypeParameters	78	85	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java	0.0734829530119896	LOW	"		public List<ResolvedTypeParameterDeclaration> getTypeParameters(){
		    if (ctBehavior.getGenericSignature() == null) {
		        return new ArrayList<>();
		    }
		    return Arrays.stream(methodSignature.getTypeParameters()).map(jasTp -> new JavassistTypeParameter(jasTp, declaration, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( ctbehavior . getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ arrays . stream ( methodsignature . gettypeparameters ( ) ) . map ( jastp $whitespace$ - > $whitespace$ new $whitespace$ javassisttypeparameter ( jastp , $whitespace$ declaration , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( ctbehavior. getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ arrays. stream ( methodsignature. gettypeparameters ( ) ). map ( jastp $whitespace$ - > $whitespace$ new $whitespace$ javassisttypeparameter ( jastp, $whitespace$ declaration, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getParam	67	76	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java	0.1034007668495178	LOW	"		public ResolvedParameterDeclaration getParam(int i){
		    boolean variadic = false;
		    if ((ctBehavior.getModifiers() & javassist.Modifier.VARARGS) > 0) {
		        variadic = i == (methodSignature.getParameterTypes().length - 1);
		    }
		    Optional<String> paramName = JavassistUtils.extractParameterName(ctBehavior, i);
		    ResolvedType type = JavassistUtils.signatureTypeToType(methodSignature.getParameterTypes()[i], typeSolver, declaration);
		    return new JavassistParameterDeclaration(type, typeSolver, variadic, paramName.orElse(null));
		}"	$indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ boolean $whitespace$ variadic $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ( ctbehavior . getmodifiers ( ) $whitespace$ & $whitespace$ javassist . modifier . varargs ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ variadic $whitespace$ = $whitespace$ i $whitespace$ == $whitespace$ ( methodsignature . getparametertypes ( ) . length $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < string > $whitespace$ paramname $whitespace$ = $whitespace$ javassistutils . extractparametername ( ctbehavior , $whitespace$ i ) ; $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ javassistutils . signaturetypetotype ( methodsignature . getparametertypes ( ) [ i ] , $whitespace$ typesolver , $whitespace$ declaration ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javassistparameterdeclaration ( type , $whitespace$ typesolver , $whitespace$ variadic , $whitespace$ paramname . orelse ( null ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ boolean $whitespace$ variadic $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ( ctbehavior. getmodifiers ( ) $whitespace$ & $whitespace$ javassist. modifier. varargs ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ variadic $whitespace$ = $whitespace$ i $whitespace$ == $whitespace$ ( methodsignature. getparametertypes ( ). length $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < string > $whitespace$ paramname $whitespace$ = $whitespace$ javassistutils. extractparametername ( ctbehavior, $whitespace$ i ) ; $newline$ $indentation$ resolvedtype $whitespace$ type $whitespace$ = $whitespace$ javassistutils. signaturetypetotype ( methodsignature. getparametertypes ( ) [ i ], $whitespace$ typesolver, $whitespace$ declaration ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ javassistparameterdeclaration ( type, $whitespace$ typesolver, $whitespace$ variadic, $whitespace$ paramname. orelse ( null ) ) ; $newline$ $indentation$ }			
getSpecifiedException	97	115	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistMethodLikeDeclarationAdapter.java	0.1174834221601486	LOW	"		public ResolvedType getSpecifiedException(int index){
		    if (index < 0) {
		        throw new IllegalArgumentException(String.format(""index < 0: %d"", index));
		    }
		    ExceptionsAttribute exceptionsAttribute = ctBehavior.getMethodInfo().getExceptionsAttribute();
		    if (exceptionsAttribute == null) {
		        throw new IllegalArgumentException(String.format(""No exception with index %d. Number of exceptions: 0"", index));
		    }
		    String[] exceptions = exceptionsAttribute.getExceptions();
		    if (exceptions == null || index >= exceptions.length) {
		        throw new IllegalArgumentException(String.format(""No exception with index %d. Number of exceptions: %d"", index, getNumberOfSpecifiedExceptions()));
		    }
		    ResolvedReferenceTypeDeclaration typeDeclaration = typeSolver.solveType(exceptions[index]);
		    return new ReferenceTypeImpl(typeDeclaration, Collections.emptyList());
		}"	$indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ index ) ) ; $newline$ $indentation$ } $newline$ $indentation$ exceptionsattribute $whitespace$ exceptionsattribute $whitespace$ = $whitespace$ ctbehavior . getmethodinfo ( ) . getexceptionsattribute ( ) ; $newline$ $indentation$ if $whitespace$ ( exceptionsattribute $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ index ) ) ; $newline$ $indentation$ } $newline$ $indentation$ string [ ] $whitespace$ exceptions $whitespace$ = $whitespace$ exceptionsattribute . getexceptions ( ) ; $newline$ $indentation$ if $whitespace$ ( exceptions $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ exceptions . length ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ index , $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( exceptions [ index ] ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration , $whitespace$ collections . emptylist ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedtype $whitespace$ getspecifiedexception ( int $whitespace$ index ) { $newline$ $indentation$ if $whitespace$ ( index $whitespace$ < $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ index ) ) ; $newline$ $indentation$ } $newline$ $indentation$ exceptionsattribute $whitespace$ exceptionsattribute $whitespace$ = $whitespace$ ctbehavior. getmethodinfo ( ). getexceptionsattribute ( ) ; $newline$ $indentation$ if $whitespace$ ( exceptionsattribute $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ index ) ) ; $newline$ $indentation$ } $newline$ $indentation$ string [ ] $whitespace$ exceptions $whitespace$ = $whitespace$ exceptionsattribute. getexceptions ( ) ; $newline$ $indentation$ if $whitespace$ ( exceptions $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ index $whitespace$ >= $whitespace$ exceptions. length ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ index, $whitespace$ getnumberofspecifiedexceptions ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver. solvetype ( exceptions [ index ] ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration, $whitespace$ collections. emptylist ( ) ) ; $newline$ $indentation$ }			
getDeclaredMethods	154	159	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.001211728202179	LOW	"		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    return Arrays.stream(ctClass.getDeclaredMethods()).filter(m -> ((m.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0) && ((m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0)).map(m -> new JavassistMethodDeclaration(m, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( ctclass . getdeclaredmethods ( ) ) . filter ( m $whitespace$ - > $whitespace$ ( ( m . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . bridge ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ && $whitespace$ ( ( m . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . synthetic ) $whitespace$ == $whitespace$ $number$ ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistmethoddeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( ctclass. getdeclaredmethods ( ) ). filter ( m $whitespace$ - > $whitespace$ ( ( m. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. bridge ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ && $newline$ $indentation$ ( ( m. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. synthetic ) $whitespace$ == $whitespace$ $number$ ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistmethoddeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
getConstructors	161	165	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.0077435751445591	LOW	"		public List<ResolvedConstructorDeclaration> getConstructors(){
		    return Arrays.stream(ctClass.getConstructors()).filter(m -> (m.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0).map(m -> new JavassistConstructorDeclaration(m, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ public $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( ctclass . getconstructors ( ) ) . filter ( m $whitespace$ - > $whitespace$ ( m . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . synthetic ) $whitespace$ == $whitespace$ $number$ ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistconstructordeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( ctclass. getconstructors ( ) ). filter ( m $whitespace$ - > $whitespace$ ( m. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. synthetic ) $whitespace$ == $whitespace$ $number$ ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ javassistconstructordeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getDeclaredAnnotations	188	202	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.0215518530458211	LOW	"		public Set<ResolvedAnnotationDeclaration> getDeclaredAnnotations(){
		    try {
		        Object[] annotations = ctClass.getAnnotations();
		        return Stream.of(annotations).map(annotation -> getAnnotationType(annotation)).filter(annotationType -> annotationType != null).map(annotationType -> typeSolver.solveType(annotationType)).map(rrtd -> rrtd.asAnnotation()).collect(Collectors.toSet());
		    } catch (ClassNotFoundException e) {
		        // There is nothing to do except returns an empty set
		    }
		    return Collections.EMPTY_SET;
		}"	$indentation$ public $whitespace$ set < resolvedannotationdeclaration > $whitespace$ getdeclaredannotations ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ object [ ] $whitespace$ annotations $whitespace$ = $whitespace$ ctclass . getannotations ( ) ; $newline$ $indentation$ return $whitespace$ stream . of ( annotations ) . map ( annotation $whitespace$ - > $whitespace$ getannotationtype ( annotation ) ) . filter ( annotationtype $whitespace$ - > $whitespace$ annotationtype $whitespace$ != $whitespace$ null ) . map ( annotationtype $whitespace$ - > $whitespace$ typesolver . solvetype ( annotationtype ) ) . map ( rrtd $whitespace$ - > $whitespace$ rrtd . asannotation ( ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classnotfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·there·is·nothing·to·do·except·returns·an·empty·set$ $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections . empty_set ; $newline$ $indentation$ }	$indentation$ public $whitespace$ set < resolvedannotationdeclaration > $whitespace$ getdeclaredannotations ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ object [ ] $whitespace$ annotations $whitespace$ = $whitespace$ ctclass. getannotations ( ) ; $newline$ $indentation$ return $whitespace$ stream. of ( annotations ) $newline$ $indentation$. map ( annotation $whitespace$ - > $whitespace$ getannotationtype ( annotation ) ) $newline$ $indentation$. filter ( annotationtype $whitespace$ - > $whitespace$ annotationtype $whitespace$!= $whitespace$ null ) $newline$ $indentation$. map ( annotationtype $whitespace$ - > $whitespace$ typesolver. solvetype ( annotationtype ) ) $newline$ $indentation$. map ( rrtd $whitespace$ - > $whitespace$ rrtd. asannotation ( ) ) $newline$ $indentation$. collect ( collectors. toset ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classnotfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ annotations : $newline$ $indentation$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ collections. empty_set ; $newline$ $indentation$ }			
getTypeParameters	215	228	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.0250685643404722	LOW	"		public List<ResolvedTypeParameterDeclaration> getTypeParameters(){
		    if (null == ctClass.getGenericSignature()) {
		        return Collections.emptyList();
		    }
		    try {
		        SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());
		        return Arrays.<SignatureAttribute.TypeParameter>stream(classSignature.getParameters()).map((tp) -> new JavassistTypeParameter(tp, JavassistFactory.toTypeDeclaration(ctClass, typeSolver), typeSolver)).collect(Collectors.toList());
		    } catch (BadBytecode badBytecode) {
		        throw new RuntimeException(badBytecode);
		    }
		}"	$indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( null $whitespace$ == $whitespace$ ctclass . getgenericsignature ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections . emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ signatureattribute . classsignature $whitespace$ classsignature $whitespace$ = $whitespace$ signatureattribute . toclasssignature ( ctclass . getgenericsignature ( ) ) ; $newline$ $indentation$ return $whitespace$ arrays . < signatureattribute . typeparameter > stream ( classsignature . getparameters ( ) ) . map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javassisttypeparameter ( tp , $whitespace$ javassistfactory . totypedeclaration ( ctclass , $whitespace$ typesolver ) , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ badbytecode ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( badbytecode ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration > $whitespace$ gettypeparameters ( ) { $newline$ $indentation$ if $whitespace$ ( null $whitespace$ == $whitespace$ ctclass. getgenericsignature ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collections. emptylist ( ) ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ signatureattribute. classsignature $whitespace$ classsignature $whitespace$ = $whitespace$ signatureattribute. toclasssignature ( ctclass. getgenericsignature ( ) ) ; $newline$ $indentation$ return $whitespace$ arrays. < signatureattribute. typeparameter > stream ( classsignature. getparameters ( ) ). map ( ( tp ) $whitespace$ - > $whitespace$ new $whitespace$ javassisttypeparameter ( tp, $whitespace$ javassistfactory. totypedeclaration ( ctclass, $whitespace$ typesolver ), $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ badbytecode ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( badbytecode ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
getInterfaces	107	138	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.1783567667007446	LOW	"		private List<ResolvedReferenceType> getInterfaces(boolean acceptIncompleteList){
		    List<ResolvedReferenceType> interfaces = new ArrayList<>();
		    try {
		        if (ctClass.getGenericSignature() == null) {
		            for (String interfaceType : ctClass.getClassFile().getInterfaces()) {
		                try {
		                    ResolvedReferenceTypeDeclaration declaration = typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(interfaceType));
		                    interfaces.add(new ReferenceTypeImpl(declaration));
		                } catch (UnsolvedSymbolException e) {
		                    if (!acceptIncompleteList) {
		                        throw e;
		                    }
		                }
		            }
		        } else {
		            SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());
		            for (SignatureAttribute.ClassType interfaceType : classSignature.getInterfaces()) {
		                try {
		                    interfaces.add(JavassistUtils.signatureTypeToType(interfaceType, typeSolver, typeDeclaration).asReferenceType());
		                } catch (UnsolvedSymbolException e) {
		                    if (!acceptIncompleteList) {
		                        throw e;
		                    }
		                }
		            }
		        }
		    } catch (BadBytecode e) {
		        throw new RuntimeException(e);
		    }
		    return interfaces;
		}"	$indentation$ private $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ctclass . getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( string $whitespace$ interfacetype $whitespace$ : $whitespace$ ctclass . getclassfile ( ) . getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ declaration $whitespace$ = $whitespace$ typesolver . solvetype ( javassistutils . internalnametocanonicalname ( interfacetype ) ) ; $newline$ $indentation$ interfaces . add ( new $whitespace$ referencetypeimpl ( declaration ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ signatureattribute . classsignature $whitespace$ classsignature $whitespace$ = $whitespace$ signatureattribute . toclasssignature ( ctclass . getgenericsignature ( ) ) ; $newline$ $indentation$ for $whitespace$ ( signatureattribute . classtype $whitespace$ interfacetype $whitespace$ : $whitespace$ classsignature . getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ interfaces . add ( javassistutils . signaturetypetotype ( interfacetype , $whitespace$ typesolver , $whitespace$ typedeclaration ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( unsolvedsymbolexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! acceptincompletelist ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ e ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ interfaces ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( boolean $whitespace$ acceptincompletelist ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ctclass. getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( string $whitespace$ interfacetype $whitespace$ : $whitespace$ ctclass. getclassfile ( ). getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ declaration $whitespace$ = $whitespace$ typesolver. solvetype ( javassistutils. internalnametocanonicalname ( interfacetype ) ) ; $newline$ $indentation$ for $whitespace$ ( signatureattribute. classtype $whitespace$ interfacetype $whitespace$ : $whitespace$ classsignature. getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ interfaces.			
containerType	230	238	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.2130153179168701	LOW	"		public Optional<ResolvedReferenceTypeDeclaration> containerType(){
		    try {
		        return ctClass.getDeclaringClass() == null ? Optional.empty() : Optional.of(JavassistFactory.toTypeDeclaration(ctClass.getDeclaringClass(), typeSolver));
		    } catch (NotFoundException e) {
		        throw new RuntimeException(e);
		    }
		}"	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ ctclass . getdeclaringclass ( ) $whitespace$ == $whitespace$ null $whitespace$ ? $whitespace$ optional . empty ( ) $whitespace$ : $whitespace$ optional . of ( javassistfactory . totypedeclaration ( ctclass . getdeclaringclass ( ) , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ ctclass. getdeclaringclass ( ) $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ optional. empty ( ) $whitespace$ : $whitespace$ javassistfactory. totypedeclaration ( ctclass. getdeclaringclass ( ), $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
getSuperClass	77	101	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.2881655395030975	LOW	"		public Optional<ResolvedReferenceType> getSuperClass(){
		    try {
		        if (""java.lang.Object"".equals(ctClass.getClassFile().getName())) {
		            // If this is java.lang.Object, ignore the presence of any superclass (preventing any infinite loops).
		            return Optional.empty();
		        }
		        if (ctClass.getGenericSignature() == null) {
		            // Compiled classes have generic types erased, but can be made available for reflection via getGenericSignature().
		            // If it is absent, then no further work is needed and we can return a reference type without generics.
		            return Optional.of(new ReferenceTypeImpl(typeSolver.solveType(JavassistUtils.internalNameToCanonicalName(ctClass.getClassFile().getSuperclass()))));
		        }
		        SignatureAttribute.ClassSignature classSignature = SignatureAttribute.toClassSignature(ctClass.getGenericSignature());
		        return Optional.ofNullable(JavassistUtils.signatureTypeToType(classSignature.getSuperClass(), typeSolver, typeDeclaration).asReferenceType());
		    } catch (BadBytecode e) {
		        throw new RuntimeException(e);
		    }
		}"	$indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$ . equals ( ctclass . getclassfile ( ) . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ $//·if·this·is·java.lang.object,·ignore·the·presence·of·any·superclass·(preventing·any·infinite·loops).$ $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclass . getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·compiled·classes·have·generic·types·erased,·but·can·be·made·available·for·reflection·via·getgenericsignature().$ $newline$ $indentation$ $//·if·it·is·absent,·then·no·further·work·is·needed·and·we·can·return·a·reference·type·without·generics.$ $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ referencetypeimpl ( typesolver . solvetype ( javassistutils . internalnametocanonicalname ( ctclass . getclassfile ( ) . getsuperclass ( ) ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ signatureattribute . classsignature $whitespace$ classsignature $whitespace$ = $whitespace$ signatureattribute . toclasssignature ( ctclass . getgenericsignature ( ) ) ; $newline$ $indentation$ return $whitespace$ optional . ofnullable ( javassistutils . signaturetypetotype ( classsignature . getsuperclass ( ) , $whitespace$ typesolver , $whitespace$ typedeclaration ) . asreferencetype ( ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( badbytecode $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < resolvedreferencetype > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ if $whitespace$ ( $string$. equals ( ctclass. getclassfile ( ). getname ( ) ) ) $whitespace$ { $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ctclass. getgenericsignature ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $string$ $whitespace$ = $whitespace$ optional. of ( new $whitespace$ referencetypeimpl ( typesolver. solvetype ( javassistutils. internalnametocanonicalname ( ctclass. getclassfile ( ). getsuperclass ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ signatureattribute. classsignature $whitespace$ classsignature $whitespace$ = $whitespace$ signatureattribute. toclasssignature ( ctclass. getgenericsignature ( ) ) ; $newline$ $indentation$ return $whitespace$ optional. ofnullable ( javassistutils. signaturetypetotype ( classsignature.			
isAssignableBy	240	265	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.292041927576065	LOW	"		public boolean isAssignableBy(ResolvedType type){
		    if (type instanceof NullType) {
		        return true;
		    }
		    if (type instanceof LambdaArgumentTypePlaceholder) {
		        return isFunctionalInterface();
		    }
		    if (type.isArray()) {
		        return false;
		    }
		    if (type.isPrimitive()) {
		        return false;
		    }
		    if (type.describe().equals(typeDeclaration.getQualifiedName())) {
		        return true;
		    }
		    if (type instanceof ReferenceTypeImpl) {
		        ReferenceTypeImpl otherTypeDeclaration = (ReferenceTypeImpl) type;
		        if (otherTypeDeclaration.getTypeDeclaration().isPresent()) {
		            return otherTypeDeclaration.getTypeDeclaration().get().canBeAssignedTo(typeDeclaration);
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nulltype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . describe ( ) . equals ( typedeclaration . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( othertypedeclaration . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ othertypedeclaration . gettypedeclaration ( ) . get ( ) . canbeassignedto ( typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nulltype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. describe ( ). equals ( typedeclaration. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( othertypedeclaration. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl			
getDeclaredFields	167	183	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeDeclarationAdapter.java	0.625497043132782	MID	"		public List<ResolvedFieldDeclaration> getDeclaredFields(){
		    List<ResolvedFieldDeclaration> fields = new ArrayList<>();
		    // First consider fields declared on this class
		    for (CtField field : ctClass.getDeclaredFields()) {
		        fields.add(new JavassistFieldDeclaration(field, typeSolver));
		    }
		    // Then consider fields inherited from ancestors
		    for (ResolvedReferenceType ancestor : typeDeclaration.getAllAncestors()) {
		        ancestor.getTypeDeclaration().ifPresent(ancestorTypeDeclaration -> {
		            fields.addAll(ancestorTypeDeclaration.getAllFields());
		        });
		    }
		    return fields;
		}"	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getdeclaredfields ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $//·first·consider·fields·declared·on·this·class$ $newline$ $indentation$ for $whitespace$ ( ctfield $whitespace$ field $whitespace$ : $whitespace$ ctclass . getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ fields . add ( new $whitespace$ javassistfielddeclaration ( field , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·then·consider·fields·inherited·from·ancestors$ $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration . getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor . gettypedeclaration ( ) . ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ fields . addall ( ancestortypedeclaration . getallfields ( ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getdeclaredfields ( ) { $newline$ $indentation$ list < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( ctfield $whitespace$ field $whitespace$ : $whitespace$ ctclass. getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ fields. add ( new $whitespace$ javassistfielddeclaration ( field, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }			
getBounds	109	120	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java	0.2833836078643799	LOW	"		@Override
		public List<ResolvedTypeParameterDeclaration.Bound> getBounds(){
		    List<Bound> bounds = new ArrayList<>();
		    SignatureAttribute.ObjectType classBound = wrapped.getClassBound();
		    if (classBound != null) {
		        bounds.add(Bound.extendsBound(JavassistUtils.signatureTypeToType(classBound, typeSolver, getContainer())));
		    }
		    for (SignatureAttribute.ObjectType ot : wrapped.getInterfaceBound()) {
		        bounds.add(Bound.extendsBound(JavassistUtils.signatureTypeToType(ot, typeSolver, getContainer())));
		    }
		    return bounds;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration . bound > $whitespace$ getbounds ( ) { $newline$ $indentation$ list < bound > $whitespace$ bounds $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ signatureattribute . objecttype $whitespace$ classbound $whitespace$ = $whitespace$ wrapped . getclassbound ( ) ; $newline$ $indentation$ if $whitespace$ ( classbound $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ bounds . add ( bound . extendsbound ( javassistutils . signaturetypetotype ( classbound , $whitespace$ typesolver , $whitespace$ getcontainer ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( signatureattribute . objecttype $whitespace$ ot $whitespace$ : $whitespace$ wrapped . getinterfacebound ( ) ) $whitespace$ { $newline$ $indentation$ bounds . add ( bound . extendsbound ( javassistutils . signaturetypetotype ( ot , $whitespace$ typesolver , $whitespace$ getcontainer ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ bounds ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedtypeparameterdeclaration. bound > $whitespace$ getbounds ( ) { $newline$ $indentation$ list < bound > $whitespace$ bounds $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ signatureattribute. objecttype $whitespace$ classbound $whitespace$ = $whitespace$ wrappedconnection. getclassbound ( ) ; $newline$ $indentation$ if $whitespace$ ( classbound $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ bounds. add ( bound. extendsbound ( javassistutils. signaturetypetotype ( classbound, $whitespace$ typesolver, $whitespace$ getcontainer ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( signatureattribute. objecttype $whitespace$ ot $whitespace$ : $whitespace$ wrappedconnection. getinterfacebound ( ) ) $whitespace$ { $newline$ $indentation$ bounds. add ( bound. extendsbound ( javassistutils. signaturetypetotype ( ot, $whitespace$ typesolver, $whitespace$ getcontainer ( ) ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ bounds ; $newline$ $indentation$ }			
containerType	122	128	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java	0.61215740442276	MID	"		@Override
		public Optional<ResolvedReferenceTypeDeclaration> containerType(){
		    if (container instanceof ResolvedReferenceTypeDeclaration) {
		        return Optional.of((ResolvedReferenceTypeDeclaration) container);
		    }
		    return Optional.empty();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( ( resolvedreferencetypedeclaration ) $whitespace$ container ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( ( resolvedreferencetypedeclaration ) $whitespace$ container ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
getContainerQualifiedName	88	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java	0.6209661364555359	MID	"		@Override
		public String getContainerQualifiedName(){
		    if (this.container instanceof ResolvedReferenceTypeDeclaration) {
		        return ((ResolvedReferenceTypeDeclaration) this.container).getQualifiedName();
		    }
		    if (this.container instanceof ResolvedMethodLikeDeclaration) {
		        return ((ResolvedMethodLikeDeclaration) this.container).getQualifiedName();
		    }
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getcontainerqualifiedname ( ) { $newline$ $indentation$ if $whitespace$ ( this . container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( resolvedreferencetypedeclaration ) $whitespace$ this . container ) . getqualifiedname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( this . container $whitespace$ instanceof $whitespace$ resolvedmethodlikedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( resolvedmethodlikedeclaration ) $whitespace$ this . container ) . getqualifiedname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getcontainerqualifiedname ( ) { $newline$ $indentation$ return $whitespace$ ( this. container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ && $whitespace$ ( ( resolvedreferencetypedeclaration ) $whitespace$ this. container ). getqualifiedname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( this. container $whitespace$ instanceof $whitespace$ resolvedmethodlikedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( resolvedmethodlikedeclaration ) $whitespace$ this. container ). getqualifiedname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
toString	76	81	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistTypeParameter.java	0.8847395181655884	HIGH	"		@Override
		public String toString(){
		    return ""JavassistTypeParameter{"" + wrapped.getName() + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ wrapped . getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ wrapped. getname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
signatureTypeToType	127	157	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.0028899090830236	LOW	"		 static ResolvedType signatureTypeToType(SignatureAttribute.Type signatureType, TypeSolver typeSolver, ResolvedTypeParametrizable typeParametrizable){
		    if (signatureType instanceof SignatureAttribute.ClassType) {
		        SignatureAttribute.ClassType classType = (SignatureAttribute.ClassType) signatureType;
		        List<ResolvedType> typeArguments = classType.getTypeArguments() == null ? Collections.emptyList() : Arrays.stream(classType.getTypeArguments()).map(ta -> typeArgumentToType(ta, typeSolver, typeParametrizable)).collect(Collectors.toList());
		        ResolvedReferenceTypeDeclaration typeDeclaration = typeSolver.solveType(removeTypeArguments(internalNameToCanonicalName(getTypeName(classType))));
		        return new ReferenceTypeImpl(typeDeclaration, typeArguments);
		    }
		    if (signatureType instanceof SignatureAttribute.TypeVariable) {
		        SignatureAttribute.TypeVariable typeVariableSignature = (SignatureAttribute.TypeVariable) signatureType;
		        Optional<ResolvedTypeParameterDeclaration> typeParameterDeclarationOpt = typeParametrizable.findTypeParameter(typeVariableSignature.getName());
		        if (!typeParameterDeclarationOpt.isPresent()) {
		            throw new UnsolvedSymbolException(""Unable to solve TypeVariable "" + typeVariableSignature);
		        }
		        ResolvedTypeParameterDeclaration typeParameterDeclaration = typeParameterDeclarationOpt.get();
		        return new ResolvedTypeVariable(typeParameterDeclaration);
		    }
		    if (signatureType instanceof SignatureAttribute.ArrayType) {
		        SignatureAttribute.ArrayType arrayType = (SignatureAttribute.ArrayType) signatureType;
		        ResolvedType baseType = signatureTypeToType(arrayType.getComponentType(), typeSolver, typeParametrizable);
		        return getArrayType(baseType, arrayType.getDimension());
		    }
		    if (signatureType instanceof SignatureAttribute.BaseType) {
		        SignatureAttribute.BaseType baseType = (SignatureAttribute.BaseType) signatureType;
		        if (baseType.toString().equals(""void"")) {
		            return ResolvedVoidType.INSTANCE;
		        }
		        return ResolvedPrimitiveType.byName(baseType.toString());
		    }
		    throw new RuntimeException(signatureType.getClass().getCanonicalName());
		}"	$indentation$ static $whitespace$ resolvedtype $whitespace$ signaturetypetotype ( signatureattribute . type $whitespace$ signaturetype , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute . classtype ) $whitespace$ { $newline$ $indentation$ signatureattribute . classtype $whitespace$ classtype $whitespace$ = $whitespace$ ( signatureattribute . classtype ) $whitespace$ signaturetype ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typearguments $whitespace$ = $whitespace$ classtype . gettypearguments ( ) $whitespace$ == $whitespace$ null $whitespace$ ? $whitespace$ collections . emptylist ( ) $whitespace$ : $whitespace$ arrays . stream ( classtype . gettypearguments ( ) ) . map ( ta $whitespace$ - > $whitespace$ typeargumenttotype ( ta , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ typesolver . solvetype ( removetypearguments ( internalnametocanonicalname ( gettypename ( classtype ) ) ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclaration , $whitespace$ typearguments ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute . typevariable ) $whitespace$ { $newline$ $indentation$ signatureattribute . typevariable $whitespace$ typevariablesignature $whitespace$ = $whitespace$ ( signatureattribute . typevariable ) $whitespace$ signaturetype ; $newline$ $indentation$ optional < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarationopt $whitespace$ = $whitespace$ typeparametrizable . findtypeparameter ( typevariablesignature . getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( ! typeparameterdeclarationopt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ typevariablesignature ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ typeparameterdeclaration $whitespace$ = $whitespace$ typeparameterdeclarationopt . get ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( typeparameterdeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute . arraytype ) $whitespace$ { $newline$ $indentation$ signatureattribute . arraytype $whitespace$ arraytype $whitespace$ = $whitespace$ ( signatureattribute . arraytype ) $whitespace$ signaturetype ; $newline$ $indentation$ resolvedtype $whitespace$ basetype $whitespace$ = $whitespace$ signaturetypetotype ( arraytype . getcomponenttype ( ) , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ; $newline$ $indentation$ return $whitespace$ getarraytype ( basetype , $whitespace$ arraytype . getdimension ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute . basetype ) $whitespace$ { $newline$ $indentation$ signatureattribute . basetype $whitespace$ basetype $whitespace$ = $whitespace$ ( signatureattribute . basetype ) $whitespace$ signaturetype ; $newline$ $indentation$ if $whitespace$ ( basetype . tostring ( ) . equals ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedvoidtype . instance ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . byname ( basetype . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( signaturetype . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ resolvedtype $whitespace$ signaturetypetotype ( signatureattribute. type $whitespace$ signaturetype, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute. classtype ) $whitespace$ { $newline$ $indentation$ signatureattribute. classtype $whitespace$ classtype $whitespace$ = $whitespace$ ( signatureattribute. classtype ) $whitespace$ signaturetype ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typearguments $whitespace$ = $whitespace$ classtype. gettypearguments ( ) ; $newline$ $indentation$ if $whitespace$ ( signaturetype $whitespace$ instanceof $whitespace$ signatureattribute. typevariable ) $whitespace$ { $newline$ $indentation$ signatureattribute. typevariable $whitespace$ typevariablesignature $whitespace$ = $whitespace$ ( signatureattribute. typevariable ) $whitespace$ signaturetype ; $newline$ $indentation$ optional < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarationopt $whitespace$ = $whitespace$ typeparametrizable. find			
solveMethodAsUsage	53	86	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.0035069526638835	LOW	"		 static Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, Context invokationContext, List<ResolvedType> typeParameterValues, ResolvedReferenceTypeDeclaration scopeType, CtClass ctClass){
		    List<ResolvedTypeParameterDeclaration> typeParameters = scopeType.getTypeParameters();
		    List<MethodUsage> methods = new ArrayList<>();
		    for (CtMethod method : ctClass.getDeclaredMethods()) {
		        if (method.getName().equals(name) && ((method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0) && ((method.getMethodInfo().getAccessFlags() & AccessFlag.SYNTHETIC) == 0)) {
		            MethodUsage methodUsage = new MethodUsage(new JavassistMethodDeclaration(method, typeSolver));
		            for (int i = 0; i < typeParameters.size() && i < typeParameterValues.size(); i++) {
		                ResolvedTypeParameterDeclaration tpToReplace = typeParameters.get(i);
		                ResolvedType newValue = typeParameterValues.get(i);
		                methodUsage = methodUsage.replaceTypeParameter(tpToReplace, newValue);
		            }
		            methods.add(methodUsage);
		            // no need to search for overloaded/inherited methods if the method has no parameters
		            if (argumentsTypes.isEmpty() && methodUsage.getNoParams() == 0) {
		                return Optional.of(methodUsage);
		            }
		        }
		    }
		    for (ResolvedReferenceType ancestor : scopeType.getAncestors()) {
		        ancestor.getTypeDeclaration().flatMap(superClassTypeDeclaration -> ancestor.getTypeDeclaration()).flatMap(interfaceTypeDeclaration -> ContextHelper.solveMethodAsUsage(interfaceTypeDeclaration, name, argumentsTypes, invokationContext, typeParameterValues)).ifPresent(methods::add);
		    }
		    return MethodResolutionLogic.findMostApplicableUsage(methods, name, argumentsTypes, typeSolver);
		}"	$indentation$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues , $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype , $whitespace$ ctclass $whitespace$ ctclass ) { $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typeparameters $whitespace$ = $whitespace$ scopetype . gettypeparameters ( ) ; $newline$ $indentation$ list < methodusage > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( ctmethod $whitespace$ method $whitespace$ : $whitespace$ ctclass . getdeclaredmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method . getname ( ) . equals ( name ) $whitespace$ && $whitespace$ ( ( method . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . bridge ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ && $whitespace$ ( ( method . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . synthetic ) $whitespace$ == $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( new $whitespace$ javassistmethoddeclaration ( method , $whitespace$ typesolver ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparameters . size ( ) $whitespace$ && $whitespace$ i $whitespace$ < $whitespace$ typeparametervalues . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ tptoreplace $whitespace$ = $whitespace$ typeparameters . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ newvalue $whitespace$ = $whitespace$ typeparametervalues . get ( i ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( tptoreplace , $whitespace$ newvalue ) ; $newline$ $indentation$ } $newline$ $indentation$ methods . add ( methodusage ) ; $newline$ $indentation$ $//·no·need·to·search·for·overloaded/inherited·methods·if·the·method·has·no·parameters$ $newline$ $indentation$ if $whitespace$ ( argumentstypes . isempty ( ) $whitespace$ && $whitespace$ methodusage . getnoparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ scopetype . getancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor . gettypedeclaration ( ) . flatmap ( superclasstypedeclaration $whitespace$ - > $whitespace$ ancestor . gettypedeclaration ( ) ) . flatmap ( interfacetypedeclaration $whitespace$ - > $whitespace$ contexthelper . solvemethodasusage ( interfacetypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ invokationcontext , $whitespace$ typeparametervalues ) ) . ifpresent ( methods : : add ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicableusage ( methods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues, $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype, $whitespace$ ctclass $whitespace$ ctclass ) { $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ typeparameters $whitespace$ = $whitespace$ scopetype. gettypeparameters ( ) ; $newline$ $indentation$ list < methodusage > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( ctmethod $whitespace$ method $whitespace$ : $whitespace$ ctclass. getdeclaredmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method. getname ( ). equals ( name ) $whitespace$ && $whitespace$ ( ( method. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. bridge ) $whitespace$ && $whitespace$ ( ( method. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. synthetic ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( new $whitespace$ javassistmethoddeclaration ( method, $whitespace$ typesolver ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ typeparameters. size ( ) $whitespace$ && $whitespace$ i $whitespace$			
solveMethod	88	125	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.006384705659002	LOW	"		 static SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly, TypeSolver typeSolver, ResolvedReferenceTypeDeclaration scopeType, CtClass ctClass){
		    List<ResolvedMethodDeclaration> candidates = new ArrayList<>();
		    Predicate<CtMethod> staticOnlyCheck = m -> !staticOnly || java.lang.reflect.Modifier.isStatic(m.getModifiers());
		    for (CtMethod method : ctClass.getDeclaredMethods()) {
		        boolean isSynthetic = method.getMethodInfo().getAttribute(SyntheticAttribute.tag) != null;
		        boolean isNotBridge = (method.getMethodInfo().getAccessFlags() & AccessFlag.BRIDGE) == 0;
		        if (method.getName().equals(name) && !isSynthetic && isNotBridge && staticOnlyCheck.test(method)) {
		            ResolvedMethodDeclaration candidate = new JavassistMethodDeclaration(method, typeSolver);
		            candidates.add(candidate);
		            // no need to search for overloaded/inherited methods if the method has no parameters
		            if (argumentsTypes.isEmpty() && candidate.getNumberOfParams() == 0) {
		                return SymbolReference.solved(candidate);
		            }
		        }
		    }
		    // add the method declaration of the interfaces to the candidates, if present
		    for (ResolvedReferenceType ancestorRefType : scopeType.getAncestors()) {
		        Optional<ResolvedReferenceTypeDeclaration> ancestorTypeDeclOpt = ancestorRefType.getTypeDeclaration();
		        if (ancestorTypeDeclOpt.isPresent()) {
		            SymbolReference<ResolvedMethodDeclaration> ancestorMethodRef = MethodResolutionLogic.solveMethodInType(ancestorTypeDeclOpt.get(), name, argumentsTypes, staticOnly);
		            if (ancestorMethodRef.isSolved()) {
		                candidates.add(ancestorMethodRef.getCorrespondingDeclaration());
		            }
		        } else {
		            // Consider IllegalStateException or similar?
		        }
		    }
		    return MethodResolutionLogic.findMostApplicable(candidates, name, argumentsTypes, typeSolver);
		}"	$indentation$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype , $whitespace$ ctclass $whitespace$ ctclass ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidates $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ predicate < ctmethod > $whitespace$ staticonlycheck $whitespace$ = $whitespace$ m $whitespace$ - > $whitespace$ ! staticonly $whitespace$ || $whitespace$ java . lang . reflect . modifier . isstatic ( m . getmodifiers ( ) ) ; $newline$ $indentation$ for $whitespace$ ( ctmethod $whitespace$ method $whitespace$ : $whitespace$ ctclass . getdeclaredmethods ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ issynthetic $whitespace$ = $whitespace$ method . getmethodinfo ( ) . getattribute ( syntheticattribute . tag ) $whitespace$ != $whitespace$ null ; $newline$ $indentation$ boolean $whitespace$ isnotbridge $whitespace$ = $whitespace$ ( method . getmethodinfo ( ) . getaccessflags ( ) $whitespace$ & $whitespace$ accessflag . bridge ) $whitespace$ == $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( method . getname ( ) . equals ( name ) $whitespace$ && $whitespace$ ! issynthetic $whitespace$ && $whitespace$ isnotbridge $whitespace$ && $whitespace$ staticonlycheck . test ( method ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ candidate $whitespace$ = $whitespace$ new $whitespace$ javassistmethoddeclaration ( method , $whitespace$ typesolver ) ; $newline$ $indentation$ candidates . add ( candidate ) ; $newline$ $indentation$ $//·no·need·to·search·for·overloaded/inherited·methods·if·the·method·has·no·parameters$ $newline$ $indentation$ if $whitespace$ ( argumentstypes . isempty ( ) $whitespace$ && $whitespace$ candidate . getnumberofparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( candidate ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·add·the·method·declaration·of·the·interfaces·to·the·candidates,·if·present$ $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestorreftype $whitespace$ : $whitespace$ scopetype . getancestors ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ ancestortypedeclopt $whitespace$ = $whitespace$ ancestorreftype . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( ancestortypedeclopt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ancestormethodref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ancestortypedeclopt . get ( ) , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( ancestormethodref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidates . add ( ancestormethodref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·consider·illegalstateexception·or·similar?$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicable ( candidates , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype, $whitespace$ ctclass $whitespace$ ctclass ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidates $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ predicate < ctmethod > $whitespace$ staticonlycheck $whitespace$ = $whitespace$ m $whitespace$ - > $whitespace$! staticonly $whitespace$ || $whitespace$ java. lang. reflect. modifier. isstatic ( m. getmodifiers ( ) ) ; $newline$ $indentation$ for $whitespace$ ( ctmethod $whitespace$ method $whitespace$ : $whitespace$ ctclass. getdeclaredmethods ( ) ) $whitespace$ { $newline$ $indentation$ boolean $whitespace$ issynthetic $whitespace$ = $whitespace$ method. getmethodinfo ( ). getattribute ( syntheticattribute. tag ) $whitespace$!= $whitespace$ null ; $newline$ $indentation$ boolean $whitespace$ isnotbridge $whitespace$ = $whitespace$ ( method. getmethodinfo ( ). getaccessflags ( ) $whitespace$ & $whitespace$ accessflag. bridge ) $whitespace$ == $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( method. getname ( ). equals ( name ) $whitespace$ && $whitespace$! issynthetic $whitespace$ && $whitespace$ isnotbridge $whitespace$ && $whitespace$ staticonlycheck. test ( method ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ candidate $whitespace$ = $whitespace$ new $whitespace$ javassistmethoddeclaration ( method, $whitespace$ typesolve			
typeArgumentToType	199	213	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.0712028816342353	LOW	"		private static ResolvedType typeArgumentToType(SignatureAttribute.TypeArgument typeArgument, TypeSolver typeSolver, ResolvedTypeParametrizable typeParametrizable){
		    if (typeArgument.isWildcard()) {
		        if (typeArgument.getType() == null) {
		            return ResolvedWildcard.UNBOUNDED;
		        }
		        if (typeArgument.getKind() == '+') {
		            return ResolvedWildcard.extendsBound(objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable));
		        }
		        if (typeArgument.getKind() == '-') {
		            return ResolvedWildcard.superBound(objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable));
		        }
		        throw new UnsupportedOperationException();
		    }
		    return objectTypeArgumentToType(typeArgument.getType(), typeSolver, typeParametrizable);
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeargumenttotype ( signatureattribute . typeargument $whitespace$ typeargument , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( typeargument . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typeargument . gettype ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . unbounded ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeargument . getkind ( ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . extendsbound ( objecttypeargumenttotype ( typeargument . gettype ( ) , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeargument . getkind ( ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . superbound ( objecttypeargumenttotype ( typeargument . gettype ( ) , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ objecttypeargumenttotype ( typeargument . gettype ( ) , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeargumenttotype ( signatureattribute. typeargument $whitespace$ typeargument, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( typeargument. iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeargument. gettype ( ) $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ resolvedwildcard. abound ( objecttypeargumenttotype ( typeargument. gettype ( ), $whitespace$ typesolver, $whitespace$ typeparametrizable ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeargument. getkind ( ) $whitespace$ == $whitespace$ $string$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typeargument. gettype ( ). gettype ( ) $whitespace$ == $whitespace$ typesolver, $whitespace$ typeparametrizable ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ objecttypeargumenttotype ( typeargument. gettype ( ), $whitespace$ typesolver, $whitespace$ typeparametrizable ) ; $newline$ $indentation$ }			
getGenericParameterByName	193	197	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.1173827871680259	LOW	"		private static ResolvedType getGenericParameterByName(String typeName, ResolvedTypeParametrizable typeParametrizable, TypeSolver typeSolver){
		    Optional<ResolvedType> type = typeParametrizable.findTypeParameter(typeName).map(ResolvedTypeVariable::new);
		    return type.orElseGet(() -> new ReferenceTypeImpl(typeSolver.solveType(removeTypeArguments(internalNameToCanonicalName(typeName)))));
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ getgenericparameterbyname ( string $whitespace$ typename , $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ optional < resolvedtype > $whitespace$ type $whitespace$ = $whitespace$ typeparametrizable . findtypeparameter ( typename ) . map ( resolvedtypevariable : : new ) ; $newline$ $indentation$ return $whitespace$ type . orelseget ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . solvetype ( removetypearguments ( internalnametocanonicalname ( typename ) ) ) ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ getgenericparameterbyname ( string $whitespace$ typename, $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ optional < resolvedtype > $whitespace$ type $whitespace$ = $whitespace$ typeparametrizable. findtypeparameter ( typename ). map ( resolvedtypevariable : : new ) ; $newline$ $indentation$ return $whitespace$ type. orelseget ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ referencetypeimpl ( typesolver. solvetype ( removetypearguments ( internalnametocanonicalname ( typename ) ) ) ) ) ; $newline$ $indentation$ }			
objectTypeArgumentToType	182	191	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.1251151710748672	LOW	"		private static ResolvedType objectTypeArgumentToType(SignatureAttribute.ObjectType typeArgument, TypeSolver typeSolver, ResolvedTypeParametrizable typeParametrizable){
		    if (typeArgument instanceof SignatureAttribute.ClassType) {
		        return signatureTypeToType(typeArgument, typeSolver, typeParametrizable);
		    }
		    if (typeArgument instanceof SignatureAttribute.ArrayType) {
		        return new ResolvedArrayType(signatureTypeToType(((SignatureAttribute.ArrayType) typeArgument).getComponentType(), typeSolver, typeParametrizable));
		    }
		    String typeName = typeArgument.jvmTypeName();
		    return getGenericParameterByName(typeName, typeParametrizable, typeSolver);
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ objecttypeargumenttotype ( signatureattribute . objecttype $whitespace$ typeargument , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( typeargument $whitespace$ instanceof $whitespace$ signatureattribute . classtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ signaturetypetotype ( typeargument , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeargument $whitespace$ instanceof $whitespace$ signatureattribute . arraytype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( signaturetypetotype ( ( ( signatureattribute . arraytype ) $whitespace$ typeargument ) . getcomponenttype ( ) , $whitespace$ typesolver , $whitespace$ typeparametrizable ) ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ typeargument . jvmtypename ( ) ; $newline$ $indentation$ return $whitespace$ getgenericparameterbyname ( typename , $whitespace$ typeparametrizable , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedtype $whitespace$ objecttypeargumenttotype ( signatureattribute. objecttype $whitespace$ typeargument, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ resolvedtypeparametrizable $whitespace$ typeparametrizable ) { $newline$ $indentation$ if $whitespace$ ( typeargument $whitespace$ instanceof $whitespace$ signatureattribute. classtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ signaturetypetotype ( typeargument, $whitespace$ typesolver, $whitespace$ typeparametrizable ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( typeargument $whitespace$ instanceof $whitespace$ signatureattribute. arraytype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( signaturetypetotype ( ( ( signatureattribute. arraytype ) $whitespace$ typeargument ). getcomponenttype ( ), $whitespace$ typesolver, $whitespace$ typeparametrizable ) ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ typename $whitespace$ = $whitespace$ typeargument. jvmtypename ( ) ; $newline$ $indentation$ return $whitespace$ getgenericparameterbyname ( typename, $whitespace$ typeparametrizable, $whitespace$ typesolver ) ; $newline$ $indentation$ }			
extractParameterName	230	242	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/javassistmodel/JavassistUtils.java	0.2594746053218841	LOW	"		 static Optional<String> extractParameterName(CtBehavior method, int paramNumber){
		    MethodInfo methodInfo = method.getMethodInfo();
		    CodeAttribute codeAttribute = methodInfo.getCodeAttribute();
		    if (codeAttribute != null) {
		        LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);
		        if (attr != null) {
		            int pos = Modifier.isStatic(method.getModifiers()) ? 0 : 1;
		            return getVariableName(attr, paramNumber + pos);
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ static $whitespace$ optional < string > $whitespace$ extractparametername ( ctbehavior $whitespace$ method , $whitespace$ int $whitespace$ paramnumber ) { $newline$ $indentation$ methodinfo $whitespace$ methodinfo $whitespace$ = $whitespace$ method . getmethodinfo ( ) ; $newline$ $indentation$ codeattribute $whitespace$ codeattribute $whitespace$ = $whitespace$ methodinfo . getcodeattribute ( ) ; $newline$ $indentation$ if $whitespace$ ( codeattribute $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ localvariableattribute $whitespace$ attr $whitespace$ = $whitespace$ ( localvariableattribute ) $whitespace$ codeattribute . getattribute ( localvariableattribute . tag ) ; $newline$ $indentation$ if $whitespace$ ( attr $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ int $whitespace$ pos $whitespace$ = $whitespace$ modifier . isstatic ( method . getmodifiers ( ) ) $whitespace$ ? $whitespace$ $number$ $whitespace$ : $whitespace$ $number$ ; $newline$ $indentation$ return $whitespace$ getvariablename ( attr , $whitespace$ paramnumber $whitespace$ + $whitespace$ pos ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ optional < string > $whitespace$ extractparametername ( ctbehavior $whitespace$ method, $whitespace$ int $whitespace$ paramnumber ) { $newline$ $indentation$ methodinfo $whitespace$ methodinfo $whitespace$ = $whitespace$ method. getmethodinfo ( ) ; $newline$ $indentation$ if $whitespace$ ( codeattribute $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ methodinfo $whitespace$ = $whitespace$ methodinfo. getcodeattribute ( ) ; $newline$ $indentation$ if $whitespace$ ( attr $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ methodinfo $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( codeattribute $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ methodinfo $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ methodinfo $whitespace$ = $whitespace$ methodinfo. getcodeattribute ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
solveMethodAsUsage	194	227	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.0771239921450614	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(final String name, final List<ResolvedType> parameterTypes, final Context invokationContext, final List<ResolvedType> typeParameterValues){
		    Optional<MethodUsage> res = ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz);
		    if (res.isPresent()) {
		        // We have to replace method type typeParametersValues here
		        InferenceContext inferenceContext = new InferenceContext(typeSolver);
		        MethodUsage methodUsage = res.get();
		        int i = 0;
		        List<ResolvedType> parameters = new LinkedList<>();
		        for (ResolvedType actualType : parameterTypes) {
		            ResolvedType formalType = methodUsage.getParamType(i);
		            // We need to replace the class type typeParametersValues (while we derive the method ones)
		            parameters.add(inferenceContext.addPair(formalType, actualType));
		            i++;
		        }
		        try {
		            ResolvedType returnType = inferenceContext.addSingle(methodUsage.returnType());
		            for (int j = 0; j < parameters.size(); j++) {
		                methodUsage = methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j)));
		            }
		            methodUsage = methodUsage.replaceReturnType(inferenceContext.resolve(returnType));
		            return Optional.of(methodUsage);
		        } catch (ConflictingGenericTypesException e) {
		            return Optional.empty();
		        }
		    } else {
		        return res;
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( final $whitespace$ string $whitespace$ name , $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ final $whitespace$ context $whitespace$ invokationcontext , $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic . solvemethodasusage ( name , $whitespace$ parametertypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·we·have·to·replace·method·type·typeparametersvalues·here$ $newline$ $indentation$ inferencecontext $whitespace$ inferencecontext $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ res . get ( ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ list < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage . getparamtype ( i ) ; $newline$ $indentation$ $//·we·need·to·replace·the·class·type·typeparametersvalues·(while·we·derive·the·method·ones)$ $newline$ $indentation$ parameters . add ( inferencecontext . addpair ( formaltype , $whitespace$ actualtype ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ inferencecontext . addsingle ( methodusage . returntype ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replaceparamtype ( j , $whitespace$ inferencecontext . resolve ( parameters . get ( j ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacereturntype ( inferencecontext . resolve ( returntype ) ) ; $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( conflictinggenerictypesexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( final $whitespace$ string $whitespace$ name, $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ final $whitespace$ context $whitespace$ invokationcontext, $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic. solvemethodasusage ( name, $whitespace$ parametertypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $////g ; $newline$ $indentation$ // $whitespace$ the $whitespace$ cached $whitespace$ data $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ ensure $whitespace$ that $whitespace$ the $whitespace$ search $whitespace$ is $whitespace$ used $newline$ $indentation$ optional < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage. getparamtype ( i ) ; $newline$ $indentation$ $////g ; $newline$ $indentation$ // $whitespace$ break $whitespace$ the $whitespace$ e.g. $whitespace$ does $whitespace$ not $whitespace$ have $whitespace$ the $whitespace$ org $whitespace$ file $whitespace$ in $whitespace$ the $whitespace$ tb ) ; $newline$ $indentation$ for			
internalTypes	175	180	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.0996970906853675	LOW	"		@Override
		public Set<ResolvedReferenceTypeDeclaration> internalTypes(){
		    return Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( this . clazz . getdeclaredclasses ( ) ) . map ( ic $whitespace$ - > $whitespace$ reflectionfactory . typedeclarationfor ( ic , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( this. clazz. getdeclaredclasses ( ) ). map ( ic $whitespace$ - > $whitespace$ reflectionfactory. typedeclarationfor ( ic, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
getAnnotationMembers	187	192	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.1114591807126998	LOW	"		@Override
		public List<ResolvedAnnotationMemberDeclaration> getAnnotationMembers(){
		    return Stream.of(clazz.getDeclaredMethods()).map(m -> new ReflectionAnnotationMemberDeclaration(m, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ stream . of ( clazz . getdeclaredmethods ( ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionannotationmemberdeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedannotationmemberdeclaration > $whitespace$ getannotationmembers ( ) { $newline$ $indentation$ return $whitespace$ stream. of ( clazz. getdeclaredmethods ( ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionannotationmemberdeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
solveMethod	229	235	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.1589801609516143	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(final String name, final List<ResolvedType> argumentsTypes, final boolean staticOnly){
		    return ReflectionMethodResolutionLogic.solveMethod(name, argumentsTypes, staticOnly, typeSolver, this, clazz);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( final $whitespace$ string $whitespace$ name , $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ final $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic . solvemethod ( name , $whitespace$ argumentstypes , $whitespace$ staticonly , $whitespace$ typesolver , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( final $whitespace$ string $whitespace$ name, $whitespace$ final $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ final $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic. solvemethod ( name, $whitespace$ argumentstypes, $whitespace$ staticonly, $whitespace$ typesolver, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ }			
equals	104	112	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.6235525608062744	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (!(o instanceof ReflectionAnnotationDeclaration))
		        return false;
		    ReflectionAnnotationDeclaration that = (ReflectionAnnotationDeclaration) o;
		    return clazz.getCanonicalName().equals(that.clazz.getCanonicalName());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( ! ( o $whitespace$ instanceof $whitespace$ reflectionannotationdeclaration ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ reflectionannotationdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( reflectionannotationdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ clazz . getcanonicalname ( ) . equals ( that . clazz . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ reflectionannotationdeclaration ) ; $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$ true ; $newline$ $indentation$ if $whitespace$ (! ( o $whitespace$ instanceof $whitespace$ reflectionannotationdeclaration ) ) $whitespace$ { $newline$ $indentation$ isequals $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! ( o $whitespace$ instanceof $whitespace$ reflectionannotationdeclaration ) ) $whitespace$ { $newline$ $indentation$ isequals $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ clazz. getcanonicalname ( ). equals ( that. clazz. getcanonicalname ( ) ) ; $newline$ $indentation$ }			
getDeclaredMethods	147	151	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.654319703578949	MID	"		@Override
		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    // TODO #1838
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//·todo·#1838$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ $//. remove ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
getClassName	83	90	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.679775595664978	MID	"		@Override
		public String getClassName(){
		    String qualifiedName = getQualifiedName();
		    if (qualifiedName.contains(""."")) {
		        return qualifiedName.substring(qualifiedName.lastIndexOf(""."") + 1);
		    }
		    return qualifiedName;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ qualifiedname $whitespace$ = $whitespace$ getqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( qualifiedname . contains ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifiedname . substring ( qualifiedname . lastindexof ( $string$ ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ qualifiedname ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ qualifiedname $whitespace$ = $whitespace$ getqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( qualifiedname. contains ( $string$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ qualifiedname. substring ( qualifiedname. lastindexof ( $string$ ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ qualifiedname ; $newline$ $indentation$ }			
toString	97	102	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.694355845451355	MID	"		@Override
		public String toString(){
		    return getClass().getSimpleName() + ""{"" + ""clazz="" + clazz.getCanonicalName() + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ clazz . getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ getclass ( ). getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ clazz. getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getPackageName	75	81	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.832897961139679	HIGH	"		@Override
		public String getPackageName(){
		    if (clazz.getPackage() != null) {
		        return clazz.getPackage().getName();
		    }
		    return """";
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getpackagename ( ) { $newline$ $indentation$ if $whitespace$ ( clazz . getpackage ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ clazz . getpackage ( ) . getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getpackagename ( ) { $newline$ $indentation$ return $whitespace$ clazz. getpackage ( ). getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getpackage ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ clazz. getpackage ( ). getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ $string$ ; $newline$ $indentation$ }			
isAssignableBy	119	123	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationDeclaration.java	0.8441368341445923	HIGH	"		@Override
		public boolean isAssignableBy(ResolvedType type){
		    // TODO #1836
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $//·todo·#1836$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ $whitespace$ // $whitespace$ the $whitespace$ use $whitespace$ of $whitespace$ the $whitespace$ harmonizer $whitespace$ -> $whitespace$ include $whitespace$ an $whitespace$ solution $whitespace$ is $whitespace$ already $whitespace$ cached $whitespace$ by $whitespace$ right $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
transformDefaultValue	85	110	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java	0.005921974312514	LOW	"		private Expression transformDefaultValue(Object value){
		    if (value instanceof Enum<?>) {
		        final Class<?> declaringClass = ((Enum<?>) value).getDeclaringClass();
		        final String name = ((Enum<?>) value).name();
		        return new FieldAccessExpr(new NameExpr(declaringClass.getSimpleName()), name);
		    } else if (value instanceof Annotation) {
		        final Class<? extends Annotation> annotationType = ((Annotation) value).annotationType();
		        final Method[] declaredMethods = annotationType.getDeclaredMethods();
		        final NodeList<MemberValuePair> pairs = Arrays.stream(declaredMethods).map(m -> {
		            final ReflectionAnnotationMemberDeclaration nestedMemberDeclaration = new ReflectionAnnotationMemberDeclaration(m, typeSolver);
		            return new MemberValuePair(m.getName(), nestedMemberDeclaration.getDefaultValue());
		        }).collect(NodeList.toNodeList());
		        return new NormalAnnotationExpr(new Name(annotationType.getSimpleName()), pairs);
		    }
		    Function<Object, ? extends Expression> fn = valueAsExpressionConverters.get(value.getClass());
		    if (fn == null)
		        throw new UnsupportedOperationException(String.format(""Obtaining the default value of the annotation member %s (of type %s) is not supported yet."", annotationMember.getName(), value.getClass().getSimpleName()));
		    return fn.apply(value);
		}"	$indentation$ private $whitespace$ expression $whitespace$ transformdefaultvalue ( object $whitespace$ value ) { $newline$ $indentation$ if $whitespace$ ( value $whitespace$ instanceof $whitespace$ enum < ? > ) $whitespace$ { $newline$ $indentation$ final $whitespace$ class < ? > $whitespace$ declaringclass $whitespace$ = $whitespace$ ( ( enum < ? > ) $whitespace$ value ) . getdeclaringclass ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ name $whitespace$ = $whitespace$ ( ( enum < ? > ) $whitespace$ value ) . name ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ fieldaccessexpr ( new $whitespace$ nameexpr ( declaringclass . getsimplename ( ) ) , $whitespace$ name ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( value $whitespace$ instanceof $whitespace$ annotation ) $whitespace$ { $newline$ $indentation$ final $whitespace$ class < ? $whitespace$ extends $whitespace$ annotation > $whitespace$ annotationtype $whitespace$ = $whitespace$ ( ( annotation ) $whitespace$ value ) . annotationtype ( ) ; $newline$ $indentation$ final $whitespace$ method [ ] $whitespace$ declaredmethods $whitespace$ = $whitespace$ annotationtype . getdeclaredmethods ( ) ; $newline$ $indentation$ final $whitespace$ nodelist < membervaluepair > $whitespace$ pairs $whitespace$ = $whitespace$ arrays . stream ( declaredmethods ) . map ( m $whitespace$ - > $whitespace$ { $newline$ $indentation$ final $whitespace$ reflectionannotationmemberdeclaration $whitespace$ nestedmemberdeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionannotationmemberdeclaration ( m , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ membervaluepair ( m . getname ( ) , $whitespace$ nestedmemberdeclaration . getdefaultvalue ( ) ) ; $newline$ $indentation$ } ) . collect ( nodelist . tonodelist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ normalannotationexpr ( new $whitespace$ name ( annotationtype . getsimplename ( ) ) , $whitespace$ pairs ) ; $newline$ $indentation$ } $newline$ $indentation$ function < object , $whitespace$ ? $whitespace$ extends $whitespace$ expression > $whitespace$ fn $whitespace$ = $whitespace$ valueasexpressionconverters . get ( value . getclass ( ) ) ; $newline$ $indentation$ if $whitespace$ ( fn $whitespace$ == $whitespace$ null ) $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ annotationmember . getname ( ) , $whitespace$ value . getclass ( ) . getsimplename ( ) ) ) ; $newline$ $indentation$ return $whitespace$ fn . apply ( value ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ expression $whitespace$ transformdefaultvalue ( object $whitespace$ value ) { $newline$ $indentation$ if $whitespace$ ( value $whitespace$ instanceof $whitespace$ enum <? > ) $whitespace$ { $newline$ $indentation$ final $whitespace$ class <? > $whitespace$ declaringclass $whitespace$ = $whitespace$ ( ( enum <? > ) $whitespace$ value ). getdeclaringclass ( ) ; $newline$ $indentation$ final $whitespace$ string $whitespace$ name $whitespace$ = $whitespace$ ( ( enum <? > ) $whitespace$ value ). name ( ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ fieldaccessexpr ( new $whitespace$ nameexpr ( declaringclass. getsimplename ( ) ), $whitespace$ name ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( value $whitespace$ instanceof $whitespace$ annotation ) $whitespace$ { $newline$ $indentation$ final $whitespace$ class <? $whitespace$ extends $whitespace$ annotation > $whitespace$ annotationtype $whitespace$ = $whitespace$ ( ( annotation ) $whitespace$ value ). annotationtype ( ) ; $newline$ $indentation$ final $whitespace$ method [ ] $whitespace$ declaredmethods $whitespace$ = $whitespace$ annotationtype. getdeclaredmethods ( ) ; $newline$ $indentation$ final $whitespace$ nodelist < membervaluepair > $whitespace$ pairs $whitespace$ = $whitespace$ arrays. stream ( declaredmethods ). map ( m $whitespace$ - > $whitespace$ { $newline$ $indentation$ final $whitespace$ reflectionannotationmemberdeclaration $whitespace$ nestedmemberdeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionannotationmemberdeclaration ( m, $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ membervaluepair ( m. getname ( ), $whitespace$ nestedmemberdeclaration. getdefaultvalue			
getType	112	123	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java	0.1377402395009994	LOW	"		@Override
		public ResolvedType getType(){
		    Class returnType = annotationMember.getReturnType();
		    if (returnType.isPrimitive()) {
		        return ResolvedPrimitiveType.byName(returnType.getName());
		    }
		    SymbolReference<ResolvedReferenceTypeDeclaration> rrtd = typeSolver.tryToSolveType(returnType.getName());
		    if (rrtd.isSolved()) {
		        return new ReferenceTypeImpl(rrtd.getCorrespondingDeclaration());
		    }
		    throw new UnsupportedOperationException(String.format(""Obtaining the type of the annotation member %s is not supported yet."", annotationMember.getName()));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ class $whitespace$ returntype $whitespace$ = $whitespace$ annotationmember . getreturntype ( ) ; $newline$ $indentation$ if $whitespace$ ( returntype . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . byname ( returntype . getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ rrtd $whitespace$ = $whitespace$ typesolver . trytosolvetype ( returntype . getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( rrtd . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( rrtd . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string . format ( $string$ , $whitespace$ annotationmember . getname ( ) ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ gettype ( ) { $newline$ $indentation$ class $whitespace$ returntype $whitespace$ = $whitespace$ annotationmember. getreturntype ( ) ; $newline$ $indentation$ if $whitespace$ ( returntype. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype. byname ( returntype. getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ rrtd $whitespace$ = $whitespace$ typesolver. trytosolvetype ( returntype. getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( rrtd. issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( rrtd. getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( string. format ( $string$, $whitespace$ annotationmember. getname ( ) ) ) ; $newline$ $indentation$ }			
getDefaultValue	69	83	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionAnnotationMemberDeclaration.java	0.2420956939458847	LOW	"		@Override
		public Expression getDefaultValue(){
		    Object value = annotationMember.getDefaultValue();
		    if (value == null)
		        return null;
		    if (value.getClass().isArray()) {
		        Object[] values = (Object[]) value;
		        final NodeList<Expression> expressions = Arrays.stream(values).map(this::transformDefaultValue).collect(NodeList.toNodeList());
		        return new ArrayInitializerExpr(expressions);
		    }
		    return transformDefaultValue(value);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ expression $whitespace$ getdefaultvalue ( ) { $newline$ $indentation$ object $whitespace$ value $whitespace$ = $whitespace$ annotationmember . getdefaultvalue ( ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ null ) $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( value . getclass ( ) . isarray ( ) ) $whitespace$ { $newline$ $indentation$ object [ ] $whitespace$ values $whitespace$ = $whitespace$ ( object [ ] ) $whitespace$ value ; $newline$ $indentation$ final $whitespace$ nodelist < expression > $whitespace$ expressions $whitespace$ = $whitespace$ arrays . stream ( values ) . map ( this : : transformdefaultvalue ) . collect ( nodelist . tonodelist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ arrayinitializerexpr ( expressions ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ transformdefaultvalue ( value ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ expression $whitespace$ getdefaultvalue ( ) { $newline$ $indentation$ object $whitespace$ value $whitespace$ = $whitespace$ annotationmember. getdefaultvalue ( ) ; $newline$ $indentation$ if $whitespace$ ( value $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( value. getclass ( ). isarray ( ) ) $whitespace$ { $newline$ $indentation$ object [ ] $whitespace$ values $whitespace$ = $whitespace$ ( object [ ] ) $whitespace$ value ; $newline$ $indentation$ final $whitespace$ nodelist < expression > $whitespace$ expressions $whitespace$ = $whitespace$ arrays. stream ( values ). map ( this : : transformdefaultvalue ). collect ( nodelist. tonodelist ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ arrayinitializerexpr ( expressions ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ transformdefaultvalue ( value ) ; $newline$ $indentation$ }			
getInterfaces	72	86	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.0216486677527427	LOW	"		public List<ResolvedReferenceType> getInterfaces(){
		    List<ResolvedReferenceType> interfaces = new ArrayList<>();
		    for (java.lang.reflect.Type superInterface : clazz.getGenericInterfaces()) {
		        if (superInterface instanceof ParameterizedType) {
		            ParameterizedType parameterizedType = (ParameterizedType) superInterface;
		            List<ResolvedType> typeParameters = Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)).collect(Collectors.toList());
		            interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) ((ParameterizedType) superInterface).getRawType(), typeSolver), typeParameters));
		        } else {
		            interfaces.add(new ReferenceTypeImpl(new ReflectionInterfaceDeclaration((Class<?>) superInterface, typeSolver)));
		        }
		    }
		    return interfaces;
		}"	$indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( java . lang . reflect . type $whitespace$ superinterface $whitespace$ : $whitespace$ clazz . getgenericinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( superinterface $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ parameterizedtype $whitespace$ parameterizedtype $whitespace$ = $whitespace$ ( parameterizedtype ) $whitespace$ superinterface ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparameters $whitespace$ = $whitespace$ arrays . stream ( parameterizedtype . getactualtypearguments ( ) ) . map ( ( t ) $whitespace$ - > $whitespace$ reflectionfactory . typeusagefor ( t , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ interfaces . add ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectioninterfacedeclaration ( ( class < ? > ) $whitespace$ ( ( parameterizedtype ) $whitespace$ superinterface ) . getrawtype ( ) , $whitespace$ typesolver ) , $whitespace$ typeparameters ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ interfaces . add ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectioninterfacedeclaration ( ( class < ? > ) $whitespace$ superinterface , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ interfaces ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedreferencetype > $whitespace$ getinterfaces ( ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ interfaces $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( java. lang. reflect. type $whitespace$ superinterface $whitespace$ : $whitespace$ clazz. getgenericinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( superinterface $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ reflectioninterfacedeclaration ( ( class <? > ) $whitespace$ ( ( parameterizedtype ) $whitespace$ superinterface ). getrawtype ( ), $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ interfaces ; $newline$ $indentation$ }			
getDeclaredMethods	159	164	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.0270309057086706	LOW	"		public Set<ResolvedMethodDeclaration> getDeclaredMethods(){
		    return Arrays.stream(clazz.getDeclaredMethods()).filter(m -> !m.isSynthetic() && !m.isBridge()).map(m -> new ReflectionMethodDeclaration(m, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( clazz . getdeclaredmethods ( ) ) . filter ( m $whitespace$ - > $whitespace$ ! m . issynthetic ( ) $whitespace$ && $whitespace$ ! m . isbridge ( ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionmethoddeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ set < resolvedmethoddeclaration > $whitespace$ getdeclaredmethods ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( clazz. getdeclaredmethods ( ) ). filter ( m $whitespace$ - > $whitespace$! m. issynthetic ( ) $whitespace$ && $whitespace$! m. isbridge ( ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionmethoddeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
getConstructors	213	218	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.0299914497882127	LOW	"		public List<ResolvedConstructorDeclaration> getConstructors(){
		    return Arrays.stream(clazz.getDeclaredConstructors()).filter(m -> !m.isSynthetic()).map(m -> new ReflectionConstructorDeclaration(m, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ public $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( clazz . getdeclaredconstructors ( ) ) . filter ( m $whitespace$ - > $whitespace$ ! m . issynthetic ( ) ) . map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionconstructordeclaration ( m , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedconstructordeclaration > $whitespace$ getconstructors ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( clazz. getdeclaredconstructors ( ) ). filter ( m $whitespace$ - > $whitespace$! m. issynthetic ( ) ). map ( m $whitespace$ - > $whitespace$ new $whitespace$ reflectionconstructordeclaration ( m, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
getSuperClass	56	70	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.0802739188075065	LOW	"		public Optional<ReferenceTypeImpl> getSuperClass(){
		    if (clazz.getGenericSuperclass() == null) {
		        // There isn't a super class (e.g. when this refers to java.lang.Object)
		        return Optional.empty();
		    }
		    java.lang.reflect.Type superType = clazz.getGenericSuperclass();
		    if (superType instanceof ParameterizedType) {
		        ParameterizedType parameterizedType = (ParameterizedType) superType;
		        List<ResolvedType> typeParameters = Arrays.stream(parameterizedType.getActualTypeArguments()).map((t) -> ReflectionFactory.typeUsageFor(t, typeSolver)).collect(Collectors.toList());
		        return Optional.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(clazz.getSuperclass(), typeSolver), typeParameters));
		    }
		    return Optional.of(new ReferenceTypeImpl(new ReflectionClassDeclaration(clazz.getSuperclass(), typeSolver)));
		}"	$indentation$ public $whitespace$ optional < referencetypeimpl > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ if $whitespace$ ( clazz . getgenericsuperclass ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $//·there·isn't·a·super·class·(e.g.·when·this·refers·to·java.lang.object)$ $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ java . lang . reflect . type $whitespace$ supertype $whitespace$ = $whitespace$ clazz . getgenericsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( supertype $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ parameterizedtype $whitespace$ parameterizedtype $whitespace$ = $whitespace$ ( parameterizedtype ) $whitespace$ supertype ; $newline$ $indentation$ list < resolvedtype > $whitespace$ typeparameters $whitespace$ = $whitespace$ arrays . stream ( parameterizedtype . getactualtypearguments ( ) ) . map ( ( t ) $whitespace$ - > $whitespace$ reflectionfactory . typeusagefor ( t , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( clazz . getsuperclass ( ) , $whitespace$ typesolver ) , $whitespace$ typeparameters ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( clazz . getsuperclass ( ) , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < referencetypeimpl > $whitespace$ getsuperclass ( ) { $newline$ $indentation$ if $whitespace$ ( clazz. getgenericsuperclass ( ) $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ clazz. getgenericsuperclass ( ). gettype ( ). getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ java. lang. reflect. type $whitespace$ supertype $whitespace$ = $whitespace$ clazz. getgenericsuperclass ( ). getsuperclass ( ) ; $newline$ $indentation$ if $whitespace$ ( supertype $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( clazz. getsuperclass ( ), $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ }			
containerType	220	225	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.1089348271489143	LOW	"		public Optional<ResolvedReferenceTypeDeclaration> containerType(){
		    Class<?> declaringClass = clazz.getDeclaringClass();
		    return declaringClass == null ? Optional.empty() : Optional.of(ReflectionFactory.typeDeclarationFor(declaringClass, typeSolver));
		}"	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ class < ? > $whitespace$ declaringclass $whitespace$ = $whitespace$ clazz . getdeclaringclass ( ) ; $newline$ $indentation$ return $whitespace$ declaringclass $whitespace$ == $whitespace$ null $whitespace$ ? $whitespace$ optional . empty ( ) $whitespace$ : $whitespace$ optional . of ( reflectionfactory . typedeclarationfor ( declaringclass , $whitespace$ typesolver ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ class <? > $whitespace$ declaringclass $whitespace$ = $whitespace$ jdtadapter. getname ( clazz ) ; $newline$ $indentation$ return $whitespace$ declaringclass $whitespace$ == $whitespace$ null $whitespace$? $whitespace$ optional. empty ( ) $whitespace$ : $whitespace$ optional. of ( reflectionfactory. typedeclarationfor ( declaringclass, $whitespace$ typesolver ) ) ; $newline$ $indentation$ }			
getField	105	121	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.1834798455238342	LOW	"		public ResolvedFieldDeclaration getField(String name){
		    for (Field field : clazz.getDeclaredFields()) {
		        if (field.getName().equals(name)) {
		            return new ReflectionFieldDeclaration(field, typeSolver);
		        }
		    }
		    for (ResolvedReferenceType ancestor : typeDeclaration.getAllAncestors()) {
		        if (ancestor.getTypeDeclaration().isPresent()) {
		            ResolvedReferenceTypeDeclaration typeDeclaration = ancestor.getTypeDeclaration().get();
		            if (typeDeclaration.hasField(name)) {
		                ReflectionFieldDeclaration reflectionFieldDeclaration = (ReflectionFieldDeclaration) typeDeclaration.getField(name);
		                return reflectionFieldDeclaration.replaceType(ancestor.getFieldType(name).get());
		            }
		        }
		    }
		    throw new UnsolvedSymbolException(name, ""Field in "" + this);
		}"	$indentation$ public $whitespace$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ clazz . getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field . getname ( ) . equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionfielddeclaration ( field , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration . getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ancestor . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ typedeclaration $whitespace$ = $whitespace$ ancestor . gettypedeclaration ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( typedeclaration . hasfield ( name ) ) $whitespace$ { $newline$ $indentation$ reflectionfielddeclaration $whitespace$ reflectionfielddeclaration $whitespace$ = $whitespace$ ( reflectionfielddeclaration ) $whitespace$ typedeclaration . getfield ( name ) ; $newline$ $indentation$ return $whitespace$ reflectionfielddeclaration . replacetype ( ancestor . getfieldtype ( name ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( name , $whitespace$ $string$ $whitespace$ + $whitespace$ this ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ resolvedfielddeclaration $whitespace$ getfield ( string $whitespace$ name ) { $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ clazz. getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( field. getname ( ). equals ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionfielddeclaration ( field, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration. getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ancestor. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionfielddeclaration ( field, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( name, $whitespace$ $string$ $whitespace$ + $whitespace$ this ) ; $newline$ $indentation$ }			
isAssignableBy	174	198	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.292041927576065	LOW	"		public boolean isAssignableBy(ResolvedType type){
		    if (type instanceof NullType) {
		        return true;
		    }
		    if (type instanceof LambdaArgumentTypePlaceholder) {
		        return isFunctionalInterface();
		    }
		    if (type.isArray()) {
		        return false;
		    }
		    if (type.isPrimitive()) {
		        return false;
		    }
		    if (type.describe().equals(typeDeclaration.getQualifiedName())) {
		        return true;
		    }
		    if (type instanceof ReferenceTypeImpl) {
		        ReferenceTypeImpl otherTypeDeclaration = (ReferenceTypeImpl) type;
		        if (otherTypeDeclaration.getTypeDeclaration().isPresent()) {
		            return otherTypeDeclaration.getTypeDeclaration().get().canBeAssignedTo(typeDeclaration);
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nulltype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . describe ( ) . equals ( typedeclaration . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( othertypedeclaration . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ othertypedeclaration . gettypedeclaration ( ) . get ( ) . canbeassignedto ( typedeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ isassignableby ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ nulltype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ lambdaargumenttypeplaceholder ) $whitespace$ { $newline$ $indentation$ return $whitespace$ isfunctionalinterface ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. describe ( ). equals ( typedeclaration. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( othertypedeclaration. gettypedeclaration ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ referencetypeimpl ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ othertypedeclaration $whitespace$ = $whitespace$ ( referencetypeimpl			
getAllFields	141	157	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.6517533659934998	MID	"		public List<ResolvedFieldDeclaration> getAllFields(){
		    ArrayList<ResolvedFieldDeclaration> fields = new ArrayList<>();
		    // First consider fields declared on this class
		    for (Field field : clazz.getDeclaredFields()) {
		        fields.add(new ReflectionFieldDeclaration(field, typeSolver));
		    }
		    // Then consider fields inherited from ancestors
		    for (ResolvedReferenceType ancestor : typeDeclaration.getAllAncestors()) {
		        ancestor.getTypeDeclaration().ifPresent(ancestorTypeDeclaration -> {
		            fields.addAll(ancestorTypeDeclaration.getAllFields());
		        });
		    }
		    return fields;
		}"	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ arraylist < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $//·first·consider·fields·declared·on·this·class$ $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ clazz . getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ fields . add ( new $whitespace$ reflectionfielddeclaration ( field , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·then·consider·fields·inherited·from·ancestors$ $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration . getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor . gettypedeclaration ( ) . ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ fields . addall ( ancestortypedeclaration . getallfields ( ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }	$indentation$ public $whitespace$ list < resolvedfielddeclaration > $whitespace$ getallfields ( ) { $newline$ $indentation$ arraylist < resolvedfielddeclaration > $whitespace$ fields $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( field $whitespace$ field $whitespace$ : $whitespace$ clazz. getdeclaredfields ( ) ) $whitespace$ { $newline$ $indentation$ fields. add ( new $whitespace$ reflectionfielddeclaration ( field, $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ // $whitespace$ add $whitespace$ eventscaping $whitespace$ method $whitespace$ to $whitespace$ the $whitespace$ nearby $whitespace$ the $whitespace$ true: $newline$ $indentation$ // $whitespace$ the $whitespace$ add $whitespace$ eventscaping $whitespace$ method $whitespace$ to $whitespace$ the $whitespace$ external $whitespace$ front $whitespace$ of $whitespace$ the $newline$ $indentation$ // $whitespace$ add $whitespace$ a $whitespace$ generation $whitespace$ to $whitespace$ the $whitespace$ same $whitespace$ depth $whitespace$ of $whitespace$ the $whitespace$ harmonizer $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ typedeclaration. getallancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor. gettypedeclaration ( ). ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ fields. addall ( ancestortypedeclaration. getallfields ( ) ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ fields ; $newline$ $indentation$ }			
hasDirectlyAnnotation	200	207	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassAdapter.java	0.6695254445075989	MID	"		public boolean hasDirectlyAnnotation(String canonicalName){
		    for (Annotation a : clazz.getDeclaredAnnotations()) {
		        if (a.annotationType().getCanonicalName().equals(canonicalName)) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ hasdirectlyannotation ( string $whitespace$ canonicalname ) { $newline$ $indentation$ for $whitespace$ ( annotation $whitespace$ a $whitespace$ : $whitespace$ clazz . getdeclaredannotations ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( a . annotationtype ( ) . getcanonicalname ( ) . equals ( canonicalname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ hasdirectlyannotation ( string $whitespace$ canonicalname ) { $newline$ $indentation$ for $whitespace$ ( annotation $whitespace$ a $whitespace$ : $whitespace$ clazz. getdeclaredannotations ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( a. annotationtype ( ). getcanonicalname ( ). equals ( canonicalname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
solveMethodAsUsage	212	255	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java	0.0012470441870391	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    List<MethodUsage> methodUsages = new ArrayList<>();
		    List<Method> allMethods = Arrays.stream(clazz.getDeclaredMethods()).filter((m) -> m.getName().equals(name)).sorted(new MethodComparator()).collect(Collectors.toList());
		    for (Method method : allMethods) {
		        if (method.isBridge() || method.isSynthetic()) {
		            continue;
		        }
		        ResolvedMethodDeclaration methodDeclaration = new ReflectionMethodDeclaration(method, typeSolver);
		        MethodUsage methodUsage = new MethodUsage(methodDeclaration);
		        for (int i = 0; i < getTypeParameters().size() && i < typeParameterValues.size(); i++) {
		            ResolvedTypeParameterDeclaration tpToReplace = getTypeParameters().get(i);
		            ResolvedType newValue = typeParameterValues.get(i);
		            methodUsage = methodUsage.replaceTypeParameter(tpToReplace, newValue);
		        }
		        methodUsages.add(methodUsage);
		        // no need to search for overloaded/inherited methodUsages if the method has no parameters
		        if (argumentsTypes.isEmpty() && methodUsage.getNoParams() == 0) {
		            return Optional.of(methodUsage);
		        }
		    }
		    getSuperClass().ifPresent(superClass -> {
		        superClass.getTypeDeclaration().ifPresent(superClassTypeDeclaration -> {
		            ContextHelper.solveMethodAsUsage(superClassTypeDeclaration, name, argumentsTypes, invokationContext, typeParameterValues).ifPresent(methodUsages::add);
		        });
		    });
		    for (ResolvedReferenceType interfaceDeclaration : getInterfaces()) {
		        interfaceDeclaration.getTypeDeclaration().flatMap(superClassTypeDeclaration -> interfaceDeclaration.getTypeDeclaration()).flatMap(interfaceTypeDeclaration -> ContextHelper.solveMethodAsUsage(interfaceTypeDeclaration, name, argumentsTypes, invokationContext, typeParameterValues)).ifPresent(methodUsages::add);
		    }
		    Optional<MethodUsage> ref = MethodResolutionLogic.findMostApplicableUsage(methodUsages, name, argumentsTypes, typeSolver);
		    return ref;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ list < methodusage > $whitespace$ methodusages $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ list < method > $whitespace$ allmethods $whitespace$ = $whitespace$ arrays . stream ( clazz . getdeclaredmethods ( ) ) . filter ( ( m ) $whitespace$ - > $whitespace$ m . getname ( ) . equals ( name ) ) . sorted ( new $whitespace$ methodcomparator ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ allmethods ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method . isbridge ( ) $whitespace$ || $whitespace$ method . issynthetic ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method , $whitespace$ typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ gettypeparameters ( ) . size ( ) $whitespace$ && $whitespace$ i $whitespace$ < $whitespace$ typeparametervalues . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ tptoreplace $whitespace$ = $whitespace$ gettypeparameters ( ) . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ newvalue $whitespace$ = $whitespace$ typeparametervalues . get ( i ) ; $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( tptoreplace , $whitespace$ newvalue ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusages . add ( methodusage ) ; $newline$ $indentation$ $//·no·need·to·search·for·overloaded/inherited·methodusages·if·the·method·has·no·parameters$ $newline$ $indentation$ if $whitespace$ ( argumentstypes . isempty ( ) $whitespace$ && $whitespace$ methodusage . getnoparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ getsuperclass ( ) . ifpresent ( superclass $whitespace$ - > $whitespace$ { $newline$ $indentation$ superclass . gettypedeclaration ( ) . ifpresent ( superclasstypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ contexthelper . solvemethodasusage ( superclasstypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ invokationcontext , $whitespace$ typeparametervalues ) . ifpresent ( methodusages : : add ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ } ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ interfacedeclaration $whitespace$ : $whitespace$ getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ interfacedeclaration . gettypedeclaration ( ) . flatmap ( superclasstypedeclaration $whitespace$ - > $whitespace$ interfacedeclaration . gettypedeclaration ( ) ) . flatmap ( interfacetypedeclaration $whitespace$ - > $whitespace$ contexthelper . solvemethodasusage ( interfacetypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ invokationcontext , $whitespace$ typeparametervalues ) ) . ifpresent ( methodusages : : add ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < methodusage > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . findmostapplicableusage ( methodusages , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ ref ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ list < methodusage > $whitespace$ methodusages $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ list < method > $whitespace$ allmethods $whitespace$ = $whitespace$ arrays. stream ( clazz. getdeclaredmethods ( ) ). filter ( ( m ) $whitespace$ - > $whitespace$ m. getname ( ). equals ( name ) ). sorted ( new $whitespace$ methodcomparator ( ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ allmethods ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method. isbridge ( ) $whitespace$ || $whitespace$ method. issynthetic ( ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method, $whitespace$ typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ gettypeparameters ( ). size ( ) $whitespace$ && $whitespace$ i $whitespace$ < $whitespace$ typeparametervalues. size ( ) ; $whitespace$ i ++ ) $whitespace$ {			
solveMethod	142	198	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java	0.0036177528090775	LOW	"		@Override
		@Deprecated
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> argumentsTypes, boolean staticOnly){
		    Predicate<Method> staticFilter = m -> !staticOnly || (staticOnly && Modifier.isStatic(m.getModifiers()));
		    List<ResolvedMethodDeclaration> candidateSolvedMethods = new ArrayList<>();
		    // First consider the directly-declared methods.
		    List<Method> methods = Arrays.stream(clazz.getDeclaredMethods()).filter(m -> m.getName().equals(name)).filter(staticFilter).filter(method -> !method.isBridge()).filter(method -> !method.isSynthetic()).sorted(new MethodComparator()).collect(Collectors.toList());
		    // Transform into resolved method declarations
		    for (Method method : methods) {
		        ResolvedMethodDeclaration methodDeclaration = new ReflectionMethodDeclaration(method, typeSolver);
		        candidateSolvedMethods.add(methodDeclaration);
		        // no need to search for overloaded/inherited candidateSolvedMethods if the method has no parameters
		        if (argumentsTypes.isEmpty() && methodDeclaration.getNumberOfParams() == 0) {
		            return SymbolReference.solved(methodDeclaration);
		        }
		    }
		    // Next consider methods declared within extended superclasses.
		    getSuperClass().flatMap(ResolvedReferenceType::getTypeDeclaration).ifPresent(superClassTypeDeclaration -> {
		        SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(superClassTypeDeclaration, name, argumentsTypes, staticOnly);
		        if (ref.isSolved()) {
		            candidateSolvedMethods.add(ref.getCorrespondingDeclaration());
		        }
		    });
		    // Next consider methods declared within implemented interfaces.
		    for (ResolvedReferenceType interfaceDeclaration : getInterfaces()) {
		        interfaceDeclaration.getTypeDeclaration().ifPresent(interfaceTypeDeclaration -> {
		            SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(interfaceTypeDeclaration, name, argumentsTypes, staticOnly);
		            if (ref.isSolved()) {
		                candidateSolvedMethods.add(ref.getCorrespondingDeclaration());
		            }
		        });
		    }
		    // When empty there is no sense in trying to find the most applicable.
		    // This is useful for debugging. Performance is not affected as
		    // MethodResolutionLogic.findMostApplicable method returns very early
		    // when candidateSolvedMethods is empty.
		    if (candidateSolvedMethods.isEmpty()) {
		        return SymbolReference.unsolved();
		    }
		    return MethodResolutionLogic.findMostApplicable(candidateSolvedMethods, name, argumentsTypes, typeSolver);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ predicate < method > $whitespace$ staticfilter $whitespace$ = $whitespace$ m $whitespace$ - > $whitespace$ ! staticonly $whitespace$ || $whitespace$ ( staticonly $whitespace$ && $whitespace$ modifier . isstatic ( m . getmodifiers ( ) ) ) ; $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ candidatesolvedmethods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $//·first·consider·the·directly-declared·methods.$ $newline$ $indentation$ list < method > $whitespace$ methods $whitespace$ = $whitespace$ arrays . stream ( clazz . getdeclaredmethods ( ) ) . filter ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( name ) ) . filter ( staticfilter ) . filter ( method $whitespace$ - > $whitespace$ ! method . isbridge ( ) ) . filter ( method $whitespace$ - > $whitespace$ ! method . issynthetic ( ) ) . sorted ( new $whitespace$ methodcomparator ( ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ $//·transform·into·resolved·method·declarations$ $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ methods ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method , $whitespace$ typesolver ) ; $newline$ $indentation$ candidatesolvedmethods . add ( methoddeclaration ) ; $newline$ $indentation$ $//·no·need·to·search·for·overloaded/inherited·candidatesolvedmethods·if·the·method·has·no·parameters$ $newline$ $indentation$ if $whitespace$ ( argumentstypes . isempty ( ) $whitespace$ && $whitespace$ methoddeclaration . getnumberofparams ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·next·consider·methods·declared·within·extended·superclasses.$ $newline$ $indentation$ getsuperclass ( ) . flatmap ( resolvedreferencetype : : gettypedeclaration ) . ifpresent ( superclasstypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( superclasstypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatesolvedmethods . add ( ref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ $//·next·consider·methods·declared·within·implemented·interfaces.$ $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ interfacedeclaration $whitespace$ : $whitespace$ getinterfaces ( ) ) $whitespace$ { $newline$ $indentation$ interfacedeclaration . gettypedeclaration ( ) . ifpresent ( interfacetypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( interfacetypedeclaration , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ candidatesolvedmethods . add ( ref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·when·empty·there·is·no·sense·in·trying·to·find·the·most·applicable.$ $newline$ $indentation$ $//·this·is·useful·for·debugging.·performance·is·not·affected·as$ $newline$ $indentation$ $//·methodresolutionlogic.findmostapplicable·method·returns·very·early$ $newline$ $indentation$ $//·when·candidatesolvedmethods·is·empty.$ $newline$ $indentation$ if $whitespace$ ( candidatesolvedmethods . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicable ( candidatesolvedmethods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ predicate < method > $whitespace$ staticfilter $whitespace$ = $whitespace$ m $whitespace$ - > $whitespace$! staticonly $whitespace$ || $whitespace$ ( staticonly $whitespace$ && $whitespace$ modifier. isstatic ( m. getmodifiers ( ) ) ) ; $newline$ $indentation$ final $whitespace$ list < resolvedmethoddeclaration > $whitespace$ candidatesolvedmethods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ $////////////////////////////////////first(); $newline$ $indentation$ // $whitespace$ the $whitespace$ current $whitespace$ method $whitespace$ that $whitespace$ surfaces $whitespace$ does $whitespace$ not $whitespace$ present $newline$ $indentation$ if $whitespace$ (! method. isbridge ( ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method, $whitespace$ typesolver ) ; $newline$ $indentation$			
internalTypes	386	391	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java	0.0996970906853675	LOW	"		@Override
		public Set<ResolvedReferenceTypeDeclaration> internalTypes(){
		    return Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( this . clazz . getdeclaredclasses ( ) ) . map ( ic $whitespace$ - > $whitespace$ reflectionfactory . typedeclarationfor ( ic , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( this. clazz. getdeclaredclasses ( ) ). map ( ic $whitespace$ - > $whitespace$ reflectionfactory. typedeclarationfor ( ic, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
toString	200	205	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionClassDeclaration.java	0.9162790775299072	HIGH	"		@Override
		public String toString(){
		    return ""ReflectionClassDeclaration{"" + ""clazz="" + getId() + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ getid ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ getid ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getParam	60	72	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionConstructorDeclaration.java	0.109079323709011	LOW	"		@Override
		public ResolvedParameterDeclaration getParam(int i){
		    if (i < 0 || i >= getNumberOfParams()) {
		        throw new IllegalArgumentException(String.format(""No param with index %d. Number of params: %d"", i, getNumberOfParams()));
		    }
		    boolean variadic = false;
		    if (constructor.isVarArgs()) {
		        variadic = i == (constructor.getParameterCount() - 1);
		    }
		    return new ReflectionParameterDeclaration(constructor.getParameterTypes()[i], constructor.getGenericParameterTypes()[i], typeSolver, variadic, constructor.getParameters()[i].getName());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ getnumberofparams ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string . format ( $string$ , $whitespace$ i , $whitespace$ getnumberofparams ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ boolean $whitespace$ variadic $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( constructor . isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ variadic $whitespace$ = $whitespace$ i $whitespace$ == $whitespace$ ( constructor . getparametercount ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionparameterdeclaration ( constructor . getparametertypes ( ) [ i ] , $whitespace$ constructor . getgenericparametertypes ( ) [ i ] , $whitespace$ typesolver , $whitespace$ variadic , $whitespace$ constructor . getparameters ( ) [ i ] . getname ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ if $whitespace$ ( i $whitespace$ < $whitespace$ $number$ $whitespace$ || $whitespace$ i $whitespace$ >= $whitespace$ getnumberofparams ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( string. format ( $string$, $whitespace$ i, $whitespace$ getnumberofparams ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( constructor. isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ // $whitespace$ method $whitespace$ that $whitespace$ actually $whitespace$ repaints $whitespace$ the $whitespace$ window $whitespace$ $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionparameterdeclaration ( constructor. getparametertypes ( ) [ i ], $whitespace$ constructor. getgenericparametertypes ( ) [ i ], $whitespace$ typesolver, $whitespace$ variadic, $whitespace$ constructor. getparameters ( ) [ i ]. getname ( ) ) ; $newline$ $indentation$ }			
getEnumConstants	240	246	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java	0.0684985890984535	LOW	"		@Override
		public List<ResolvedEnumConstantDeclaration> getEnumConstants(){
		    return Arrays.stream(clazz.getFields()).filter(Field::isEnumConstant).map(c -> new ReflectionEnumConstantDeclaration(c, typeSolver)).collect(Collectors.toList());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( clazz . getfields ( ) ) . filter ( field : : isenumconstant ) . map ( c $whitespace$ - > $whitespace$ new $whitespace$ reflectionenumconstantdeclaration ( c , $whitespace$ typesolver ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ list < resolvedenumconstantdeclaration > $whitespace$ getenumconstants ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( clazz ). filter ( field : : isenumconstant ). map ( c $whitespace$ - > $whitespace$ new $whitespace$ reflectionenumconstantdeclaration ( c, $whitespace$ typesolver ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
solveMethodAsUsage	198	229	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java	0.0985698625445365	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> parameterTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    Optional<MethodUsage> res = ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz);
		    if (res.isPresent()) {
		        // We have to replace method type typeParametersValues here
		        InferenceContext inferenceContext = new InferenceContext(typeSolver);
		        MethodUsage methodUsage = res.get();
		        int i = 0;
		        List<ResolvedType> parameters = new LinkedList<>();
		        for (ResolvedType actualType : parameterTypes) {
		            ResolvedType formalType = methodUsage.getParamType(i);
		            // We need to replace the class type typeParametersValues (while we derive the method ones)
		            parameters.add(inferenceContext.addPair(formalType, actualType));
		            i++;
		        }
		        try {
		            ResolvedType returnType = inferenceContext.addSingle(methodUsage.returnType());
		            for (int j = 0; j < parameters.size(); j++) {
		                methodUsage = methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j)));
		            }
		            methodUsage = methodUsage.replaceReturnType(inferenceContext.resolve(returnType));
		            return Optional.of(methodUsage);
		        } catch (ConflictingGenericTypesException e) {
		            return Optional.empty();
		        }
		    } else {
		        return res;
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic . solvemethodasusage ( name , $whitespace$ parametertypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·we·have·to·replace·method·type·typeparametersvalues·here$ $newline$ $indentation$ inferencecontext $whitespace$ inferencecontext $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ res . get ( ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ list < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage . getparamtype ( i ) ; $newline$ $indentation$ $//·we·need·to·replace·the·class·type·typeparametersvalues·(while·we·derive·the·method·ones)$ $newline$ $indentation$ parameters . add ( inferencecontext . addpair ( formaltype , $whitespace$ actualtype ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ inferencecontext . addsingle ( methodusage . returntype ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replaceparamtype ( j , $whitespace$ inferencecontext . resolve ( parameters . get ( j ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacereturntype ( inferencecontext . resolve ( returntype ) ) ; $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( conflictinggenerictypesexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic. solvemethodasusage ( name, $whitespace$ parametertypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $////g ; $newline$ $indentation$ // $whitespace$ the $whitespace$ cached $whitespace$ data $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ ensure $whitespace$ that $whitespace$ the $whitespace$ search $whitespace$ is $whitespace$ used $newline$ $indentation$ optional < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage. getparamtype ( i ) ; $newline$ $indentation$ $////g ; $newline$ $indentation$			
internalTypes	248	253	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java	0.0996970906853675	LOW	"		@Override
		public Set<ResolvedReferenceTypeDeclaration> internalTypes(){
		    return Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( this . clazz . getdeclaredclasses ( ) ) . map ( ic $whitespace$ - > $whitespace$ reflectionfactory . typedeclarationfor ( ic , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( this. clazz. getdeclaredclasses ( ) ). map ( ic $whitespace$ - > $whitespace$ reflectionfactory. typedeclarationfor ( ic, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
solveMethod	192	196	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java	0.1558957248926162	LOW	"		@Override
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes, boolean staticOnly){
		    return ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic . solvemethod ( name , $whitespace$ parametertypes , $whitespace$ staticonly , $whitespace$ typesolver , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic. solvemethod ( name, $whitespace$ parametertypes, $whitespace$ staticonly, $whitespace$ typesolver, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ }			
canBeAssignedTo	147	165	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionEnumDeclaration.java	0.7203753590583801	MID	"		@Override
		public boolean canBeAssignedTo(ResolvedReferenceTypeDeclaration other){
		    String otherName = other.getQualifiedName();
		    // Enums cannot be extended
		    if (otherName.equals(this.getQualifiedName())) {
		        return true;
		    }
		    if (JAVA_LANG_ENUM.equals(otherName)) {
		        return true;
		    }
		    // Enum implements Comparable and Serializable
		    if (otherName.equals(JAVA_LANG_COMPARABLE)) {
		        return true;
		    }
		    if (otherName.equals(JAVA_IO_SERIALIZABLE)) {
		        return true;
		    }
		    return other.isJavaLangObject();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other . getqualifiedname ( ) ; $newline$ $indentation$ $//·enums·cannot·be·extended$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( this . getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum . equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·enum·implements·comparable·and·serializable$ $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_lang_comparable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername . equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other . isjavalangobject ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ canbeassignedto ( resolvedreferencetypedeclaration $whitespace$ other ) { $newline$ $indentation$ string $whitespace$ othername $whitespace$ = $whitespace$ other. getqualifiedname ( ) ; $newline$ $indentation$ if $whitespace$ ( othername. equals ( this. getqualifiedname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( java_lang_enum. equals ( othername ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////enumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenumenums ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( othername. equals ( java_io_serializable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ other. isjavalangobject ( ) ; $newline$ $indentation$ }			
typeUsageFor	65	123	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java	0.002322640037164	LOW	"		public static ResolvedType typeUsageFor(java.lang.reflect.Type type, TypeSolver typeSolver){
		    if (type instanceof java.lang.reflect.TypeVariable) {
		        java.lang.reflect.TypeVariable<?> tv = (java.lang.reflect.TypeVariable<?>) type;
		        boolean declaredOnClass = tv.getGenericDeclaration() instanceof java.lang.reflect.Type;
		        ResolvedTypeParameterDeclaration typeParameter = new ReflectionTypeParameter(tv, declaredOnClass, typeSolver);
		        return new ResolvedTypeVariable(typeParameter);
		    }
		    if (type instanceof ParameterizedType) {
		        ParameterizedType pt = (ParameterizedType) type;
		        ResolvedReferenceType rawType = typeUsageFor(pt.getRawType(), typeSolver).asReferenceType();
		        List<java.lang.reflect.Type> actualTypes = new ArrayList<>();
		        actualTypes.addAll(Arrays.asList(pt.getActualTypeArguments()));
		        // we consume the actual types
		        rawType = rawType.transformTypeParameters(tp -> typeUsageFor(actualTypes.remove(0), typeSolver)).asReferenceType();
		        return rawType;
		    }
		    if (type instanceof Class) {
		        Class<?> c = (Class<?>) type;
		        if (c.isPrimitive()) {
		            if (c.getName().equals(Void.TYPE.getName())) {
		                return ResolvedVoidType.INSTANCE;
		            }
		            return ResolvedPrimitiveType.byName(c.getName());
		        }
		        if (c.isArray()) {
		            return new ResolvedArrayType(typeUsageFor(c.getComponentType(), typeSolver));
		        }
		        return new ReferenceTypeImpl(typeDeclarationFor(c, typeSolver));
		    }
		    if (type instanceof GenericArrayType) {
		        GenericArrayType genericArrayType = (GenericArrayType) type;
		        return new ResolvedArrayType(typeUsageFor(genericArrayType.getGenericComponentType(), typeSolver));
		    }
		    if (type instanceof WildcardType) {
		        WildcardType wildcardType = (WildcardType) type;
		        if (wildcardType.getLowerBounds().length > 0 && wildcardType.getUpperBounds().length > 0) {
		            if (wildcardType.getUpperBounds().length == 1 && wildcardType.getUpperBounds()[0].getTypeName().equals(JAVA_LANG_OBJECT)) {
		                // ok, it does not matter
		            }
		        }
		        if (wildcardType.getLowerBounds().length > 0) {
		            if (wildcardType.getLowerBounds().length > 1) {
		                throw new UnsupportedOperationException();
		            }
		            return ResolvedWildcard.superBound(typeUsageFor(wildcardType.getLowerBounds()[0], typeSolver));
		        }
		        if (wildcardType.getUpperBounds().length > 0) {
		            if (wildcardType.getUpperBounds().length > 1) {
		                throw new UnsupportedOperationException();
		            }
		            if (wildcardType.getUpperBounds().length == 1 && wildcardType.getUpperBounds()[0].getTypeName().equals(JAVA_LANG_OBJECT)) {
		                return ResolvedWildcard.UNBOUNDED;
		            }
		            return ResolvedWildcard.extendsBound(typeUsageFor(wildcardType.getUpperBounds()[0], typeSolver));
		        }
		        return ResolvedWildcard.UNBOUNDED;
		    }
		    throw new UnsupportedOperationException(type.getClass().getCanonicalName() + "" "" + type);
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeusagefor ( java . lang . reflect . type $whitespace$ type , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ java . lang . reflect . typevariable ) $whitespace$ { $newline$ $indentation$ java . lang . reflect . typevariable < ? > $whitespace$ tv $whitespace$ = $whitespace$ ( java . lang . reflect . typevariable < ? > ) $whitespace$ type ; $newline$ $indentation$ boolean $whitespace$ declaredonclass $whitespace$ = $whitespace$ tv . getgenericdeclaration ( ) $whitespace$ instanceof $whitespace$ java . lang . reflect . type ; $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ typeparameter $whitespace$ = $whitespace$ new $whitespace$ reflectiontypeparameter ( tv , $whitespace$ declaredonclass , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( typeparameter ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ parameterizedtype $whitespace$ pt $whitespace$ = $whitespace$ ( parameterizedtype ) $whitespace$ type ; $newline$ $indentation$ resolvedreferencetype $whitespace$ rawtype $whitespace$ = $whitespace$ typeusagefor ( pt . getrawtype ( ) , $whitespace$ typesolver ) . asreferencetype ( ) ; $newline$ $indentation$ list < java . lang . reflect . type > $whitespace$ actualtypes $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ actualtypes . addall ( arrays . aslist ( pt . getactualtypearguments ( ) ) ) ; $newline$ $indentation$ $//·we·consume·the·actual·types$ $newline$ $indentation$ rawtype $whitespace$ = $whitespace$ rawtype . transformtypeparameters ( tp $whitespace$ - > $whitespace$ typeusagefor ( actualtypes . remove ( $number$ ) , $whitespace$ typesolver ) ) . asreferencetype ( ) ; $newline$ $indentation$ return $whitespace$ rawtype ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ class ) $whitespace$ { $newline$ $indentation$ class < ? > $whitespace$ c $whitespace$ = $whitespace$ ( class < ? > ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( c . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( c . getname ( ) . equals ( void . type . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedvoidtype . instance ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . byname ( c . getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( c . isarray ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( typeusagefor ( c . getcomponenttype ( ) , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( typedeclarationfor ( c , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ genericarraytype ) $whitespace$ { $newline$ $indentation$ genericarraytype $whitespace$ genericarraytype $whitespace$ = $whitespace$ ( genericarraytype ) $whitespace$ type ; $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedarraytype ( typeusagefor ( genericarraytype . getgenericcomponenttype ( ) , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ wildcardtype ) $whitespace$ { $newline$ $indentation$ wildcardtype $whitespace$ wildcardtype $whitespace$ = $whitespace$ ( wildcardtype ) $whitespace$ type ; $newline$ $indentation$ if $whitespace$ ( wildcardtype . getlowerbounds ( ) . length $whitespace$ > $whitespace$ $number$ $whitespace$ && $whitespace$ wildcardtype . getupperbounds ( ) . length $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wildcardtype . getupperbounds ( ) . length $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ wildcardtype . getupperbounds ( ) [ $number$ ] . gettypename ( ) . equals ( java_lang_object ) ) $whitespace$ { $newline$ $indentation$ $//·ok,·it·does·not·matter$ $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wildcardtype . getlowerbounds ( ) . length $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wildcardtype . getlowerbounds ( ) . length $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedwildcard . superbound ( typeusagefor ( wildcardtype . getlowerbounds ( ) [ $number$ ] , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wildcardtype . getupperbounds ( ) . length $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( wildcardtype . getupperbounds ( ) . length $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( wildcardtype . getupperbounds ( ) . length $whitespace$ == $whitespace$ $number$ $whitespace$ && $whitespace$ wildcardtype . getupperbounds ( ) [ $number$ ] . gettypename ( ) . equals ( java_lang_object ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedwildcard . unbounded ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedwildcard . extendsbound ( typeusagefor ( wildcardtype . getupperbounds ( ) [ $number$ ] , $whitespace$ typesolver ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedwildcard . unbounded ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . getclass ( ) . getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ typeusagefor ( java. lang. reflect. type $whitespace$ type, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ java. lang. reflect. typevariable ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ reflecttypevariable ( type, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type $whitespace$ instanceof $whitespace$ parameterizedtype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectiontypeparameter ( tv, $whitespace$ declaredonclass, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedtypevariable ( typeparameter ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ map < string, $whitespace$ string > $whitespace$ getvarianttype $whitespace$ = $whitespace$ typeusagefor ( pt. getrawtype ( ), $whitespace$ typesolver ) ; $newline$ $indentation$			
modifiersToAccessLevel	125	136	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionFactory.java	0.6368815898895264	MID	"		 static AccessSpecifier modifiersToAccessLevel(final int modifiers){
		    if (Modifier.isPublic(modifiers)) {
		        return AccessSpecifier.PUBLIC;
		    }
		    if (Modifier.isProtected(modifiers)) {
		        return AccessSpecifier.PROTECTED;
		    }
		    if (Modifier.isPrivate(modifiers)) {
		        return AccessSpecifier.PRIVATE;
		    }
		    return AccessSpecifier.NONE;
		}"	$indentation$ static $whitespace$ accessspecifier $whitespace$ modifierstoaccesslevel ( final $whitespace$ int $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( modifier . ispublic ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . public ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( modifier . isprotected ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . protected ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( modifier . isprivate ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier . private ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier . none ; $newline$ $indentation$ }	$indentation$ static $whitespace$ accessspecifier $whitespace$ modifierstoaccesslevel ( final $whitespace$ int $whitespace$ modifiers ) { $newline$ $indentation$ if $whitespace$ ( recyclerview. ispublic ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. public ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( recyclerview. isprotected ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. protected ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( recyclerview. isprivate ( modifiers ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ accessspecifier. private ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ accessspecifier. none ; $newline$ $indentation$ }			
solveMethodAsUsage	142	173	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java	0.0985698625445365	LOW	"		@Override
		public Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> parameterTypes, Context invokationContext, List<ResolvedType> typeParameterValues){
		    Optional<MethodUsage> res = ReflectionMethodResolutionLogic.solveMethodAsUsage(name, parameterTypes, typeSolver, invokationContext, typeParameterValues, this, clazz);
		    if (res.isPresent()) {
		        // We have to replace method type typeParametersValues here
		        InferenceContext inferenceContext = new InferenceContext(typeSolver);
		        MethodUsage methodUsage = res.get();
		        int i = 0;
		        List<ResolvedType> parameters = new LinkedList<>();
		        for (ResolvedType actualType : parameterTypes) {
		            ResolvedType formalType = methodUsage.getParamType(i);
		            // We need to replace the class type typeParametersValues (while we derive the method ones)
		            parameters.add(inferenceContext.addPair(formalType, actualType));
		            i++;
		        }
		        try {
		            ResolvedType returnType = inferenceContext.addSingle(methodUsage.returnType());
		            for (int j = 0; j < parameters.size(); j++) {
		                methodUsage = methodUsage.replaceParamType(j, inferenceContext.resolve(parameters.get(j)));
		            }
		            methodUsage = methodUsage.replaceReturnType(inferenceContext.resolve(returnType));
		            return Optional.of(methodUsage);
		        } catch (ConflictingGenericTypesException e) {
		            return Optional.empty();
		        }
		    } else {
		        return res;
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic . solvemethodasusage ( name , $whitespace$ parametertypes , $whitespace$ typesolver , $whitespace$ invokationcontext , $whitespace$ typeparametervalues , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $//·we·have·to·replace·method·type·typeparametersvalues·here$ $newline$ $indentation$ inferencecontext $whitespace$ inferencecontext $whitespace$ = $whitespace$ new $whitespace$ inferencecontext ( typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ res . get ( ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ list < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage . getparamtype ( i ) ; $newline$ $indentation$ $//·we·need·to·replace·the·class·type·typeparametersvalues·(while·we·derive·the·method·ones)$ $newline$ $indentation$ parameters . add ( inferencecontext . addpair ( formaltype , $whitespace$ actualtype ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ inferencecontext . addsingle ( methodusage . returntype ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ parameters . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replaceparamtype ( j , $whitespace$ inferencecontext . resolve ( parameters . get ( j ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacereturntype ( inferencecontext . resolve ( returntype ) ) ; $newline$ $indentation$ return $whitespace$ optional . of ( methodusage ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( conflictinggenerictypesexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues ) { $newline$ $indentation$ optional < methodusage > $whitespace$ res $whitespace$ = $whitespace$ reflectionmethodresolutionlogic. solvemethodasusage ( name, $whitespace$ parametertypes, $whitespace$ typesolver, $whitespace$ invokationcontext, $whitespace$ typeparametervalues, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ if $whitespace$ ( res. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ $////g ; $newline$ $indentation$ // $whitespace$ the $whitespace$ cached $whitespace$ data $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ ensure $whitespace$ that $whitespace$ the $whitespace$ search $whitespace$ is $whitespace$ used $newline$ $indentation$ optional < resolvedtype > $whitespace$ parameters $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ actualtype $whitespace$ : $whitespace$ parametertypes ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ formaltype $whitespace$ = $whitespace$ methodusage. getparamtype ( i ) ; $newline$ $indentation$ $////g ; $newline$ $indentation$			
internalTypes	290	295	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java	0.0996970906853675	LOW	"		@Override
		public Set<ResolvedReferenceTypeDeclaration> internalTypes(){
		    return Arrays.stream(this.clazz.getDeclaredClasses()).map(ic -> ReflectionFactory.typeDeclarationFor(ic, typeSolver)).collect(Collectors.toSet());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays . stream ( this . clazz . getdeclaredclasses ( ) ) . map ( ic $whitespace$ - > $whitespace$ reflectionfactory . typedeclarationfor ( ic , $whitespace$ typesolver ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ set < resolvedreferencetypedeclaration > $whitespace$ internaltypes ( ) { $newline$ $indentation$ return $whitespace$ arrays. stream ( this. clazz. getdeclaredclasses ( ) ). map ( ic $whitespace$ - > $whitespace$ reflectionfactory. typedeclarationfor ( ic, $whitespace$ typesolver ) ). collect ( collectors. toset ( ) ) ; $newline$ $indentation$ }			
solveMethod	107	112	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java	0.1844206601381302	LOW	"		@Override
		@Deprecated
		public SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes, boolean staticOnly){
		    return ReflectionMethodResolutionLogic.solveMethod(name, parameterTypes, staticOnly, typeSolver, this, clazz);
		}"	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic . solvemethod ( name , $whitespace$ parametertypes , $whitespace$ staticonly , $whitespace$ typesolver , $whitespace$ this , $whitespace$ clazz ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ @ deprecated $newline$ $indentation$ public $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ boolean $whitespace$ staticonly ) { $newline$ $indentation$ return $whitespace$ reflectionmethodresolutionlogic. solvemethod ( name, $whitespace$ parametertypes, $whitespace$ staticonly, $whitespace$ typesolver, $whitespace$ this, $whitespace$ clazz ) ; $newline$ $indentation$ }			
getClassName	93	100	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java	0.6232369542121887	MID	"		@Override
		public String getClassName(){
		    String canonicalName = clazz.getCanonicalName();
		    if (canonicalName != null && getPackageName() != null) {
		        return canonicalName.substring(getPackageName().length() + 1);
		    }
		    return null;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ canonicalname $whitespace$ = $whitespace$ clazz . getcanonicalname ( ) ; $newline$ $indentation$ if $whitespace$ ( canonicalname $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ getpackagename ( ) $whitespace$ != $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ canonicalname . substring ( getpackagename ( ) . length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getclassname ( ) { $newline$ $indentation$ string $whitespace$ canonicalname $whitespace$ = $whitespace$ clazz. getcanonicalname ( ) ; $newline$ $indentation$ if $whitespace$ ( canonicalname $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getpackagename ( ) $whitespace$!= $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ canonicalname. substring ( getpackagename ( ). length ( ) $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ }			
toString	114	119	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionInterfaceDeclaration.java	0.8421123027801514	HIGH	"		@Override
		public String toString(){
		    return ""ReflectionInterfaceDeclaration{"" + ""clazz="" + clazz.getCanonicalName() + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ clazz . getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ clazz. getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getParam	107	115	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodDeclaration.java	0.1924171298742294	LOW	"		@Override
		public ResolvedParameterDeclaration getParam(int i){
		    boolean variadic = false;
		    if (method.isVarArgs()) {
		        variadic = i == (method.getParameterCount() - 1);
		    }
		    return new ReflectionParameterDeclaration(method.getParameterTypes()[i], method.getGenericParameterTypes()[i], typeSolver, variadic, method.getParameters()[i].getName());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ boolean $whitespace$ variadic $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( method . isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ variadic $whitespace$ = $whitespace$ i $whitespace$ == $whitespace$ ( method . getparametercount ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionparameterdeclaration ( method . getparametertypes ( ) [ i ] , $whitespace$ method . getgenericparametertypes ( ) [ i ] , $whitespace$ typesolver , $whitespace$ variadic , $whitespace$ method . getparameters ( ) [ i ] . getname ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedparameterdeclaration $whitespace$ getparam ( int $whitespace$ i ) { $newline$ $indentation$ boolean $whitespace$ variadic $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( method. isvarargs ( ) ) $whitespace$ { $newline$ $indentation$ variadic $whitespace$ = $whitespace$ i $whitespace$ == $whitespace$ ( method. getparametercount ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ reflectionparameterdeclaration ( method. getparametertypes ( ) [ i ], $whitespace$ method. getgenericparametertypes ( ) [ i ], $whitespace$ typesolver, $whitespace$ variadic, $whitespace$ method. getparameters ( ) [ i ]. getname ( ) ) ; $newline$ $indentation$ }			
toString	74	79	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodDeclaration.java	0.9163758158683776	HIGH	"		@Override
		public String toString(){
		    return ""ReflectionMethodDeclaration{"" + ""method="" + method + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ method $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ method $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
solveMethodAsUsage	82	140	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java	0.0030207969248294	LOW	"		 static Optional<MethodUsage> solveMethodAsUsage(String name, List<ResolvedType> argumentsTypes, TypeSolver typeSolver, Context invokationContext, List<ResolvedType> typeParameterValues, ResolvedReferenceTypeDeclaration scopeType, Class clazz){
		    if (typeParameterValues.size() != scopeType.getTypeParameters().size()) {
		        // if it is zero we are going to ignore them
		        if (!scopeType.getTypeParameters().isEmpty()) {
		            // Parameters not specified, so default to Object
		            typeParameterValues = new ArrayList<>();
		            for (int i = 0; i < scopeType.getTypeParameters().size(); i++) {
		                typeParameterValues.add(new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)));
		            }
		        }
		    }
		    List<MethodUsage> methods = new ArrayList<>();
		    for (Method method : clazz.getMethods()) {
		        if (method.getName().equals(name) && !method.isBridge() && !method.isSynthetic()) {
		            ResolvedMethodDeclaration methodDeclaration = new ReflectionMethodDeclaration(method, typeSolver);
		            MethodUsage methodUsage = replaceParams(typeParameterValues, scopeType, methodDeclaration);
		            methods.add(methodUsage);
		        }
		    }
		    List<ResolvedReferenceType> ancestors = scopeType.getAncestors();
		    for (ResolvedReferenceType ancestor : ancestors) {
		        if (ancestor.getTypeDeclaration().isPresent()) {
		            ResolvedReferenceTypeDeclaration ancestorTypeDeclaration = ancestor.getTypeDeclaration().get();
		            SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(ancestorTypeDeclaration, name, argumentsTypes);
		            if (ref.isSolved()) {
		                ResolvedMethodDeclaration correspondingDeclaration = ref.getCorrespondingDeclaration();
		                MethodUsage methodUsage = replaceParams(typeParameterValues, ancestorTypeDeclaration, correspondingDeclaration);
		                methods.add(methodUsage);
		            }
		        }
		    }
		    if (ancestors.isEmpty()) {
		        Optional<ResolvedReferenceTypeDeclaration> optionalObjectClass = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver)).getTypeDeclaration();
		        if (optionalObjectClass.isPresent()) {
		            SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(optionalObjectClass.get(), name, argumentsTypes);
		            if (ref.isSolved()) {
		                MethodUsage usage = replaceParams(typeParameterValues, optionalObjectClass.get(), ref.getCorrespondingDeclaration());
		                methods.add(usage);
		            }
		        }
		    }
		    final List<ResolvedType> finalTypeParameterValues = typeParameterValues;
		    argumentsTypes = argumentsTypes.stream().map((pt) -> {
		        int i = 0;
		        for (ResolvedTypeParameterDeclaration tp : scopeType.getTypeParameters()) {
		            pt = pt.replaceTypeVariables(tp, finalTypeParameterValues.get(i));
		            i++;
		        }
		        return pt;
		    }).collect(Collectors.toList());
		    return MethodResolutionLogic.findMostApplicableUsage(methods, name, argumentsTypes, typeSolver);
		}"	$indentation$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ context $whitespace$ invokationcontext , $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues , $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype , $whitespace$ class $whitespace$ clazz ) { $newline$ $indentation$ if $whitespace$ ( typeparametervalues . size ( ) $whitespace$ != $whitespace$ scopetype . gettypeparameters ( ) . size ( ) ) $whitespace$ { $newline$ $indentation$ $//·if·it·is·zero·we·are·going·to·ignore·them$ $newline$ $indentation$ if $whitespace$ ( ! scopetype . gettypeparameters ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·parameters·not·specified,·so·default·to·object$ $newline$ $indentation$ typeparametervalues $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ scopetype . gettypeparameters ( ) . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ typeparametervalues . add ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( object . class , $whitespace$ typesolver ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ list < methodusage > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ clazz . getmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method . getname ( ) . equals ( name ) $whitespace$ && $whitespace$ ! method . isbridge ( ) $whitespace$ && $whitespace$ ! method . issynthetic ( ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method , $whitespace$ typesolver ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ replaceparams ( typeparametervalues , $whitespace$ scopetype , $whitespace$ methoddeclaration ) ; $newline$ $indentation$ methods . add ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ ancestors $whitespace$ = $whitespace$ scopetype . getancestors ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ ancestors ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ancestor . gettypedeclaration ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ ancestortypedeclaration $whitespace$ = $whitespace$ ancestor . gettypedeclaration ( ) . get ( ) ; $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ancestortypedeclaration , $whitespace$ name , $whitespace$ argumentstypes ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ correspondingdeclaration $whitespace$ = $whitespace$ ref . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ replaceparams ( typeparametervalues , $whitespace$ ancestortypedeclaration , $whitespace$ correspondingdeclaration ) ; $newline$ $indentation$ methods . add ( methodusage ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ancestors . isempty ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ optionalobjectclass $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( object . class , $whitespace$ typesolver ) ) . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( optionalobjectclass . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( optionalobjectclass . get ( ) , $whitespace$ name , $whitespace$ argumentstypes ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ usage $whitespace$ = $whitespace$ replaceparams ( typeparametervalues , $whitespace$ optionalobjectclass . get ( ) , $whitespace$ ref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ methods . add ( usage ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ final $whitespace$ list < resolvedtype > $whitespace$ finaltypeparametervalues $whitespace$ = $whitespace$ typeparametervalues ; $newline$ $indentation$ argumentstypes $whitespace$ = $whitespace$ argumentstypes . stream ( ) . map ( ( pt ) $whitespace$ - > $whitespace$ { $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ scopetype . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ pt $whitespace$ = $whitespace$ pt . replacetypevariables ( tp , $whitespace$ finaltypeparametervalues . get ( i ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pt ; $newline$ $indentation$ } ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicableusage ( methods , $whitespace$ name , $whitespace$ argumentstypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ optional < methodusage > $whitespace$ solvemethodasusage ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ context $whitespace$ invokationcontext, $whitespace$ list < resolvedtype > $whitespace$ typeparametervalues, $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype, $whitespace$ class $whitespace$ clazz ) { $newline$ $indentation$ if $whitespace$ ( typeparametervalues. size ( ) $whitespace$!= $whitespace$ scopetype. gettypeparameters ( ). size ( ) ) $whitespace$ { $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ there $whitespace$ is $whitespace$ a $whitespace$ valid $whitespace$ cors $whitespace$ request $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ */ $newline$ $indentation$ boolean $whitespace$ validcourses $whitespace$ = $whitespace$ false ; $newline$ $indentation$ if $whitespace$ (! scopetype. gettypeparameters ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$ { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ scopetype. gettypeparameters ( ). size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ typeparametervalues. add ( new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( object. class, $whitespace$ typesolve			
solveMethod	50	80	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java	0.0076200310140848	LOW	"		 static SymbolReference<ResolvedMethodDeclaration> solveMethod(String name, List<ResolvedType> parameterTypes, boolean staticOnly, TypeSolver typeSolver, ResolvedReferenceTypeDeclaration scopeType, Class clazz){
		    List<ResolvedMethodDeclaration> methods = new ArrayList<>();
		    Predicate<Method> staticOnlyCheck = m -> !staticOnly || (staticOnly && Modifier.isStatic(m.getModifiers()));
		    for (Method method : clazz.getMethods()) {
		        if (method.isBridge() || method.isSynthetic() || !method.getName().equals(name) || !staticOnlyCheck.test(method))
		            continue;
		        ResolvedMethodDeclaration methodDeclaration = new ReflectionMethodDeclaration(method, typeSolver);
		        methods.add(methodDeclaration);
		    }
		    for (ResolvedReferenceType ancestor : scopeType.getAncestors()) {
		        ancestor.getTypeDeclaration().ifPresent(ancestorTypeDeclaration -> {
		            SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(ancestorTypeDeclaration, name, parameterTypes, staticOnly);
		            if (ref.isSolved()) {
		                methods.add(ref.getCorrespondingDeclaration());
		            }
		        });
		    }
		    if (scopeType.getAncestors().isEmpty()) {
		        ReferenceTypeImpl objectClass = new ReferenceTypeImpl(new ReflectionClassDeclaration(Object.class, typeSolver));
		        objectClass.getTypeDeclaration().ifPresent(objectTypeDeclaration -> {
		            SymbolReference<ResolvedMethodDeclaration> ref = MethodResolutionLogic.solveMethodInType(objectTypeDeclaration, name, parameterTypes, staticOnly);
		            if (ref.isSolved()) {
		                methods.add(ref.getCorrespondingDeclaration());
		            }
		        });
		    }
		    return MethodResolutionLogic.findMostApplicable(methods, name, parameterTypes, typeSolver);
		}"	$indentation$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name , $whitespace$ list < resolvedtype > $whitespace$ parametertypes , $whitespace$ boolean $whitespace$ staticonly , $whitespace$ typesolver $whitespace$ typesolver , $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype , $whitespace$ class $whitespace$ clazz ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ predicate < method > $whitespace$ staticonlycheck $whitespace$ = $whitespace$ m $whitespace$ - > $whitespace$ ! staticonly $whitespace$ || $whitespace$ ( staticonly $whitespace$ && $whitespace$ modifier . isstatic ( m . getmodifiers ( ) ) ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ clazz . getmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method . isbridge ( ) $whitespace$ || $whitespace$ method . issynthetic ( ) $whitespace$ || $whitespace$ ! method . getname ( ) . equals ( name ) $whitespace$ || $whitespace$ ! staticonlycheck . test ( method ) ) $newline$ $indentation$ continue ; $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method , $whitespace$ typesolver ) ; $newline$ $indentation$ methods . add ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ scopetype . getancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor . gettypedeclaration ( ) . ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( ancestortypedeclaration , $whitespace$ name , $whitespace$ parametertypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ methods . add ( ref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scopetype . getancestors ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ referencetypeimpl $whitespace$ objectclass $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( new $whitespace$ reflectionclassdeclaration ( object . class , $whitespace$ typesolver ) ) ; $newline$ $indentation$ objectclass . gettypedeclaration ( ) . ifpresent ( objecttypedeclaration $whitespace$ - > $whitespace$ { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ ref $whitespace$ = $whitespace$ methodresolutionlogic . solvemethodintype ( objecttypedeclaration , $whitespace$ name , $whitespace$ parametertypes , $whitespace$ staticonly ) ; $newline$ $indentation$ if $whitespace$ ( ref . issolved ( ) ) $whitespace$ { $newline$ $indentation$ methods . add ( ref . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodresolutionlogic . findmostapplicable ( methods , $whitespace$ name , $whitespace$ parametertypes , $whitespace$ typesolver ) ; $newline$ $indentation$ }	$indentation$ static $whitespace$ symbolreference < resolvedmethoddeclaration > $whitespace$ solvemethod ( string $whitespace$ name, $whitespace$ list < resolvedtype > $whitespace$ parametertypes, $whitespace$ boolean $whitespace$ staticonly, $whitespace$ typesolver $whitespace$ typesolver, $whitespace$ resolvedreferencetypedeclaration $whitespace$ scopetype, $whitespace$ class $whitespace$ clazz ) { $newline$ $indentation$ list < resolvedmethoddeclaration > $whitespace$ methods $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( method $whitespace$ method $whitespace$ : $whitespace$ clazz. getmethods ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( method. isbridge ( ) $whitespace$ || $whitespace$ method. issynthetic ( ) $whitespace$ || $whitespace$! method. getname ( ). equals ( name ) $whitespace$ || $whitespace$! staticonlycheck. test ( method ) ) $whitespace$ { $newline$ $indentation$ continue ; $newline$ $indentation$ } $newline$ $indentation$ resolvedmethoddeclaration $whitespace$ methoddeclaration $whitespace$ = $whitespace$ new $whitespace$ reflectionmethoddeclaration ( method, $whitespace$ typesolver ) ; $newline$ $indentation$ methods. add ( methoddeclaration ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ ancestor $whitespace$ : $whitespace$ scopetype. getancestors ( ) ) $whitespace$ { $newline$ $indentation$ ancestor. gettypedeclaration ( ). ifpresent ( ancestortypedeclaration $whitespace$ - > $whitespace$ ancestor. gettypedeclaration ( ). ifpresent ( ancestortypedeclaration $whitespace$			
replaceParams	142	159	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionMethodResolutionLogic.java	0.1147361174225807	LOW	"		private static MethodUsage replaceParams(List<ResolvedType> typeParameterValues, ResolvedReferenceTypeDeclaration typeParametrizable, ResolvedMethodDeclaration methodDeclaration){
		    MethodUsage methodUsage = new MethodUsage(methodDeclaration);
		    int i = 0;
		    // Only replace if we have enough values provided
		    if (typeParameterValues.size() == typeParametrizable.getTypeParameters().size()) {
		        for (ResolvedTypeParameterDeclaration tp : typeParametrizable.getTypeParameters()) {
		            methodUsage = methodUsage.replaceTypeParameter(tp, typeParameterValues.get(i));
		            i++;
		        }
		    }
		    for (ResolvedTypeParameterDeclaration methodTypeParameter : methodDeclaration.getTypeParameters()) {
		        methodUsage = methodUsage.replaceTypeParameter(methodTypeParameter, new ResolvedTypeVariable(methodTypeParameter));
		    }
		    return methodUsage;
		}"	$indentation$ private $whitespace$ static $whitespace$ methodusage $whitespace$ replaceparams ( list < resolvedtype > $whitespace$ typeparametervalues , $whitespace$ resolvedreferencetypedeclaration $whitespace$ typeparametrizable , $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $//·only·replace·if·we·have·enough·values·provided$ $newline$ $indentation$ if $whitespace$ ( typeparametervalues . size ( ) $whitespace$ == $whitespace$ typeparametrizable . gettypeparameters ( ) . size ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparametrizable . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( tp , $whitespace$ typeparametervalues . get ( i ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ methodtypeparameter $whitespace$ : $whitespace$ methoddeclaration . gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage . replacetypeparameter ( methodtypeparameter , $whitespace$ new $whitespace$ resolvedtypevariable ( methodtypeparameter ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ methodusage $whitespace$ replaceparams ( list < resolvedtype > $whitespace$ typeparametervalues, $whitespace$ resolvedreferencetypedeclaration $whitespace$ typeparametrizable, $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ methodusage $whitespace$ methodusage $whitespace$ = $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( typeparametervalues. size ( ) $whitespace$ == $whitespace$ typeparametrizable. gettypeparameters ( ). size ( ) ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparametrizable. gettypeparameters ( ) ) $whitespace$ { $newline$ $indentation$ methodusage $whitespace$ = $whitespace$ methodusage. replacetypeparameter ( tp, $whitespace$ typeparametervalues. get ( i ) ) ; $newline$ $indentation$ i ++ ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ methodusage ; $newline$ $indentation$ }			
equals	104	114	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionParameterDeclaration.java	0.0912151560187339	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ReflectionParameterDeclaration that = (ReflectionParameterDeclaration) o;
		    return variadic == that.variadic && Objects.equals(type, that.type) && Objects.equals(genericType, that.genericType) && Objects.equals(typeSolver, that.typeSolver) && Objects.equals(name, that.name);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ reflectionparameterdeclaration $whitespace$ that $whitespace$ = $whitespace$ ( reflectionparameterdeclaration ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ variadic $whitespace$ == $whitespace$ that . variadic $whitespace$ && $whitespace$ objects . equals ( type , $whitespace$ that . type ) $whitespace$ && $whitespace$ objects . equals ( generictype , $whitespace$ that . generictype ) $whitespace$ && $whitespace$ objects . equals ( typesolver , $whitespace$ that . typesolver ) $whitespace$ && $whitespace$ objects . equals ( name , $whitespace$ that . name ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$! this. isequals ( o ) ; $newline$ $indentation$ boolean $whitespace$ isequals $whitespace$ = $whitespace$! isequals ( o ) ; $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ isequals $whitespace$ = $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ isequals $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ variadic $whitespace$ == $whitespace$ that. variadic $whitespace$ && $whitespace$ objects. equals ( type, $whitespace$ that. type ) $whitespace$ && $whitespace$ objects. equals ( generictype, $whitespace$ that. generictype ) $whitespace$ && $whitespace$ objects. equals ( typesolver, $whitespace$ that. typesolver ) $whitespace$ && $whitespace$ objects. equals ( name, $whitespace$ that. name ) ; $newline$ $indentation$ }			
toString	71	77	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionParameterDeclaration.java	0.8957583904266357	HIGH	"		@Override
		public String toString(){
		    return ""ReflectionParameterDeclaration{"" + ""type="" + type + "", name="" + name + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ type $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ type $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
containerType	125	131	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java	0.61215740442276	MID	"		@Override
		public Optional<ResolvedReferenceTypeDeclaration> containerType(){
		    if (container instanceof ResolvedReferenceTypeDeclaration) {
		        return Optional.of((ResolvedReferenceTypeDeclaration) container);
		    }
		    return Optional.empty();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( ( resolvedreferencetypedeclaration ) $whitespace$ container ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < resolvedreferencetypedeclaration > $whitespace$ containertype ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( ( resolvedreferencetypedeclaration ) $whitespace$ container ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
getContainerId	100	106	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java	0.6213810443878174	MID	"		@Override
		public String getContainerId(){
		    if (container instanceof ResolvedReferenceTypeDeclaration) {
		        return ((ResolvedReferenceTypeDeclaration) container).getId();
		    }
		    return ((ResolvedMethodLikeDeclaration) container).getQualifiedSignature();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getcontainerid ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( resolvedreferencetypedeclaration ) $whitespace$ container ) . getid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ( ( resolvedmethodlikedeclaration ) $whitespace$ container ) . getqualifiedsignature ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ getcontainerid ( ) { $newline$ $indentation$ if $whitespace$ ( container $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( resolvedreferencetypedeclaration ) $whitespace$ container ). getid ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ ( ( resolvedmethodlikedeclaration ) $whitespace$ container ). getqualifiedsignature ( ) ; $newline$ $indentation$ }			
toString	118	123	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/ReflectionTypeParameter.java	0.8887633681297302	HIGH	"		@Override
		public String toString(){
		    return ""ReflectionTypeParameter{"" + ""typeVariable="" + typeVariable + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typevariable $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ typevariable $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
compare	31	45	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/ClassComparator.java	0.1369320154190063	LOW	"		@Override
		public int compare(Class<?> o1, Class<?> o2){
		    int subCompare;
		    subCompare = o1.getCanonicalName().compareTo(o2.getCanonicalName());
		    if (subCompare != 0)
		        return subCompare;
		    subCompare = Boolean.compare(o1.isAnnotation(), o2.isAnnotation());
		    if (subCompare != 0)
		        return subCompare;
		    subCompare = Boolean.compare(o1.isArray(), o2.isArray());
		    if (subCompare != 0)
		        return subCompare;
		    subCompare = Boolean.compare(o1.isEnum(), o2.isEnum());
		    if (subCompare != 0)
		        return subCompare;
		    subCompare = Boolean.compare(o1.isInterface(), o2.isInterface());
		    if (subCompare != 0)
		        return subCompare;
		    return 0;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compare ( class < ? > $whitespace$ o1 , $whitespace$ class < ? > $whitespace$ o2 ) { $newline$ $indentation$ int $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ o1 . getcanonicalname ( ) . compareto ( o2 . getcanonicalname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean . compare ( o1 . isannotation ( ) , $whitespace$ o2 . isannotation ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean . compare ( o1 . isarray ( ) , $whitespace$ o2 . isarray ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean . compare ( o1 . isenum ( ) , $whitespace$ o2 . isenum ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean . compare ( o1 . isinterface ( ) , $whitespace$ o2 . isinterface ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compare ( class <? > $whitespace$ o1, $whitespace$ class <? > $whitespace$ o2 ) { $newline$ $indentation$ int $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ ( o1. getcanonicalname ( ). compareto ( o2. getcanonicalname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean. compare ( o1. isannotation ( ), $whitespace$ o2. isannotation ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean. compare ( o1. isarray ( ), $whitespace$ o2. isarray ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean. compare ( o1. isenum ( ), $whitespace$ o2. isenum ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ subcompare ; $newline$ $indentation$ subcompare $whitespace$ = $whitespace$ boolean. compare ( o1. isinterface ( ), $whitespace$ o2. isinterface ( ) ) ; $newline$ $indentation$ if $whitespace$ ( subcompare $whitespace$!= $whitespace$ $number$ ) $newline$ $indentation$			
compare	32	45	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/reflectionmodel/comparators/MethodComparator.java	0.2657164633274078	LOW	"		@Override
		public int compare(Method o1, Method o2){
		    int compareName = o1.getName().compareTo(o2.getName());
		    if (compareName != 0)
		        return compareName;
		    int compareNParams = o1.getParameterCount() - o2.getParameterCount();
		    if (compareNParams != 0)
		        return compareNParams;
		    for (int i = 0; i < o1.getParameterCount(); i++) {
		        int compareParam = new ParameterComparator().compare(o1.getParameters()[i], o2.getParameters()[i]);
		        if (compareParam != 0)
		            return compareParam;
		    }
		    int compareResult = new ClassComparator().compare(o1.getReturnType(), o2.getReturnType());
		    if (compareResult != 0)
		        return compareResult;
		    return 0;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compare ( method $whitespace$ o1 , $whitespace$ method $whitespace$ o2 ) { $newline$ $indentation$ int $whitespace$ comparename $whitespace$ = $whitespace$ o1 . getname ( ) . compareto ( o2 . getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( comparename $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ comparename ; $newline$ $indentation$ int $whitespace$ comparenparams $whitespace$ = $whitespace$ o1 . getparametercount ( ) $whitespace$ - $whitespace$ o2 . getparametercount ( ) ; $newline$ $indentation$ if $whitespace$ ( comparenparams $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ comparenparams ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ o1 . getparametercount ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ int $whitespace$ compareparam $whitespace$ = $whitespace$ new $whitespace$ parametercomparator ( ) . compare ( o1 . getparameters ( ) [ i ] , $whitespace$ o2 . getparameters ( ) [ i ] ) ; $newline$ $indentation$ if $whitespace$ ( compareparam $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ compareparam ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ compareresult $whitespace$ = $whitespace$ new $whitespace$ classcomparator ( ) . compare ( o1 . getreturntype ( ) , $whitespace$ o2 . getreturntype ( ) ) ; $newline$ $indentation$ if $whitespace$ ( compareresult $whitespace$ != $whitespace$ $number$ ) $newline$ $indentation$ return $whitespace$ compareresult ; $newline$ $indentation$ return $whitespace$ $number$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ compare ( method $whitespace$ o1, $whitespace$ method $whitespace$ o2 ) { $newline$ $indentation$ int $whitespace$ comparename $whitespace$ = $whitespace$ o1. getname ( ). compareto ( o2. getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( comparename $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ comparename ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ comparenparams $whitespace$ = $whitespace$ o1. getparametercount ( ) $whitespace$ - $whitespace$ o2. getparametercount ( ) ; $newline$ $indentation$ if $whitespace$ ( comparenparams $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ comparenparams ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ compareresult $whitespace$ = $whitespace$ new $whitespace$ classcomparator ( ). compare ( o1. getreturntype ( ), $whitespace$ o2. getreturntype ( ) ) ; $newline$ $indentation$ if $whitespace$ ( compareresult $whitespace$!= $whitespace$			
solveMethod	95	102	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/SymbolSolver.java	0.2464608252048492	LOW	"		@Override
		public MethodUsage solveMethod(String methodName, List<ResolvedType> argumentsTypes, Context context){
		    SymbolReference<ResolvedMethodDeclaration> decl = context.solveMethod(methodName, argumentsTypes, false);
		    if (!decl.isSolved()) {
		        throw new UnsolvedSymbolException(context.toString(), methodName);
		    }
		    return new MethodUsage(decl.getCorrespondingDeclaration());
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ methodusage $whitespace$ solvemethod ( string $whitespace$ methodname , $whitespace$ list < resolvedtype > $whitespace$ argumentstypes , $whitespace$ context $whitespace$ context ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ decl $whitespace$ = $whitespace$ context . solvemethod ( methodname , $whitespace$ argumentstypes , $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ ( ! decl . issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( context . tostring ( ) , $whitespace$ methodname ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( decl . getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ methodusage $whitespace$ solvemethod ( string $whitespace$ methodname, $whitespace$ list < resolvedtype > $whitespace$ argumentstypes, $whitespace$ context $whitespace$ context ) { $newline$ $indentation$ symbolreference < resolvedmethoddeclaration > $whitespace$ parents $whitespace$ = $whitespace$ context. solvemethod ( methodname, $whitespace$ argumentstypes, $whitespace$ false ) ; $newline$ $indentation$ if $whitespace$ (! decl. issolved ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( context. tostring ( ), $whitespace$ methodname ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( decl. getcorrespondingdeclaration ( ) ) ; $newline$ $indentation$ }			
classifyRole	110	307	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	2.194262566784788e-14	LOW	"		public static NameRole classifyRole(Node name){
		    if (!isAName(name)) {
		        throw new IllegalArgumentException(""The given node is not a name"");
		    }
		    if (!name.getParentNode().isPresent()) {
		        throw new IllegalArgumentException(""We cannot understand the role of a name if it has no parent"");
		    }
		    if (whenParentIs(Name.class, name, (p, c) -> p.getQualifier().isPresent() && p.getQualifier().get() == c)) {
		        return classifyRole(name.getParentNode().get());
		    }
		    if (whenParentIs(PackageDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(ImportDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MarkerAnnotationExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ClassOrInterfaceDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(ClassOrInterfaceDeclaration.class, name, (p, c) -> p.getExtendedTypes().contains(c) || p.getImplementedTypes().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ClassOrInterfaceType.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(NameExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(FieldAccessExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(Parameter.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(AnnotationDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(AnnotationMemberDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(AnnotationMemberDeclaration.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getType() == c || p.getThrownExceptions().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(Parameter.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(Parameter.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(PatternExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(PatternExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ReceiverParameter.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getName() == c || (p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c)) || (p.hasScope() && p.getScope().get() == c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getName() == c || p.getThrownExceptions().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(TypeParameter.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(EnumDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(EnumConstantDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(FieldAccessExpr.class, name, (p, c) -> p.getName() == c || p.getScope() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ObjectCreationExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ReturnStmt.class, name, (p, c) -> p.getExpression().isPresent() && p.getExpression().get() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleDeclaration.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(ModuleRequiresDirective.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleExportsDirective.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleExportsDirective.class, name, (p, c) -> p.getModuleNames().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleOpensDirective.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleOpensDirective.class, name, (p, c) -> p.getModuleNames().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleUsesDirective.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ModuleProvidesDirective.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ClassExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ThisExpr.class, name, (p, c) -> p.getTypeName().isPresent() && p.getTypeName().get() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(SuperExpr.class, name, (p, c) -> p.getTypeName().isPresent() && p.getTypeName().get() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ArrayCreationExpr.class, name, (p, c) -> p.getElementType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(CastExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(InstanceOfExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(TypeExpr.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ArrayAccessExpr.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(UnaryExpr.class, name, (p, c) -> p.getExpression() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(AssignExpr.class, name, (p, c) -> p.getTarget() == c || p.getValue() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(TryStmt.class, name, (p, c) -> p.getResources().contains(c))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getType() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p, c) -> p.getInitializer().isPresent() && p.getInitializer().get() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MemberValuePair.class, name, (p, c) -> p.getValue() == c)) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(MemberValuePair.class, name, (p, c) -> p.getName() == c)) {
		        return NameRole.DECLARATION;
		    }
		    if (whenParentIs(ExplicitConstructorInvocationStmt.class, name, (p, c) -> (p.getExpression().isPresent() && p.getExpression().get() == c) || (p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c)))) {
		        return NameRole.REFERENCE;
		    }
		    if (whenParentIs(ObjectCreationExpr.class, name, (p, c) -> p.getType() == c || (p.hasScope() && p.getScope().get() == c))) {
		        return NameRole.REFERENCE;
		    }
		    if (name.getParentNode().isPresent() && NameLogic.isAName(name.getParentNode().get())) {
		        return classifyRole(name.getParentNode().get());
		    }
		    throw new UnsupportedOperationException(""Unable to classify role of name contained in "" + name.getParentNode().get().getClass().getSimpleName());
		}"	$indentation$ public $whitespace$ static $whitespace$ namerole $whitespace$ classifyrole ( node $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! isaname ( name ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! name . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( name . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getqualifier ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getqualifier ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classifyrole ( name . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( packagedeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( importdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( markerannotationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacedeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacedeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getextendedtypes ( ) . contains ( c ) $whitespace$ || $whitespace$ p . getimplementedtypes ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacetype . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( fieldaccessexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methoddeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( parameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methodcallexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( constructordeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( annotationdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( annotationmemberdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( annotationmemberdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methoddeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methoddeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ p . getthrownexceptions ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( parameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( parameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( patternexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( patternexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( receiverparameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methodcallexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ ( p . gettypearguments ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypearguments ( ) . get ( ) . contains ( c ) ) $whitespace$ || $whitespace$ ( p . hasscope ( ) $whitespace$ && $whitespace$ p . getscope ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( constructordeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ p . getthrownexceptions ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( typeparameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( enumdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( enumconstantdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( fieldaccessexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ p . getscope ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( objectcreationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( returnstmt . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getexpression ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getexpression ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduledeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( modulerequiresdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleexportsdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleexportsdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getmodulenames ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleopensdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleopensdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getmodulenames ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleusesdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleprovidesdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( classexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( thisexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettypename ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypename ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( superexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettypename ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypename ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( arraycreationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getelementtype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( castexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( instanceofexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( typeexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( arrayaccessexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( unaryexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getexpression ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( assignexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettarget ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ p . getvalue ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( trystmt . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getresources ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getinitializer ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getinitializer ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( membervaluepair . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getvalue ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( membervaluepair . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( explicitconstructorinvocationstmt . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ ( p . getexpression ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getexpression ( ) . get ( ) $whitespace$ == $whitespace$ c ) $whitespace$ || $whitespace$ ( p . gettypearguments ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypearguments ( ) . get ( ) . contains ( c ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( objectcreationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c $whitespace$ || $whitespace$ ( p . hasscope ( ) $whitespace$ && $whitespace$ p . getscope ( ) . get ( ) $whitespace$ == $whitespace$ c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole . reference ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ namelogic . isaname ( name . getparentnode ( ) . get ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ classifyrole ( name . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ name . getparentnode ( ) . get ( ) . getclass ( ) . getsimplename ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ namerole $whitespace$ classifyrole ( node $whitespace$ name ) { $newline$ $indentation$ // $whitespace$ to $whitespace$ be $whitespace$ handled $whitespace$ if $whitespace$ the $whitespace$ name $whitespace$ is $whitespace$ not $whitespace$ contain $whitespace$ the $whitespace$ bearer $whitespace$ prefix $newline$ $indentation$ string $whitespace$ msg $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ (! name. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( msg ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! name. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( createreason ( name. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getqualifier ( ). ispresent ( ) $whitespace$ && $whitespace$ p. getqualifier ( ). get ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole. declaration ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( createreason ( name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namerole. reference ; $newline$ $indentation$ }			
isSyntacticallyATypeName	641	852	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	2.0825925730605377e-06	LOW	"		private static boolean isSyntacticallyATypeName(Node name){
		    // A name is syntactically classified as a TypeName in these contexts:
		    //
		    // The first eleven non-generic contexts (§6.1):
		    //
		    // 1. In a uses or provides directive in a module declaration (§7.7.1)
		    if (whenParentIs(ModuleUsesDirective.class, name, (p, c) -> p.getName() == c)) {
		        return true;
		    }
		    if (whenParentIs(ModuleProvidesDirective.class, name, (p, c) -> p.getName() == c)) {
		        return true;
		    }
		    // 2. In a single-type-import declaration (§7.5.1)
		    if (whenParentIs(ImportDeclaration.class, name, (p, c) -> !p.isStatic() && !p.isAsterisk() && p.getName() == name)) {
		        return true;
		    }
		    // 3. To the left of the . in a single-static-import declaration (§7.5.3)
		    if (whenParentIs(Name.class, name, (largerName, c) -> whenParentIs(ImportDeclaration.class, largerName, (importDecl, c2) -> importDecl.isStatic() && !importDecl.isAsterisk() && importDecl.getName() == c2))) {
		        return true;
		    }
		    if (whenParentIs(ImportDeclaration.class, name, (importDecl, c2) -> importDecl.isStatic() && !importDecl.isAsterisk() && importDecl.getName() == c2)) {
		        return true;
		    }
		    // 4. To the left of the . in a static-import-on-demand declaration (§7.5.4)
		    if (whenParentIs(ImportDeclaration.class, name, (p, c) -> p.isStatic() && p.isAsterisk() && p.getName() == name)) {
		        return true;
		    }
		    // 5. To the left of the ( in a constructor declaration (§8.8)
		    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getName() == name)) {
		        return true;
		    }
		    // 6. After the @ sign in an annotation (§9.7)
		    if (whenParentIs(AnnotationExpr.class, name, (p, c) -> p.getName() == name)) {
		        return true;
		    }
		    // 7. To the left of .class in a class literal (§15.8.2)
		    if (whenParentIs(ClassExpr.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 8. To the left of .this in a qualified this expression (§15.8.4)
		    if (whenParentIs(ThisExpr.class, name, (ne, c2) -> ne.getTypeName().isPresent() && ne.getTypeName().get() == c2)) {
		        return true;
		    }
		    // 9. To the left of .super in a qualified superclass field access expression (§15.11.2)
		    if (whenParentIs(SuperExpr.class, name, (ne, c2) -> ne.getTypeName().isPresent() && ne.getTypeName().get() == c2)) {
		        return true;
		    }
		    // 10. To the left of .Identifier or .super.Identifier in a qualified method invocation expression (§15.12)
		    //
		    // 11. To the left of .super:: in a method reference expression (§15.13)
		    //
		    // As the Identifier or dotted Identifier sequence that constitutes any ReferenceType (including a
		    // ReferenceType to the left of the brackets in an array type, or to the left of the < in a parameterized type,
		    // or in a non-wildcard type argument of a parameterized type, or in an extends or super clause of a wildcard
		    // type argument of a parameterized type) in the 16 contexts where types are used (§4.11):
		    //
		    // 1. In an extends or implements clause of a class declaration (§8.1.4, §8.1.5, §8.5, §9.5)
		    // 2. In an extends clause of an interface declaration (§9.1.3)
		    if (whenParentIs(ClassOrInterfaceDeclaration.class, name, (p, c) -> p.getExtendedTypes().contains(c) || p.getImplementedTypes().contains(c))) {
		        return true;
		    }
		    // 3. The return type of a method (§8.4, §9.4) (including the type of an element of an annotation type (§9.6.1))
		    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    if (whenParentIs(AnnotationMemberDeclaration.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 4. In the throws clause of a method or constructor (§8.4.6, §8.8.5, §9.4)
		    if (whenParentIs(MethodDeclaration.class, name, (p, c) -> p.getThrownExceptions().contains(c))) {
		        return true;
		    }
		    if (whenParentIs(ConstructorDeclaration.class, name, (p, c) -> p.getThrownExceptions().contains(c))) {
		        return true;
		    }
		    // 5. In an extends clause of a type parameter declaration of a generic class, interface, method, or
		    //    constructor (§8.1.2, §9.1.2, §8.4.4, §8.8.4)
		    //
		    // 6. The type in a field declaration of a class or interface (§8.3, §9.3)
		    if (whenParentIs(VariableDeclarator.class, name, (p1, c1) -> p1.getType() == c1 && whenParentIs(FieldDeclaration.class, p1, (p2, c2) -> p2.getVariables().contains(c2)))) {
		        return true;
		    }
		    // 7. The type in a formal parameter declaration of a method, constructor, or lambda expression
		    //    (§8.4.1, §8.8.1, §9.4, §15.27.1)
		    if (whenParentIs(Parameter.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 8. The type of the receiver parameter of a method (§8.4.1)
		    if (whenParentIs(ReceiverParameter.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 9. The type in a local variable declaration (§14.4, §14.14.1, §14.14.2, §14.20.3)
		    if (whenParentIs(VariableDeclarator.class, name, (p1, c1) -> p1.getType() == c1 && whenParentIs(VariableDeclarationExpr.class, p1, (p2, c2) -> p2.getVariables().contains(c2)))) {
		        return true;
		    }
		    // 10. A type in an exception parameter declaration (§14.20)
		    //
		    // 11. In an explicit type argument list to an explicit constructor invocation statement or class instance
		    //     creation expression or method invocation expression (§8.8.7.1, §15.9, §15.12)
		    if (whenParentIs(ClassOrInterfaceType.class, name, (p, c) -> p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c))) {
		        return true;
		    }
		    if (whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getTypeArguments().isPresent() && p.getTypeArguments().get().contains(c))) {
		        return true;
		    }
		    // 12. In an unqualified class instance creation expression, either as the class type to be instantiated (§15.9)
		    //     or as the direct superclass or direct superinterface of an anonymous class to be instantiated (§15.9.5)
		    if (whenParentIs(ObjectCreationExpr.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 13. The element type in an array creation expression (§15.10.1)
		    if (whenParentIs(ArrayCreationExpr.class, name, (p, c) -> p.getElementType() == c)) {
		        return true;
		    }
		    // 14. The type in the cast operator of a cast expression (§15.16)
		    if (whenParentIs(CastExpr.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 15. The type that follows the instanceof relational operator (§15.20.2)
		    if (whenParentIs(InstanceOfExpr.class, name, (p, c) -> p.getType() == c)) {
		        return true;
		    }
		    // 16. In a method reference expression (§15.13), as the reference type to search for a member method or as the class type or array type to construct.
		    if (whenParentIs(TypeExpr.class, name, (p1, c1) -> p1.getType() == c1 && whenParentIs(MethodReferenceExpr.class, p1, (p2, c2) -> p2.getScope() == c2))) {
		        return true;
		    }
		    // The extraction of a TypeName from the identifiers of a ReferenceType in the 16 contexts above is intended to
		    // apply recursively to all sub-terms of the ReferenceType, such as its element type and any type arguments.
		    //
		    // For example, suppose a field declaration uses the type p.q.Foo[]. The brackets of the array type are ignored,
		    // and the term p.q.Foo is extracted as a dotted sequence of Identifiers to the left of the brackets in an array
		    // type, and classified as a TypeName. A later step determines which of p, q, and Foo is a type name or a
		    // package name.
		    //
		    // As another example, suppose a cast operator uses the type p.q.Foo<? extends String>. The term p.q.Foo is
		    // again extracted as a dotted sequence of Identifier terms, this time to the left of the < in a parameterized
		    // type, and classified as a TypeName. The term String is extracted as an Identifier in an extends clause of a
		    // wildcard type argument of a parameterized type, and classified as a TypeName.
		    return false;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyatypename ( node $whitespace$ name ) { $newline$ $indentation$ $//·a·name·is·syntactically·classified·as·a·typename·in·these·contexts:$ $newline$ $indentation$ // $newline$ $indentation$ $//·the·first·eleven·non-generic·contexts·(§6.1):$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·in·a·uses·or·provides·directive·in·a·module·declaration·(§7.7.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleusesdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleprovidesdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·in·a·single-type-import·declaration·(§7.5.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( importdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ ! p . isstatic ( ) $whitespace$ && $whitespace$ ! p . isasterisk ( ) $whitespace$ && $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·3.·to·the·left·of·the·.·in·a·single-static-import·declaration·(§7.5.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( name . class , $whitespace$ name , $whitespace$ ( largername , $whitespace$ c ) $whitespace$ - > $whitespace$ whenparentis ( importdeclaration . class , $whitespace$ largername , $whitespace$ ( importdecl , $whitespace$ c2 ) $whitespace$ - > $whitespace$ importdecl . isstatic ( ) $whitespace$ && $whitespace$ ! importdecl . isasterisk ( ) $whitespace$ && $whitespace$ importdecl . getname ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( importdeclaration . class , $whitespace$ name , $whitespace$ ( importdecl , $whitespace$ c2 ) $whitespace$ - > $whitespace$ importdecl . isstatic ( ) $whitespace$ && $whitespace$ ! importdecl . isasterisk ( ) $whitespace$ && $whitespace$ importdecl . getname ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·4.·to·the·left·of·the·.·in·a·static-import-on-demand·declaration·(§7.5.4)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( importdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . isstatic ( ) $whitespace$ && $whitespace$ p . isasterisk ( ) $whitespace$ && $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·5.·to·the·left·of·the·(·in·a·constructor·declaration·(§8.8)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( constructordeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·6.·after·the·@·sign·in·an·annotation·(§9.7)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( annotationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·7.·to·the·left·of·.class·in·a·class·literal·(§15.8.2)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( classexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·8.·to·the·left·of·.this·in·a·qualified·this·expression·(§15.8.4)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( thisexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . gettypename ( ) . ispresent ( ) $whitespace$ && $whitespace$ ne . gettypename ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·9.·to·the·left·of·.super·in·a·qualified·superclass·field·access·expression·(§15.11.2)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( superexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . gettypename ( ) . ispresent ( ) $whitespace$ && $whitespace$ ne . gettypename ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·10.·to·the·left·of·.identifier·or·.super.identifier·in·a·qualified·method·invocation·expression·(§15.12)$ $newline$ $indentation$ // $newline$ $indentation$ $//·11.·to·the·left·of·.super::·in·a·method·reference·expression·(§15.13)$ $newline$ $indentation$ // $newline$ $indentation$ $//·as·the·identifier·or·dotted·identifier·sequence·that·constitutes·any·referencetype·(including·a$ $newline$ $indentation$ $//·referencetype·to·the·left·of·the·brackets·in·an·array·type,·or·to·the·left·of·the·<·in·a·parameterized·type,$ $newline$ $indentation$ $//·or·in·a·non-wildcard·type·argument·of·a·parameterized·type,·or·in·an·extends·or·super·clause·of·a·wildcard$ $newline$ $indentation$ $//·type·argument·of·a·parameterized·type)·in·the·16·contexts·where·types·are·used·(§4.11):$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·in·an·extends·or·implements·clause·of·a·class·declaration·(§8.1.4,·§8.1.5,·§8.5,·§9.5)$ $newline$ $indentation$ $//·2.·in·an·extends·clause·of·an·interface·declaration·(§9.1.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacedeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getextendedtypes ( ) . contains ( c ) $whitespace$ || $whitespace$ p . getimplementedtypes ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·3.·the·return·type·of·a·method·(§8.4,·§9.4)·(including·the·type·of·an·element·of·an·annotation·type·(§9.6.1))$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( methoddeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( annotationmemberdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·4.·in·the·throws·clause·of·a·method·or·constructor·(§8.4.6,·§8.8.5,·§9.4)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( methoddeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getthrownexceptions ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( constructordeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getthrownexceptions ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·5.·in·an·extends·clause·of·a·type·parameter·declaration·of·a·generic·class,·interface,·method,·or$ $newline$ $indentation$ $//····constructor·(§8.1.2,·§9.1.2,·§8.4.4,·§8.8.4)$ $newline$ $indentation$ // $newline$ $indentation$ $//·6.·the·type·in·a·field·declaration·of·a·class·or·interface·(§8.3,·§9.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p1 , $whitespace$ c1 ) $whitespace$ - > $whitespace$ p1 . gettype ( ) $whitespace$ == $whitespace$ c1 $whitespace$ && $whitespace$ whenparentis ( fielddeclaration . class , $whitespace$ p1 , $whitespace$ ( p2 , $whitespace$ c2 ) $whitespace$ - > $whitespace$ p2 . getvariables ( ) . contains ( c2 ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·7.·the·type·in·a·formal·parameter·declaration·of·a·method,·constructor,·or·lambda·expression$ $newline$ $indentation$ $//····(§8.4.1,·§8.8.1,·§9.4,·§15.27.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( parameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·8.·the·type·of·the·receiver·parameter·of·a·method·(§8.4.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( receiverparameter . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·9.·the·type·in·a·local·variable·declaration·(§14.4,·§14.14.1,·§14.14.2,·§14.20.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p1 , $whitespace$ c1 ) $whitespace$ - > $whitespace$ p1 . gettype ( ) $whitespace$ == $whitespace$ c1 $whitespace$ && $whitespace$ whenparentis ( variabledeclarationexpr . class , $whitespace$ p1 , $whitespace$ ( p2 , $whitespace$ c2 ) $whitespace$ - > $whitespace$ p2 . getvariables ( ) . contains ( c2 ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·10.·a·type·in·an·exception·parameter·declaration·(§14.20)$ $newline$ $indentation$ // $newline$ $indentation$ $//·11.·in·an·explicit·type·argument·list·to·an·explicit·constructor·invocation·statement·or·class·instance$ $newline$ $indentation$ $//·····creation·expression·or·method·invocation·expression·(§8.8.7.1,·§15.9,·§15.12)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacetype . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettypearguments ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypearguments ( ) . get ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( methodcallexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettypearguments ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . gettypearguments ( ) . get ( ) . contains ( c ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·12.·in·an·unqualified·class·instance·creation·expression,·either·as·the·class·type·to·be·instantiated·(§15.9)$ $newline$ $indentation$ $//·····or·as·the·direct·superclass·or·direct·superinterface·of·an·anonymous·class·to·be·instantiated·(§15.9.5)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( objectcreationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·13.·the·element·type·in·an·array·creation·expression·(§15.10.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( arraycreationexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getelementtype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·14.·the·type·in·the·cast·operator·of·a·cast·expression·(§15.16)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( castexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·15.·the·type·that·follows·the·instanceof·relational·operator·(§15.20.2)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( instanceofexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . gettype ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·16.·in·a·method·reference·expression·(§15.13),·as·the·reference·type·to·search·for·a·member·method·or·as·the·class·type·or·array·type·to·construct.$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( typeexpr . class , $whitespace$ name , $whitespace$ ( p1 , $whitespace$ c1 ) $whitespace$ - > $whitespace$ p1 . gettype ( ) $whitespace$ == $whitespace$ c1 $whitespace$ && $whitespace$ whenparentis ( methodreferenceexpr . class , $whitespace$ p1 , $whitespace$ ( p2 , $whitespace$ c2 ) $whitespace$ - > $whitespace$ p2 . getscope ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·extraction·of·a·typename·from·the·identifiers·of·a·referencetype·in·the·16·contexts·above·is·intended·to$ $newline$ $indentation$ $//·apply·recursively·to·all·sub-terms·of·the·referencetype,·such·as·its·element·type·and·any·type·arguments.$ $newline$ $indentation$ // $newline$ $indentation$ $//·for·example,·suppose·a·field·declaration·uses·the·type·p.q.foo[].·the·brackets·of·the·array·type·are·ignored,$ $newline$ $indentation$ $//·and·the·term·p.q.foo·is·extracted·as·a·dotted·sequence·of·identifiers·to·the·left·of·the·brackets·in·an·array$ $newline$ $indentation$ $//·type,·and·classified·as·a·typename.·a·later·step·determines·which·of·p,·q,·and·foo·is·a·type·name·or·a$ $newline$ $indentation$ $//·package·name.$ $newline$ $indentation$ // $newline$ $indentation$ $//·as·another·example,·suppose·a·cast·operator·uses·the·type·p.q.foo<?·extends·string>.·the·term·p.q.foo·is$ $newline$ $indentation$ $//·again·extracted·as·a·dotted·sequence·of·identifier·terms,·this·time·to·the·left·of·the·<·in·a·parameterized$ $newline$ $indentation$ $//·type,·and·classified·as·a·typename.·the·term·string·is·extracted·as·an·identifier·in·an·extends·clause·of·a$ $newline$ $indentation$ $//·wildcard·type·argument·of·a·parameterized·type,·and·classified·as·a·typename.$ $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyatypename ( node $whitespace$ name ) { $newline$ $indentation$ $////任$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$////. graphncycylation ( node, $whitespace$ $number$ ) ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$// $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ ( whenparentis ( moduleusesdirective. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ // $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleprovidesdirective. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getname ( ) $whitespace$ == $whitespace$ c ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ check $whitespace$ for $whitespace$ pipes $newline$ $indentation$ if $whitespace$ ( whenparentis ( importdeclaration. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$! p. isstatic ( ) $whitespace$			
isSyntacticallyAnExpressionName	854	954	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	8.958108810475096e-05	LOW	"		private static boolean isSyntacticallyAnExpressionName(Node name){
		    // A name is syntactically classified as an ExpressionName in these contexts:
		    //
		    // 1. As the qualifying expression in a qualified superclass constructor invocation (§8.8.7.1)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(ExplicitConstructorInvocationStmt.class, nameExpr, (ne, c2) -> ne.getExpression().isPresent() && ne.getExpression().get() == c2))) {
		        return true;
		    }
		    if (whenParentIs(ExplicitConstructorInvocationStmt.class, name, (ne, c2) -> ne.getExpression().isPresent() && ne.getExpression().get() == c2)) {
		        return true;
		    }
		    // 2. As the qualifying expression in a qualified class instance creation expression (§15.9)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(ObjectCreationExpr.class, nameExpr, (ne, c2) -> ne.hasScope() && ne.getScope().get() == c2))) {
		        return true;
		    }
		    if (whenParentIs(ObjectCreationExpr.class, name, (ne, c2) -> ne.hasScope() && ne.getScope().get() == c2)) {
		        return true;
		    }
		    // 3. As the array reference expression in an array access expression (§15.10.3)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(ArrayAccessExpr.class, nameExpr, (ne, c2) -> ne.getName() == c2))) {
		        return true;
		    }
		    if (whenParentIs(ArrayAccessExpr.class, name, (ne, c2) -> ne.getName() == c2)) {
		        return true;
		    }
		    // 4. As a PostfixExpression (§15.14)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(UnaryExpr.class, nameExpr, (ne, c2) -> ne.getExpression() == c2 && ne.isPostfix()))) {
		        return true;
		    }
		    if (whenParentIs(UnaryExpr.class, name, (ne, c2) -> ne.getExpression() == c2 && ne.isPostfix())) {
		        return true;
		    }
		    // 5. As the left-hand operand of an assignment operator (§15.26)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(AssignExpr.class, nameExpr, (ne, c2) -> ne.getTarget() == c2))) {
		        return true;
		    }
		    if (whenParentIs(AssignExpr.class, name, (ne, c2) -> ne.getTarget() == c2)) {
		        return true;
		    }
		    // 6. As a VariableAccess in a try-with-resources statement (§14.20.3)
		    if (whenParentIs(NameExpr.class, name, (nameExpr, c) -> nameExpr.getName() == c && whenParentIs(TryStmt.class, nameExpr, (ne, c2) -> ne.getResources().contains(c2)))) {
		        return true;
		    }
		    if (whenParentIs(NameExpr.class, name, (p1, /*NameExpr*/
		    c1) -> p1.getName() == c1 && whenParentIs(VariableDeclarator.class, p1, (p2, c2) -> p2.getInitializer().isPresent() && p2.getInitializer().get() == c2 && whenParentIs(VariableDeclarationExpr.class, p2, (p3, c3) -> p3.getVariables().contains(c3) && whenParentIs(TryStmt.class, p3, (p4, c4) -> p4.getResources().contains(c4)))))) {
		        return true;
		    }
		    if (whenParentIs(TryStmt.class, name, (ne, c2) -> ne.getResources().contains(c2))) {
		        return true;
		    }
		    if (whenParentIs(VariableDeclarator.class, name, (p2, c2) -> p2.getInitializer().isPresent() && p2.getInitializer().get() == c2 && whenParentIs(VariableDeclarationExpr.class, p2, (p3, c3) -> p3.getVariables().contains(c3) && whenParentIs(TryStmt.class, p3, (p4, c4) -> p4.getResources().contains(c4))))) {
		        return true;
		    }
		    return false;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyanexpressionname ( node $whitespace$ name ) { $newline$ $indentation$ $//·a·name·is·syntactically·classified·as·an·expressionname·in·these·contexts:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·as·the·qualifying·expression·in·a·qualified·superclass·constructor·invocation·(§8.8.7.1)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( explicitconstructorinvocationstmt . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getexpression ( ) . ispresent ( ) $whitespace$ && $whitespace$ ne . getexpression ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( explicitconstructorinvocationstmt . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getexpression ( ) . ispresent ( ) $whitespace$ && $whitespace$ ne . getexpression ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·as·the·qualifying·expression·in·a·qualified·class·instance·creation·expression·(§15.9)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( objectcreationexpr . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . hasscope ( ) $whitespace$ && $whitespace$ ne . getscope ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( objectcreationexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . hasscope ( ) $whitespace$ && $whitespace$ ne . getscope ( ) . get ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·3.·as·the·array·reference·expression·in·an·array·access·expression·(§15.10.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( arrayaccessexpr . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getname ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( arrayaccessexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getname ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·4.·as·a·postfixexpression·(§15.14)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( unaryexpr . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getexpression ( ) $whitespace$ == $whitespace$ c2 $whitespace$ && $whitespace$ ne . ispostfix ( ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( unaryexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getexpression ( ) $whitespace$ == $whitespace$ c2 $whitespace$ && $whitespace$ ne . ispostfix ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·5.·as·the·left-hand·operand·of·an·assignment·operator·(§15.26)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( assignexpr . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . gettarget ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( assignexpr . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . gettarget ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·6.·as·a·variableaccess·in·a·try-with-resources·statement·(§14.20.3)$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( nameexpr , $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr . getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( trystmt . class , $whitespace$ nameexpr , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getresources ( ) . contains ( c2 ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr . class , $whitespace$ name , $whitespace$ ( p1 , $whitespace$ /*nameexpr*/ $newline$ $indentation$ c1 ) $whitespace$ - > $whitespace$ p1 . getname ( ) $whitespace$ == $whitespace$ c1 $whitespace$ && $whitespace$ whenparentis ( variabledeclarator . class , $whitespace$ p1 , $whitespace$ ( p2 , $whitespace$ c2 ) $whitespace$ - > $whitespace$ p2 . getinitializer ( ) . ispresent ( ) $whitespace$ && $whitespace$ p2 . getinitializer ( ) . get ( ) $whitespace$ == $whitespace$ c2 $whitespace$ && $whitespace$ whenparentis ( variabledeclarationexpr . class , $whitespace$ p2 , $whitespace$ ( p3 , $whitespace$ c3 ) $whitespace$ - > $whitespace$ p3 . getvariables ( ) . contains ( c3 ) $whitespace$ && $whitespace$ whenparentis ( trystmt . class , $whitespace$ p3 , $whitespace$ ( p4 , $whitespace$ c4 ) $whitespace$ - > $whitespace$ p4 . getresources ( ) . contains ( c4 ) ) ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( trystmt . class , $whitespace$ name , $whitespace$ ( ne , $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne . getresources ( ) . contains ( c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( variabledeclarator . class , $whitespace$ name , $whitespace$ ( p2 , $whitespace$ c2 ) $whitespace$ - > $whitespace$ p2 . getinitializer ( ) . ispresent ( ) $whitespace$ && $whitespace$ p2 . getinitializer ( ) . get ( ) $whitespace$ == $whitespace$ c2 $whitespace$ && $whitespace$ whenparentis ( variabledeclarationexpr . class , $whitespace$ p2 , $whitespace$ ( p3 , $whitespace$ c3 ) $whitespace$ - > $whitespace$ p3 . getvariables ( ) . contains ( c3 ) $whitespace$ && $whitespace$ whenparentis ( trystmt . class , $whitespace$ p3 , $whitespace$ ( p4 , $whitespace$ c4 ) $whitespace$ - > $whitespace$ p4 . getresources ( ) . contains ( c4 ) ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	"$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyanexpressionname ( node $whitespace$ name ) { $newline$ $indentation$ $////"""" $whitespace$ = $whitespace$ nameexpr. class ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$////"""" $whitespace$ = $whitespace$ cellmass'). $newline$ $indentation$ // $newline$ $indentation$ if $whitespace$ ( whenparentis ( nameexpr. class, $whitespace$ name, $whitespace$ ( nameexpr, $whitespace$ c ) $whitespace$ - > $whitespace$ nameexpr. getname ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ whenparentis ( explicitconstructorinvocationstmt. class, $whitespace$ nameexpr, $whitespace$ ( ne, $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne. getexpression ( ). ispresent ( ) $whitespace$ && $whitespace$ ne. getexpression ( ). get ( ) $whitespace$ == $whitespace$ c2 ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( explicitconstructorinvocationstmt. class, $whitespace$ name, $whitespace$ ( ne, $whitespace$ c2 ) $whitespace$ - > $whitespace$ ne. getexpression ( ). ispresent ( ) $whitespace$ && $whitespace$ ne. getexpression ( ). get ( ) $whitespace$ == $whitespace$ c2 ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $////space$2.2.2$ = $whitespace$$ tmplexpressionexpression$qualifying ( node $whitespace$ name ) { $newline$ $indentation$ $whitespace$// $newline$ $indentation$"			
syntacticClassificationAccordingToContext	504	553	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.0153586510568857	LOW	"		public static NameCategory syntacticClassificationAccordingToContext(Node name){
		    if (name.getParentNode().isPresent()) {
		        Node parent = name.getParentNode().get();
		        if (isAName(parent) && nameAsString(name).equals(nameAsString(parent))) {
		            return syntacticClassificationAccordingToContext(parent);
		        }
		    }
		    if (isSyntacticallyATypeName(name)) {
		        return NameCategory.TYPE_NAME;
		    }
		    if (isSyntacticallyAnExpressionName(name)) {
		        return NameCategory.EXPRESSION_NAME;
		    }
		    if (isSyntacticallyAMethodName(name)) {
		        return NameCategory.METHOD_NAME;
		    }
		    if (isSyntacticallyAPackageOrTypeName(name)) {
		        return NameCategory.PACKAGE_OR_TYPE_NAME;
		    }
		    if (isSyntacticallyAAmbiguousName(name)) {
		        return NameCategory.AMBIGUOUS_NAME;
		    }
		    if (isSyntacticallyAModuleName(name)) {
		        return NameCategory.MODULE_NAME;
		    }
		    if (isSyntacticallyAPackageName(name)) {
		        return NameCategory.PACKAGE_NAME;
		    }
		    if (name instanceof NameExpr) {
		        return NameCategory.EXPRESSION_NAME;
		    }
		    if (name instanceof FieldAccessExpr) {
		        return NameCategory.EXPRESSION_NAME;
		    }
		    if (name instanceof ClassOrInterfaceType) {
		        return NameCategory.TYPE_NAME;
		    }
		    if (name.getParentNode().isPresent() && name.getParentNode().get() instanceof ClassOrInterfaceType) {
		        return NameCategory.TYPE_NAME;
		    }
		    if (name.getParentNode().isPresent() && name.getParentNode().get() instanceof FieldAccessExpr) {
		        return NameCategory.EXPRESSION_NAME;
		    }
		    throw new UnsupportedOperationException(""Unable to classify category of name contained in "" + name.getParentNode().get().getClass().getSimpleName() + "". See "" + name + "" at "" + name.getRange());
		}"	$indentation$ public $whitespace$ static $whitespace$ namecategory $whitespace$ syntacticclassificationaccordingtocontext ( node $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( name . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ name . getparentnode ( ) . get ( ) ; $newline$ $indentation$ if $whitespace$ ( isaname ( parent ) $whitespace$ && $whitespace$ nameasstring ( name ) . equals ( nameasstring ( parent ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ syntacticclassificationaccordingtocontext ( parent ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyatypename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyanexpressionname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyamethodname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . method_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyapackageortypename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . package_or_type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyaambiguousname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . ambiguous_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyamodulename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . module_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyapackagename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . package_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ classorinterfacetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ name . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ classorinterfacetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name . getparentnode ( ) . ispresent ( ) $whitespace$ && $whitespace$ name . getparentnode ( ) . get ( ) $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ name . getparentnode ( ) . get ( ) . getclass ( ) . getsimplename ( ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name . getrange ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ namecategory $whitespace$ syntacticclassificationaccordingtocontext ( node $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( name. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ syntacticclassificationaccordingtocontext ( name ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyatypename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory. type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyanexpressionname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory. expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyamethodname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory. package_or_type_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( issyntacticallyaambiguousname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory. ambiguous_name ; $newline$ $indentation$ }			
reclassificationOfContextuallyAmbiguousQualifiedAmbiguousName	388	455	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.0623214021325111	LOW	"		private static NameCategory reclassificationOfContextuallyAmbiguousQualifiedAmbiguousName(Node nameNode, TypeSolver typeSolver){
		    // If the AmbiguousName is a qualified name, consisting of a name, a ""."", and an Identifier, then the name to
		    // the left of the ""."" is first reclassified, for it is itself an AmbiguousName. There is then a choice:
		    Node leftName = NameLogic.getQualifier(nameNode);
		    String rightName = NameLogic.nameAsString(NameLogic.getRightMostName(nameNode));
		    NameCategory leftNameCategory = classifyReference(leftName, typeSolver);
		    // * If the name to the left of the ""."" is reclassified as a PackageName, then:
		    //
		    //      * If the Identifier is a valid TypeIdentifier, and there is a package whose name is the name to the left
		    //        of the ""."", and that package contains a declaration of a type whose name is the same as the Identifier,
		    //        then this AmbiguousName is reclassified as a TypeName.
		    //
		    //      * Otherwise, this AmbiguousName is reclassified as a PackageName. A later step determines whether or not
		    //        a package of that name actually exists.
		    if (leftNameCategory == NameCategory.PACKAGE_NAME) {
		        if (typeSolver.hasType(nameAsString(nameNode))) {
		            return NameCategory.TYPE_NAME;
		        }
		        return NameCategory.PACKAGE_NAME;
		    }
		    // * If the name to the left of the ""."" is reclassified as a TypeName, then:
		    //
		    //      * If the Identifier is the name of a method or field of the type denoted by TypeName, then this
		    //        AmbiguousName is reclassified as an ExpressionName.
		    //
		    //      * Otherwise, if the Identifier is a valid TypeIdentifier and is the name of a member type of the type
		    //        denoted by TypeName, then this AmbiguousName is reclassified as a TypeName.
		    //
		    //      * Otherwise, a compile-time error occurs.
		    if (leftNameCategory == NameCategory.TYPE_NAME) {
		        SymbolReference<ResolvedTypeDeclaration> scopeTypeRef = JavaParserFactory.getContext(leftName, typeSolver).solveType(NameLogic.nameAsString(leftName));
		        if (scopeTypeRef.isSolved()) {
		            ResolvedTypeDeclaration scopeType = scopeTypeRef.getCorrespondingDeclaration();
		            if (scopeType instanceof ResolvedReferenceTypeDeclaration) {
		                ResolvedReferenceTypeDeclaration scopeRefType = scopeType.asReferenceType();
		                if (scopeRefType.getAllMethods().stream().anyMatch(m -> m.getName().equals(rightName))) {
		                    return NameCategory.EXPRESSION_NAME;
		                }
		                if (scopeRefType.getAllFields().stream().anyMatch(f -> f.isStatic() && f.getName().equals(rightName))) {
		                    return NameCategory.EXPRESSION_NAME;
		                }
		                if (scopeRefType.hasInternalType(rightName)) {
		                    return NameCategory.TYPE_NAME;
		                }
		                return NameCategory.COMPILATION_ERROR;
		            }
		            throw new UnsupportedOperationException(""The name is a type but it has been resolved to something that is not a reference type"");
		        }
		        throw new UnsolvedSymbolException(""Unable to solve context type: "" + NameLogic.nameAsString(leftName));
		    }
		    // * If the name to the left of the ""."" is reclassified as an ExpressionName, then this AmbiguousName is
		    //   reclassified as an ExpressionName. A later step determines whether or not a member with the name Identifier
		    //   actually exists.
		    if (leftNameCategory == NameCategory.EXPRESSION_NAME) {
		        return NameCategory.EXPRESSION_NAME;
		    }
		    throw new UnsupportedOperationException(""I do not know how to handle this semantic reclassification of ambiguous name categories"");
		}"	"$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguousqualifiedambiguousname ( node $whitespace$ namenode , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $//·if·the·ambiguousname·is·a·qualified·name,·consisting·of·a·name,·a·""."",·and·an·identifier,·then·the·name·to$ $newline$ $indentation$ $//·the·left·of·the·"".""·is·first·reclassified,·for·it·is·itself·an·ambiguousname.·there·is·then·a·choice:$ $newline$ $indentation$ node $whitespace$ leftname $whitespace$ = $whitespace$ namelogic . getqualifier ( namenode ) ; $newline$ $indentation$ string $whitespace$ rightname $whitespace$ = $whitespace$ namelogic . nameasstring ( namelogic . getrightmostname ( namenode ) ) ; $newline$ $indentation$ namecategory $whitespace$ leftnamecategory $whitespace$ = $whitespace$ classifyreference ( leftname , $whitespace$ typesolver ) ; $newline$ $indentation$ $//·*·if·the·name·to·the·left·of·the·"".""·is·reclassified·as·a·packagename,·then:$ $newline$ $indentation$ // $newline$ $indentation$ $//······*·if·the·identifier·is·a·valid·typeidentifier,·and·there·is·a·package·whose·name·is·the·name·to·the·left$ $newline$ $indentation$ $//········of·the·""."",·and·that·package·contains·a·declaration·of·a·type·whose·name·is·the·same·as·the·identifier,$ $newline$ $indentation$ $//········then·this·ambiguousname·is·reclassified·as·a·typename.$ $newline$ $indentation$ // $newline$ $indentation$ $//······*·otherwise,·this·ambiguousname·is·reclassified·as·a·packagename.·a·later·step·determines·whether·or·not$ $newline$ $indentation$ $//········a·package·of·that·name·actually·exists.$ $newline$ $indentation$ if $whitespace$ ( leftnamecategory $whitespace$ == $whitespace$ namecategory . package_name ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( typesolver . hastype ( nameasstring ( namenode ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ namecategory . package_name ; $newline$ $indentation$ } $newline$ $indentation$ $//·*·if·the·name·to·the·left·of·the·"".""·is·reclassified·as·a·typename,·then:$ $newline$ $indentation$ // $newline$ $indentation$ $//······*·if·the·identifier·is·the·name·of·a·method·or·field·of·the·type·denoted·by·typename,·then·this$ $newline$ $indentation$ $//········ambiguousname·is·reclassified·as·an·expressionname.$ $newline$ $indentation$ // $newline$ $indentation$ $//······*·otherwise,·if·the·identifier·is·a·valid·typeidentifier·and·is·the·name·of·a·member·type·of·the·type$ $newline$ $indentation$ $//········denoted·by·typename,·then·this·ambiguousname·is·reclassified·as·a·typename.$ $newline$ $indentation$ // $newline$ $indentation$ $//······*·otherwise,·a·compile-time·error·occurs.$ $newline$ $indentation$ if $whitespace$ ( leftnamecategory $whitespace$ == $whitespace$ namecategory . type_name ) $whitespace$ { $newline$ $indentation$ symbolreference < resolvedtypedeclaration > $whitespace$ scopetyperef $whitespace$ = $whitespace$ javaparserfactory . getcontext ( leftname , $whitespace$ typesolver ) . solvetype ( namelogic . nameasstring ( leftname ) ) ; $newline$ $indentation$ if $whitespace$ ( scopetyperef . issolved ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtypedeclaration $whitespace$ scopetype $whitespace$ = $whitespace$ scopetyperef . getcorrespondingdeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( scopetype $whitespace$ instanceof $whitespace$ resolvedreferencetypedeclaration ) $whitespace$ { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ scopereftype $whitespace$ = $whitespace$ scopetype . asreferencetype ( ) ; $newline$ $indentation$ if $whitespace$ ( scopereftype . getallmethods ( ) . stream ( ) . anymatch ( m $whitespace$ - > $whitespace$ m . getname ( ) . equals ( rightname ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scopereftype . getallfields ( ) . stream ( ) . anymatch ( f $whitespace$ - > $whitespace$ f . isstatic ( ) $whitespace$ && $whitespace$ f . getname ( ) . equals ( rightname ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( scopereftype . hasinternaltype ( rightname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ namecategory . compilation_error ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsolvedsymbolexception ( $string$ $whitespace$ + $whitespace$ namelogic . nameasstring ( leftname ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·*·if·the·name·to·the·left·of·the·"".""·is·reclassified·as·an·expressionname,·then·this·ambiguousname·is$ $newline$ $indentation$ $//···reclassified·as·an·expressionname.·a·later·step·determines·whether·or·not·a·member·with·the·name·identifier$ $newline$ $indentation$ $//···actually·exists.$ $newline$ $indentation$ if $whitespace$ ( leftnamecategory $whitespace$ == $whitespace$ namecategory . expression_name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . expression_name ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguousqualifiedambiguousname ( node $whitespace$ namenode, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $////space$if $whitespace$ = $whitespace$ would would $whitespace$ like $whitespace$ to $whitespace$ be $whitespace$ namenode $newline$ $indentation$ // $whitespace$ you $whitespace$ would $whitespace$ like $whitespace$ to $whitespace$ test $whitespace$ neutral $whitespace$ score $newline$ $indentation$ $whitespace$// $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$			
isSyntacticallyAPackageOrTypeName	584	597	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.0877925604581832	LOW	"		private static boolean isSyntacticallyAPackageOrTypeName(Node name){
		    // A name is syntactically classified as a PackageOrTypeName in these contexts:
		    //
		    // 1. To the left of the ""."" in a qualified TypeName
		    if (whenParentIs(ClassOrInterfaceType.class, name, (p, c) -> p.getScope().isPresent() && p.getScope().get() == c && (isSyntacticallyATypeName(p) || isSyntacticallyAPackageOrTypeName(p)))) {
		        return true;
		    }
		    // 2. In a type-import-on-demand declaration (§7.5.2)
		    return whenParentIs(ImportDeclaration.class, name, (p, c) -> !p.isStatic() && p.isAsterisk() && p.getName() == name);
		}"	"$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyapackageortypename ( node $whitespace$ name ) { $newline$ $indentation$ $//·a·name·is·syntactically·classified·as·a·packageortypename·in·these·contexts:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·to·the·left·of·the·"".""·in·a·qualified·typename$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacetype . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getscope ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getscope ( ) . get ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ ( issyntacticallyatypename ( p ) $whitespace$ || $whitespace$ issyntacticallyapackageortypename ( p ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·in·a·type-import-on-demand·declaration·(§7.5.2)$ $newline$ $indentation$ return $whitespace$ whenparentis ( importdeclaration . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ ! p . isstatic ( ) $whitespace$ && $whitespace$ p . isasterisk ( ) $whitespace$ && $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyapackageortypename ( node $whitespace$ name ) { $newline$ $indentation$ $////任$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$////l. graphtypename $whitespace$ = $whitespace$ types. of ( getparameter ( $number$ ) ) ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$////l. graphtypename $whitespace$ = $whitespace$ linestyle. of ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( whenparentis ( classorinterfacetype. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getscope ( ). ispresent ( ) $whitespace$ && $whitespace$ p. getscope ( ). get ( ) $whitespace$ == $whitespace$ c $whitespace$ && $whitespace$ ( issyntacticallyatypename ( p ) $whitespace$ || $whitespace$ issyntacticallyapackageortypename ( p ) ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ return $whitespace$ true ; $newline$ $indentation$ }			
nameAsString	959	984	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.1639351993799209	LOW	"		public static String nameAsString(Node name){
		    if (!isAName(name)) {
		        throw new IllegalArgumentException(""A name was expected"");
		    }
		    if (name instanceof Name) {
		        return ((Name) name).asString();
		    }
		    if (name instanceof SimpleName) {
		        return ((SimpleName) name).getIdentifier();
		    }
		    if (name instanceof ClassOrInterfaceType) {
		        return ((ClassOrInterfaceType) name).asString();
		    }
		    if (name instanceof FieldAccessExpr) {
		        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) name;
		        if (isAName(fieldAccessExpr.getScope())) {
		            return nameAsString(fieldAccessExpr.getScope()) + ""."" + nameAsString(fieldAccessExpr.getName());
		        }
		        throw new IllegalArgumentException();
		    }
		    if (name instanceof NameExpr) {
		        return ((NameExpr) name).getNameAsString();
		    }
		    throw new UnsupportedOperationException(""Unknown type of name found: "" + name + "" ("" + name.getClass().getCanonicalName() + "")"");
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ nameasstring ( node $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( ! isaname ( name ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( name ) $whitespace$ name ) . asstring ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ simplename ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( simplename ) $whitespace$ name ) . getidentifier ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ classorinterfacetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( classorinterfacetype ) $whitespace$ name ) . asstring ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ name ; $newline$ $indentation$ if $whitespace$ ( isaname ( fieldaccessexpr . getscope ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nameasstring ( fieldaccessexpr . getscope ( ) ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ nameasstring ( fieldaccessexpr . getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ nameexpr ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( nameexpr ) $whitespace$ name ) . getnameasstring ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ name $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ name . getclass ( ) . getcanonicalname ( ) $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ nameasstring ( node $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ (! isaname ( name ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( name ) $whitespace$ name ). asstring ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ simplename ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( simplename ) $whitespace$ name ). getidentifier ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ classorinterfacetype ) $whitespace$ { $newline$ $indentation$ return $whitespace$ ( ( classorinterfacetype ) $whitespace$ name ). asstring ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( name $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ name ; $newline$ $indentation$ if $whitespace$ ( isaname ( fieldaccessexpr. getscope ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ nameasstring ( fieldaccessexpr. getscope ( ) ) $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ nameasstring ( fieldaccessexpr. getname ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ;			
reclassificationOfContextuallyAmbiguousNames	336	351	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.2101184725761413	LOW	"		private static NameCategory reclassificationOfContextuallyAmbiguousNames(Node name, NameCategory ambiguousCategory, TypeSolver typeSolver){
		    if (!ambiguousCategory.isNeedingDisambiguation()) {
		        throw new IllegalArgumentException(""The Name Category is not ambiguous: "" + ambiguousCategory);
		    }
		    if (ambiguousCategory == NameCategory.AMBIGUOUS_NAME && isSimpleName(name)) {
		        return reclassificationOfContextuallyAmbiguousSimpleAmbiguousName(name, typeSolver);
		    }
		    if (ambiguousCategory == NameCategory.AMBIGUOUS_NAME && isQualifiedName(name)) {
		        return reclassificationOfContextuallyAmbiguousQualifiedAmbiguousName(name, typeSolver);
		    }
		    if (ambiguousCategory == NameCategory.PACKAGE_OR_TYPE_NAME) {
		        return reclassificationOfContextuallyAmbiguousPackageOrTypeName(name, typeSolver);
		    }
		    throw new UnsupportedOperationException(""I do not know how to handle this semantic reclassification of ambiguous name categories"");
		}"	$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguousnames ( node $whitespace$ name , $whitespace$ namecategory $whitespace$ ambiguouscategory , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( ! ambiguouscategory . isneedingdisambiguation ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ ambiguouscategory ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ambiguouscategory $whitespace$ == $whitespace$ namecategory . ambiguous_name $whitespace$ && $whitespace$ issimplename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguoussimpleambiguousname ( name , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ambiguouscategory $whitespace$ == $whitespace$ namecategory . ambiguous_name $whitespace$ && $whitespace$ isqualifiedname ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguousqualifiedambiguousname ( name , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ambiguouscategory $whitespace$ == $whitespace$ namecategory . package_or_type_name ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguouspackageortypename ( name , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguousnames ( node $whitespace$ name, $whitespace$ namecategory $whitespace$ ambiguouscategory, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ (! ambiguouscategory. isneedingdisambiguation ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguoussimpleambiguousname ( name, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ambiguouscategory $whitespace$ == $whitespace$ namecategory. ambiguous_name $whitespace$ && $whitespace$ issimplename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguoussimpleambiguousname ( name, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ reclassificationofcontextuallyambiguouspackageortypename ( name, $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$			
isSyntacticallyAPackageName	625	639	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.2132977545261383	LOW	"		private static boolean isSyntacticallyAPackageName(Node name){
		    // A name is syntactically classified as a PackageName in these contexts:
		    //
		    // 1. To the right of exports or opens in a module declaration
		    if (whenParentIs(ModuleExportsDirective.class, name, (p, c) -> p.getName() == name)) {
		        return true;
		    }
		    if (whenParentIs(ModuleOpensDirective.class, name, (p, c) -> p.getName() == name)) {
		        return true;
		    }
		    // 2. To the left of the ""."" in a qualified PackageName
		    return whenParentIs(Name.class, name, (p, c) -> p.getQualifier().isPresent() && p.getQualifier().get() == name && isSyntacticallyAPackageName(p));
		}"	"$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyapackagename ( node $whitespace$ name ) { $newline$ $indentation$ $//·a·name·is·syntactically·classified·as·a·packagename·in·these·contexts:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·to·the·right·of·exports·or·opens·in·a·module·declaration$ $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleexportsdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( whenparentis ( moduleopensdirective . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·to·the·left·of·the·"".""·in·a·qualified·packagename$ $newline$ $indentation$ return $whitespace$ whenparentis ( name . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getqualifier ( ) . ispresent ( ) $whitespace$ && $whitespace$ p . getqualifier ( ) . get ( ) $whitespace$ == $whitespace$ name $whitespace$ && $whitespace$ issyntacticallyapackagename ( p ) ) ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyapackagename ( node $whitespace$ name ) { $newline$ $indentation$ $//ization$apathpathpathpathpath ( ) ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ = $whitespace$ authorizeparentis ( moduleexportsdirective. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! whenparentis ( moduleexportsdirective. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getname ( ) $whitespace$ == $whitespace$ name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ if $whitespace$ ( whenparentis ( moduleopensdirective. class, $whitespace$ name, $whitespace$ ( p, $whitespace$ c ) $whitespace$ - > $whitespace$ p. getqualifier ( ). ispresent ( ) $whitespace$ && $whitespace$ p. getqualifier ( ). get ( ) $whitespace$ == $whitespace$ name $whitespace$ && $whitespace$ issyntacticallyapackagename ( p )			
whenParentIs	994	1003	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.2740673422813415	LOW	"		private static boolean whenParentIs(Class<P> parentClass, C child, PredicateOnParentAndChild<P, C> predicate){
		    if (child.getParentNode().isPresent()) {
		        Node parent = child.getParentNode().get();
		        return parentClass.isInstance(parent) && predicate.isSatisfied(parentClass.cast(parent), child);
		    }
		    return false;
		}"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ whenparentis ( class < p > $whitespace$ parentclass , $whitespace$ c $whitespace$ child , $whitespace$ predicateonparentandchild < p , $whitespace$ c > $whitespace$ predicate ) { $newline$ $indentation$ if $whitespace$ ( child . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ child . getparentnode ( ) . get ( ) ; $newline$ $indentation$ return $whitespace$ parentclass . isinstance ( parent ) $whitespace$ && $whitespace$ predicate . issatisfied ( parentclass . cast ( parent ) , $whitespace$ child ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ whenparentis ( class < p > $whitespace$ parentclass, $whitespace$ c $whitespace$ child, $whitespace$ predicateonparentandchild < p, $whitespace$ c > $whitespace$ predicate ) { $newline$ $indentation$ node $whitespace$ parent $whitespace$ = $whitespace$ child. getparentnode ( ) ; $newline$ $indentation$ if $whitespace$ ( child. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentclass. isinstance ( parent ) $whitespace$ && $whitespace$ predicate. issatisfied ( parentclass. cast ( parent ), $whitespace$ child ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
reclassificationOfContextuallyAmbiguousPackageOrTypeName	353	386	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.6240552663803101	MID	"		private static NameCategory reclassificationOfContextuallyAmbiguousPackageOrTypeName(Node name, TypeSolver typeSolver){
		    // 6.5.4.1. Simple PackageOrTypeNames
		    //
		    // If the PackageOrTypeName, Q, is a valid TypeIdentifier and occurs in the scope of a type named Q, then the
		    // PackageOrTypeName is reclassified as a TypeName.
		    //
		    // Otherwise, the PackageOrTypeName is reclassified as a PackageName. The meaning of the PackageOrTypeName is
		    // the meaning of the reclassified name.
		    if (isSimpleName(name)) {
		        if (JavaParserFactory.getContext(name, typeSolver).solveType(nameAsString(name)).isSolved()) {
		            return NameCategory.TYPE_NAME;
		        }
		        return NameCategory.PACKAGE_NAME;
		    }
		    // 6.5.4.2. Qualified PackageOrTypeNames
		    //
		    // Given a qualified PackageOrTypeName of the form Q.Id, if Id is a valid TypeIdentifier and the type or package
		    // denoted by Q has a member type named Id, then the qualified PackageOrTypeName name is reclassified as a
		    // TypeName.
		    //
		    // Otherwise, it is reclassified as a PackageName. The meaning of the qualified PackageOrTypeName is the meaning
		    // of the reclassified name.
		    if (isQualifiedName(name)) {
		        if (JavaParserFactory.getContext(name, typeSolver).solveType(nameAsString(name)).isSolved()) {
		            return NameCategory.TYPE_NAME;
		        }
		        return NameCategory.PACKAGE_NAME;
		    }
		    throw new UnsupportedOperationException(""This is unexpected: the name is neither simple or qualified"");
		}"	$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguouspackageortypename ( node $whitespace$ name , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $//·6.5.4.1.·simple·packageortypenames$ $newline$ $indentation$ // $newline$ $indentation$ $//·if·the·packageortypename,·q,·is·a·valid·typeidentifier·and·occurs·in·the·scope·of·a·type·named·q,·then·the$ $newline$ $indentation$ $//·packageortypename·is·reclassified·as·a·typename.$ $newline$ $indentation$ // $newline$ $indentation$ $//·otherwise,·the·packageortypename·is·reclassified·as·a·packagename.·the·meaning·of·the·packageortypename·is$ $newline$ $indentation$ $//·the·meaning·of·the·reclassified·name.$ $newline$ $indentation$ if $whitespace$ ( issimplename ( name ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( javaparserfactory . getcontext ( name , $whitespace$ typesolver ) . solvetype ( nameasstring ( name ) ) . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ namecategory . package_name ; $newline$ $indentation$ } $newline$ $indentation$ $//·6.5.4.2.·qualified·packageortypenames$ $newline$ $indentation$ // $newline$ $indentation$ $//·given·a·qualified·packageortypename·of·the·form·q.id,·if·id·is·a·valid·typeidentifier·and·the·type·or·package$ $newline$ $indentation$ $//·denoted·by·q·has·a·member·type·named·id,·then·the·qualified·packageortypename·name·is·reclassified·as·a$ $newline$ $indentation$ $//·typename.$ $newline$ $indentation$ // $newline$ $indentation$ $//·otherwise,·it·is·reclassified·as·a·packagename.·the·meaning·of·the·qualified·packageortypename·is·the·meaning$ $newline$ $indentation$ $//·of·the·reclassified·name.$ $newline$ $indentation$ if $whitespace$ ( isqualifiedname ( name ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( javaparserfactory . getcontext ( name , $whitespace$ typesolver ) . solvetype ( nameasstring ( name ) ) . issolved ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ namecategory . type_name ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ namecategory . package_name ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ namecategory $whitespace$ reclassificationofcontextuallyambiguouspackageortypename ( node $whitespace$ name, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $////////////////////////////////////6.5.4.1. $newline$ $indentation$ // $newline$ $indentation$ $////// $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ certsbytes $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ if $whitespace$ ( issimplename ( name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return			
classifyReference	309	331	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.6537021398544312	MID	"		public static NameCategory classifyReference(Node name, TypeSolver typeSolver){
		    if (!name.getParentNode().isPresent()) {
		        throw new IllegalArgumentException(""We cannot understand the category of a name if it has no parent"");
		    }
		    if (classifyRole(name) != NameRole.REFERENCE) {
		        throw new IllegalArgumentException(""This method can be used only to classify names used as references"");
		    }
		    // JLS 6.5
		    // First, context causes a name syntactically to fall into one of seven categories: ModuleName, PackageName,
		    // TypeName, ExpressionName, MethodName, PackageOrTypeName, or AmbiguousName.
		    NameCategory first = syntacticClassificationAccordingToContext(name);
		    // Second, a name that is initially classified by its context as an AmbiguousName or as a PackageOrTypeName is
		    if (first.isNeedingDisambiguation()) {
		        NameCategory second = reclassificationOfContextuallyAmbiguousNames(name, first, typeSolver);
		        assert !second.isNeedingDisambiguation();
		        return second;
		    }
		    return first;
		}"	$indentation$ public $whitespace$ static $whitespace$ namecategory $whitespace$ classifyreference ( node $whitespace$ name , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( ! name . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( classifyrole ( name ) $whitespace$ != $whitespace$ namerole . reference ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·jls·6.5$ $newline$ $indentation$ $//·first,·context·causes·a·name·syntactically·to·fall·into·one·of·seven·categories:·modulename,·packagename,$ $newline$ $indentation$ $//·typename,·expressionname,·methodname,·packageortypename,·or·ambiguousname.$ $newline$ $indentation$ namecategory $whitespace$ first $whitespace$ = $whitespace$ syntacticclassificationaccordingtocontext ( name ) ; $newline$ $indentation$ $//·second,·a·name·that·is·initially·classified·by·its·context·as·an·ambiguousname·or·as·a·packageortypename·is$ $newline$ $indentation$ if $whitespace$ ( first . isneedingdisambiguation ( ) ) $whitespace$ { $newline$ $indentation$ namecategory $whitespace$ second $whitespace$ = $whitespace$ reclassificationofcontextuallyambiguousnames ( name , $whitespace$ first , $whitespace$ typesolver ) ; $newline$ $indentation$ assert $whitespace$ ! second . isneedingdisambiguation ( ) ; $newline$ $indentation$ return $whitespace$ second ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ first ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ namecategory $whitespace$ classifyreference ( node $whitespace$ name, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ (! name. getparentnode ( ). ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( classifyrole ( name ) $whitespace$!= $whitespace$ namerole. reference ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$////////////////////////////////////jlsrollroll $whitespace$6.5ball $newline$ $indentation$ $whitespace$////slationfirst, $whitespace$ method $whitespace$cause $whitespace$ = $whitespace$ajjlsroll ( name ) ; $newline$ $indentation$ $whitespace$//how $whitespace$ = $whitespace$ beyond $whitespace$ the $whitespace$ initial $whitespace$ capacity $whitespace$ of $whitespace$ 1 $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ assert $whitespace$ isequals ( null ) ; $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $whitespace$ $whitespace$ is $whitespace$ used $whitespace$ for $whitespace$ the $whitespace$ project $whitespace$ algorithm $whitespace$ across $whitespace$ all $			
isSyntacticallyAMethodName	599	605	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.691424548625946	MID	"		private static boolean isSyntacticallyAMethodName(Node name){
		    // A name is syntactically classified as a MethodName in this context:
		    //
		    // 1. Before the ""("" in a method invocation expression (§15.12)
		    return whenParentIs(MethodCallExpr.class, name, (p, c) -> p.getName() == c);
		}"	"$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyamethodname ( node $whitespace$ name ) { $newline$ $indentation$ $//·a·name·is·syntactically·classified·as·a·methodname·in·this·context:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·before·the·""(""·in·a·method·invocation·expression·(§15.12)$ $newline$ $indentation$ return $whitespace$ whenparentis ( methodcallexpr . class , $whitespace$ name , $whitespace$ ( p , $whitespace$ c ) $whitespace$ - > $whitespace$ p . getname ( ) $whitespace$ == $whitespace$ c ) ; $newline$ $indentation$ }"	$indentation$ private $whitespace$ static $whitespace$ boolean $whitespace$ issyntacticallyamethodname ( node $whitespace$ name ) { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ = $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace			
getRightMostName	96	102	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.7112152576446533	MID	"		private static Node getRightMostName(Node node){
		    if (node instanceof FieldAccessExpr) {
		        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;
		        return fieldAccessExpr.getName();
		    }
		    throw new UnsupportedOperationException(node.getClass().getCanonicalName());
		}"	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getrightmostname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ fieldaccessexpr . getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( node . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getrightmostname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ fieldaccessexpr. getname ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( node. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ }			
isAName	77	86	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.7152643203735352	MID	"		public static boolean isAName(Node node){
		    if (node instanceof FieldAccessExpr) {
		        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;
		        return isAName(fieldAccessExpr.getScope());
		    }
		    return node instanceof SimpleName || node instanceof Name || node instanceof ClassOrInterfaceType || node instanceof NameExpr;
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isaname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ isaname ( fieldaccessexpr . getscope ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ instanceof $whitespace$ simplename $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ name $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ classorinterfacetype $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ nameexpr ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isaname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ isaname ( fieldaccessexpr. getscope ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ node $whitespace$ instanceof $whitespace$ simplename $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ name $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ classorinterfacetype $whitespace$ || $whitespace$ node $whitespace$ instanceof $whitespace$ nameexpr ; $newline$ $indentation$ }			
getQualifier	88	94	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.7173274159431458	MID	"		private static Node getQualifier(Node node){
		    if (node instanceof FieldAccessExpr) {
		        FieldAccessExpr fieldAccessExpr = (FieldAccessExpr) node;
		        return fieldAccessExpr.getScope();
		    }
		    throw new UnsupportedOperationException(node.getClass().getCanonicalName());
		}"	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getqualifier ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( node $whitespace$ instanceof $whitespace$ fieldaccessexpr ) $whitespace$ { $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ ( fieldaccessexpr ) $whitespace$ node ; $newline$ $indentation$ return $whitespace$ fieldaccessexpr . getscope ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( node . getclass ( ) . getcanonicalname ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getqualifier ( node $whitespace$ node ) { $newline$ $indentation$ get. get ( ). getparent ( ) ; $newline$ $indentation$ fieldaccessexpr $whitespace$ fieldaccessexpr $whitespace$ = $whitespace$ getfieldaccessexpr ( node ) ; $newline$ $indentation$ return $whitespace$ fieldaccessexpr. getscope ( ). getparent ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getfieldaccessexpr ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ list < fieldaccessexpr > $whitespace$ annotations $whitespace$ = $whitespace$ fieldaccessexpr. getscope ( ). getcanonicalname ( ) ; $newline$ $indentation$ return $whitespace$ annotations. getbody ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ node $whitespace$ getfieldaccessexpr ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ list. getbody ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( node. getclass ( ). getcanonicalname ( ) ) ; $newline$ $indentation$ }			
isQualifiedName	64	69	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/naming/NameLogic.java	0.8676165342330933	HIGH	"		public static boolean isQualifiedName(Node node){
		    if (!isAName(node)) {
		        throw new IllegalArgumentException();
		    }
		    return nameAsString(node).contains(""."");
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isqualifiedname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ ( ! isaname ( node ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nameasstring ( node ) . contains ( $string$ ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ isqualifiedname ( node $whitespace$ node ) { $newline$ $indentation$ if $whitespace$ (! isaname ( node ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ nameasstring ( node ). contains ( $string$ ) ; $newline$ $indentation$ }			
resolveType	41	47	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/BooleanConditionalExprHandler.java	0.6188259124755859	MID	"		@Override
		public ResolvedType resolveType(){
		    if (thenExpr.isReferenceType() && elseExpr.isReferenceType()) {
		        return thenExpr.asReferenceType();
		    }
		    return thenExpr.isPrimitive() ? thenExpr : elseExpr;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ resolvetype ( ) { $newline$ $indentation$ if $whitespace$ ( thenexpr . isreferencetype ( ) $whitespace$ && $whitespace$ elseexpr . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr . asreferencetype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ thenexpr . isprimitive ( ) $whitespace$ ? $whitespace$ thenexpr $whitespace$ : $whitespace$ elseexpr ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ resolvetype ( ) { $newline$ $indentation$ if $whitespace$ ( thenexpr. isreferencetype ( ) $whitespace$ && $whitespace$ isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr. asreferencetype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ thenexpr. isprimitive ( ) $whitespace$? $whitespace$ thenexpr $whitespace$ : $whitespace$ elseexpr ; $newline$ $indentation$ }			
getConditionExprHandler	40	52	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/ConditionalExprResolver.java	0.2907730937004089	LOW	"		public static ConditionalExprHandler getConditionExprHandler(ResolvedType thenExpr, ResolvedType elseExpr){
		    // boolean conditional expressions
		    if (!thenExpr.isNull() && !elseExpr.isNull() && thenExpr.isAssignableBy(TYPE_BOOLEAN) && elseExpr.isAssignableBy(TYPE_BOOLEAN)) {
		        return new BooleanConditionalExprHandler(thenExpr, elseExpr);
		        // numeric conditional expressions
		    }
		    if (thenExpr.isNumericType() && elseExpr.isNumericType()) {
		        return new NumericConditionalExprHandler(thenExpr, elseExpr);
		    }
		    // reference conditional expressions
		    return new ReferenceConditionalExprHandler(thenExpr, elseExpr);
		}"	$indentation$ public $whitespace$ static $whitespace$ conditionalexprhandler $whitespace$ getconditionexprhandler ( resolvedtype $whitespace$ thenexpr , $whitespace$ resolvedtype $whitespace$ elseexpr ) { $newline$ $indentation$ $//·boolean·conditional·expressions$ $newline$ $indentation$ if $whitespace$ ( ! thenexpr . isnull ( ) $whitespace$ && $whitespace$ ! elseexpr . isnull ( ) $whitespace$ && $whitespace$ thenexpr . isassignableby ( type_boolean ) $whitespace$ && $whitespace$ elseexpr . isassignableby ( type_boolean ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ booleanconditionalexprhandler ( thenexpr , $whitespace$ elseexpr ) ; $newline$ $indentation$ $//·numeric·conditional·expressions$ $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( thenexpr . isnumerictype ( ) $whitespace$ && $whitespace$ elseexpr . isnumerictype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ numericconditionalexprhandler ( thenexpr , $whitespace$ elseexpr ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·reference·conditional·expressions$ $newline$ $indentation$ return $whitespace$ new $whitespace$ referenceconditionalexprhandler ( thenexpr , $whitespace$ elseexpr ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ conditionalexprhandler $whitespace$ getconditionexprhandler ( resolvedtype $whitespace$ thenexpr, $whitespace$ resolvedtype $whitespace$ elseexpr ) { $newline$ $indentation$ $////asciiasciiascii $boolean $whitespace$ if $whitespace$ if $whitespace$ (! thenexpr. isnull ( ) $whitespace$ && $whitespace$! elseexpr. isnull ( ) $whitespace$ && $whitespace$ thenexpr. isassignableby ( type_boolean ) $whitespace$ && $whitespace$ elseexpr. isassignableby ( type_boolean ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ booleanconditionalexprhandler ( thenexpr, $whitespace$ elseexpr ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( thenexpr. isnumerictype ( ) $whitespace$ && $whitespace$ elseexpr. isnumerictype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ numericconditionalexprhandler ( thenexpr, $whitespace$ elseexpr ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referenceconditionalexprhandler ( thenexpr, $whitespace$ elseexpr ) ; $newline$ $indentation$ }			
isResolvableTo	166	171	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/NumericConditionalExprHandler.java	0.0016422708285972	LOW	"		protected boolean isResolvableTo(ResolvedPrimitiveType toType, ResolvedType resolvedType, boolean verifyBoxedType){
		    return NumericConverter.entrySet().stream().filter(e -> e.getKey() == toType).flatMap(entry -> entry.getValue().stream()).anyMatch(rt -> rt == resolvedType || (verifyBoxedType && resolvedType.isReferenceType() && resolvedType.asReferenceType().toUnboxedType().get() == toType));
		}"	$indentation$ protected $whitespace$ boolean $whitespace$ isresolvableto ( resolvedprimitivetype $whitespace$ totype , $whitespace$ resolvedtype $whitespace$ resolvedtype , $whitespace$ boolean $whitespace$ verifyboxedtype ) { $newline$ $indentation$ return $whitespace$ numericconverter . entryset ( ) . stream ( ) . filter ( e $whitespace$ - > $whitespace$ e . getkey ( ) $whitespace$ == $whitespace$ totype ) . flatmap ( entry $whitespace$ - > $whitespace$ entry . getvalue ( ) . stream ( ) ) . anymatch ( rt $whitespace$ - > $whitespace$ rt $whitespace$ == $whitespace$ resolvedtype $whitespace$ || $whitespace$ ( verifyboxedtype $whitespace$ && $whitespace$ resolvedtype . isreferencetype ( ) $whitespace$ && $whitespace$ resolvedtype . asreferencetype ( ) . tounboxedtype ( ) . get ( ) $whitespace$ == $whitespace$ totype ) ) ; $newline$ $indentation$ }	$indentation$ protected $whitespace$ boolean $whitespace$ isresolvableto ( resolvedprimitivetype $whitespace$ totype, $whitespace$ resolvedtype $whitespace$ resolvedtype, $whitespace$ boolean $whitespace$ verifyboxedtype ) { $newline$ $indentation$ return $whitespace$ numericconverter. entryset ( ). stream ( ). filter ( e $whitespace$ - > $whitespace$ e. getkey ( ) $whitespace$ == $whitespace$ totype ). flatmap ( entry $whitespace$ - > $whitespace$ entry. getvalue ( ). stream ( ) ). anymatch ( rt $whitespace$ - > $whitespace$ rt $whitespace$ == $whitespace$ resolvedtype $whitespace$ || $whitespace$ ( verifyboxedtype $whitespace$ && $whitespace$ resolvedtype. isreferencetype ( ) $whitespace$ && $whitespace$ resolvedtype. asreferencetype ( ). tounboxedtype ( ). get ( ) $whitespace$ == $whitespace$ totype ) ) ; $newline$ $indentation$ }			
resolveType	63	145	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/promotion/NumericConditionalExprHandler.java	0.0441980957984924	LOW	"		@Override
		public ResolvedType resolveType(){
		    String qnameTypeThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive().describe() : thenExpr.asReferenceType().describe();
		    String qnameTypeElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive().describe() : elseExpr.asReferenceType().describe();
		    if (qnameTypeThenExpr.equals(qnameTypeElseExpr)) {
		        return thenExpr;
		    }
		    /*
		         * If one of the second and third operands is of primitive type T, and the type of the other is the result of
		         * applying boxing conversion (§5.1.7) to T, then the type of the conditional expression is T.
		         */
		    if (thenExpr.isPrimitive() && elseExpr.isReferenceType() && elseExpr.asReferenceType().isUnboxableTo((ResolvedPrimitiveType) ResolvedPrimitiveType.byName(qnameTypeThenExpr))) {
		        return thenExpr;
		    }
		    if (elseExpr.isPrimitive() && thenExpr.isReferenceType() && thenExpr.asReferenceType().isUnboxableTo((ResolvedPrimitiveType) ResolvedPrimitiveType.byName(qnameTypeElseExpr))) {
		        return elseExpr;
		    }
		    /*
		         * If one of the operands is of type byte or Byte and the other is of type short or Short, then the type of the
		         * conditional expression is short.
		         */
		    if ((isResolvableTo(ResolvedPrimitiveType.SHORT, thenExpr) && relaxMatch(elseExpr, ResolvedPrimitiveType.BYTE)) || (isResolvableTo(ResolvedPrimitiveType.SHORT, elseExpr) && relaxMatch(thenExpr, ResolvedPrimitiveType.BYTE))) {
		        return ResolvedPrimitiveType.SHORT;
		    }
		    //        if ((in(thenExpr, ResolvedPrimitiveType.SHORT) && in(elseExpr, ResolvedPrimitiveType.BYTE))
		    //                || (in(elseExpr, ResolvedPrimitiveType.SHORT) && in(thenExpr, ResolvedPrimitiveType.BYTE))) {
		    //            return ResolvedPrimitiveType.SHORT;
		    //        }
		    // If one of the operands is of type T where T is byte, short, or char, and the
		    // other operand is a constant expression (§15.28) of type int whose value is
		    // representable in type T, then the type of the conditional expression is T
		    // How can we know if the constant expression of type int is representable in
		    // type T ?
		    if (thenExpr.isPrimitive() && elseExpr.isPrimitive()) {
		        if (((ResolvedPrimitiveType) thenExpr).in(resolvedPrimitiveTypeSubList) && ((ResolvedPrimitiveType) elseExpr).equals(ResolvedPrimitiveType.INT)) {
		            return thenExpr;
		        }
		        if (((ResolvedPrimitiveType) elseExpr).in(resolvedPrimitiveTypeSubList) && ((ResolvedPrimitiveType) thenExpr).equals(ResolvedPrimitiveType.INT)) {
		            return elseExpr;
		        }
		    }
		    // If one of the operands is of type T, where T is Byte, Short, or Character,
		    // and the other operand is a constant expression of type int whose value is
		    // representable in the type U which is the result of applying unboxing
		    // conversion to T, then the type of the conditional expression is U.
		    // How can we know it?
		    if (thenExpr.isReference() && elseExpr.isPrimitive() && thenExpr.asReferenceType().isUnboxable() && thenExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList) && ((ResolvedPrimitiveType) elseExpr).equals(ResolvedPrimitiveType.INT)) {
		        return thenExpr.asReferenceType().toUnboxedType().get();
		    }
		    if (elseExpr.isReference() && thenExpr.isPrimitive() && elseExpr.asReferenceType().isUnboxable() && elseExpr.asReferenceType().toUnboxedType().get().in(resolvedPrimitiveTypeSubList) && ((ResolvedPrimitiveType) thenExpr).equals(ResolvedPrimitiveType.INT)) {
		        return elseExpr.asReferenceType().toUnboxedType().get();
		    }
		    // Otherwise, binary numeric promotion (§5.6.2) is applied to the operand types,
		    // and the type of the conditional expression is the promoted type of the second
		    // and third operands.
		    ResolvedPrimitiveType PrimitiveThenExpr = thenExpr.isPrimitive() ? thenExpr.asPrimitive() : thenExpr.asReferenceType().toUnboxedType().get();
		    ResolvedPrimitiveType PrimitiveElseExpr = elseExpr.isPrimitive() ? elseExpr.asPrimitive() : elseExpr.asReferenceType().toUnboxedType().get();
		    return PrimitiveThenExpr.bnp(PrimitiveElseExpr);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ resolvetype ( ) { $newline$ $indentation$ string $whitespace$ qnametypethenexpr $whitespace$ = $whitespace$ thenexpr . isprimitive ( ) $whitespace$ ? $whitespace$ thenexpr . asprimitive ( ) . describe ( ) $whitespace$ : $whitespace$ thenexpr . asreferencetype ( ) . describe ( ) ; $newline$ $indentation$ string $whitespace$ qnametypeelseexpr $whitespace$ = $whitespace$ elseexpr . isprimitive ( ) $whitespace$ ? $whitespace$ elseexpr . asprimitive ( ) . describe ( ) $whitespace$ : $whitespace$ elseexpr . asreferencetype ( ) . describe ( ) ; $newline$ $indentation$ if $whitespace$ ( qnametypethenexpr . equals ( qnametypeelseexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr ; $newline$ $indentation$ } $newline$ $indentation$ $/*············*·if·one·of·the·second·and·third·operands·is·of·primitive·type·t,·and·the·type·of·the·other·is·the·result·of············*·applying·boxing·conversion·(§5.1.7)·to·t,·then·the·type·of·the·conditional·expression·is·t.············*/$ $newline$ $indentation$ if $whitespace$ ( thenexpr . isprimitive ( ) $whitespace$ && $whitespace$ elseexpr . isreferencetype ( ) $whitespace$ && $whitespace$ elseexpr . asreferencetype ( ) . isunboxableto ( ( resolvedprimitivetype ) $whitespace$ resolvedprimitivetype . byname ( qnametypethenexpr ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( elseexpr . isprimitive ( ) $whitespace$ && $whitespace$ thenexpr . isreferencetype ( ) $whitespace$ && $whitespace$ thenexpr . asreferencetype ( ) . isunboxableto ( ( resolvedprimitivetype ) $whitespace$ resolvedprimitivetype . byname ( qnametypeelseexpr ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ elseexpr ; $newline$ $indentation$ } $newline$ $indentation$ $/*············*·if·one·of·the·operands·is·of·type·byte·or·byte·and·the·other·is·of·type·short·or·short,·then·the·type·of·the············*·conditional·expression·is·short.············*/$ $newline$ $indentation$ if $whitespace$ ( ( isresolvableto ( resolvedprimitivetype . short , $whitespace$ thenexpr ) $whitespace$ && $whitespace$ relaxmatch ( elseexpr , $whitespace$ resolvedprimitivetype . byte ) ) $whitespace$ || $whitespace$ ( isresolvableto ( resolvedprimitivetype . short , $whitespace$ elseexpr ) $whitespace$ && $whitespace$ relaxmatch ( thenexpr , $whitespace$ resolvedprimitivetype . byte ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedprimitivetype . short ; $newline$ $indentation$ } $newline$ $indentation$ $//········if·((in(thenexpr,·resolvedprimitivetype.short)·&&·in(elseexpr,·resolvedprimitivetype.byte))$ $newline$ $indentation$ $//················||·(in(elseexpr,·resolvedprimitivetype.short)·&&·in(thenexpr,·resolvedprimitivetype.byte)))·{$ $newline$ $indentation$ $//············return·resolvedprimitivetype.short;$ $newline$ $indentation$ $//········}$ $newline$ $indentation$ $//·if·one·of·the·operands·is·of·type·t·where·t·is·byte,·short,·or·char,·and·the$ $newline$ $indentation$ $//·other·operand·is·a·constant·expression·(§15.28)·of·type·int·whose·value·is$ $newline$ $indentation$ $//·representable·in·type·t,·then·the·type·of·the·conditional·expression·is·t$ $newline$ $indentation$ $//·how·can·we·know·if·the·constant·expression·of·type·int·is·representable·in$ $newline$ $indentation$ $//·type·t·?$ $newline$ $indentation$ if $whitespace$ ( thenexpr . isprimitive ( ) $whitespace$ && $whitespace$ elseexpr . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ( ( resolvedprimitivetype ) $whitespace$ thenexpr ) . in ( resolvedprimitivetypesublist ) $whitespace$ && $whitespace$ ( ( resolvedprimitivetype ) $whitespace$ elseexpr ) . equals ( resolvedprimitivetype . int ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ( ( resolvedprimitivetype ) $whitespace$ elseexpr ) . in ( resolvedprimitivetypesublist ) $whitespace$ && $whitespace$ ( ( resolvedprimitivetype ) $whitespace$ thenexpr ) . equals ( resolvedprimitivetype . int ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ elseexpr ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·one·of·the·operands·is·of·type·t,·where·t·is·byte,·short,·or·character,$ $newline$ $indentation$ $//·and·the·other·operand·is·a·constant·expression·of·type·int·whose·value·is$ $newline$ $indentation$ $//·representable·in·the·type·u·which·is·the·result·of·applying·unboxing$ $newline$ $indentation$ $//·conversion·to·t,·then·the·type·of·the·conditional·expression·is·u.$ $newline$ $indentation$ $//·how·can·we·know·it?$ $newline$ $indentation$ if $whitespace$ ( thenexpr . isreference ( ) $whitespace$ && $whitespace$ elseexpr . isprimitive ( ) $whitespace$ && $whitespace$ thenexpr . asreferencetype ( ) . isunboxable ( ) $whitespace$ && $whitespace$ thenexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) . in ( resolvedprimitivetypesublist ) $whitespace$ && $whitespace$ ( ( resolvedprimitivetype ) $whitespace$ elseexpr ) . equals ( resolvedprimitivetype . int ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( elseexpr . isreference ( ) $whitespace$ && $whitespace$ thenexpr . isprimitive ( ) $whitespace$ && $whitespace$ elseexpr . asreferencetype ( ) . isunboxable ( ) $whitespace$ && $whitespace$ elseexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) . in ( resolvedprimitivetypesublist ) $whitespace$ && $whitespace$ ( ( resolvedprimitivetype ) $whitespace$ thenexpr ) . equals ( resolvedprimitivetype . int ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ elseexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·binary·numeric·promotion·(§5.6.2)·is·applied·to·the·operand·types,$ $newline$ $indentation$ $//·and·the·type·of·the·conditional·expression·is·the·promoted·type·of·the·second$ $newline$ $indentation$ $//·and·third·operands.$ $newline$ $indentation$ resolvedprimitivetype $whitespace$ primitivethenexpr $whitespace$ = $whitespace$ thenexpr . isprimitive ( ) $whitespace$ ? $whitespace$ thenexpr . asprimitive ( ) $whitespace$ : $whitespace$ thenexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) ; $newline$ $indentation$ resolvedprimitivetype $whitespace$ primitiveelseexpr $whitespace$ = $whitespace$ elseexpr . isprimitive ( ) $whitespace$ ? $whitespace$ elseexpr . asprimitive ( ) $whitespace$ : $whitespace$ elseexpr . asreferencetype ( ) . tounboxedtype ( ) . get ( ) ; $newline$ $indentation$ return $whitespace$ primitivethenexpr . bnp ( primitiveelseexpr ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ resolvedtype $whitespace$ resolvetype ( ) { $newline$ $indentation$ string $whitespace$ qnametypethenexpr $whitespace$ = $whitespace$ thenexpr. isprimitive ( ) $whitespace$? $whitespace$ thenexpr. asprimitive ( ). describe ( ) $whitespace$ : $whitespace$ thenexpr. asreferencetype ( ). describe ( ) ; $newline$ $indentation$ string $whitespace$ qnametypeelseexpr $whitespace$ = $whitespace$ elseexpr. isprimitive ( ) $whitespace$? $whitespace$ elseexpr. asprimitive ( ). describe ( ) $whitespace$ : $whitespace$ elseexpr. asreferencetype ( ). describe ( ) ; $newline$ $indentation$ if $whitespace$ (! qnametypethenexpr. equals ( qnametypeelseexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ thenexpr ; $newline$ $indentation$ } $newline$ $indentation$ $/*/*ation$ = = = = $whitespace$$$$indentation$$$ tmplexpr. isprimitive ( ) $whitespace$ && $whitespace$ elseexpr. isreferencetype ( ) $whitespace$ && $whitespace$ elseexpr. asreferencetype			
performResolution	576	776	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.0001621648843865	LOW	"		public Optional<InstantiationSet> performResolution(List<InferenceVariable> variablesToResolve, TypeSolver typeSolver){
		    if (this.containsFalse()) {
		        return Optional.empty();
		    }
		    List<VariableDependency> dependencies = new LinkedList<>();
		    // Given a bound set that does not contain the bound false, a subset of the inference variables mentioned by
		    // the bound set may be resolved. This means that a satisfactory instantiation may be added to the set for each
		    // inference variable, until all the requested variables have instantiations.
		    //
		    // Dependencies in the bound set may require that the variables be resolved in a particular order, or that
		    // additional variables be resolved. Dependencies are specified as follows:
		    //
		    // - Given a bound of one of the following forms, where T is either an inference variable β or a type that
		    // mentions β:
		    //
		    //   - α = T
		    //
		    //   - α <: T
		    //
		    //   - T = α
		    //
		    //   - T <: α
		    //
		    //   If α appears on the left-hand side of another bound of the form G<..., α, ...> = capture(G<...>), then β
		    //   depends on the resolution of α. Otherwise, α depends on the resolution of β.
		    for (Bound b : bounds) {
		        if (b instanceof CapturesBound) {
		            throw new UnsupportedOperationException();
		        }
		    }
		    // - An inference variable α appearing on the left-hand side of a bound of the form
		    //   G<..., α, ...> = capture(G<...>) depends on the resolution of every other inference variable mentioned in
		    //   this bound (on both sides of the = sign).
		    for (Bound b : bounds) {
		        if (b instanceof CapturesBound) {
		            throw new UnsupportedOperationException();
		        }
		    }
		    // - An inference variable α depends on the resolution of an inference variable β if there exists an inference
		    //   variable γ such that α depends on the resolution of γ and γ depends on the resolution of β.
		    for (int i = 0; i < dependencies.size(); i++) {
		        VariableDependency di = dependencies.get(i);
		        for (int j = i + 1; j < dependencies.size(); j++) {
		            VariableDependency dj = dependencies.get(j);
		            if (di.dependedOn.equals(dj.depending)) {
		                dependencies.add(new VariableDependency(di.getDepending(), dj.getDependedOn()));
		            }
		        }
		    }
		    // - An inference variable α depends on the resolution of itself.
		    for (InferenceVariable v : allInferenceVariables()) {
		        dependencies.add(new VariableDependency(v, v));
		    }
		    // Given a set of inference variables to resolve, let V be the union of this set and all variables upon which
		    // the resolution of at least one variable in this set depends.
		    Set<InferenceVariable> V = new HashSet<>();
		    V.addAll(variablesToResolve);
		    for (VariableDependency dependency : dependencies) {
		        if (variablesToResolve.contains(dependency.depending)) {
		            V.add(dependency.dependedOn);
		        }
		    }
		    // If every variable in V has an instantiation, then resolution succeeds and this procedure terminates.
		    boolean ok = true;
		    for (InferenceVariable v : V) {
		        if (!hasInstantiationFor(v)) {
		            ok = false;
		        }
		    }
		    if (ok) {
		        InstantiationSet instantiationSet = InstantiationSet.empty();
		        for (InferenceVariable v : V) {
		            instantiationSet = instantiationSet.withInstantiation(getInstantiationFor(v));
		        }
		        return Optional.of(instantiationSet);
		    }
		    // Otherwise, let { α1, ..., αn } be a non-empty subset of uninstantiated variables in V such that i)
		    // for all i (1 ≤ i ≤ n), if αi depends on the resolution of a variable β, then either β has an instantiation
		    // or there is some j such that β = αj; and ii) there exists no non-empty proper subset of { α1, ..., αn }
		    // with this property.
		    Set<InferenceVariable> uninstantiatedPortionOfV = new HashSet<>();
		    for (InferenceVariable v : V) {
		        if (!hasInstantiationFor(v)) {
		            uninstantiatedPortionOfV.add(v);
		        }
		    }
		    for (Set<InferenceVariable> alphas : allSetsWithProperty(uninstantiatedPortionOfV, dependencies)) {
		        // Resolution proceeds by generating an instantiation for each of α1, ..., αn based on the
		        // bounds in the bound set:
		        boolean hasSomeCaptureForAlphas = alphas.stream().anyMatch(alphaI -> appearInLeftPartOfCapture(alphaI));
		        // - If the bound set does not contain a bound of the form G<..., αi, ...> = capture(G<...>)
		        //   for all i (1 ≤ i ≤ n), then a candidate instantiation Ti is defined for each αi:
		        if (!hasSomeCaptureForAlphas) {
		            BoundSet newBounds = BoundSet.empty();
		            for (InferenceVariable alphaI : alphas) {
		                Set<ResolvedType> properLowerBounds = bounds.stream().filter(b -> b.isProperLowerBoundFor(alphaI).isPresent()).map(b -> b.isProperLowerBoundFor(alphaI).get().getProperType()).collect(Collectors.toSet());
		                ResolvedType Ti = null;
		                //   - If αi has one or more proper lower bounds, L1, ..., Lk, then Ti = lub(L1, ..., Lk) (§4.10.4).
		                if (properLowerBounds.size() > 0) {
		                    Ti = leastUpperBound(properLowerBounds);
		                }
		                //   - Otherwise, if the bound set contains throws αi, and the proper upper bounds of αi are, at most,
		                //     Exception, Throwable, and Object, then Ti = RuntimeException.
		                boolean throwsBound = bounds.stream().anyMatch(b -> b.isThrowsBoundOn(alphaI));
		                if (Ti == null && throwsBound && properUpperBoundsAreAtMostExceptionThrowableAndObject(alphaI)) {
		                    Ti = new ReferenceTypeImpl(typeSolver.solveType(JAVA_LANG_RUNTIME_EXCEPTION));
		                }
		                //   - Otherwise, where αi has proper upper bounds U1, ..., Uk, Ti = glb(U1, ..., Uk) (§5.1.10).
		                if (Ti == null) {
		                    Set<ResolvedType> properUpperBounds = bounds.stream().filter(b -> b.isProperUpperBoundFor(alphaI).isPresent()).map(b -> b.isProperUpperBoundFor(alphaI).get().getProperType()).collect(Collectors.toSet());
		                    if (properUpperBounds.size() == 0) {
		                        throw new IllegalStateException();
		                    }
		                    Ti = glb(properUpperBounds);
		                }
		                newBounds = newBounds.withBound(new SameAsBound(alphaI, Ti));
		            }
		            //   The bounds α1 = T1, ..., αn = Tn are incorporated with the current bound set.
		            BoundSet incorporatedBoundSet = this.incorporate(newBounds, typeSolver);
		            //   If the result does not contain the bound false, then the result becomes the new bound set, and resolution
		            //   proceeds by selecting a new set of variables to instantiate (if necessary), as described above.
		            if (!incorporatedBoundSet.containsFalse()) {
		                return incorporatedBoundSet.performResolution(variablesToResolve, typeSolver);
		            }
		            //   Otherwise, the result contains the bound false, so a second attempt is made to instantiate { α1, ..., αn }
		            //   by performing the step below.
		            throw new UnsupportedOperationException();
		        } else // - If the bound set contains a bound of the form G<..., αi, ...> = capture(G<...>) for some i (1 ≤ i ≤ n), or;
		        {
		            //   If the bound set produced in the step above contains the bound false;
		            //
		            //   then let Y1, ..., Yn be fresh type variables whose bounds are as follows:
		            //
		            //   - For all i (1 ≤ i ≤ n), if αi has one or more proper lower bounds L1, ..., Lk, then let the lower bound
		            //     of Yi be lub(L1, ..., Lk); if not, then Yi has no lower bound.
		            //
		            //   - For all i (1 ≤ i ≤ n), where αi has upper bounds U1, ..., Uk, let the upper bound of Yi be
		            //     glb(U1 θ, ..., Uk θ), where θ is the substitution [α1:=Y1, ..., αn:=Yn].
		            //
		            //   If the type variables Y1, ..., Yn do not have well-formed bounds (that is, a lower bound is not a subtype
		            //   of an upper bound, or an intersection type is inconsistent), then resolution fails.
		            //
		            //   Otherwise, for all i (1 ≤ i ≤ n), all bounds of the form G<..., αi, ...> = capture(G<...>) are removed
		            //   from the current bound set, and the bounds α1 = Y1, ..., αn = Yn are incorporated.
		            //
		            //   If the result does not contain the bound false, then the result becomes the new bound set, and resolution
		            //   proceeds by selecting a new set of variables to instantiate (if necessary), as described above.
		            //
		            //   Otherwise, the result contains the bound false, and resolution fails.
		            throw new UnsupportedOperationException();
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ public $whitespace$ optional < instantiationset > $whitespace$ performresolution ( list < inferencevariable > $whitespace$ variablestoresolve , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( this . containsfalse ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < variabledependency > $whitespace$ dependencies $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $//·given·a·bound·set·that·does·not·contain·the·bound·false,·a·subset·of·the·inference·variables·mentioned·by$ $newline$ $indentation$ $//·the·bound·set·may·be·resolved.·this·means·that·a·satisfactory·instantiation·may·be·added·to·the·set·for·each$ $newline$ $indentation$ $//·inference·variable,·until·all·the·requested·variables·have·instantiations.$ $newline$ $indentation$ // $newline$ $indentation$ $//·dependencies·in·the·bound·set·may·require·that·the·variables·be·resolved·in·a·particular·order,·or·that$ $newline$ $indentation$ $//·additional·variables·be·resolved.·dependencies·are·specified·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·given·a·bound·of·one·of·the·following·forms,·where·t·is·either·an·inference·variable·β·or·a·type·that$ $newline$ $indentation$ $//·mentions·β:$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·α·=·t$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·α·<:·t$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·t·=·α$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·t·<:·α$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·α·appears·on·the·left-hand·side·of·another·bound·of·the·form·g<...,·α,·...>·=·capture(g<...>),·then·β$ $newline$ $indentation$ $//···depends·on·the·resolution·of·α.·otherwise,·α·depends·on·the·resolution·of·β.$ $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ capturesbound ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·-·an·inference·variable·α·appearing·on·the·left-hand·side·of·a·bound·of·the·form$ $newline$ $indentation$ $//···g<...,·α,·...>·=·capture(g<...>)·depends·on·the·resolution·of·every·other·inference·variable·mentioned·in$ $newline$ $indentation$ $//···this·bound·(on·both·sides·of·the·=·sign).$ $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ capturesbound ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·-·an·inference·variable·α·depends·on·the·resolution·of·an·inference·variable·β·if·there·exists·an·inference$ $newline$ $indentation$ $//···variable·γ·such·that·α·depends·on·the·resolution·of·γ·and·γ·depends·on·the·resolution·of·β.$ $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ dependencies . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ variabledependency $whitespace$ di $whitespace$ = $whitespace$ dependencies . get ( i ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ i $whitespace$ + $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ dependencies . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ variabledependency $whitespace$ dj $whitespace$ = $whitespace$ dependencies . get ( j ) ; $newline$ $indentation$ if $whitespace$ ( di . dependedon . equals ( dj . depending ) ) $whitespace$ { $newline$ $indentation$ dependencies . add ( new $whitespace$ variabledependency ( di . getdepending ( ) , $whitespace$ dj . getdependedon ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·-·an·inference·variable·α·depends·on·the·resolution·of·itself.$ $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ v $whitespace$ : $whitespace$ allinferencevariables ( ) ) $whitespace$ { $newline$ $indentation$ dependencies . add ( new $whitespace$ variabledependency ( v , $whitespace$ v ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·given·a·set·of·inference·variables·to·resolve,·let·v·be·the·union·of·this·set·and·all·variables·upon·which$ $newline$ $indentation$ $//·the·resolution·of·at·least·one·variable·in·this·set·depends.$ $newline$ $indentation$ set < inferencevariable > $whitespace$ v $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ v . addall ( variablestoresolve ) ; $newline$ $indentation$ for $whitespace$ ( variabledependency $whitespace$ dependency $whitespace$ : $whitespace$ dependencies ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( variablestoresolve . contains ( dependency . depending ) ) $whitespace$ { $newline$ $indentation$ v . add ( dependency . dependedon ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·if·every·variable·in·v·has·an·instantiation,·then·resolution·succeeds·and·this·procedure·terminates.$ $newline$ $indentation$ boolean $whitespace$ ok $whitespace$ = $whitespace$ true ; $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ v $whitespace$ : $whitespace$ v ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! hasinstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ ok $whitespace$ = $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ok ) $whitespace$ { $newline$ $indentation$ instantiationset $whitespace$ instantiationset $whitespace$ = $whitespace$ instantiationset . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ v $whitespace$ : $whitespace$ v ) $whitespace$ { $newline$ $indentation$ instantiationset $whitespace$ = $whitespace$ instantiationset . withinstantiation ( getinstantiationfor ( v ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( instantiationset ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·let·{·α1,·...,·αn·}·be·a·non-empty·subset·of·uninstantiated·variables·in·v·such·that·i)$ $newline$ $indentation$ $//·for·all·i·(1·≤·i·≤·n),·if·αi·depends·on·the·resolution·of·a·variable·β,·then·either·β·has·an·instantiation$ $newline$ $indentation$ $//·or·there·is·some·j·such·that·β·=·αj;·and·ii)·there·exists·no·non-empty·proper·subset·of·{·α1,·...,·αn·}$ $newline$ $indentation$ $//·with·this·property.$ $newline$ $indentation$ set < inferencevariable > $whitespace$ uninstantiatedportionofv $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ v $whitespace$ : $whitespace$ v ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! hasinstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ uninstantiatedportionofv . add ( v ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ alphas $whitespace$ : $whitespace$ allsetswithproperty ( uninstantiatedportionofv , $whitespace$ dependencies ) ) $whitespace$ { $newline$ $indentation$ $//·resolution·proceeds·by·generating·an·instantiation·for·each·of·α1,·...,·αn·based·on·the$ $newline$ $indentation$ $//·bounds·in·the·bound·set:$ $newline$ $indentation$ boolean $whitespace$ hassomecaptureforalphas $whitespace$ = $whitespace$ alphas . stream ( ) . anymatch ( alphai $whitespace$ - > $whitespace$ appearinleftpartofcapture ( alphai ) ) ; $newline$ $indentation$ $//·-·if·the·bound·set·does·not·contain·a·bound·of·the·form·g<...,·αi,·...>·=·capture(g<...>)$ $newline$ $indentation$ $//···for·all·i·(1·≤·i·≤·n),·then·a·candidate·instantiation·ti·is·defined·for·each·αi:$ $newline$ $indentation$ if $whitespace$ ( ! hassomecaptureforalphas ) $whitespace$ { $newline$ $indentation$ boundset $whitespace$ newbounds $whitespace$ = $whitespace$ boundset . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ alphai $whitespace$ : $whitespace$ alphas ) $whitespace$ { $newline$ $indentation$ set < resolvedtype > $whitespace$ properlowerbounds $whitespace$ = $whitespace$ bounds . stream ( ) . filter ( b $whitespace$ - > $whitespace$ b . isproperlowerboundfor ( alphai ) . ispresent ( ) ) . map ( b $whitespace$ - > $whitespace$ b . isproperlowerboundfor ( alphai ) . get ( ) . getpropertype ( ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ resolvedtype $whitespace$ ti $whitespace$ = $whitespace$ null ; $newline$ $indentation$ $//···-·if·αi·has·one·or·more·proper·lower·bounds,·l1,·...,·lk,·then·ti·=·lub(l1,·...,·lk)·(§4.10.4).$ $newline$ $indentation$ if $whitespace$ ( properlowerbounds . size ( ) $whitespace$ > $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ ti $whitespace$ = $whitespace$ leastupperbound ( properlowerbounds ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···-·otherwise,·if·the·bound·set·contains·throws·αi,·and·the·proper·upper·bounds·of·αi·are,·at·most,$ $newline$ $indentation$ $//·····exception,·throwable,·and·object,·then·ti·=·runtimeexception.$ $newline$ $indentation$ boolean $whitespace$ throwsbound $whitespace$ = $whitespace$ bounds . stream ( ) . anymatch ( b $whitespace$ - > $whitespace$ b . isthrowsboundon ( alphai ) ) ; $newline$ $indentation$ if $whitespace$ ( ti $whitespace$ == $whitespace$ null $whitespace$ && $whitespace$ throwsbound $whitespace$ && $whitespace$ properupperboundsareatmostexceptionthrowableandobject ( alphai ) ) $whitespace$ { $newline$ $indentation$ ti $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . solvetype ( java_lang_runtime_exception ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···-·otherwise,·where·αi·has·proper·upper·bounds·u1,·...,·uk,·ti·=·glb(u1,·...,·uk)·(§5.1.10).$ $newline$ $indentation$ if $whitespace$ ( ti $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ set < resolvedtype > $whitespace$ properupperbounds $whitespace$ = $whitespace$ bounds . stream ( ) . filter ( b $whitespace$ - > $whitespace$ b . isproperupperboundfor ( alphai ) . ispresent ( ) ) . map ( b $whitespace$ - > $whitespace$ b . isproperupperboundfor ( alphai ) . get ( ) . getpropertype ( ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ if $whitespace$ ( properupperbounds . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ ti $whitespace$ = $whitespace$ glb ( properupperbounds ) ; $newline$ $indentation$ } $newline$ $indentation$ newbounds $whitespace$ = $whitespace$ newbounds . withbound ( new $whitespace$ sameasbound ( alphai , $whitespace$ ti ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···the·bounds·α1·=·t1,·...,·αn·=·tn·are·incorporated·with·the·current·bound·set.$ $newline$ $indentation$ boundset $whitespace$ incorporatedboundset $whitespace$ = $whitespace$ this . incorporate ( newbounds , $whitespace$ typesolver ) ; $newline$ $indentation$ $//···if·the·result·does·not·contain·the·bound·false,·then·the·result·becomes·the·new·bound·set,·and·resolution$ $newline$ $indentation$ $//···proceeds·by·selecting·a·new·set·of·variables·to·instantiate·(if·necessary),·as·described·above.$ $newline$ $indentation$ if $whitespace$ ( ! incorporatedboundset . containsfalse ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ incorporatedboundset . performresolution ( variablestoresolve , $whitespace$ typesolver ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···otherwise,·the·result·contains·the·bound·false,·so·a·second·attempt·is·made·to·instantiate·{·α1,·...,·αn·}$ $newline$ $indentation$ $//···by·performing·the·step·below.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ $//·-·if·the·bound·set·contains·a·bound·of·the·form·g<...,·αi,·...>·=·capture(g<...>)·for·some·i·(1·≤·i·≤·n),·or;$ $newline$ $indentation$ { $newline$ $indentation$ $//···if·the·bound·set·produced·in·the·step·above·contains·the·bound·false;$ $newline$ $indentation$ // $newline$ $indentation$ $//···then·let·y1,·...,·yn·be·fresh·type·variables·whose·bounds·are·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·for·all·i·(1·≤·i·≤·n),·if·αi·has·one·or·more·proper·lower·bounds·l1,·...,·lk,·then·let·the·lower·bound$ $newline$ $indentation$ $//·····of·yi·be·lub(l1,·...,·lk);·if·not,·then·yi·has·no·lower·bound.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·for·all·i·(1·≤·i·≤·n),·where·αi·has·upper·bounds·u1,·...,·uk,·let·the·upper·bound·of·yi·be$ $newline$ $indentation$ $//·····glb(u1·θ,·...,·uk·θ),·where·θ·is·the·substitution·[α1:=y1,·...,·αn:=yn].$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·the·type·variables·y1,·...,·yn·do·not·have·well-formed·bounds·(that·is,·a·lower·bound·is·not·a·subtype$ $newline$ $indentation$ $//···of·an·upper·bound,·or·an·intersection·type·is·inconsistent),·then·resolution·fails.$ $newline$ $indentation$ // $newline$ $indentation$ $//···otherwise,·for·all·i·(1·≤·i·≤·n),·all·bounds·of·the·form·g<...,·αi,·...>·=·capture(g<...>)·are·removed$ $newline$ $indentation$ $//···from·the·current·bound·set,·and·the·bounds·α1·=·y1,·...,·αn·=·yn·are·incorporated.$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·the·result·does·not·contain·the·bound·false,·then·the·result·becomes·the·new·bound·set,·and·resolution$ $newline$ $indentation$ $//···proceeds·by·selecting·a·new·set·of·variables·to·instantiate·(if·necessary),·as·described·above.$ $newline$ $indentation$ // $newline$ $indentation$ $//···otherwise,·the·result·contains·the·bound·false,·and·resolution·fails.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ optional < instantiationset > $whitespace$ performresolution ( list < inferencevariable > $whitespace$ variablestoresolve, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ if $whitespace$ ( this. containsfalse ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < variabledependency > $whitespace$ dependencies $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $////////////////////////////////////given $newline$ $indentation$ // $whitespace$ the $whitespace$ list $whitespace$ of $whitespace$ dependencies $whitespace$ in $whitespace$ the $whitespace$all $whitespace$ stack $whitespace$ providers $whitespace$ = $whitespace$ null ; $newline$ $indentation$ if $whitespace$ ( this. containsfalse ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ list < variabledependency > $whitespace$ dependencies $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ $////////////////////////////////////given $newline$ $indentation$ // $whitespace$ the $whitespace$ list $whitespace$ of $whitespace$ dependencies $whitespace$ in $whitespace$ minutes $whitespace$ to $whitespace$ the $whitespace$ list $whitespace$ of $whitespace$ dependencies $newline$ $indentation$ // $newline$ $indentation$ $whitespace$// $whitespace$ 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11			
findPairsOfCommonAncestors	185	205	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.0617245212197303	LOW	"		private List<Pair<ResolvedReferenceType, ResolvedReferenceType>> findPairsOfCommonAncestors(ResolvedReferenceType r1, ResolvedReferenceType r2){
		    List<ResolvedReferenceType> set1 = new LinkedList<>();
		    set1.add(r1);
		    set1.addAll(r1.getAllAncestors());
		    List<ResolvedReferenceType> set2 = new LinkedList<>();
		    set2.add(r2);
		    set2.addAll(r2.getAllAncestors());
		    List<Pair<ResolvedReferenceType, ResolvedReferenceType>> pairs = new LinkedList<>();
		    for (ResolvedReferenceType rtFrom1 : set1) {
		        for (ResolvedReferenceType rtFrom2 : set2) {
		            Optional<ResolvedReferenceTypeDeclaration> rtFrom1TypeDeclaration = rtFrom1.getTypeDeclaration();
		            Optional<ResolvedReferenceTypeDeclaration> rtFrom2TypeDeclaration = rtFrom2.getTypeDeclaration();
		            if (rtFrom1TypeDeclaration.isPresent() && rtFrom2TypeDeclaration.isPresent()) {
		                if (rtFrom1TypeDeclaration.get().equals(rtFrom2TypeDeclaration.get())) {
		                    pairs.add(new Pair<>(rtFrom1, rtFrom2));
		                }
		            }
		        }
		    }
		    return pairs;
		}"	$indentation$ private $whitespace$ list < pair < resolvedreferencetype , $whitespace$ resolvedreferencetype >> $whitespace$ findpairsofcommonancestors ( resolvedreferencetype $whitespace$ r1 , $whitespace$ resolvedreferencetype $whitespace$ r2 ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ set1 $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ set1 . add ( r1 ) ; $newline$ $indentation$ set1 . addall ( r1 . getallancestors ( ) ) ; $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ set2 $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ set2 . add ( r2 ) ; $newline$ $indentation$ set2 . addall ( r2 . getallancestors ( ) ) ; $newline$ $indentation$ list < pair < resolvedreferencetype , $whitespace$ resolvedreferencetype >> $whitespace$ pairs $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ rtfrom1 $whitespace$ : $whitespace$ set1 ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ rtfrom2 $whitespace$ : $whitespace$ set2 ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ rtfrom1typedeclaration $whitespace$ = $whitespace$ rtfrom1 . gettypedeclaration ( ) ; $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ rtfrom2typedeclaration $whitespace$ = $whitespace$ rtfrom2 . gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( rtfrom1typedeclaration . ispresent ( ) $whitespace$ && $whitespace$ rtfrom2typedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( rtfrom1typedeclaration . get ( ) . equals ( rtfrom2typedeclaration . get ( ) ) ) $whitespace$ { $newline$ $indentation$ pairs . add ( new $whitespace$ pair < > ( rtfrom1 , $whitespace$ rtfrom2 ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ pairs ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < pair < resolvedreferencetype, $whitespace$ resolvedreferencetype >> $whitespace$ findpairsofcommonancestors ( resolvedreferencetype $whitespace$ r1, $whitespace$ resolvedreferencetype $whitespace$ r2 ) { $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ set1 $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ set1. add ( r1 ) ; $newline$ $indentation$ set1. addall ( r1. getallancestors ( ) ) ; $newline$ $indentation$ list < resolvedreferencetype > $whitespace$ set2 $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ set2. add ( r2 ) ; $newline$ $indentation$ set2. addall ( resolvedreferencetype, $whitespace$ r2. getallancestors ( ) ) ; $newline$ $indentation$ list < pair < resolvedreferencetype, $whitespace$ resolvedreferencetype >> $whitespace$ pairs $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ rtfrom1 $whitespace$ : $whitespace$ set1 ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedreferencetype $whitespace$ rtfrom2 $whitespace$ : $whitespace$ set2 ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ rtfrom1typedeclaration $whitespace$ = $whitespace$ rtfrom1. gettypedeclaration ( ) ; $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ rtfrom2typedeclaration $whitespace$ = $whitespace$ rtfrom2. gettypedeclaration ( ) ; $newline$ $indentation$ if $whitespace$ ( rtfrom1typedeclaration. ispresent ( ) $whitespace$ && $whitespace$ rtfrom2typedeclaration			
hasProperty	557	570	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.0768325999379158	LOW	"		private boolean hasProperty(Set<InferenceVariable> alphas, List<VariableDependency> dependencies){
		    for (InferenceVariable alphaI : alphas) {
		        for (InferenceVariable beta : dependencies.stream().filter(d -> d.depending.equals(alphaI)).filter(d -> !d.isReflexive()).map(d -> d.dependedOn).collect(Collectors.toList())) {
		            if (!hasInstantiationFor(beta) && !thereIsSomeJSuchThatβequalAlphaJ(alphas, beta)) {
		                return false;
		            }
		        }
		    }
		    return true;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ hasproperty ( set < inferencevariable > $whitespace$ alphas , $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ alphai $whitespace$ : $whitespace$ alphas ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ beta $whitespace$ : $whitespace$ dependencies . stream ( ) . filter ( d $whitespace$ - > $whitespace$ d . depending . equals ( alphai ) ) . filter ( d $whitespace$ - > $whitespace$ ! d . isreflexive ( ) ) . map ( d $whitespace$ - > $whitespace$ d . dependedon ) . collect ( collectors . tolist ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! hasinstantiationfor ( beta ) $whitespace$ && $whitespace$ ! thereissomejsuchthat β equalalphaj ( alphas , $whitespace$ beta ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ hasproperty ( set < inferencevariable > $whitespace$ alphas, $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ for $whitespace$ ( inferencevariable $whitespace$ alphai $whitespace$ : $whitespace$ alphas ) $whitespace$ { $newline$ $indentation$ return $whitespace$! matrix. stream ( ). filter ( d $whitespace$ - > $whitespace$ d. depending. equals ( alphai ) ). filter ( d $whitespace$ - > $whitespace$! d. isrr_14 ( ) ). map ( d $whitespace$ - > $whitespace$ d. dependedon ). collect ( collectors. tolist ( ) ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! hasinstantiationfor ( beta ) $whitespace$ && $whitespace$! thereissomejsuchthat  nanos2 equalalphaj ( alphas, $whitespace$ beta ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }			
allSetsWithProperty	805	814	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.1032632812857627	LOW	"		private Set<Set<InferenceVariable>> allSetsWithProperty(Set<InferenceVariable> allElements, List<VariableDependency> dependencies){
		    Set<Set<InferenceVariable>> allPossibleSets = allPossibleSetsWithProperty(allElements, dependencies);
		    Set<Set<InferenceVariable>> selected = new HashSet<>();
		    for (Set<InferenceVariable> aSet : allPossibleSets) {
		        if (!thereAreProperSubsets(aSet, allPossibleSets)) {
		            selected.add(aSet);
		        }
		    }
		    return selected;
		}"	$indentation$ private $whitespace$ set < set < inferencevariable >> $whitespace$ allsetswithproperty ( set < inferencevariable > $whitespace$ allelements , $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ allpossiblesets $whitespace$ = $whitespace$ allpossiblesetswithproperty ( allelements , $whitespace$ dependencies ) ; $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ selected $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ aset $whitespace$ : $whitespace$ allpossiblesets ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! therearepropersubsets ( aset , $whitespace$ allpossiblesets ) ) $whitespace$ { $newline$ $indentation$ selected . add ( aset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ selected ; $newline$ $indentation$ }	$indentation$ private $whitespace$ set < set < inferencevariable >> $whitespace$ allsetswithproperty ( set < inferencevariable > $whitespace$ allelements, $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ allpossiblesets $whitespace$ = $whitespace$ allpossiblesetswithproperty ( allelements, $whitespace$ dependencies ) ; $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ selected $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ aset $whitespace$ : $whitespace$ allpossiblesets ) $whitespace$ { $newline$ $indentation$ if $whitespace$ (! therearepropersubsets ( aset, $whitespace$ allpossiblesets ) ) $whitespace$ { $newline$ $indentation$ selected. add ( aset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ selected ; $newline$ $indentation$ }			
smallestSetWithProperty	540	550	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.1188511177897453	LOW	"		private Optional<Set<InferenceVariable>> smallestSetWithProperty(Set<InferenceVariable> uninstantiatedVariables, List<VariableDependency> dependencies){
		    for (int i = 1; i <= uninstantiatedVariables.size(); i++) {
		        for (Set<InferenceVariable> aSubSet : buildAllSubsetsOfSize(uninstantiatedVariables, i)) {
		            if (hasProperty(aSubSet, dependencies)) {
		                return Optional.of(aSubSet);
		            }
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ private $whitespace$ optional < set < inferencevariable >> $whitespace$ smallestsetwithproperty ( set < inferencevariable > $whitespace$ uninstantiatedvariables , $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ <= $whitespace$ uninstantiatedvariables . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ asubset $whitespace$ : $whitespace$ buildallsubsetsofsize ( uninstantiatedvariables , $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( hasproperty ( asubset , $whitespace$ dependencies ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( asubset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < set < inferencevariable >> $whitespace$ smallestsetwithproperty ( set < inferencevariable > $whitespace$ uninstantiatedvariables, $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ <= $whitespace$ uninstantiatedvariables. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ asubset $whitespace$ : $whitespace$ buildallsubsetsofsize ( uninstantiatedvariables, $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( hasproperty ( asubset, $whitespace$ dependencies ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( asubset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
allPossibleSetsWithProperty	778	788	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.1217537373304367	LOW	"		private Set<Set<InferenceVariable>> allPossibleSetsWithProperty(Set<InferenceVariable> allElements, List<VariableDependency> dependencies){
		    Set<Set<InferenceVariable>> result = new HashSet<>();
		    for (int i = 1; i <= allElements.size(); i++) {
		        for (Set<InferenceVariable> aSubSet : buildAllSubsetsOfSize(allElements, i)) {
		            if (hasProperty(aSubSet, dependencies)) {
		                result.add(aSubSet);
		            }
		        }
		    }
		    return result;
		}"	$indentation$ private $whitespace$ set < set < inferencevariable >> $whitespace$ allpossiblesetswithproperty ( set < inferencevariable > $whitespace$ allelements , $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ <= $whitespace$ allelements . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ asubset $whitespace$ : $whitespace$ buildallsubsetsofsize ( allelements , $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( hasproperty ( asubset , $whitespace$ dependencies ) ) $whitespace$ { $newline$ $indentation$ result . add ( asubset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ private $whitespace$ set < set < inferencevariable >> $whitespace$ allpossiblesetswithproperty ( set < inferencevariable > $whitespace$ allelements, $whitespace$ list < variabledependency > $whitespace$ dependencies ) { $newline$ $indentation$ set < set < inferencevariable >> $whitespace$ result $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ <= $whitespace$ allelements. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( set < inferencevariable > $whitespace$ asubset $whitespace$ : $whitespace$ buildallsubsetsofsize ( allelements, $whitespace$ i ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( hasproperty ( asubset, $whitespace$ dependencies ) ) $whitespace$ { $newline$ $indentation$ result. add ( asubset ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
findPairSameAs	99	117	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.2575388550758362	LOW	"		private Optional<Pair<SameAsBound, SameAsBound>> findPairSameAs(Predicate<Pair<SameAsBound, SameAsBound>> condition){
		    for (int i = 0; i < bounds.size(); i++) {
		        Bound bi = bounds.get(i);
		        if (bi instanceof SameAsBound) {
		            SameAsBound si = (SameAsBound) bi;
		            for (int j = i + 1; j < bounds.size(); j++) {
		                Bound bj = bounds.get(j);
		                if (bj instanceof SameAsBound) {
		                    SameAsBound sj = (SameAsBound) bj;
		                    Pair<SameAsBound, SameAsBound> pair = new Pair<SameAsBound, SameAsBound>(si, sj);
		                    if (condition.test(pair)) {
		                        return Optional.of(pair);
		                    }
		                }
		            }
		        }
		    }
		    return Optional.empty();
		}"	$indentation$ private $whitespace$ optional < pair < sameasbound , $whitespace$ sameasbound >> $whitespace$ findpairsameas ( predicate < pair < sameasbound , $whitespace$ sameasbound >> $whitespace$ condition ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ bounds . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ bound $whitespace$ bi $whitespace$ = $whitespace$ bounds . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( bi $whitespace$ instanceof $whitespace$ sameasbound ) $whitespace$ { $newline$ $indentation$ sameasbound $whitespace$ si $whitespace$ = $whitespace$ ( sameasbound ) $whitespace$ bi ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ i $whitespace$ + $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ bounds . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ bound $whitespace$ bj $whitespace$ = $whitespace$ bounds . get ( j ) ; $newline$ $indentation$ if $whitespace$ ( bj $whitespace$ instanceof $whitespace$ sameasbound ) $whitespace$ { $newline$ $indentation$ sameasbound $whitespace$ sj $whitespace$ = $whitespace$ ( sameasbound ) $whitespace$ bj ; $newline$ $indentation$ pair < sameasbound , $whitespace$ sameasbound > $whitespace$ pair $whitespace$ = $whitespace$ new $whitespace$ pair < sameasbound , $whitespace$ sameasbound > ( si , $whitespace$ sj ) ; $newline$ $indentation$ if $whitespace$ ( condition . test ( pair ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( pair ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < pair < sameasbound, $whitespace$ sameasbound >> $whitespace$ findpairsameas ( predicate < pair < sameasbound, $whitespace$ sameasbound >> $whitespace$ condition ) { $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ bounds. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( bi $whitespace$ instanceof $whitespace$ sameasbound ) $whitespace$ { $newline$ $indentation$ sameasbound $whitespace$ si $whitespace$ = $whitespace$ ( sameasbound ) $whitespace$ bi ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ i $whitespace$ + $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ bounds. size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ bound $whitespace$ bj $whitespace$ = $whitespace$ bounds. get ( j ) ; $newline$ $indentation$ if $whitespace$ ( bj $whitespace$ instanceof $whitespace$ sameasbound ) $whitespace$ { $newline$ $indentation$ sameasbound $whitespace$ sj $whitespace$ = $whitespace$ ( sameasbound ) $whitespace$ bj ; $newline$ $indentation$ pair < sameasbound, $whitespace$ sameasbound > $whitespace$ pair $whitespace$ = $whitespace$ new $whitespace$ pair < sameasbound, $whitespace$ sameasbound > ( si, $whitespace$ sj ) ; $newline$ $indentation$ if $whitespace$ ( condition. test ( pair ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of			
incorporate	212	218	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.6164349913597107	MID	"		public BoundSet incorporate(BoundSet otherBounds, TypeSolver typeSolver){
		    BoundSet newBoundSet = this;
		    for (Bound b : otherBounds.bounds) {
		        newBoundSet = newBoundSet.withBound(b);
		    }
		    return newBoundSet.deriveImpliedBounds(typeSolver);
		}"	$indentation$ public $whitespace$ boundset $whitespace$ incorporate ( boundset $whitespace$ otherbounds , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ boundset $whitespace$ newboundset $whitespace$ = $whitespace$ this ; $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ otherbounds . bounds ) $whitespace$ { $newline$ $indentation$ newboundset $whitespace$ = $whitespace$ newboundset . withbound ( b ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ newboundset . deriveimpliedbounds ( typesolver ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boundset $whitespace$ incorporate ( boundset $whitespace$ otherbounds, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ boundset $whitespace$ newboundset $whitespace$ = $whitespace$ this ; $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ otherbounds. bounds ) $whitespace$ { $newline$ $indentation$ newboundset $whitespace$ = $whitespace$ newboundset. withbound ( b ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ newboundset. deriveimpliedbounds ( typesolver ) ; $newline$ $indentation$ }			
appearInLeftPartOfCapture	820	830	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.6744288206100464	MID	"		private boolean appearInLeftPartOfCapture(InferenceVariable inferenceVariable){
		    for (Bound b : bounds) {
		        if (b instanceof CapturesBound) {
		            CapturesBound capturesBound = (CapturesBound) b;
		            if (capturesBound.getInferenceVariables().contains(inferenceVariable)) {
		                return true;
		            }
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ appearinleftpartofcapture ( inferencevariable $whitespace$ inferencevariable ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ capturesbound ) $whitespace$ { $newline$ $indentation$ capturesbound $whitespace$ capturesbound $whitespace$ = $whitespace$ ( capturesbound ) $whitespace$ b ; $newline$ $indentation$ if $whitespace$ ( capturesbound . getinferencevariables ( ) . contains ( inferencevariable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ appearinleftpartofcapture ( inferencevariable $whitespace$ inferencevariable ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b $whitespace$ instanceof $whitespace$ capturesbound ) $whitespace$ { $newline$ $indentation$ capturesbound $whitespace$ capturesbound $whitespace$ = $whitespace$ ( capturesbound ) $whitespace$ b ; $newline$ $indentation$ if $whitespace$ ( capturesbound. getinferencevariables ( ). contains ( inferencevariable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
getInstantiationFor	492	499	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.7258151173591614	MID	"		private Instantiation getInstantiationFor(InferenceVariable v){
		    for (Bound b : bounds) {
		        if (b.isAnInstantiationFor(v)) {
		            return b.isAnInstantiation().get();
		        }
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ private $whitespace$ instantiation $whitespace$ getinstantiationfor ( inferencevariable $whitespace$ v ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . isaninstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b . isaninstantiation ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ instantiation $whitespace$ getinstantiationfor ( inferencevariable $whitespace$ v ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. isaninstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ b. isaninstantiation ( ). get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
withBound	89	97	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.8544381260871887	HIGH	"		public BoundSet withBound(Bound bound){
		    if (this.bounds.contains(bound)) {
		        return this;
		    }
		    BoundSet boundSet = new BoundSet();
		    boundSet.bounds.addAll(this.bounds);
		    boundSet.bounds.add(bound);
		    return boundSet;
		}"	$indentation$ public $whitespace$ boundset $whitespace$ withbound ( bound $whitespace$ bound ) { $newline$ $indentation$ if $whitespace$ ( this . bounds . contains ( bound ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ boundset $whitespace$ boundset $whitespace$ = $whitespace$ new $whitespace$ boundset ( ) ; $newline$ $indentation$ boundset . bounds . addall ( this . bounds ) ; $newline$ $indentation$ boundset . bounds . add ( bound ) ; $newline$ $indentation$ return $whitespace$ boundset ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boundset $whitespace$ withbound ( bound $whitespace$ bound ) { $newline$ $indentation$ if $whitespace$ ( this. bounds. contains ( bound ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ } $newline$ $indentation$ boundset $whitespace$ boundset $whitespace$ = $whitespace$ new $whitespace$ boundset ( ) ; $newline$ $indentation$ boundset. bounds. addall ( this. bounds ) ; $newline$ $indentation$ boundset. bounds. add ( bound ) ; $newline$ $indentation$ return $whitespace$ boundset ; $newline$ $indentation$ }			
hasInstantiationFor	483	490	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.8719754815101624	HIGH	"		private boolean hasInstantiationFor(InferenceVariable v){
		    for (Bound b : bounds) {
		        if (b.isAnInstantiationFor(v)) {
		            return true;
		        }
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ hasinstantiationfor ( inferencevariable $whitespace$ v ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b . isaninstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ hasinstantiationfor ( inferencevariable $whitespace$ v ) { $newline$ $indentation$ for $whitespace$ ( bound $whitespace$ b $whitespace$ : $whitespace$ bounds ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( b. isaninstantiationfor ( v ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
toString	69	74	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/BoundSet.java	0.9259522557258606	HIGH	"		@Override
		public String toString(){
		    return ""BoundSet{"" + ""bounds="" + bounds + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ bounds $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ bounds $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
withBound	60	65	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormula.java	0.6195499300956726	MID	"		public ReductionResult withBound(Bound bound){
		    ReductionResult newInstance = new ReductionResult();
		    newInstance.boundSet = this.boundSet.withBound(bound);
		    newInstance.constraintFormulas = this.constraintFormulas;
		    return newInstance;
		}"	$indentation$ public $whitespace$ reductionresult $whitespace$ withbound ( bound $whitespace$ bound ) { $newline$ $indentation$ reductionresult $whitespace$ newinstance $whitespace$ = $whitespace$ new $whitespace$ reductionresult ( ) ; $newline$ $indentation$ newinstance . boundset $whitespace$ = $whitespace$ this . boundset . withbound ( bound ) ; $newline$ $indentation$ newinstance . constraintformulas $whitespace$ = $whitespace$ this . constraintformulas ; $newline$ $indentation$ return $whitespace$ newinstance ; $newline$ $indentation$ }	$indentation$ public $whitespace$ reductionresult $whitespace$ withbound ( bound $whitespace$ bound ) { $newline$ $indentation$ reductionresult $whitespace$ newinstance $whitespace$ = $whitespace$ new $whitespace$ reductionresult ( ) ; $newline$ $indentation$ newinstance. boundset $whitespace$ = $whitespace$ this. boundset. withbound ( bound ) ; $newline$ $indentation$ newinstance. constraintformulas $whitespace$ = $whitespace$ this. constraintformulas ; $newline$ $indentation$ return $whitespace$ newinstance ; $newline$ $indentation$ }			
equals	80	89	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ConstraintFormula.java	0.6552314758300781	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ReductionResult that = (ReductionResult) o;
		    if (!boundSet.equals(that.boundSet))
		        return false;
		    return constraintFormulas.equals(that.constraintFormulas);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ reductionresult $whitespace$ that $whitespace$ = $whitespace$ ( reductionresult ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! boundset . equals ( that . boundset ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ constraintformulas . equals ( that . constraintformulas ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! boundset. equals ( that. boundset ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ boundset. equals ( that. boundset ) { $newline$ $indentation$ return $whitespace$! boundset. equals ( that. boundset ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ constraintformulas. equals ( that. constraintformulas ) ; $newline$ $indentation$ }			
parentIs	110	115	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ControlFlowLogic.java	0.6407738327980042	MID	"		private boolean parentIs(Node node, Class<P> parentClass){
		    if (node.getParentNode().isPresent()) {
		        return parentClass.isInstance(node.getParentNode().get());
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ parentis ( node $whitespace$ node , $whitespace$ class < p > $whitespace$ parentclass ) { $newline$ $indentation$ if $whitespace$ ( node . getparentnode ( ) . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentclass . isinstance ( node . getparentnode ( ) . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ parentis ( node $whitespace$ node, $whitespace$ class < p > $whitespace$ parentclass ) { $newline$ $indentation$ return $whitespace$ node. getparentnode ( ). ispresent ( ) $whitespace$ && $whitespace$ parentclass. isinstance ( node. getparentnode ( ). get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ parentis ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ parentclass. isinstance ( node. getparentnode ( ). get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ parentis ( node $whitespace$ node ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
isReachableBecauseOfPosition	193	207	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ControlFlowLogic.java	0.9446379542350768	HIGH	"		private boolean isReachableBecauseOfPosition(Statement statement){
		    // The first statement in a non-empty block that is not a switch block is reachable iff the block is reachable.
		    // Every other statement S in a non-empty block that is not a switch block is reachable iff the statement
		    // preceding S can complete normally.
		    // The contained statement of a Labelled Statement is reachable iff the labeled statement is reachable.
		    // The then-statement of an if-then statement is reachable iff the if-then statement is reachable.
		    // The then-statement of an if-then-else  statement is reachable iff the if-then-else statement is reachable.
		    // The else-statement is reachable iff the if-then-else statement is reachable.
		    throw new UnsupportedOperationException();
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isreachablebecauseofposition ( statement $whitespace$ statement ) { $newline$ $indentation$ $//·the·first·statement·in·a·non-empty·block·that·is·not·a·switch·block·is·reachable·iff·the·block·is·reachable.$ $newline$ $indentation$ $//·every·other·statement·s·in·a·non-empty·block·that·is·not·a·switch·block·is·reachable·iff·the·statement$ $newline$ $indentation$ $//·preceding·s·can·complete·normally.$ $newline$ $indentation$ $//·the·contained·statement·of·a·labelled·statement·is·reachable·iff·the·labeled·statement·is·reachable.$ $newline$ $indentation$ $//·the·then-statement·of·an·if-then·statement·is·reachable·iff·the·if-then·statement·is·reachable.$ $newline$ $indentation$ $//·the·then-statement·of·an·if-then-else··statement·is·reachable·iff·the·if-then-else·statement·is·reachable.$ $newline$ $indentation$ $//·the·else-statement·is·reachable·iff·the·if-then-else·statement·is·reachable.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isreachablebecauseofposition ( statement $whitespace$ statement ) { $newline$ $indentation$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }			
instantiate	44	50	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariable.java	0.1695562154054641	LOW	"		public static List<InferenceVariable> instantiate(List<ResolvedTypeParameterDeclaration> typeParameterDeclarations){
		    List<InferenceVariable> inferenceVariables = new LinkedList<>();
		    for (ResolvedTypeParameterDeclaration tp : typeParameterDeclarations) {
		        inferenceVariables.add(InferenceVariable.unnamed(tp));
		    }
		    return inferenceVariables;
		}"	$indentation$ public $whitespace$ static $whitespace$ list < inferencevariable > $whitespace$ instantiate ( list < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarations ) { $newline$ $indentation$ list < inferencevariable > $whitespace$ inferencevariables $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparameterdeclarations ) $whitespace$ { $newline$ $indentation$ inferencevariables . add ( inferencevariable . unnamed ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ inferencevariables ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ list < inferencevariable > $whitespace$ instantiate ( list < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarations ) { $newline$ $indentation$ list < inferencevariable > $whitespace$ inferencevariables $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ tp $whitespace$ : $whitespace$ typeparameterdeclarations ) $whitespace$ { $newline$ $indentation$ inferencevariables. add ( inferencevariable. unnamed ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ inferencevariables ; $newline$ $indentation$ }			
equals	71	81	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InferenceVariable.java	0.2539356350898742	LOW	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    InferenceVariable that = (InferenceVariable) o;
		    if (!name.equals(that.name))
		        return false;
		    return typeParameterDeclaration != null ? typeParameterDeclaration.equals(that.typeParameterDeclaration) : that.typeParameterDeclaration == null;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ inferencevariable $whitespace$ that $whitespace$ = $whitespace$ ( inferencevariable ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! name . equals ( that . name ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ typeparameterdeclaration $whitespace$ != $whitespace$ null $whitespace$ ? $whitespace$ typeparameterdeclaration . equals ( that . typeparameterdeclaration ) $whitespace$ : $whitespace$ that . typeparameterdeclaration $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ inferencevariable $whitespace$ that $whitespace$ = $whitespace$ ( inferencevariable ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! name. equals ( that. name ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typeparameterdeclaration $whitespace$!= $whitespace$ null $whitespace$? $whitespace$ typeparameterdeclaration. equals ( that. typeparameterdeclaration ) $whitespace$ : $whitespace$ that. typeparameterdeclaration $whitespace$ == $whitespace$ null ; $newline$ $indentation$ }			
equals	47	56	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/Instantiation.java	0.6675122976303101	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    Instantiation that = (Instantiation) o;
		    if (!inferenceVariable.equals(that.inferenceVariable))
		        return false;
		    return properType.equals(that.properType);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ instantiation $whitespace$ that $whitespace$ = $whitespace$ ( instantiation ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! inferencevariable . equals ( that . inferencevariable ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ propertype . equals ( that . propertype ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ instantiation $whitespace$ that $whitespace$ = $whitespace$ ( instantiation ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! inferencevariable. equals ( that. inferencevariable ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ propertype. equals ( that. propertype ) ; $newline$ $indentation$ }			
withInstantiation	50	55	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java	0.6592005491256714	MID	"		public InstantiationSet withInstantiation(Instantiation instantiation){
		    InstantiationSet newInstance = new InstantiationSet();
		    newInstance.instantiations.addAll(this.instantiations);
		    newInstance.instantiations.add(instantiation);
		    return newInstance;
		}"	$indentation$ public $whitespace$ instantiationset $whitespace$ withinstantiation ( instantiation $whitespace$ instantiation ) { $newline$ $indentation$ instantiationset $whitespace$ newinstance $whitespace$ = $whitespace$ new $whitespace$ instantiationset ( ) ; $newline$ $indentation$ newinstance . instantiations . addall ( this . instantiations ) ; $newline$ $indentation$ newinstance . instantiations . add ( instantiation ) ; $newline$ $indentation$ return $whitespace$ newinstance ; $newline$ $indentation$ }	$indentation$ public $whitespace$ instantiationset $whitespace$ withinstantiation ( instantiation $whitespace$ instantiation ) { $newline$ $indentation$ springdata $whitespace$ newinstance $whitespace$ = $whitespace$ createconfigwithclass ( ) ; $newline$ $indentation$ public $whitespace$ void $whitespace$ init ( ) $whitespace$ { $newline$ $indentation$ // $whitespace$ create $whitespace$ a $whitespace$ generic $whitespace$ exception $whitespace$ for $whitespace$ tests $newline$ $indentation$ // $whitespace$ to $whitespace$ add $whitespace$ a $whitespace$ generic $whitespace$ exception $whitespace$ for $whitespace$ tests $newline$ $indentation$ // $whitespace$ to $whitespace$ add $whitespace$ it $whitespace$ is $whitespace$ not $whitespace$ the $whitespace$ generic $whitespace$ exception $whitespace$ for $whitespace$ tests $newline$ $indentation$ newinstance. instantiations. addall ( this. instantiations ) ; $newline$ $indentation$ newinstance. instantiations. add ( instantiation ) ; $newline$ $indentation$ return $whitespace$ newinstance ; $newline$ $indentation$ }			
equals	61	69	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java	0.713248074054718	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    InstantiationSet that = (InstantiationSet) o;
		    return instantiations.equals(that.instantiations);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ instantiationset $whitespace$ that $whitespace$ = $whitespace$ ( instantiationset ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ instantiations . equals ( that . instantiations ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ other. getclass ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isneeded ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this. isneeded ( ) $whitespace$ || $whitespace$ isneeded ( ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isneeded ( ) $whitespace$ { $newline$ $indentation$ return $whitespace$ this. isneeded ( ) $whitespace$ || $whitespace$ isneeded ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
toString	76	81	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/InstantiationSet.java	0.8937819004058838	HIGH	"		@Override
		public String toString(){
		    return ""InstantiationSet{"" + ""instantiations="" + instantiations + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ instantiations $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ instantiations $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
erased	281	286	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.0072167655453085	LOW	"		private List<Set<ResolvedType>> erased(List<Set<ResolvedType>> typeSets){
		    return typeSets.stream().map(set -> set.stream().map(ResolvedType::erasure).collect(Collectors.toCollection(LinkedHashSet::new))).collect(Collectors.toList());
		}"	$indentation$ private $whitespace$ list < set < resolvedtype >> $whitespace$ erased ( list < set < resolvedtype >> $whitespace$ typesets ) { $newline$ $indentation$ return $whitespace$ typesets . stream ( ) . map ( set $whitespace$ - > $whitespace$ set . stream ( ) . map ( resolvedtype : : erasure ) . collect ( collectors . tocollection ( linkedhashset : : new ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < set < resolvedtype >> $whitespace$ erased ( list < set < resolvedtype >> $whitespace$ typesets ) { $newline$ $indentation$ return $whitespace$ typesets. stream ( ). map ( set $whitespace$ - > $whitespace$ set. stream ( ). map ( resolvedtype : : options ). collect ( collectors. tocollection ( linkedhashset : : new ) ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
supertypes	262	266	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.0197582766413688	LOW	"		private List<Set<ResolvedType>> supertypes(Set<ResolvedType> types){
		    return types.stream().map(type -> supertypes(type).stream().collect(Collectors.toCollection(LinkedHashSet::new))).collect(Collectors.toList());
		}"	$indentation$ private $whitespace$ list < set < resolvedtype >> $whitespace$ supertypes ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ return $whitespace$ types . stream ( ) . map ( type $whitespace$ - > $whitespace$ supertypes ( type ) . stream ( ) . collect ( collectors . tocollection ( linkedhashset : : new ) ) ) . collect ( collectors . tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < set < resolvedtype >> $whitespace$ supertypes ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ return $whitespace$ types. stream ( ). map ( type $whitespace$ - > $whitespace$ supertypes ( type ). stream ( ). collect ( collectors. tocollection ( linkedhashset : : new ) ) ). collect ( collectors. tolist ( ) ) ; $newline$ $indentation$ }			
lub	55	226	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.0414646156132221	LOW	"		public ResolvedType lub(Set<ResolvedType> types){
		    if (types.isEmpty()) {
		        throw new IllegalArgumentException();
		    }
		    // The direct supertypes of the null type are all reference types other than the null type itself.
		    // One way to handle this case is to remove the type null from the list of types.
		    // Provides the concret type of Lazy type if needed
		    Set<ResolvedType> resolvedTypes = types.stream().filter(type -> !(type instanceof NullType)).map(type -> concreteType(type)).collect(Collectors.toSet());
		    // reduces the set in the presence of enumeration type because members are
		    // not equal and they do not have an explicit super type.
		    // So we only keep one enumeration for all the members of an enumeration
		    filterEnumType(resolvedTypes);
		    // The least upper bound, or ""lub"", of a set of reference types is a shared supertype that is more specific
		    // than any other shared supertype (that is, no other shared supertype is a subtype of the least upper bound).
		    // This type, lub(U1, ..., Uk), is determined as follows.
		    //
		    // If k = 1, then the lub is the type itself: lub(U) = U.
		    if (resolvedTypes.size() == 1) {
		        return resolvedTypes.stream().findFirst().get();
		    }
		    // can we have primitive types?
		    //
		    // Otherwise:
		    //
		    // For each Ui (1 ≤ i ≤ k):
		    //
		    // Let ST(Ui) be the set of supertypes of Ui.
		    List<Set<ResolvedType>> supertypes = supertypes(resolvedTypes);
		    //
		    // Let EST(Ui), the set of erased supertypes of Ui, be:
		    //
		    // EST(Ui) = { |W| | W in ST(Ui) } where |W| is the erasure of W.
		    //
		    // The reason for computing the set of erased supertypes is to deal with situations where the set of types
		    // includes several distinct parameterizations of a generic type.
		    //
		    // For example, given List<String> and List<Object>, simply intersecting the sets ST(List<String>) = {
		    // List<String>, Collection<String>, Object } and ST(List<Object>) = { List<Object>, Collection<Object>, Object
		    // } would yield a set { Object }, and we would have lost track of the fact that the upper bound can safely be
		    // assumed to be a List.
		    //
		    // In contrast, intersecting EST(List<String>) = { List, Collection, Object } and EST(List<Object>) = { List,
		    // Collection, Object } yields { List, Collection, Object }, which will eventually enable us to produce
		    // List<?>.
		    //
		    List<Set<ResolvedType>> erasedSupertypes = erased(supertypes);
		    // Let EC, the erased candidate set for U1 ... Uk, be the intersection of all the sets EST(Ui) (1 ≤ i ≤ k).
		    //
		    List<ResolvedType> erasedCandidates = intersection(erasedSupertypes);
		    // Let MEC, the minimal erased candidate set for U1 ... Uk, be:
		    //
		    // MEC = { V | V in EC, and for all W ≠ V in EC, it is not the case that W <: V }
		    //
		    // Because we are seeking to infer more precise types, we wish to filter out any candidates that are supertypes
		    // of other candidates.
		    // This is what computing MEC accomplishes.
		    // In our running example, we had EC = { List, Collection, Object }, so MEC = { List }.
		    List<ResolvedType> minimalErasedCandidates = minimalCandidates(erasedCandidates);
		    if (minimalErasedCandidates.isEmpty()) {
		        return null;
		    }
		    // The next step is to recover type arguments for the erased types in MEC.
		    //
		    // For any element G of MEC that is a generic type:
		    //
		    // Let the ""relevant"" parameterizations of G, Relevant(G), be:
		    //
		    // Relevant(G) = { V | 1 ≤ i ≤ k: V in ST(Ui) and V = G<...> }
		    //
		    // In our running example, the only generic element of MEC is List, and Relevant(List) = { List<String>,
		    // List<Object> }.
		    Multimap<ResolvedType, ResolvedType> relevantParameterizations = relevantParameterizations(minimalErasedCandidates, supertypes);
		    // We will now seek to find a type argument for List that contains (§4.5.1) both String and Object.
		    //
		    // This is done by means of the least containing parameterization (lcp) operation defined below.
		    // The first line defines lcp() on a set, such as Relevant(List), as an operation on a list of the elements of
		    // the set.
		    // The next line defines the operation on such lists, as a pairwise reduction on the elements of the list.
		    // The third line is the definition of lcp() on pairs of parameterized types,
		    // which in turn relies on the notion of least containing type argument (lcta).
		    // lcta() is defined for all possible cases.
		    //
		    // Let the ""candidate"" parameterization of G, Candidate(G), be the most specific parameterization of the
		    // generic type G that contains all the relevant parameterizations of G:
		    //
		    // Candidate(G) = lcp(Relevant(G))
		    //
		    // where lcp(), the least containing invocation, is:
		    //
		    // lcp(S) = lcp(e1, ..., en) where ei (1 ≤ i ≤ n) in S
		    //
		    // lcp(e1, ..., en) = lcp(lcp(e1, e2), e3, ..., en)
		    //
		    // lcp(G<X1, ..., Xn>, G<Y1, ..., Yn>) = G<lcta(X1, Y1), ..., lcta(Xn, Yn)>
		    //
		    // lcp(G<X1, ..., Xn>) = G<lcta(X1), ..., lcta(Xn)>
		    //
		    // and where lcta(), the least containing type argument, is: (assuming U and V are types)
		    //
		    // lcta(U, V) = U if U = V, otherwise ? extends lub(U, V)
		    //
		    // lcta(U, ? extends V) = ? extends lub(U, V)
		    //
		    // lcta(U, ? super V) = ? super glb(U, V)
		    //
		    // lcta(? extends U, ? extends V) = ? extends lub(U, V)
		    //
		    // lcta(? extends U, ? super V) = U if U = V, otherwise ?
		    //
		    // lcta(? super U, ? super V) = ? super glb(U, V)
		    //
		    // lcta(U) = ? if U's upper bound is Object, otherwise ? extends lub(U,Object)
		    //
		    // and where glb() is as defined in §5.1.10.
		    //
		    // Let lub(U1 ... Uk) be:
		    //
		    // Best(W1) & ... & Best(Wr)
		    //
		    // where Wi (1 ≤ i ≤ r) are the elements of MEC, the minimal erased candidate set of U1 ... Uk;
		    //
		    // and where, if any of these elements are generic, we use the candidate parameterization (so as to recover
		    // type arguments):
		    //
		    // Best(X) = Candidate(X) if X is generic; X otherwise.
		    //
		    // Strictly speaking, this lub() function only approximates a least upper bound.
		    // Formally, there may exist some other type T such that all of U1 ... Uk are subtypes of T and T is a subtype
		    // of lub(U1, ..., Uk).
		    // However, a compiler for the Java programming language must implement lub() as specified above.
		    //
		    ResolvedType erasedBest = best(minimalErasedCandidates);
		    // It is possible that the lub() function yields an infinite type.
		    // This is permissible, and a compiler for the Java programming language must recognize such situations and
		    // represent them appropriately using cyclic data structures.
		    //
		    // The possibility of an infinite type stems from the recursive calls to lub().
		    // Readers familiar with recursive types should note that an infinite type is not the same as a recursive type.
		    Collection<ResolvedType> erasedTypeParameterizations = relevantParameterizations.get(erasedBest);
		    if (erasedTypeParameterizations != null && !erasedTypeParameterizations.contains(erasedBest)) {
		        Set<ResolvedType> searchedTypes = new HashSet<>(resolvedTypes);
		        // if we already encountered these types in LUB calculation,
		        // we interrupt calculation and use the erasure of the parameterized type instead
		        if (!lubCache.contains(searchedTypes)) {
		            lubCache.add(searchedTypes);
		            return leastContainingParameterization(new ArrayList<>(erasedTypeParameterizations));
		        }
		    }
		    return erasedBest;
		}"	"$indentation$ public $whitespace$ resolvedtype $whitespace$ lub ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·direct·supertypes·of·the·null·type·are·all·reference·types·other·than·the·null·type·itself.$ $newline$ $indentation$ $//·one·way·to·handle·this·case·is·to·remove·the·type·null·from·the·list·of·types.$ $newline$ $indentation$ $//·provides·the·concret·type·of·lazy·type·if·needed$ $newline$ $indentation$ set < resolvedtype > $whitespace$ resolvedtypes $whitespace$ = $whitespace$ types . stream ( ) . filter ( type $whitespace$ - > $whitespace$ ! ( type $whitespace$ instanceof $whitespace$ nulltype ) ) . map ( type $whitespace$ - > $whitespace$ concretetype ( type ) ) . collect ( collectors . toset ( ) ) ; $newline$ $indentation$ $//·reduces·the·set·in·the·presence·of·enumeration·type·because·members·are$ $newline$ $indentation$ $//·not·equal·and·they·do·not·have·an·explicit·super·type.$ $newline$ $indentation$ $//·so·we·only·keep·one·enumeration·for·all·the·members·of·an·enumeration$ $newline$ $indentation$ filterenumtype ( resolvedtypes ) ; $newline$ $indentation$ $//·the·least·upper·bound,·or·""lub"",·of·a·set·of·reference·types·is·a·shared·supertype·that·is·more·specific$ $newline$ $indentation$ $//·than·any·other·shared·supertype·(that·is,·no·other·shared·supertype·is·a·subtype·of·the·least·upper·bound).$ $newline$ $indentation$ $//·this·type,·lub(u1,·...,·uk),·is·determined·as·follows.$ $newline$ $indentation$ // $newline$ $indentation$ $//·if·k·=·1,·then·the·lub·is·the·type·itself:·lub(u)·=·u.$ $newline$ $indentation$ if $whitespace$ ( resolvedtypes . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ resolvedtypes . stream ( ) . findfirst ( ) . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·can·we·have·primitive·types?$ $newline$ $indentation$ // $newline$ $indentation$ $//·otherwise:$ $newline$ $indentation$ // $newline$ $indentation$ $//·for·each·ui·(1·≤·i·≤·k):$ $newline$ $indentation$ // $newline$ $indentation$ $//·let·st(ui)·be·the·set·of·supertypes·of·ui.$ $newline$ $indentation$ list < set < resolvedtype >> $whitespace$ supertypes $whitespace$ = $whitespace$ supertypes ( resolvedtypes ) ; $newline$ $indentation$ // $newline$ $indentation$ $//·let·est(ui),·the·set·of·erased·supertypes·of·ui,·be:$ $newline$ $indentation$ // $newline$ $indentation$ $//·est(ui)·=·{·|w|·|·w·in·st(ui)·}·where·|w|·is·the·erasure·of·w.$ $newline$ $indentation$ // $newline$ $indentation$ $//·the·reason·for·computing·the·set·of·erased·supertypes·is·to·deal·with·situations·where·the·set·of·types$ $newline$ $indentation$ $//·includes·several·distinct·parameterizations·of·a·generic·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//·for·example,·given·list<string>·and·list<object>,·simply·intersecting·the·sets·st(list<string>)·=·{$ $newline$ $indentation$ $//·list<string>,·collection<string>,·object·}·and·st(list<object>)·=·{·list<object>,·collection<object>,·object$ $newline$ $indentation$ $//·}·would·yield·a·set·{·object·},·and·we·would·have·lost·track·of·the·fact·that·the·upper·bound·can·safely·be$ $newline$ $indentation$ $//·assumed·to·be·a·list.$ $newline$ $indentation$ // $newline$ $indentation$ $//·in·contrast,·intersecting·est(list<string>)·=·{·list,·collection,·object·}·and·est(list<object>)·=·{·list,$ $newline$ $indentation$ $//·collection,·object·}·yields·{·list,·collection,·object·},·which·will·eventually·enable·us·to·produce$ $newline$ $indentation$ $//·list<?>.$ $newline$ $indentation$ // $newline$ $indentation$ list < set < resolvedtype >> $whitespace$ erasedsupertypes $whitespace$ = $whitespace$ erased ( supertypes ) ; $newline$ $indentation$ $//·let·ec,·the·erased·candidate·set·for·u1·...·uk,·be·the·intersection·of·all·the·sets·est(ui)·(1·≤·i·≤·k).$ $newline$ $indentation$ // $newline$ $indentation$ list < resolvedtype > $whitespace$ erasedcandidates $whitespace$ = $whitespace$ intersection ( erasedsupertypes ) ; $newline$ $indentation$ $//·let·mec,·the·minimal·erased·candidate·set·for·u1·...·uk,·be:$ $newline$ $indentation$ // $newline$ $indentation$ $//·mec·=·{·v·|·v·in·ec,·and·for·all·w·≠·v·in·ec,·it·is·not·the·case·that·w·<:·v·}$ $newline$ $indentation$ // $newline$ $indentation$ $//·because·we·are·seeking·to·infer·more·precise·types,·we·wish·to·filter·out·any·candidates·that·are·supertypes$ $newline$ $indentation$ $//·of·other·candidates.$ $newline$ $indentation$ $//·this·is·what·computing·mec·accomplishes.$ $newline$ $indentation$ $//·in·our·running·example,·we·had·ec·=·{·list,·collection,·object·},·so·mec·=·{·list·}.$ $newline$ $indentation$ list < resolvedtype > $whitespace$ minimalerasedcandidates $whitespace$ = $whitespace$ minimalcandidates ( erasedcandidates ) ; $newline$ $indentation$ if $whitespace$ ( minimalerasedcandidates . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·next·step·is·to·recover·type·arguments·for·the·erased·types·in·mec.$ $newline$ $indentation$ // $newline$ $indentation$ $//·for·any·element·g·of·mec·that·is·a·generic·type:$ $newline$ $indentation$ // $newline$ $indentation$ $//·let·the·""relevant""·parameterizations·of·g,·relevant(g),·be:$ $newline$ $indentation$ // $newline$ $indentation$ $//·relevant(g)·=·{·v·|·1·≤·i·≤·k:·v·in·st(ui)·and·v·=·g<...>·}$ $newline$ $indentation$ // $newline$ $indentation$ $//·in·our·running·example,·the·only·generic·element·of·mec·is·list,·and·relevant(list)·=·{·list<string>,$ $newline$ $indentation$ $//·list<object>·}.$ $newline$ $indentation$ multimap < resolvedtype , $whitespace$ resolvedtype > $whitespace$ relevantparameterizations $whitespace$ = $whitespace$ relevantparameterizations ( minimalerasedcandidates , $whitespace$ supertypes ) ; $newline$ $indentation$ $//·we·will·now·seek·to·find·a·type·argument·for·list·that·contains·(§4.5.1)·both·string·and·object.$ $newline$ $indentation$ // $newline$ $indentation$ $//·this·is·done·by·means·of·the·least·containing·parameterization·(lcp)·operation·defined·below.$ $newline$ $indentation$ $//·the·first·line·defines·lcp()·on·a·set,·such·as·relevant(list),·as·an·operation·on·a·list·of·the·elements·of$ $newline$ $indentation$ $//·the·set.$ $newline$ $indentation$ $//·the·next·line·defines·the·operation·on·such·lists,·as·a·pairwise·reduction·on·the·elements·of·the·list.$ $newline$ $indentation$ $//·the·third·line·is·the·definition·of·lcp()·on·pairs·of·parameterized·types,$ $newline$ $indentation$ $//·which·in·turn·relies·on·the·notion·of·least·containing·type·argument·(lcta).$ $newline$ $indentation$ $//·lcta()·is·defined·for·all·possible·cases.$ $newline$ $indentation$ // $newline$ $indentation$ $//·let·the·""candidate""·parameterization·of·g,·candidate(g),·be·the·most·specific·parameterization·of·the$ $newline$ $indentation$ $//·generic·type·g·that·contains·all·the·relevant·parameterizations·of·g:$ $newline$ $indentation$ // $newline$ $indentation$ $//·candidate(g)·=·lcp(relevant(g))$ $newline$ $indentation$ // $newline$ $indentation$ $//·where·lcp(),·the·least·containing·invocation,·is:$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcp(s)·=·lcp(e1,·...,·en)·where·ei·(1·≤·i·≤·n)·in·s$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcp(e1,·...,·en)·=·lcp(lcp(e1,·e2),·e3,·...,·en)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcp(g<x1,·...,·xn>,·g<y1,·...,·yn>)·=·g<lcta(x1,·y1),·...,·lcta(xn,·yn)>$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcp(g<x1,·...,·xn>)·=·g<lcta(x1),·...,·lcta(xn)>$ $newline$ $indentation$ // $newline$ $indentation$ $//·and·where·lcta(),·the·least·containing·type·argument,·is:·(assuming·u·and·v·are·types)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(u,·v)·=·u·if·u·=·v,·otherwise·?·extends·lub(u,·v)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(u,·?·extends·v)·=·?·extends·lub(u,·v)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(u,·?·super·v)·=·?·super·glb(u,·v)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(?·extends·u,·?·extends·v)·=·?·extends·lub(u,·v)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(?·extends·u,·?·super·v)·=·u·if·u·=·v,·otherwise·?$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(?·super·u,·?·super·v)·=·?·super·glb(u,·v)$ $newline$ $indentation$ // $newline$ $indentation$ $//·lcta(u)·=·?·if·u's·upper·bound·is·object,·otherwise·?·extends·lub(u,object)$ $newline$ $indentation$ // $newline$ $indentation$ $//·and·where·glb()·is·as·defined·in·§5.1.10.$ $newline$ $indentation$ // $newline$ $indentation$ $//·let·lub(u1·...·uk)·be:$ $newline$ $indentation$ // $newline$ $indentation$ $//·best(w1)·&·...·&·best(wr)$ $newline$ $indentation$ // $newline$ $indentation$ $//·where·wi·(1·≤·i·≤·r)·are·the·elements·of·mec,·the·minimal·erased·candidate·set·of·u1·...·uk;$ $newline$ $indentation$ // $newline$ $indentation$ $//·and·where,·if·any·of·these·elements·are·generic,·we·use·the·candidate·parameterization·(so·as·to·recover$ $newline$ $indentation$ $//·type·arguments):$ $newline$ $indentation$ // $newline$ $indentation$ $//·best(x)·=·candidate(x)·if·x·is·generic;·x·otherwise.$ $newline$ $indentation$ // $newline$ $indentation$ $//·strictly·speaking,·this·lub()·function·only·approximates·a·least·upper·bound.$ $newline$ $indentation$ $//·formally,·there·may·exist·some·other·type·t·such·that·all·of·u1·...·uk·are·subtypes·of·t·and·t·is·a·subtype$ $newline$ $indentation$ $//·of·lub(u1,·...,·uk).$ $newline$ $indentation$ $//·however,·a·compiler·for·the·java·programming·language·must·implement·lub()·as·specified·above.$ $newline$ $indentation$ // $newline$ $indentation$ resolvedtype $whitespace$ erasedbest $whitespace$ = $whitespace$ best ( minimalerasedcandidates ) ; $newline$ $indentation$ $//·it·is·possible·that·the·lub()·function·yields·an·infinite·type.$ $newline$ $indentation$ $//·this·is·permissible,·and·a·compiler·for·the·java·programming·language·must·recognize·such·situations·and$ $newline$ $indentation$ $//·represent·them·appropriately·using·cyclic·data·structures.$ $newline$ $indentation$ // $newline$ $indentation$ $//·the·possibility·of·an·infinite·type·stems·from·the·recursive·calls·to·lub().$ $newline$ $indentation$ $//·readers·familiar·with·recursive·types·should·note·that·an·infinite·type·is·not·the·same·as·a·recursive·type.$ $newline$ $indentation$ collection < resolvedtype > $whitespace$ erasedtypeparameterizations $whitespace$ = $whitespace$ relevantparameterizations . get ( erasedbest ) ; $newline$ $indentation$ if $whitespace$ ( erasedtypeparameterizations $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ! erasedtypeparameterizations . contains ( erasedbest ) ) $whitespace$ { $newline$ $indentation$ set < resolvedtype > $whitespace$ searchedtypes $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( resolvedtypes ) ; $newline$ $indentation$ $//·if·we·already·encountered·these·types·in·lub·calculation,$ $newline$ $indentation$ $//·we·interrupt·calculation·and·use·the·erasure·of·the·parameterized·type·instead$ $newline$ $indentation$ if $whitespace$ ( ! lubcache . contains ( searchedtypes ) ) $whitespace$ { $newline$ $indentation$ lubcache . add ( searchedtypes ) ; $newline$ $indentation$ return $whitespace$ leastcontainingparameterization ( new $whitespace$ arraylist < > ( erasedtypeparameterizations ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ erasedbest ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ resolvedtype $whitespace$ lub ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types. isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////the $newline$ $indentation$ // $whitespace$ empty $whitespace$ resolved $whitespace$ is $whitespace$ null $whitespace$ or $whitespace$ empty $whitespace$ and $whitespace$ that $whitespace$ its $whitespace$ und $whitespace$ in $whitespace$ this $whitespace$ direction $newline$ $indentation$ $whitespace$// $newline$ $indentation$ $whitespace$ val $whitespace$ = $whitespace$ resolvedtype. get ( ) ; $newline$ $indentation$ return $whitespace$ $whitespace$ ; $newline$ $indentation$ } $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ link $whitespace$ the $whitespace$ function $whitespace$ to $whitespace$ the $whitespace$$-null $whitespace$ map $whitespace$ with $whitespace$ other $whitespace$ tree $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace			
relevantParameterizations	321	333	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.0890694633126258	LOW	"		private Multimap<ResolvedType, ResolvedType> relevantParameterizations(List<ResolvedType> minimalErasedCandidates, List<Set<ResolvedType>> supertypes){
		    Multimap<ResolvedType, ResolvedType> result = Multimaps.newSetMultimap(new HashMap<>(), LinkedHashSet::new);
		    for (Set<ResolvedType> supertypesSet : supertypes) {
		        for (ResolvedType supertype : supertypesSet) {
		            ResolvedType erasedSupertype = supertype.erasure();
		            if (minimalErasedCandidates.contains(erasedSupertype)) {
		                result.put(erasedSupertype, supertype);
		            }
		        }
		    }
		    return result;
		}"	$indentation$ private $whitespace$ multimap < resolvedtype , $whitespace$ resolvedtype > $whitespace$ relevantparameterizations ( list < resolvedtype > $whitespace$ minimalerasedcandidates , $whitespace$ list < set < resolvedtype >> $whitespace$ supertypes ) { $newline$ $indentation$ multimap < resolvedtype , $whitespace$ resolvedtype > $whitespace$ result $whitespace$ = $whitespace$ multimaps . newsetmultimap ( new $whitespace$ hashmap < > ( ) , $whitespace$ linkedhashset : : new ) ; $newline$ $indentation$ for $whitespace$ ( set < resolvedtype > $whitespace$ supertypesset $whitespace$ : $whitespace$ supertypes ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ supertype $whitespace$ : $whitespace$ supertypesset ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ erasedsupertype $whitespace$ = $whitespace$ supertype . erasure ( ) ; $newline$ $indentation$ if $whitespace$ ( minimalerasedcandidates . contains ( erasedsupertype ) ) $whitespace$ { $newline$ $indentation$ result . put ( erasedsupertype , $whitespace$ supertype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ private $whitespace$ multimap < resolvedtype, $whitespace$ resolvedtype > $whitespace$ relevantparameterizations ( list < resolvedtype > $whitespace$ minimalerasedcandidates, $whitespace$ list < set < resolvedtype >> $whitespace$ supertypes ) { $newline$ $indentation$ multimap < resolvedtype, $whitespace$ resolvedtype > $whitespace$ result $whitespace$ = $whitespace$ multimaps. newsetmultimap ( new $whitespace$ hashmap < > ( ), $whitespace$ linkedhashset : : new ) ; $newline$ $indentation$ for $whitespace$ ( set < resolvedtype > $whitespace$ supertypesset $whitespace$ : $whitespace$ supertypes ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ supertype $whitespace$ : $whitespace$ supertypesset ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ erasedsupertype $whitespace$ = $whitespace$ supertype.任 ( ) ; $newline$ $indentation$ if $whitespace$ ( minimalerasedcandidates. contains ( erasedsupertype ) ) $whitespace$ { $newline$ $indentation$ result. put ( erasedsupertype, $whitespace$ supertype ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
substitution	460	464	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.2137317508459091	LOW	"		private TypeSubstitution substitution(List<Pair<ResolvedTypeParameterDeclaration, ResolvedType>> pairs){
		    TypeSubstitution substitution = TypeSubstitution.empty();
		    pairs.stream().forEach(pair -> substitution.withPair(pair.a, pair.b));
		    return substitution;
		}"	$indentation$ private $whitespace$ typesubstitution $whitespace$ substitution ( list < pair < resolvedtypeparameterdeclaration , $whitespace$ resolvedtype >> $whitespace$ pairs ) { $newline$ $indentation$ typesubstitution $whitespace$ substitution $whitespace$ = $whitespace$ typesubstitution . empty ( ) ; $newline$ $indentation$ pairs . stream ( ) . foreach ( pair $whitespace$ - > $whitespace$ substitution . withpair ( pair . a , $whitespace$ pair . b ) ) ; $newline$ $indentation$ return $whitespace$ substitution ; $newline$ $indentation$ }	$indentation$ private $whitespace$ typesubstitution $whitespace$ substitution ( list < pair < resolvedtypeparameterdeclaration, $whitespace$ resolvedtype >> $whitespace$ pairs ) { $newline$ $indentation$ typesubstitution $whitespace$ substitution $whitespace$ = $whitespace$ typesubstitution. empty ( ) ; $newline$ $indentation$ pairs. foreach ( pair $whitespace$ - > $whitespace$ substitution. withpair ( pair. a, $whitespace$ pair. b ) ) ; $newline$ $indentation$ return $whitespace$ substitution ; $newline$ $indentation$ }			
minimalCandidates	303	311	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.2249611616134643	LOW	"		private List<ResolvedType> minimalCandidates(List<ResolvedType> erasedCandidates){
		    List<ResolvedType> results = new ArrayList<>();
		    for (ResolvedType v : erasedCandidates) {
		        if (erasedCandidates.stream().noneMatch(w -> !w.equals(v) && v.isAssignableBy(w))) {
		            results.add(v);
		        }
		    }
		    return results;
		}"	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ minimalcandidates ( list < resolvedtype > $whitespace$ erasedcandidates ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ v $whitespace$ : $whitespace$ erasedcandidates ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( erasedcandidates . stream ( ) . nonematch ( w $whitespace$ - > $whitespace$ ! w . equals ( v ) $whitespace$ && $whitespace$ v . isassignableby ( w ) ) ) $whitespace$ { $newline$ $indentation$ results . add ( v ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ minimalcandidates ( list < resolvedtype > $whitespace$ erasedcandidates ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ results $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ v $whitespace$ : $whitespace$ erasedcandidates ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( erasedcandidates. stream ( ). nonematch ( w $whitespace$ - > $whitespace$! w. equals ( v ) $whitespace$ && $whitespace$ v. isassignableby ( w ) ) ) $whitespace$ { $newline$ $indentation$ results. add ( v ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ results ; $newline$ $indentation$ }			
substituteType	413	419	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.2453500777482986	LOW	"		private ResolvedType substituteType(ResolvedType type1, TypeSubstitution typeSubstitution){
		    Builder typeParametersMapBuilder = type1.asReferenceType().typeParametersMap().toBuilder();
		    for (ResolvedTypeParameterDeclaration rtpd : typeSubstitution.typeParameterDeclarations) {
		        typeParametersMapBuilder.setValue(rtpd, typeSubstitution.substitutedType(rtpd));
		    }
		    return type1.asReferenceType().deriveTypeParameters(typeParametersMapBuilder.build());
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ substitutetype ( resolvedtype $whitespace$ type1 , $whitespace$ typesubstitution $whitespace$ typesubstitution ) { $newline$ $indentation$ builder $whitespace$ typeparametersmapbuilder $whitespace$ = $whitespace$ type1 . asreferencetype ( ) . typeparametersmap ( ) . tobuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ rtpd $whitespace$ : $whitespace$ typesubstitution . typeparameterdeclarations ) $whitespace$ { $newline$ $indentation$ typeparametersmapbuilder . setvalue ( rtpd , $whitespace$ typesubstitution . substitutedtype ( rtpd ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type1 . asreferencetype ( ) . derivetypeparameters ( typeparametersmapbuilder . build ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ substitutetype ( resolvedtype $whitespace$ type1, $whitespace$ typesubstitution $whitespace$ typesubstitution ) { $newline$ $indentation$ builder $whitespace$ typeparametersmapbuilder $whitespace$ = $whitespace$ type1. asreferencetype ( ). typeparametersmap ( ). tobuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration $whitespace$ rtpd $whitespace$ : $whitespace$ typesubstitution. typeparameterdeclarations ) $whitespace$ { $newline$ $indentation$ typeparametersmapbuilder. setvalue ( rtpd, $whitespace$ typesubstitution. substitutedtype ( rtpd ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ type1. asreferencetype ( ). derivetypeparameters ( typeparametersmapbuilder. build ( ) ) ; $newline$ $indentation$ }			
lctaBothWildcards	515	531	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.2463257610797882	LOW	"		private ResolvedType lctaBothWildcards(ResolvedWildcard type1, ResolvedWildcard type2){
		    // lcta(? super U, ? super V) = ? super glb(U, V)
		    if (type1.isUpperBounded() && type2.isUpperBounded()) {
		        ResolvedType glb = TypeHelper.glb(toSet(type1.getBoundedType(), type2.getBoundedType()));
		        return bound(glb, BoundType.SUPER);
		    }
		    // lcta(? extends U, ? extends V) = ? extends lub(U, V)
		    if (type1.isLowerBounded() && type2.isLowerBounded()) {
		        ResolvedType lub = lub(toSet(type1.getBoundedType(), type2.getBoundedType()));
		        return bound(lub, BoundType.EXTENDS);
		    }
		    // lcta(? extends U, ? super V) = U if U = V, otherwise ?
		    if (type1.getBoundedType().equals(type2.getBoundedType())) {
		        return type1.getBoundedType();
		    }
		    return ResolvedWildcard.UNBOUNDED;
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ lctabothwildcards ( resolvedwildcard $whitespace$ type1 , $whitespace$ resolvedwildcard $whitespace$ type2 ) { $newline$ $indentation$ $//·lcta(?·super·u,·?·super·v)·=·?·super·glb(u,·v)$ $newline$ $indentation$ if $whitespace$ ( type1 . isupperbounded ( ) $whitespace$ && $whitespace$ type2 . isupperbounded ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ glb $whitespace$ = $whitespace$ typehelper . glb ( toset ( type1 . getboundedtype ( ) , $whitespace$ type2 . getboundedtype ( ) ) ) ; $newline$ $indentation$ return $whitespace$ bound ( glb , $whitespace$ boundtype . super ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·lcta(?·extends·u,·?·extends·v)·=·?·extends·lub(u,·v)$ $newline$ $indentation$ if $whitespace$ ( type1 . islowerbounded ( ) $whitespace$ && $whitespace$ type2 . islowerbounded ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ lub $whitespace$ = $whitespace$ lub ( toset ( type1 . getboundedtype ( ) , $whitespace$ type2 . getboundedtype ( ) ) ) ; $newline$ $indentation$ return $whitespace$ bound ( lub , $whitespace$ boundtype . extends ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·lcta(?·extends·u,·?·super·v)·=·u·if·u·=·v,·otherwise·?$ $newline$ $indentation$ if $whitespace$ ( type1 . getboundedtype ( ) . equals ( type2 . getboundedtype ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ type1 . getboundedtype ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ resolvedwildcard . unbounded ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ lctabothwildcards ( resolvedwildcard $whitespace$ type1, $whitespace$ resolvedwildcard $whitespace$ type2 ) { $newline$ $indentation$ $////lll $whitespace$ = $whitespace$ type1. isupperbounded ( ) $whitespace$ && $whitespace$ type2. isupperbounded ( ) ; $newline$ $indentation$ if $whitespace$ ( type1. islowerbounded ( ) $whitespace$ && $whitespace$ type2. islowerbounded ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ glb $whitespace$ = $whitespace$ typehelper. glb ( toset ( type1. getboundedtype ( ), $whitespace$ type2. getboundedtype ( ) ) ) ; $newline$ $indentation$ return $whitespace$ bound ( glb, $whitespace$ boundtype. super ) ; $newline$ $indentation$ } $newline$ $indentation$ $indentation$ $whitespace$////ll $whitespace$ = $whitespace$ lub ( toset ( type1. getboundedtype ( ), $whitespace$ type2. getboundedtype ( ) ) ) ; $newline$ $indentation$ return $whitespace$ bound ( lub, $whitespace$ boundtype. extends ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ //////////////////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ method $whitespace$ for $whitespace$ current $whitespace$ function $newline$ $indentation$ $whitespace$ = $whitespace$ typehelper. glb ( toset ( type1. getboundedtype ( ), $whitespace$ type2. getboundedtype ( ) ) ) ; $newline$ $indentation$ return $whitespace$ bound ( lub, $whitespace$ boundtype. extends ) ; $newline$ $indentation$ } $newline$ $indentation$			
leastContainingParameterization	363	375	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/LeastUpperBoundLogic.java	0.295306921005249	LOW	"		private ResolvedType leastContainingParameterization(List<ResolvedType> types){
		    if (types.size() == 1) {
		        return types.get(0);
		    }
		    ResolvedType type1 = types.get(0);
		    ResolvedType type2 = types.get(1);
		    ResolvedType reduction = leastContainingTypeArgument(type1, type2);
		    List<ResolvedType> reducedList = Lists.newArrayList(reduction);
		    reducedList.addAll(types.subList(2, types.size()));
		    return leastContainingParameterization(reducedList);
		}"	$indentation$ private $whitespace$ resolvedtype $whitespace$ leastcontainingparameterization ( list < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ types . get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ type1 $whitespace$ = $whitespace$ types . get ( $number$ ) ; $newline$ $indentation$ resolvedtype $whitespace$ type2 $whitespace$ = $whitespace$ types . get ( $number$ ) ; $newline$ $indentation$ resolvedtype $whitespace$ reduction $whitespace$ = $whitespace$ leastcontainingtypeargument ( type1 , $whitespace$ type2 ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ reducedlist $whitespace$ = $whitespace$ lists . newarraylist ( reduction ) ; $newline$ $indentation$ reducedlist . addall ( types . sublist ( $number$ , $whitespace$ types . size ( ) ) ) ; $newline$ $indentation$ return $whitespace$ leastcontainingparameterization ( reducedlist ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ resolvedtype $whitespace$ leastcontainingparameterization ( list < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ types. get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ type1 $whitespace$ = $whitespace$ types. get ( $number$ ) ; $newline$ $indentation$ resolvedtype $whitespace$ type2 $whitespace$ = $whitespace$ types. get ( $number$ ) ; $newline$ $indentation$ resolvedtype $whitespace$ reduction $whitespace$ = $whitespace$ leastcontainingtypeargument ( type1, $whitespace$ type2 ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ reducedlist $whitespace$ = $whitespace$ lists. newarraylist ( reduction ) ; $newline$ $indentation$ reducedlist. addall ( types. sublist ( $number$, $whitespace$ types. size ( ) ) ) ; $newline$ $indentation$ return $whitespace$ leastcontainingparameterization ( reducedlist ) ; $newline$ $indentation$ }			
equals	38	47	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperLowerBound.java	0.6490206122398376	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ProperLowerBound that = (ProperLowerBound) o;
		    if (!inferenceVariable.equals(that.inferenceVariable))
		        return false;
		    return properType.equals(that.properType);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ properlowerbound $whitespace$ that $whitespace$ = $whitespace$ ( properlowerbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! inferencevariable . equals ( that . inferencevariable ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ propertype . equals ( that . propertype ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! this. equals ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! this. equals ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
equals	38	47	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/ProperUpperBound.java	0.6490206122398376	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ProperUpperBound that = (ProperUpperBound) o;
		    if (!inferenceVariable.equals(that.inferenceVariable))
		        return false;
		    return properType.equals(that.properType);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ properupperbound $whitespace$ that $whitespace$ = $whitespace$ ( properupperbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! inferencevariable . equals ( that . inferencevariable ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ propertype . equals ( that . propertype ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! this. equals ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! this. equals ( other ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ propertype. equals ( that. propertype ) ; $newline$ $indentation$ }			
nonWildcardParameterizationOf	240	303	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.0646188780665397	LOW	"		private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver){
		    ResolvedReferenceTypeDeclaration originalTypeDeclaration = originalType.getTypeDeclaration().orElseThrow(() -> new RuntimeException(""TypeDeclaration unexpectedly empty.""));
		    List<ResolvedType> TIs = new LinkedList<>();
		    List<ResolvedType> AIs = originalType.typeParametersValues();
		    List<ResolvedTypeParameterDeclaration> TPs = originalTypeDeclaration.getTypeParameters();
		    // Let P1...Pn be the type parameters of I with corresponding bounds B1...Bn. For all i (1 ≤ i ≤ n),
		    // Ti is derived according to the form of Ai:
		    ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.getSolvedJavaLangObject());
		    for (int i = 0; i < AIs.size(); i++) {
		        ResolvedType Ai = AIs.get(i);
		        ResolvedType Ti = null;
		        // - If Ai is a type, then Ti = Ai.
		        if (!Ai.isWildcard()) {
		            Ti = Ai;
		        }
		        // - If Ai is a wildcard, and the corresponding type parameter's bound, Bi, mentions one of P1...Pn, then
		        //   Ti is undefined and there is no function type.
		        if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalTypeDeclaration.getTypeParameters())) {
		            throw new IllegalArgumentException();
		        }
		        // - Otherwise:
		        if (Ti == null) {
		            ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;
		            //   - If Ai is an unbound wildcard ?, then Ti = Bi.
		            if (Ai.isWildcard() && !Ai.asWildcard().isBounded()) {
		                Ti = Bi;
		            } else //   - If Ai is a upper-bounded wildcard ? extends Ui, then Ti = glb(Ui, Bi) (§5.1.10).
		            if (Ai.isWildcard() && Ai.asWildcard().isUpperBounded()) {
		                ResolvedType Ui = Ai.asWildcard().getBoundedType();
		                Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));
		            } else //   - If Ai is a lower-bounded wildcard ? super Li, then Ti = Li.
		            if (Ai.isWildcard() && Ai.asWildcard().isLowerBounded()) {
		                Ti = Ai.asWildcard().getBoundedType();
		            } else {
		                throw new RuntimeException(""This should not happen"");
		            }
		        }
		        TIs.add(Ti);
		    }
		    return new ReferenceTypeImpl(originalTypeDeclaration, TIs);
		}"	$indentation$ private $whitespace$ static $whitespace$ resolvedreferencetype $whitespace$ nonwildcardparameterizationof ( resolvedreferencetype $whitespace$ originaltype , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ resolvedreferencetypedeclaration $whitespace$ originaltypedeclaration $whitespace$ = $whitespace$ originaltype . gettypedeclaration ( ) . orelsethrow ( ( ) $whitespace$ - > $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ tis $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ ais $whitespace$ = $whitespace$ originaltype . typeparametersvalues ( ) ; $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ tps $whitespace$ = $whitespace$ originaltypedeclaration . gettypeparameters ( ) ; $newline$ $indentation$ $//·let·p1...pn·be·the·type·parameters·of·i·with·corresponding·bounds·b1...bn.·for·all·i·(1·≤·i·≤·n),$ $newline$ $indentation$ $//·ti·is·derived·according·to·the·form·of·ai:$ $newline$ $indentation$ resolvedreferencetype $whitespace$ object $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . getsolvedjavalangobject ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ ais . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ai $whitespace$ = $whitespace$ ais . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ ti $whitespace$ = $whitespace$ null ; $newline$ $indentation$ $//·-·if·ai·is·a·type,·then·ti·=·ai.$ $newline$ $indentation$ if $whitespace$ ( ! ai . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ ti $whitespace$ = $whitespace$ ai ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·if·ai·is·a·wildcard,·and·the·corresponding·type·parameter's·bound,·bi,·mentions·one·of·p1...pn,·then$ $newline$ $indentation$ $//···ti·is·undefined·and·there·is·no·function·type.$ $newline$ $indentation$ if $whitespace$ ( ti $whitespace$ == $whitespace$ null $whitespace$ && $whitespace$ ai . iswildcard ( ) $whitespace$ && $whitespace$ ai . aswildcard ( ) . mention ( originaltypedeclaration . gettypeparameters ( ) ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·otherwise:$ $newline$ $indentation$ if $whitespace$ ( ti $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ bi $whitespace$ = $whitespace$ tps . get ( i ) . haslowerbound ( ) $whitespace$ ? $whitespace$ tps . get ( i ) . getlowerbound ( ) $whitespace$ : $whitespace$ object ; $newline$ $indentation$ $//···-·if·ai·is·an·unbound·wildcard·?,·then·ti·=·bi.$ $newline$ $indentation$ if $whitespace$ ( ai . iswildcard ( ) $whitespace$ && $whitespace$ ! ai . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ ti $whitespace$ = $whitespace$ bi ; $newline$ $indentation$ } $whitespace$ else $whitespace$ $//···-·if·ai·is·a·upper-bounded·wildcard·?·extends·ui,·then·ti·=·glb(ui,·bi)·(§5.1.10).$ $newline$ $indentation$ if $whitespace$ ( ai . iswildcard ( ) $whitespace$ && $whitespace$ ai . aswildcard ( ) . isupperbounded ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ui $whitespace$ = $whitespace$ ai . aswildcard ( ) . getboundedtype ( ) ; $newline$ $indentation$ ti $whitespace$ = $whitespace$ glb ( new $whitespace$ hashset < > ( arrays . aslist ( ui , $whitespace$ bi ) ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ $//···-·if·ai·is·a·lower-bounded·wildcard·?·super·li,·then·ti·=·li.$ $newline$ $indentation$ if $whitespace$ ( ai . iswildcard ( ) $whitespace$ && $whitespace$ ai . aswildcard ( ) . islowerbounded ( ) ) $whitespace$ { $newline$ $indentation$ ti $whitespace$ = $whitespace$ ai . aswildcard ( ) . getboundedtype ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ tis . add ( ti ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ referencetypeimpl ( originaltypedeclaration , $whitespace$ tis ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ resolvedreferencetype $whitespace$ nonwildcardparameterizationof ( resolvedreferencetype $whitespace$ originaltype, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ tis $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ ais $whitespace$ = $whitespace$ originaltype. typeparametersvalues ( ) ; $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ tps $whitespace$ = $whitespace$ originaltypedeclaration. gettypeparameters ( ) ; $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ ais. size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$			
areCompatibleThroughWideningReferenceConversion	172	178	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.0736848190426826	LOW	"		public static boolean areCompatibleThroughWideningReferenceConversion(ResolvedType s, ResolvedType t){
		    Optional<ResolvedPrimitiveType> correspondingPrimitiveTypeForS = Arrays.stream(ResolvedPrimitiveType.values()).filter(pt -> pt.getBoxTypeQName().equals(s.asReferenceType().getQualifiedName())).findFirst();
		    if (!correspondingPrimitiveTypeForS.isPresent()) {
		        return false;
		    }
		    throw new UnsupportedOperationException(""areCompatibleThroughWideningReferenceConversion s="" + s + "", t="" + t);
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ arecompatiblethroughwideningreferenceconversion ( resolvedtype $whitespace$ s , $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ optional < resolvedprimitivetype > $whitespace$ correspondingprimitivetypefors $whitespace$ = $whitespace$ arrays . stream ( resolvedprimitivetype . values ( ) ) . filter ( pt $whitespace$ - > $whitespace$ pt . getboxtypeqname ( ) . equals ( s . asreferencetype ( ) . getqualifiedname ( ) ) ) . findfirst ( ) ; $newline$ $indentation$ if $whitespace$ ( ! correspondingprimitivetypefors . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ arecompatiblethroughwideningreferenceconversion ( resolvedtype $whitespace$ s, $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ optional < resolvedprimitivetype > $whitespace$ correspondingprimitivetypefors $whitespace$ = $whitespace$ arrays. stream ( resolvedprimitivetype. values ( ) ) $newline$ $indentation$. filter ( pt $whitespace$ - > $whitespace$ pt. getboxtypeqname ( ). equals ( s. asreferencetype ( ). getqualifiedname ( ) ) ) $newline$ $indentation$. findfirst ( ) ; $newline$ $indentation$ if $whitespace$ (! correspondingprimitivetypefors. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t ) ; $newline$ $indentation$ }			
isCompatibleInALooseInvocationContext	112	160	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.2516999244689941	LOW	"		public static boolean isCompatibleInALooseInvocationContext(ResolvedType s, ResolvedType t){
		    // Loose invocation contexts allow a more permissive set of conversions, because they are only used for a
		    // particular invocation if no applicable declaration can be found using strict invocation contexts. Loose
		    // invocation contexts allow the use of one of the following:
		    //
		    // - an identity conversion (§5.1.1)
		    if (s.equals(t)) {
		        return true;
		    }
		    // - a widening primitive conversion (§5.1.2)
		    if (s.isPrimitive() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s, t)) {
		        return true;
		    }
		    // - a widening reference conversion (§5.1.5)
		    if (s.isReferenceType() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(s, t)) {
		        return true;
		    }
		    // - a boxing conversion (§5.1.7) optionally followed by widening reference conversion
		    if (s.isPrimitive() && t.isReferenceType() && areCompatibleThroughWideningReferenceConversion(toBoxedType(s.asPrimitive()), t)) {
		        return true;
		    }
		    // - an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion
		    if (s.isReferenceType() && s.asReferenceType().isUnboxable() && t.isPrimitive() && areCompatibleThroughWideningPrimitiveConversion(s.asReferenceType().toUnboxedType().get(), t)) {
		        return true;
		    }
		    // If, after the conversions listed for an invocation context have been applied, the resulting type is a raw
		    // type (§4.8), an unchecked conversion (§5.1.9) may then be applied.
		    //
		    // A value of the null type (the null reference is the only such value) may be assigned to any reference type
		    if (s.isNull() && t.isReferenceType()) {
		        return true;
		    }
		    //throw new UnsupportedOperationException(""isCompatibleInALooseInvocationContext unable to decide on s="" + s + "", t="" + t);
		    // TODO FIXME
		    return t.isAssignableBy(s);
		}"	"$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ iscompatibleinalooseinvocationcontext ( resolvedtype $whitespace$ s , $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ $//·loose·invocation·contexts·allow·a·more·permissive·set·of·conversions,·because·they·are·only·used·for·a$ $newline$ $indentation$ $//·particular·invocation·if·no·applicable·declaration·can·be·found·using·strict·invocation·contexts.·loose$ $newline$ $indentation$ $//·invocation·contexts·allow·the·use·of·one·of·the·following:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·an·identity·conversion·(§5.1.1)$ $newline$ $indentation$ if $whitespace$ ( s . equals ( t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·a·widening·primitive·conversion·(§5.1.2)$ $newline$ $indentation$ if $whitespace$ ( s . isprimitive ( ) $whitespace$ && $whitespace$ t . isprimitive ( ) $whitespace$ && $whitespace$ arecompatiblethroughwideningprimitiveconversion ( s , $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·a·widening·reference·conversion·(§5.1.5)$ $newline$ $indentation$ if $whitespace$ ( s . isreferencetype ( ) $whitespace$ && $whitespace$ t . isreferencetype ( ) $whitespace$ && $whitespace$ arecompatiblethroughwideningreferenceconversion ( s , $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·a·boxing·conversion·(§5.1.7)·optionally·followed·by·widening·reference·conversion$ $newline$ $indentation$ if $whitespace$ ( s . isprimitive ( ) $whitespace$ && $whitespace$ t . isreferencetype ( ) $whitespace$ && $whitespace$ arecompatiblethroughwideningreferenceconversion ( toboxedtype ( s . asprimitive ( ) ) , $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·an·unboxing·conversion·(§5.1.8)·optionally·followed·by·a·widening·primitive·conversion$ $newline$ $indentation$ if $whitespace$ ( s . isreferencetype ( ) $whitespace$ && $whitespace$ s . asreferencetype ( ) . isunboxable ( ) $whitespace$ && $whitespace$ t . isprimitive ( ) $whitespace$ && $whitespace$ arecompatiblethroughwideningprimitiveconversion ( s . asreferencetype ( ) . tounboxedtype ( ) . get ( ) , $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//·if,·after·the·conversions·listed·for·an·invocation·context·have·been·applied,·the·resulting·type·is·a·raw$ $newline$ $indentation$ $//·type·(§4.8),·an·unchecked·conversion·(§5.1.9)·may·then·be·applied.$ $newline$ $indentation$ // $newline$ $indentation$ $//·a·value·of·the·null·type·(the·null·reference·is·the·only·such·value)·may·be·assigned·to·any·reference·type$ $newline$ $indentation$ if $whitespace$ ( s . isnull ( ) $whitespace$ && $whitespace$ t . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $//throw·new·unsupportedoperationexception(""iscompatibleinalooseinvocationcontext·unable·to·decide·on·s=""·+·s·+·"",·t=""·+·t);$ $newline$ $indentation$ $//·todo·fixme$ $newline$ $indentation$ return $whitespace$ t . isassignableby ( s ) ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ iscompatibleinalooseinvocationcontext ( resolvedtype $whitespace$ s, $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ jdtadapter. getname ( s ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ resolvedtype $whitespace$ = $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ s. equals ( t ) $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ if $whitespace$ ( s. isprimitive ( ) $whitespace$ && $whitespace$ t. isprimitive ( ) $whitespace$ && $whitespace$ arecompatiblethroughwideningprimitiveconversion ( s, $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace			
groundTargetTypeOfLambda	215	235	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.2553504705429077	LOW	"		public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver){
		    // The ground target type is derived from T as follows:
		    //
		    boolean used18_5_3 = false;
		    boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream().anyMatch(tp -> tp.isWildcard());
		    if (wildcardParameterized) {
		        // - If T is a wildcard-parameterized functional interface type and the lambda expression is explicitly typed,
		        //   then the ground target type is inferred as described in §18.5.3.
		        if (lambdaExpr.isExplicitlyTyped()) {
		            used18_5_3 = true;
		            throw new UnsupportedOperationException();
		        }
		        return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);
		    }
		    // - Otherwise, the ground target type is T.
		    return new Pair<>(T, used18_5_3);
		}"	$indentation$ public $whitespace$ static $whitespace$ pair < resolvedtype , $whitespace$ boolean > $whitespace$ groundtargettypeoflambda ( lambdaexpr $whitespace$ lambdaexpr , $whitespace$ resolvedtype $whitespace$ t , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $//·the·ground·target·type·is·derived·from·t·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ boolean $whitespace$ used18_5_3 $whitespace$ = $whitespace$ false ; $newline$ $indentation$ boolean $whitespace$ wildcardparameterized $whitespace$ = $whitespace$ t . asreferencetype ( ) . typeparametersvalues ( ) . stream ( ) . anymatch ( tp $whitespace$ - > $whitespace$ tp . iswildcard ( ) ) ; $newline$ $indentation$ if $whitespace$ ( wildcardparameterized ) $whitespace$ { $newline$ $indentation$ $//·-·if·t·is·a·wildcard-parameterized·functional·interface·type·and·the·lambda·expression·is·explicitly·typed,$ $newline$ $indentation$ $//···then·the·ground·target·type·is·inferred·as·described·in·§18.5.3.$ $newline$ $indentation$ if $whitespace$ ( lambdaexpr . isexplicitlytyped ( ) ) $whitespace$ { $newline$ $indentation$ used18_5_3 $whitespace$ = $whitespace$ true ; $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( nonwildcardparameterizationof ( t . asreferencetype ( ) , $whitespace$ typesolver ) , $whitespace$ used18_5_3 ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·otherwise,·the·ground·target·type·is·t.$ $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( t , $whitespace$ used18_5_3 ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ pair < resolvedtype, $whitespace$ boolean > $whitespace$ groundtargettypeoflambda ( lambdaexpr $whitespace$ lambdaexpr, $whitespace$ resolvedtype $whitespace$ t, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ _getcasechar $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ _ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ boolean $whitespace$ used18_5_3 $whitespace$ = $whitespace$ false ; $newline$ $indentation$ boolean $whitespace$ wildcardparameterized $whitespace$ = $whitespace$ t. asreferencetype ( ). typeparametersvalues ( ). stream ( ). anymatch ( tp $whitespace$ - > $whitespace$ tp. iswildcard ( ) ) ; $newline$ $indentation$ boolean $whitespace$ wildcardparameterized $whitespace$ = $whitespace$ t. asreferencetype ( ). typeparametersvalues ( ). stream ( ). anymatch ( tp $whitespace$ - > $whitespace$ tp. iswildcard ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ pair < > ( nonwildcardparameterizationof ( t. asreferencetype ( ), $whitespace$ typesolver			
usedInferenceVariables	187	199	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.2715753614902496	LOW	"		public static Set<InferenceVariable> usedInferenceVariables(ResolvedType type){
		    if (type.isInferenceVariable()) {
		        return new HashSet<>(Arrays.asList((InferenceVariable) type));
		    }
		    if (type.isReferenceType()) {
		        Set<InferenceVariable> res = new HashSet<>();
		        for (ResolvedType tp : type.asReferenceType().typeParametersValues()) {
		            res.addAll(usedInferenceVariables(tp));
		        }
		        return res;
		    }
		    throw new UnsupportedOperationException(type.toString());
		}"	$indentation$ public $whitespace$ static $whitespace$ set < inferencevariable > $whitespace$ usedinferencevariables ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type . isinferencevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ hashset < > ( arrays . aslist ( ( inferencevariable ) $whitespace$ type ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ set < inferencevariable > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ tp $whitespace$ : $whitespace$ type . asreferencetype ( ) . typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ res . addall ( usedinferencevariables ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type . tostring ( ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ set < inferencevariable > $whitespace$ usedinferencevariables ( resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( type. isinferencevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ hashset < > ( arrays. aslist ( ( inferencevariable ) $whitespace$ type ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( type. isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ set < inferencevariable > $whitespace$ res $whitespace$ = $whitespace$ new $whitespace$ hashset < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ tp $whitespace$ : $whitespace$ type. asreferencetype ( ). typeparametersvalues ( ) ) $whitespace$ { $newline$ $indentation$ res. addall ( usedinferencevariables ( tp ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ res ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( type. tostring ( ) ) ; $newline$ $indentation$ }			
areCompatibleThroughWideningPrimitiveConversion	180	185	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.6432803869247437	MID	"		public static boolean areCompatibleThroughWideningPrimitiveConversion(ResolvedType s, ResolvedType t){
		    if (s.isPrimitive() && t.isPrimitive()) {
		        return s.isAssignableBy(t);
		    }
		    return false;
		}"	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ arecompatiblethroughwideningprimitiveconversion ( resolvedtype $whitespace$ s , $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ if $whitespace$ ( s . isprimitive ( ) $whitespace$ && $whitespace$ t . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ s . isassignableby ( t ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ boolean $whitespace$ arecompatiblethroughwideningprimitiveconversion ( resolvedtype $whitespace$ s, $whitespace$ resolvedtype $whitespace$ t ) { $newline$ $indentation$ if $whitespace$ ( s. isprimitive ( ) $whitespace$ && $whitespace$ t. isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ s. isassignableby ( t ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
glb	316	324	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeHelper.java	0.7060308456420898	MID	"		public static ResolvedType glb(Set<ResolvedType> types){
		    if (types.isEmpty()) {
		        throw new IllegalArgumentException();
		    }
		    if (types.size() == 1) {
		        return types.iterator().next();
		    }
		    return new ResolvedIntersectionType(types);
		}"	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ glb ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( types . size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ types . iterator ( ) . next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedintersectiontype ( types ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ resolvedtype $whitespace$ glb ( set < resolvedtype > $whitespace$ types ) { $newline$ $indentation$ if $whitespace$ ( types. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ null ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( types. size ( ) $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ types. iterator ( ). next ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ resolvedintersectiontype ( types ) ; $newline$ $indentation$ }			
invocationTypeInference	238	346	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.0156073663383722	LOW	"		public void invocationTypeInference(){
		    BoundSet B3 = invocationTypeInferenceBoundsSetB3();
		    //
		    //A set of constraint formulas, C, is constructed as follows.
		    //
		    //        Let e1, ..., ek be the actual argument expressions of the invocation. If m is applicable by strict or loose invocation, let F1, ..., Fk be the formal parameter types of m; if m is applicable by variable arity invocation, let F1, ..., Fk the first k variable arity parameter types of m (§15.12.2.4). Then:
		    //
		    //For all i (1 ≤ i ≤ k), if ei is not pertinent to applicability, C contains ‹ei → Fi θ›.
		    //
		    //For all i (1 ≤ i ≤ k), additional constraints may be included, depending on the form of ei:
		    //
		    //If ei is a LambdaExpression, C contains ‹LambdaExpression →throws Fi θ›.
		    //
		    //In addition, the lambda body is searched for additional constraints:
		    //
		    //For a block lambda body, the search is applied recursively to each result expression.
		    //
		    //For a poly class instance creation expression (§15.9) or a poly method invocation expression (§15.12), C contains all the constraint formulas that would appear in the set C generated by §18.5.2 when inferring the poly expression's invocation type.
		    //
		    //For a parenthesized expression, the search is applied recursively to the contained expression.
		    //
		    //For a conditional expression, the search is applied recursively to the second and third operands.
		    //
		    //For a lambda expression, the search is applied recursively to the lambda body.
		    //
		    //If ei is a MethodReference, C contains ‹MethodReference →throws Fi θ›.
		    //
		    //If ei is a poly class instance creation expression (§15.9) or a poly method invocation expression (§15.12), C contains all the constraint formulas that would appear in the set C generated by §18.5.2 when inferring the poly expression's invocation type.
		    //
		    //If ei is a parenthesized expression, these rules are applied recursively to the contained expression.
		    //
		    //If ei is a conditional expression, these rules are applied recursively to the second and third operands.
		    //
		    //While C is not empty, the following process is repeated, starting with the bound set B3 and accumulating new bounds into a ""current"" bound set, ultimately producing a new bound set, B4:
		    //
		    //A subset of constraints is selected in C, satisfying the property that, for each constraint, no input variable can influence an output variable of another constraint in C. The terms input variable and output variable are defined below. An inference variable α can influence an inference variable β if α depends on the resolution of β (§18.4), or vice versa; or if there exists a third inference variable γ such that α can influence γ and γ can influence β.
		    //
		    //If this subset is empty, then there is a cycle (or cycles) in the graph of dependencies between constraints. In this case, all constraints are considered that participate in a dependency cycle (or cycles) and do not depend on any constraints outside of the cycle (or cycles). A single constraint is selected from the considered constraints, as follows:
		    //
		    //If any of the considered constraints have the form ‹Expression → T›, then the selected constraint is the considered constraint of this form that contains the expression to the left (§3.5) of the expression of every other considered constraint of this form.
		    //
		    //        If no considered constraint has the form ‹Expression → T›, then the selected constraint is the considered constraint that contains the expression to the left of the expression of every other considered constraint.
		    //
		    //        The selected constraint(s) are removed from C.
		    //
		    //        The input variables α1, ..., αm of all the selected constraint(s) are resolved.
		    //
		    //        Where T1, ..., Tm are the instantiations of α1, ..., αm, the substitution [α1:=T1, ..., αm:=Tm] is applied to every constraint.
		    //
		    //        The constraint(s) resulting from substitution are reduced and incorporated with the current bound set.
		    //
		    //Finally, if B4 does not contain the bound false, the inference variables in B4 are resolved.
		    //
		    //If resolution succeeds with instantiations T1, ..., Tp for inference variables α1, ..., αp, let θ' be the substitution [P1:=T1, ..., Pp:=Tp]. Then:
		    //
		    //If unchecked conversion was necessary for the method to be applicable during constraint set reduction in §18.5.1, then the parameter types of the invocation type of m are obtained by applying θ' to the parameter types of m's type, and the return type and thrown types of the invocation type of m are given by the erasure of the return type and thrown types of m's type.
		    //
		    //If unchecked conversion was not necessary for the method to be applicable, then the invocation type of m is obtained by applying θ' to the type of m.
		    //
		    //If B4 contains the bound false, or if resolution fails, then a compile-time error occurs.
		    //
		    //Invocation type inference may require carefully sequencing the reduction of constraint formulas of the forms ‹Expression → T›, ‹LambdaExpression →throws T›, and ‹MethodReference →throws T›. To facilitate this sequencing, the input variables of these constraints are defined as follows:
		    //
		    //For ‹LambdaExpression → T›:
		    //
		    //If T is an inference variable, it is the (only) input variable.
		    //
		    //        If T is a functional interface type, and a function type can be derived from T (§15.27.3), then the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and ii) if the function type's return type, R, is not void, then for each result expression e in the lambda body (or for the body itself if it is an expression), the input variables of ‹e → R›.
		    //
		    //Otherwise, there are no input variables.
		    //
		    //For ‹LambdaExpression →throws T›:
		    //
		    //If T is an inference variable, it is the (only) input variable.
		    //
		    //        If T is a functional interface type, and a function type can be derived, as described in §15.27.3, the input variables include i) if the lambda expression is implicitly typed, the inference variables mentioned by the function type's parameter types; and ii) the inference variables mentioned by the function type's return type.
		    //
		    //        Otherwise, there are no input variables.
		    //
		    //        For ‹MethodReference → T›:
		    //
		    //If T is an inference variable, it is the (only) input variable.
		    //
		    //        If T is a functional interface type with a function type, and if the method reference is inexact (§15.13.1), the input variables are the inference variables mentioned by the function type's parameter types.
		    //
		    //Otherwise, there are no input variables.
		    //
		    //For ‹MethodReference →throws T›:
		    //
		    //If T is an inference variable, it is the (only) input variable.
		    //
		    //        If T is a functional interface type with a function type, and if the method reference is inexact (§15.13.1), the input variables are the inference variables mentioned by the function type's parameter types and the function type's return type.
		    //
		    //        Otherwise, there are no input variables.
		    //
		    //        For ‹Expression → T›, if Expression is a parenthesized expression:
		    //
		    //Where the contained expression of Expression is Expression', the input variables are the input variables of ‹Expression' → T›.
		    //
		    //For ‹ConditionalExpression → T›:
		    //
		    //Where the conditional expression has the form e1 ? e2 : e3, the input variables are the input variables of ‹e2 → T› and ‹e3 → T›.
		    //
		    //For all other constraint formulas, there are no input variables.
		    //
		    //The output variables of these constraints are all inference variables mentioned by the type on the right-hand side of the constraint, T, that are not input variables.
		    throw new UnsupportedOperationException();
		}"	"$indentation$ public $whitespace$ void $whitespace$ invocationtypeinference ( ) { $newline$ $indentation$ boundset $whitespace$ b3 $whitespace$ = $whitespace$ invocationtypeinferenceboundssetb3 ( ) ; $newline$ $indentation$ // $newline$ $indentation$ $//a·set·of·constraint·formulas,·c,·is·constructed·as·follows.$ $newline$ $indentation$ // $newline$ $indentation$ $//········let·e1,·...,·ek·be·the·actual·argument·expressions·of·the·invocation.·if·m·is·applicable·by·strict·or·loose·invocation,·let·f1,·...,·fk·be·the·formal·parameter·types·of·m;·if·m·is·applicable·by·variable·arity·invocation,·let·f1,·...,·fk·the·first·k·variable·arity·parameter·types·of·m·(§15.12.2.4).·then:$ $newline$ $indentation$ // $newline$ $indentation$ $//for·all·i·(1·≤·i·≤·k),·if·ei·is·not·pertinent·to·applicability,·c·contains·‹ei·→·fi·θ›.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·all·i·(1·≤·i·≤·k),·additional·constraints·may·be·included,·depending·on·the·form·of·ei:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·ei·is·a·lambdaexpression,·c·contains·‹lambdaexpression·→throws·fi·θ›.$ $newline$ $indentation$ // $newline$ $indentation$ $//in·addition,·the·lambda·body·is·searched·for·additional·constraints:$ $newline$ $indentation$ // $newline$ $indentation$ $//for·a·block·lambda·body,·the·search·is·applied·recursively·to·each·result·expression.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·a·poly·class·instance·creation·expression·(§15.9)·or·a·poly·method·invocation·expression·(§15.12),·c·contains·all·the·constraint·formulas·that·would·appear·in·the·set·c·generated·by·§18.5.2·when·inferring·the·poly·expression's·invocation·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·a·parenthesized·expression,·the·search·is·applied·recursively·to·the·contained·expression.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·a·conditional·expression,·the·search·is·applied·recursively·to·the·second·and·third·operands.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·a·lambda·expression,·the·search·is·applied·recursively·to·the·lambda·body.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·ei·is·a·methodreference,·c·contains·‹methodreference·→throws·fi·θ›.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·ei·is·a·poly·class·instance·creation·expression·(§15.9)·or·a·poly·method·invocation·expression·(§15.12),·c·contains·all·the·constraint·formulas·that·would·appear·in·the·set·c·generated·by·§18.5.2·when·inferring·the·poly·expression's·invocation·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·ei·is·a·parenthesized·expression,·these·rules·are·applied·recursively·to·the·contained·expression.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·ei·is·a·conditional·expression,·these·rules·are·applied·recursively·to·the·second·and·third·operands.$ $newline$ $indentation$ // $newline$ $indentation$ $//while·c·is·not·empty,·the·following·process·is·repeated,·starting·with·the·bound·set·b3·and·accumulating·new·bounds·into·a·""current""·bound·set,·ultimately·producing·a·new·bound·set,·b4:$ $newline$ $indentation$ // $newline$ $indentation$ $//a·subset·of·constraints·is·selected·in·c,·satisfying·the·property·that,·for·each·constraint,·no·input·variable·can·influence·an·output·variable·of·another·constraint·in·c.·the·terms·input·variable·and·output·variable·are·defined·below.·an·inference·variable·α·can·influence·an·inference·variable·β·if·α·depends·on·the·resolution·of·β·(§18.4),·or·vice·versa;·or·if·there·exists·a·third·inference·variable·γ·such·that·α·can·influence·γ·and·γ·can·influence·β.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·this·subset·is·empty,·then·there·is·a·cycle·(or·cycles)·in·the·graph·of·dependencies·between·constraints.·in·this·case,·all·constraints·are·considered·that·participate·in·a·dependency·cycle·(or·cycles)·and·do·not·depend·on·any·constraints·outside·of·the·cycle·(or·cycles).·a·single·constraint·is·selected·from·the·considered·constraints,·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·any·of·the·considered·constraints·have·the·form·‹expression·→·t›,·then·the·selected·constraint·is·the·considered·constraint·of·this·form·that·contains·the·expression·to·the·left·(§3.5)·of·the·expression·of·every·other·considered·constraint·of·this·form.$ $newline$ $indentation$ // $newline$ $indentation$ $//········if·no·considered·constraint·has·the·form·‹expression·→·t›,·then·the·selected·constraint·is·the·considered·constraint·that·contains·the·expression·to·the·left·of·the·expression·of·every·other·considered·constraint.$ $newline$ $indentation$ // $newline$ $indentation$ $//········the·selected·constraint(s)·are·removed·from·c.$ $newline$ $indentation$ // $newline$ $indentation$ $//········the·input·variables·α1,·...,·αm·of·all·the·selected·constraint(s)·are·resolved.$ $newline$ $indentation$ // $newline$ $indentation$ $//········where·t1,·...,·tm·are·the·instantiations·of·α1,·...,·αm,·the·substitution·[α1:=t1,·...,·αm:=tm]·is·applied·to·every·constraint.$ $newline$ $indentation$ // $newline$ $indentation$ $//········the·constraint(s)·resulting·from·substitution·are·reduced·and·incorporated·with·the·current·bound·set.$ $newline$ $indentation$ // $newline$ $indentation$ $//finally,·if·b4·does·not·contain·the·bound·false,·the·inference·variables·in·b4·are·resolved.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·resolution·succeeds·with·instantiations·t1,·...,·tp·for·inference·variables·α1,·...,·αp,·let·θ'·be·the·substitution·[p1:=t1,·...,·pp:=tp].·then:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·unchecked·conversion·was·necessary·for·the·method·to·be·applicable·during·constraint·set·reduction·in·§18.5.1,·then·the·parameter·types·of·the·invocation·type·of·m·are·obtained·by·applying·θ'·to·the·parameter·types·of·m's·type,·and·the·return·type·and·thrown·types·of·the·invocation·type·of·m·are·given·by·the·erasure·of·the·return·type·and·thrown·types·of·m's·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·unchecked·conversion·was·not·necessary·for·the·method·to·be·applicable,·then·the·invocation·type·of·m·is·obtained·by·applying·θ'·to·the·type·of·m.$ $newline$ $indentation$ // $newline$ $indentation$ $//if·b4·contains·the·bound·false,·or·if·resolution·fails,·then·a·compile-time·error·occurs.$ $newline$ $indentation$ // $newline$ $indentation$ $//invocation·type·inference·may·require·carefully·sequencing·the·reduction·of·constraint·formulas·of·the·forms·‹expression·→·t›,·‹lambdaexpression·→throws·t›,·and·‹methodreference·→throws·t›.·to·facilitate·this·sequencing,·the·input·variables·of·these·constraints·are·defined·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//for·‹lambdaexpression·→·t›:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·t·is·an·inference·variable,·it·is·the·(only)·input·variable.$ $newline$ $indentation$ // $newline$ $indentation$ $//········if·t·is·a·functional·interface·type,·and·a·function·type·can·be·derived·from·t·(§15.27.3),·then·the·input·variables·include·i)·if·the·lambda·expression·is·implicitly·typed,·the·inference·variables·mentioned·by·the·function·type's·parameter·types;·and·ii)·if·the·function·type's·return·type,·r,·is·not·void,·then·for·each·result·expression·e·in·the·lambda·body·(or·for·the·body·itself·if·it·is·an·expression),·the·input·variables·of·‹e·→·r›.$ $newline$ $indentation$ // $newline$ $indentation$ $//otherwise,·there·are·no·input·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·‹lambdaexpression·→throws·t›:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·t·is·an·inference·variable,·it·is·the·(only)·input·variable.$ $newline$ $indentation$ // $newline$ $indentation$ $//········if·t·is·a·functional·interface·type,·and·a·function·type·can·be·derived,·as·described·in·§15.27.3,·the·input·variables·include·i)·if·the·lambda·expression·is·implicitly·typed,·the·inference·variables·mentioned·by·the·function·type's·parameter·types;·and·ii)·the·inference·variables·mentioned·by·the·function·type's·return·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//········otherwise,·there·are·no·input·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//········for·‹methodreference·→·t›:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·t·is·an·inference·variable,·it·is·the·(only)·input·variable.$ $newline$ $indentation$ // $newline$ $indentation$ $//········if·t·is·a·functional·interface·type·with·a·function·type,·and·if·the·method·reference·is·inexact·(§15.13.1),·the·input·variables·are·the·inference·variables·mentioned·by·the·function·type's·parameter·types.$ $newline$ $indentation$ // $newline$ $indentation$ $//otherwise,·there·are·no·input·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·‹methodreference·→throws·t›:$ $newline$ $indentation$ // $newline$ $indentation$ $//if·t·is·an·inference·variable,·it·is·the·(only)·input·variable.$ $newline$ $indentation$ // $newline$ $indentation$ $//········if·t·is·a·functional·interface·type·with·a·function·type,·and·if·the·method·reference·is·inexact·(§15.13.1),·the·input·variables·are·the·inference·variables·mentioned·by·the·function·type's·parameter·types·and·the·function·type's·return·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//········otherwise,·there·are·no·input·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//········for·‹expression·→·t›,·if·expression·is·a·parenthesized·expression:$ $newline$ $indentation$ // $newline$ $indentation$ $//where·the·contained·expression·of·expression·is·expression',·the·input·variables·are·the·input·variables·of·‹expression'·→·t›.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·‹conditionalexpression·→·t›:$ $newline$ $indentation$ // $newline$ $indentation$ $//where·the·conditional·expression·has·the·form·e1·?·e2·:·e3,·the·input·variables·are·the·input·variables·of·‹e2·→·t›·and·‹e3·→·t›.$ $newline$ $indentation$ // $newline$ $indentation$ $//for·all·other·constraint·formulas,·there·are·no·input·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//the·output·variables·of·these·constraints·are·all·inference·variables·mentioned·by·the·type·on·the·right-hand·side·of·the·constraint,·t,·that·are·not·input·variables.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ void $whitespace$ invocationtypeinference ( ) { $newline$ $indentation$ boundset $whitespace$ b3 $whitespace$ = $whitespace$ invocationtypeinferenceboundssetb3 ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ bound $whitespace$ = $whitespace$ ( ) $whitespace$ - > $whitespace$ $newline$ $indentation$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $whitespace$ set $whitespace$ block $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$ $whitespace$ set $whitespace$ block $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$//for$			
boundSetup	522	565	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.0751275941729545	LOW	"		private BoundSet boundSetup(List<ResolvedTypeParameterDeclaration> typeParameterDeclarations, List<InferenceVariable> inferenceVariables){
		    if (typeParameterDeclarations.size() != inferenceVariables.size()) {
		        throw new IllegalArgumentException();
		    }
		    // When inference begins, a bound set is typically generated from a list of
		    // type parameter declarations P1, ..., Pp and associated inference variables α1, ..., αp.
		    // Such a bound set is constructed as follows. For each l (1 ≤ l ≤ p):
		    BoundSet boundSet = BoundSet.empty();
		    for (int l = 0; l < typeParameterDeclarations.size(); l++) {
		        ResolvedTypeParameterDeclaration Pl = typeParameterDeclarations.get(l);
		        InferenceVariable alphaL = inferenceVariables.get(l);
		        // - If Pl has no TypeBound, the bound αl <: Object appears in the set.
		        if (Pl.getBounds().isEmpty()) {
		            boundSet = boundSet.withBound(new SubtypeOfBound(alphaL, object));
		        } else {
		            // - Otherwise, for each type T delimited by & in the TypeBound, the bound αl <: T[P1:=α1, ..., Pp:=αp] appears
		            // in the set; if this results in no proper upper bounds for αl (only dependencies), then the
		            // bound αl <: Object also appears in the set.
		            for (ResolvedTypeParameterDeclaration.Bound bound : Pl.getBounds()) {
		                ResolvedType T = bound.getType();
		                Substitution substitution = Substitution.empty();
		                for (int j = 0; j < typeParameterDeclarations.size(); j++) {
		                    substitution = substitution.withPair(typeParameterDeclarations.get(j), inferenceVariables.get(j));
		                }
		                ResolvedType TWithSubstitutions = substitution.apply(T);
		                boundSet = boundSet.withBound(new SubtypeOfBound(alphaL, TWithSubstitutions));
		                if (boundSet.getProperUpperBoundsFor(alphaL).isEmpty()) {
		                    boundSet = boundSet.withBound(new SubtypeOfBound(alphaL, object));
		                }
		            }
		        }
		    }
		    return boundSet;
		}"	$indentation$ private $whitespace$ boundset $whitespace$ boundsetup ( list < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarations , $whitespace$ list < inferencevariable > $whitespace$ inferencevariables ) { $newline$ $indentation$ if $whitespace$ ( typeparameterdeclarations . size ( ) $whitespace$ != $whitespace$ inferencevariables . size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·when·inference·begins,·a·bound·set·is·typically·generated·from·a·list·of$ $newline$ $indentation$ $//·type·parameter·declarations·p1,·...,·pp·and·associated·inference·variables·α1,·...,·αp.$ $newline$ $indentation$ $//·such·a·bound·set·is·constructed·as·follows.·for·each·l·(1·≤·l·≤·p):$ $newline$ $indentation$ boundset $whitespace$ boundset $whitespace$ = $whitespace$ boundset . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ l $whitespace$ = $whitespace$ $number$ ; $whitespace$ l $whitespace$ < $whitespace$ typeparameterdeclarations . size ( ) ; $whitespace$ l ++ ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ pl $whitespace$ = $whitespace$ typeparameterdeclarations . get ( l ) ; $newline$ $indentation$ inferencevariable $whitespace$ alphal $whitespace$ = $whitespace$ inferencevariables . get ( l ) ; $newline$ $indentation$ $//·-·if·pl·has·no·typebound,·the·bound·αl·<:·object·appears·in·the·set.$ $newline$ $indentation$ if $whitespace$ ( pl . getbounds ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ boundset $whitespace$ = $whitespace$ boundset . withbound ( new $whitespace$ subtypeofbound ( alphal , $whitespace$ object ) ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ $//·-·otherwise,·for·each·type·t·delimited·by·&·in·the·typebound,·the·bound·αl·<:·t[p1:=α1,·...,·pp:=αp]·appears$ $newline$ $indentation$ $//·in·the·set;·if·this·results·in·no·proper·upper·bounds·for·αl·(only·dependencies),·then·the$ $newline$ $indentation$ $//·bound·αl·<:·object·also·appears·in·the·set.$ $newline$ $indentation$ for $whitespace$ ( resolvedtypeparameterdeclaration . bound $whitespace$ bound $whitespace$ : $whitespace$ pl . getbounds ( ) ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ t $whitespace$ = $whitespace$ bound . gettype ( ) ; $newline$ $indentation$ substitution $whitespace$ substitution $whitespace$ = $whitespace$ substitution . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ typeparameterdeclarations . size ( ) ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ substitution $whitespace$ = $whitespace$ substitution . withpair ( typeparameterdeclarations . get ( j ) , $whitespace$ inferencevariables . get ( j ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ twithsubstitutions $whitespace$ = $whitespace$ substitution . apply ( t ) ; $newline$ $indentation$ boundset $whitespace$ = $whitespace$ boundset . withbound ( new $whitespace$ subtypeofbound ( alphal , $whitespace$ twithsubstitutions ) ) ; $newline$ $indentation$ if $whitespace$ ( boundset . getproperupperboundsfor ( alphal ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ boundset $whitespace$ = $whitespace$ boundset . withbound ( new $whitespace$ subtypeofbound ( alphal , $whitespace$ object ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ boundset ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boundset $whitespace$ boundsetup ( list < resolvedtypeparameterdeclaration > $whitespace$ typeparameterdeclarations, $whitespace$ list < inferencevariable > $whitespace$ inferencevariables ) { $newline$ $indentation$ if $whitespace$ ( typeparameterdeclarations. size ( ) $whitespace$!= $whitespace$ inferencevariables. size ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $////////////////////////////////////when $newline$ $indentation$ methodbegins, $whitespace$ = = $whitespace$ arrsa. size ( ) ; $newline$ $indentation$ $whitespace$//variables. size ( ) $newline$ $indentation$. size ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ l $whitespace$ = $whitespace$ $number$ ; $whitespace$ l $whitespace$ < $whitespace$ typeparameterdeclarations. size ( ) ; $whitespace$ l ++ ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ pl $whitespace$ = $whitespace$ typeparameterdeclarations. get ( l ) ; $newline$ $indentation$ inferencevariable $whitespace$ alphal $whitespace$ = $whitespace$ inferencevariables. get ( l ) ; $newline$ $indentation$ $////////////////////////////////////----------------------------------------------------------------------------------------------------------------------------------------------------			
instantiationInference	80	159	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.0792537629604339	LOW	"		public Optional<InstantiationSet> instantiationInference(List<Expression> argumentExpressions, ResolvedMethodDeclaration methodDeclaration){
		    //        if (methodCallExpr.getTypeArguments().isPresent()) {
		    //            throw new IllegalArgumentException(""Type inference unnecessary as type arguments have been specified"");
		    //        }
		    // Given a method invocation that provides no explicit type arguments, the process to determine whether a
		    // potentially applicable generic method m is applicable is as follows:
		    // - Where P1, ..., Pp (p ≥ 1) are the type parameters of m, let α1, ..., αp be inference variables, and
		    //   let θ be the substitution [P1:=α1, ..., Pp:=αp].
		    List<ResolvedTypeParameterDeclaration> Ps = methodDeclaration.getTypeParameters();
		    List<InferenceVariable> alphas = InferenceVariable.instantiate(Ps);
		    Substitution theta = Substitution.empty();
		    for (int i = 0; i < Ps.size(); i++) {
		        theta = theta.withPair(Ps.get(0), alphas.get(0));
		    }
		    // - An initial bound set, B0, is constructed from the declared bounds of P1, ..., Pp, as described in §18.1.3.
		    BoundSet B0 = boundSetup(Ps, alphas);
		    // - For all i (1 ≤ i ≤ p), if Pi appears in the throws clause of m, then the bound throws αi is implied.
		    //   These bounds, if any, are incorporated with B0 to produce a new bound set, B1.
		    BoundSet B1 = B0;
		    for (int i = 0; i < Ps.size(); i++) {
		        ResolvedTypeParameterDeclaration Pi = Ps.get(i);
		        if (appearInThrowsClause(Pi, methodDeclaration)) {
		            B1 = B1.withBound(new ThrowsBound(alphas.get(i)));
		        }
		    }
		    // - A set of constraint formulas, C, is constructed as follows.
		    //
		    //   Let F1, ..., Fn be the formal parameter types of m, and let e1, ..., ek be the actual argument expressions
		    //   of the invocation. Then:
		    List<ResolvedType> Fs = formalParameterTypes(methodDeclaration);
		    List<Expression> es = argumentExpressions;
		    Optional<ConstraintFormulaSet> C = Optional.empty();
		    //   - To test for applicability by strict invocation:
		    if (!C.isPresent()) {
		        C = testForApplicabilityByStrictInvocation(Fs, es, theta);
		    }
		    //   - To test for applicability by loose invocation:
		    if (!C.isPresent()) {
		        C = testForApplicabilityByLooseInvocation(Fs, es, theta);
		    }
		    //   - To test for applicability by variable arity invocation:
		    if (!C.isPresent()) {
		        C = testForApplicabilityByVariableArityInvocation(Fs, es, theta);
		    }
		    if (!C.isPresent()) {
		        return Optional.empty();
		    }
		    // - C is reduced (§18.2) and the resulting bounds are incorporated with B1 to produce a new bound set, B2.
		    BoundSet resultingBounds = C.get().reduce(typeSolver);
		    BoundSet B2 = B1.incorporate(resultingBounds, typeSolver);
		    // - Finally, the method m is applicable if B2 does not contain the bound false and resolution of all the
		    //   inference variables in B2 succeeds (§18.4).
		    if (B2.containsFalse()) {
		        return Optional.empty();
		    }
		    Optional<InstantiationSet> instantiation = B2.performResolution(alphas, typeSolver);
		    return instantiation;
		}"	"$indentation$ public $whitespace$ optional < instantiationset > $whitespace$ instantiationinference ( list < expression > $whitespace$ argumentexpressions , $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ $//········if·(methodcallexpr.gettypearguments().ispresent())·{$ $newline$ $indentation$ $//············throw·new·illegalargumentexception(""type·inference·unnecessary·as·type·arguments·have·been·specified"");$ $newline$ $indentation$ $//········}$ $newline$ $indentation$ $//·given·a·method·invocation·that·provides·no·explicit·type·arguments,·the·process·to·determine·whether·a$ $newline$ $indentation$ $//·potentially·applicable·generic·method·m·is·applicable·is·as·follows:$ $newline$ $indentation$ $//·-·where·p1,·...,·pp·(p·≥·1)·are·the·type·parameters·of·m,·let·α1,·...,·αp·be·inference·variables,·and$ $newline$ $indentation$ $//···let·θ·be·the·substitution·[p1:=α1,·...,·pp:=αp].$ $newline$ $indentation$ list < resolvedtypeparameterdeclaration > $whitespace$ ps $whitespace$ = $whitespace$ methoddeclaration . gettypeparameters ( ) ; $newline$ $indentation$ list < inferencevariable > $whitespace$ alphas $whitespace$ = $whitespace$ inferencevariable . instantiate ( ps ) ; $newline$ $indentation$ substitution $whitespace$ theta $whitespace$ = $whitespace$ substitution . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ ps . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ theta $whitespace$ = $whitespace$ theta . withpair ( ps . get ( $number$ ) , $whitespace$ alphas . get ( $number$ ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·an·initial·bound·set,·b0,·is·constructed·from·the·declared·bounds·of·p1,·...,·pp,·as·described·in·§18.1.3.$ $newline$ $indentation$ boundset $whitespace$ b0 $whitespace$ = $whitespace$ boundsetup ( ps , $whitespace$ alphas ) ; $newline$ $indentation$ $//·-·for·all·i·(1·≤·i·≤·p),·if·pi·appears·in·the·throws·clause·of·m,·then·the·bound·throws·αi·is·implied.$ $newline$ $indentation$ $//···these·bounds,·if·any,·are·incorporated·with·b0·to·produce·a·new·bound·set,·b1.$ $newline$ $indentation$ boundset $whitespace$ b1 $whitespace$ = $whitespace$ b0 ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ ps . size ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtypeparameterdeclaration $whitespace$ pi $whitespace$ = $whitespace$ ps . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( appearinthrowsclause ( pi , $whitespace$ methoddeclaration ) ) $whitespace$ { $newline$ $indentation$ b1 $whitespace$ = $whitespace$ b1 . withbound ( new $whitespace$ throwsbound ( alphas . get ( i ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·-·a·set·of·constraint·formulas,·c,·is·constructed·as·follows.$ $newline$ $indentation$ // $newline$ $indentation$ $//···let·f1,·...,·fn·be·the·formal·parameter·types·of·m,·and·let·e1,·...,·ek·be·the·actual·argument·expressions$ $newline$ $indentation$ $//···of·the·invocation.·then:$ $newline$ $indentation$ list < resolvedtype > $whitespace$ fs $whitespace$ = $whitespace$ formalparametertypes ( methoddeclaration ) ; $newline$ $indentation$ list < expression > $whitespace$ es $whitespace$ = $whitespace$ argumentexpressions ; $newline$ $indentation$ optional < constraintformulaset > $whitespace$ c $whitespace$ = $whitespace$ optional . empty ( ) ; $newline$ $indentation$ $//···-·to·test·for·applicability·by·strict·invocation:$ $newline$ $indentation$ if $whitespace$ ( ! c . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ c $whitespace$ = $whitespace$ testforapplicabilitybystrictinvocation ( fs , $whitespace$ es , $whitespace$ theta ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···-·to·test·for·applicability·by·loose·invocation:$ $newline$ $indentation$ if $whitespace$ ( ! c . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ c $whitespace$ = $whitespace$ testforapplicabilitybylooseinvocation ( fs , $whitespace$ es , $whitespace$ theta ) ; $newline$ $indentation$ } $newline$ $indentation$ $//···-·to·test·for·applicability·by·variable·arity·invocation:$ $newline$ $indentation$ if $whitespace$ ( ! c . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ c $whitespace$ = $whitespace$ testforapplicabilitybyvariablearityinvocation ( fs , $whitespace$ es , $whitespace$ theta ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! c . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·c·is·reduced·(§18.2)·and·the·resulting·bounds·are·incorporated·with·b1·to·produce·a·new·bound·set,·b2.$ $newline$ $indentation$ boundset $whitespace$ resultingbounds $whitespace$ = $whitespace$ c . get ( ) . reduce ( typesolver ) ; $newline$ $indentation$ boundset $whitespace$ b2 $whitespace$ = $whitespace$ b1 . incorporate ( resultingbounds , $whitespace$ typesolver ) ; $newline$ $indentation$ $//·-·finally,·the·method·m·is·applicable·if·b2·does·not·contain·the·bound·false·and·resolution·of·all·the$ $newline$ $indentation$ $//···inference·variables·in·b2·succeeds·(§18.4).$ $newline$ $indentation$ if $whitespace$ ( b2 . containsfalse ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < instantiationset > $whitespace$ instantiation $whitespace$ = $whitespace$ b2 . performresolution ( alphas , $whitespace$ typesolver ) ; $newline$ $indentation$ return $whitespace$ instantiation ; $newline$ $indentation$ }"	$indentation$ public $whitespace$ optional < instantiationset > $whitespace$ instantiationinference ( list < expression > $whitespace$ argumentexpressions, $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ $////// $newline$ $indentation$ // $whitespace$ the $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $			
testForApplicabilityByVariableArityInvocation	720	734	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.0936108604073524	LOW	"		private Optional<ConstraintFormulaSet> testForApplicabilityByVariableArityInvocation(List<ResolvedType> Fs, List<Expression> es, Substitution theta){
		    int k = es.size();
		    // Let F'1, ..., F'k be the first k variable arity parameter types of m (§15.12.2.4). C includes,
		    // for all i (1 ≤ i ≤ k) where ei is pertinent to applicability, ‹ei → F'i θ›.
		    List<ResolvedType> FsFirst = new LinkedList<>();
		    for (int i = 0; i < k; i++) {
		        ResolvedType FFirstI = i < Fs.size() ? Fs.get(i) : Fs.get(Fs.size() - 1);
		        FsFirst.add(FFirstI);
		    }
		    return Optional.of(constraintSetFromArgumentsSubstitution(FsFirst, es, theta, k));
		}"	$indentation$ private $whitespace$ optional < constraintformulaset > $whitespace$ testforapplicabilitybyvariablearityinvocation ( list < resolvedtype > $whitespace$ fs , $whitespace$ list < expression > $whitespace$ es , $whitespace$ substitution $whitespace$ theta ) { $newline$ $indentation$ int $whitespace$ k $whitespace$ = $whitespace$ es . size ( ) ; $newline$ $indentation$ $//·let·f'1,·...,·f'k·be·the·first·k·variable·arity·parameter·types·of·m·(§15.12.2.4).·c·includes,$ $newline$ $indentation$ $//·for·all·i·(1·≤·i·≤·k)·where·ei·is·pertinent·to·applicability,·‹ei·→·f'i·θ›.$ $newline$ $indentation$ list < resolvedtype > $whitespace$ fsfirst $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ k ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ resolvedtype $whitespace$ ffirsti $whitespace$ = $whitespace$ i $whitespace$ < $whitespace$ fs . size ( ) $whitespace$ ? $whitespace$ fs . get ( i ) $whitespace$ : $whitespace$ fs . get ( fs . size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ fsfirst . add ( ffirsti ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( constraintsetfromargumentssubstitution ( fsfirst , $whitespace$ es , $whitespace$ theta , $whitespace$ k ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < constraintformulaset > $whitespace$ testforapplicabilitybyvariablearityinvocation ( list < resolvedtype > $whitespace$ fs, $whitespace$ list < expression > $whitespace$ es, $whitespace$ substitution $whitespace$ theta ) { $newline$ $indentation$ int $whitespace$ k $whitespace$ = $whitespace$ es. size ( ) ; $newline$ $indentation$ $indentation$ $whitespace$ = $whitespace$ es. size ( ) ; $newline$ $indentation$ $whitespace$ = $whitespace$ $whitespace$ es. size ( ) ; $newline$ $indentation$ $whitespace$ = $whitespace$ $whitespace$ es. get ( fs. size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ $whitespace$ = $whitespace$ $whitespace$ es. get ( fs. size ( ) $whitespace$ - $whitespace$ $number$ ) ; $newline$ $indentation$ $whitespace$ = $whitespace$ optional. of ( constraintsetfromargumentssub			
instantiationSetToMethodUsage	498	508	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.0996462702751159	LOW	"		private static MethodUsage instantiationSetToMethodUsage(ResolvedMethodDeclaration methodDeclaration, InstantiationSet instantiationSet){
		    if (instantiationSet.isEmpty()) {
		        return new MethodUsage(methodDeclaration);
		    }
		    List<ResolvedType> paramTypes = new LinkedList<>();
		    for (int i = 0; i < methodDeclaration.getNumberOfParams(); i++) {
		        paramTypes.add(instantiationSet.apply(methodDeclaration.getParam(i).getType()));
		    }
		    ResolvedType returnType = instantiationSet.apply(methodDeclaration.getReturnType());
		    return new MethodUsage(methodDeclaration, paramTypes, returnType);
		}"	$indentation$ private $whitespace$ static $whitespace$ methodusage $whitespace$ instantiationsettomethodusage ( resolvedmethoddeclaration $whitespace$ methoddeclaration , $whitespace$ instantiationset $whitespace$ instantiationset ) { $newline$ $indentation$ if $whitespace$ ( instantiationset . isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ paramtypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ paramtypes . add ( instantiationset . apply ( methoddeclaration . getparam ( i ) . gettype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ instantiationset . apply ( methoddeclaration . getreturntype ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( methoddeclaration , $whitespace$ paramtypes , $whitespace$ returntype ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ static $whitespace$ methodusage $whitespace$ instantiationsettomethodusage ( resolvedmethoddeclaration $whitespace$ methoddeclaration, $whitespace$ instantiationset $whitespace$ instantiationset ) { $newline$ $indentation$ if $whitespace$ ( instantiationset. isempty ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( methoddeclaration ) ; $newline$ $indentation$ } $newline$ $indentation$ list < resolvedtype > $whitespace$ paramtypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration. getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ paramtypes. add ( instantiationset. apply ( methoddeclaration. getparam ( i ). gettype ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ returntype $whitespace$ = $whitespace$ instantiationset. apply ( methoddeclaration. getreturntype ( ) ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodusage ( methoddeclaration, $whitespace$ paramtypes, $whitespace$ returntype ) ; $newline$ $indentation$ }			
testForApplicabilityByStrictInvocation	657	687	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.1199934110045433	LOW	"		private Optional<ConstraintFormulaSet> testForApplicabilityByStrictInvocation(List<ResolvedType> Fs, List<Expression> es, Substitution theta){
		    int n = Fs.size();
		    int k = es.size();
		    // If k ≠ n, or if there exists an i (1 ≤ i ≤ n) such that ei is pertinent to applicability (§15.12.2.2)
		    // and either:
		    // i) ei is a standalone expression of a primitive type but Fi is a reference type, or
		    // ii) Fi is a primitive type but ei is not a standalone expression of a primitive type;
		    if (k != n) {
		        return Optional.empty();
		    }
		    for (int i = 0; i < n; i++) {
		        Expression ei = es.get(i);
		        ResolvedType fi = Fs.get(i);
		        if (isPertinentToApplicability(ei)) {
		            if (ei.isStandaloneExpression() && JavaParserFacade.get(typeSolver).getType(ei).isPrimitive() && fi.isReferenceType()) {
		                return Optional.empty();
		            }
		            if (fi.isPrimitive() && (!ei.isStandaloneExpression() || !JavaParserFacade.get(typeSolver).getType(ei).isPrimitive())) {
		                return Optional.empty();
		            }
		        }
		    }
		    // then the method is not applicable and there is no need to proceed with inference.
		    //
		    // Otherwise, C includes, for all i (1 ≤ i ≤ k) where ei is pertinent to applicability, ‹ei → Fi θ›.
		    return Optional.of(constraintSetFromArgumentsSubstitution(Fs, es, theta, k));
		}"	$indentation$ private $whitespace$ optional < constraintformulaset > $whitespace$ testforapplicabilitybystrictinvocation ( list < resolvedtype > $whitespace$ fs , $whitespace$ list < expression > $whitespace$ es , $whitespace$ substitution $whitespace$ theta ) { $newline$ $indentation$ int $whitespace$ n $whitespace$ = $whitespace$ fs . size ( ) ; $newline$ $indentation$ int $whitespace$ k $whitespace$ = $whitespace$ es . size ( ) ; $newline$ $indentation$ $//·if·k·≠·n,·or·if·there·exists·an·i·(1·≤·i·≤·n)·such·that·ei·is·pertinent·to·applicability·(§15.12.2.2)$ $newline$ $indentation$ $//·and·either:$ $newline$ $indentation$ $//·i)·ei·is·a·standalone·expression·of·a·primitive·type·but·fi·is·a·reference·type,·or$ $newline$ $indentation$ $//·ii)·fi·is·a·primitive·type·but·ei·is·not·a·standalone·expression·of·a·primitive·type;$ $newline$ $indentation$ if $whitespace$ ( k $whitespace$ != $whitespace$ n ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ n ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ ei $whitespace$ = $whitespace$ es . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ fi $whitespace$ = $whitespace$ fs . get ( i ) ; $newline$ $indentation$ if $whitespace$ ( ispertinenttoapplicability ( ei ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ei . isstandaloneexpression ( ) $whitespace$ && $whitespace$ javaparserfacade . get ( typesolver ) . gettype ( ei ) . isprimitive ( ) $whitespace$ && $whitespace$ fi . isreferencetype ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( fi . isprimitive ( ) $whitespace$ && $whitespace$ ( ! ei . isstandaloneexpression ( ) $whitespace$ || $whitespace$ ! javaparserfacade . get ( typesolver ) . gettype ( ei ) . isprimitive ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//·then·the·method·is·not·applicable·and·there·is·no·need·to·proceed·with·inference.$ $newline$ $indentation$ // $newline$ $indentation$ $//·otherwise,·c·includes,·for·all·i·(1·≤·i·≤·k)·where·ei·is·pertinent·to·applicability,·‹ei·→·fi·θ›.$ $newline$ $indentation$ return $whitespace$ optional . of ( constraintsetfromargumentssubstitution ( fs , $whitespace$ es , $whitespace$ theta , $whitespace$ k ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < constraintformulaset > $whitespace$ testforapplicabilitybystrictinvocation ( list < resolvedtype > $whitespace$ fs, $whitespace$ list < expression > $whitespace$ es, $whitespace$ substitution $whitespace$ theta ) { $newline$ $indentation$ int $whitespace$ n $whitespace$ = $whitespace$ fs. size ( ) ; $newline$ $indentation$ int $whitespace$ k $whitespace$ = $whitespace$ es. size ( ) ; $newline$ $indentation$ $indentation$ $whitespace$//asciiationif $whitespace$ if $whitespace$ ( $whitespace$ // $whitespace$ node $whitespace$ is $whitespace$ not $whitespace$ supported $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $			
constraintSetFromArgumentsSubstitution	708	718	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.125000461935997	LOW	"		private ConstraintFormulaSet constraintSetFromArgumentsSubstitution(List<ResolvedType> Fs, List<Expression> es, Substitution theta, int k){
		    ConstraintFormulaSet constraintFormulaSet = ConstraintFormulaSet.empty();
		    for (int i = 0; i < k; i++) {
		        Expression ei = es.get(i);
		        ResolvedType fi = Fs.get(i);
		        ResolvedType fiTheta = typeWithSubstitution(fi, theta);
		        constraintFormulaSet = constraintFormulaSet.withConstraint(new ExpressionCompatibleWithType(typeSolver, ei, fiTheta));
		    }
		    return constraintFormulaSet;
		}"	$indentation$ private $whitespace$ constraintformulaset $whitespace$ constraintsetfromargumentssubstitution ( list < resolvedtype > $whitespace$ fs , $whitespace$ list < expression > $whitespace$ es , $whitespace$ substitution $whitespace$ theta , $whitespace$ int $whitespace$ k ) { $newline$ $indentation$ constraintformulaset $whitespace$ constraintformulaset $whitespace$ = $whitespace$ constraintformulaset . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ k ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ ei $whitespace$ = $whitespace$ es . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ fi $whitespace$ = $whitespace$ fs . get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ fitheta $whitespace$ = $whitespace$ typewithsubstitution ( fi , $whitespace$ theta ) ; $newline$ $indentation$ constraintformulaset $whitespace$ = $whitespace$ constraintformulaset . withconstraint ( new $whitespace$ expressioncompatiblewithtype ( typesolver , $whitespace$ ei , $whitespace$ fitheta ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ constraintformulaset ; $newline$ $indentation$ }	$indentation$ private $whitespace$ constraintformulaset $whitespace$ constraintsetfromargumentssubstitution ( list < resolvedtype > $whitespace$ fs, $whitespace$ list < expression > $whitespace$ es, $whitespace$ substitution $whitespace$ theta, $whitespace$ int $whitespace$ k ) { $newline$ $indentation$ constraintformulaset $whitespace$ constraintformulaset $whitespace$ = $whitespace$ constraintformulaset. empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ k ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ expression $whitespace$ ei $whitespace$ = $whitespace$ es. get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ fi $whitespace$ = $whitespace$ fs. get ( i ) ; $newline$ $indentation$ resolvedtype $whitespace$ fitheta $whitespace$ = $whitespace$ typewithsubstitution ( fi, $whitespace$ theta ) ; $newline$ $indentation$ constraintformulaset $whitespace$ = $whitespace$ constraintformulaset. withconstraint ( new $whitespace$ expressioncompatiblewithtype ( typesolver, $whitespace$ ei, $whitespace$ fitheta ) ) ; $newline$ $indentation$ return $whitespace$ constraintformulaset ; $newline$ $indentation$ }			
toMethodUsage	63	70	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.1897926032543182	LOW	"		public static MethodUsage toMethodUsage(MethodCallExpr call, ResolvedMethodDeclaration methodDeclaration, TypeSolver typeSolver){
		    TypeInference typeInference = new TypeInference(typeSolver);
		    Optional<InstantiationSet> instantiationSetOpt = typeInference.instantiationInference(call, methodDeclaration);
		    if (instantiationSetOpt.isPresent()) {
		        return instantiationSetToMethodUsage(methodDeclaration, instantiationSetOpt.get());
		    }
		    throw new IllegalArgumentException();
		}"	$indentation$ public $whitespace$ static $whitespace$ methodusage $whitespace$ tomethodusage ( methodcallexpr $whitespace$ call , $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration , $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ typeinference $whitespace$ typeinference $whitespace$ = $whitespace$ new $whitespace$ typeinference ( typesolver ) ; $newline$ $indentation$ optional < instantiationset > $whitespace$ instantiationsetopt $whitespace$ = $whitespace$ typeinference . instantiationinference ( call , $whitespace$ methoddeclaration ) ; $newline$ $indentation$ if $whitespace$ ( instantiationsetopt . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ instantiationsettomethodusage ( methoddeclaration , $whitespace$ instantiationsetopt . get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ methodusage $whitespace$ tomethodusage ( methodcallexpr $whitespace$ call, $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration, $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ typeinference $whitespace$ typeinference $whitespace$ = $whitespace$ new $whitespace$ typeinference ( typesolver ) ; $newline$ $indentation$ int $whitespace$ idx $whitespace$ = $whitespace$ methoddeclaration. haschild ( methoddeclaration ) ; $newline$ $indentation$ return $whitespace$participusage ( methoddeclaration, $whitespace$ idx ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ static $whitespace$ methodusage $whitespace$ tomethod ( methodcallexpr $whitespace$ methoddeclaration, $whitespace$ resolvedmethoddeclaration $whitespace$ typesolver ) { $newline$ $indentation$ typeinference $whitespace$ typeinference $whitespace$ = $whitespace$ new $whitespace$ typeinference ( typesolver ) ; $newline$ $indentation$ return $whitespace$ instantiationsettomethodusage ( methoddeclaration, $whitespace$ instantiationsetopt. get ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ }			
moreSpecificMethodInference	404	491	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.2233246862888336	LOW	"		public boolean moreSpecificMethodInference(MethodCallExpr methodCall, ResolvedMethodDeclaration m1, ResolvedMethodDeclaration m2){
		    // When testing that one applicable method is more specific than another (§15.12.2.5), where the second method
		    // is generic, it is necessary to test whether some instantiation of the second method's type parameters can be
		    // inferred to make the first method more specific than the second.
		    if (!m2.isGeneric()) {
		        throw new IllegalArgumentException(""M2 is not generic (m2: "" + m2 + "")"");
		    }
		    // Let m1 be the first method and m2 be the second method. Where m2 has type parameters P1, ..., Pp,
		    // let α1, ..., αp be inference variables, and let θ be the substitution [P1:=α1, ..., Pp:=αp].
		    //
		    // Let e1, ..., ek be the argument expressions of the corresponding invocation. Then:
		    //
		    // - If m1 and m2 are applicable by strict or loose invocation (§15.12.2.2, §15.12.2.3), then let S1, ..., Sk be the formal parameter types of m1, and let T1, ..., Tk be the result of θ applied to the formal parameter types of m2.
		    //
		    // - If m1 and m2 are applicable by variable arity invocation (§15.12.2.4), then let S1, ..., Sk be the first k variable arity parameter types of m1, and let T1, ..., Tk be the result of θ applied to the first k variable arity parameter types of m2.
		    //
		    // Note that no substitution is applied to S1, ..., Sk; even if m1 is generic, the type parameters of m1 are treated as type variables, not inference variables.
		    //
		    // The process to determine if m1 is more specific than m2 is as follows:
		    //
		    // - First, an initial bound set, B, is constructed from the declared bounds of P1, ..., Pp, as specified in §18.1.3.
		    //
		    // - Second, for all i (1 ≤ i ≤ k), a set of constraint formulas or bounds is generated.
		    //
		    //   If Ti is a proper type, the result is true if Si is more specific than Ti for ei (§15.12.2.5), and false otherwise. (Note that Si is always a proper type.)
		    //
		    //   Otherwise, if Ti is not a functional interface type, the constraint formula ‹Si <: Ti› is generated.
		    //
		    //   Otherwise, Ti is a parameterization of a functional interface, I. It must be determined whether Si satisfies the following five conditions:
		    //
		    //   1. Si is a functional interface type.
		    //
		    //   2. Si is not a superinterface of I, nor a parameterization of a superinterface of I.
		    //
		    //   3. Si is not a subinterface of I, nor a parameterization of a subinterface of I.
		    //
		    //   4. If Si is an intersection type, at least one element of the intersection is not a superinterface of I, nor a parameterization of a superinterface of I.
		    //
		    //   5. If Si is an intersection type, no element of the intersection is a subinterface of I, nor a parameterization of a subinterface of I.
		    //
		    //   If all five conditions are true, then the following constraint formulas or bounds are generated (where U1 ... Uk and R1 are the parameter types and return type of the function type of the capture of Si, and V1 ... Vk and R2 are the parameter types and return type of the function type of Ti):
		    //
		    //   - If ei is an explicitly typed lambda expression:
		    //
		    //     - For all j (1 ≤ j ≤ k), ‹Uj = Vj›.
		    //
		    //     - If R2 is void, true.
		    //
		    //     - Otherwise, if R1 and R2 are functional interface types, and neither interface is a subinterface of the other, and ei has at least one result expression, then these rules are applied recursively to R1 and R2, for each result expression in ei.
		    //
		    //     - Otherwise, if R1 is a primitive type and R2 is not, and ei has at least one result expression, and each result expression of ei is a standalone expression (§15.2) of a primitive type, true.
		    //
		    //     - Otherwise, if R2 is a primitive type and R1 is not, and ei has at least one result expression, and each result expression of ei is either a standalone expression of a reference type or a poly expression, true.
		    //
		    //     - Otherwise, ‹R1 <: R2›.
		    //
		    //   - If ei is an exact method reference:
		    //
		    //     - For all j (1 ≤ j ≤ k), ‹Uj = Vj›.
		    //
		    //     - If R2 is void, true.
		    //
		    //     - Otherwise, if R1 is a primitive type and R2 is not, and the compile-time declaration for ei has a primitive return type, true.
		    //
		    //     - Otherwise if R2 is a primitive type and R1 is not, and the compile-time declaration for ei has a reference return type, true.
		    //
		    //     - Otherwise, ‹R1 <: R2›.
		    //
		    //   - If ei is a parenthesized expression, these rules are applied recursively to the contained expression.
		    //
		    //   - If ei is a conditional expression, these rules are applied recursively to each of the second and third operands.
		    //
		    //   - Otherwise, false.
		    //
		    //   If the five constraints on Si are not satisfied, the constraint formula ‹Si <: Ti› is generated instead.
		    //
		    // - Third, if m2 is applicable by variable arity invocation and has k+1 parameters, then where Sk+1 is the k+1'th variable arity parameter type of m1 and Tk+1 is the result of θ applied to the k+1'th variable arity parameter type of m2, the constraint ‹Sk+1 <: Tk+1› is generated.
		    //
		    // - Fourth, the generated bounds and constraint formulas are reduced and incorporated with B to produce a bound set B'.
		    //
		    //   If B' does not contain the bound false, and resolution of all the inference variables in B' succeeds, then m1 is more specific than m2.
		    //
		    //   Otherwise, m1 is not more specific than m2.
		    throw new UnsupportedOperationException();
		}"	$indentation$ public $whitespace$ boolean $whitespace$ morespecificmethodinference ( methodcallexpr $whitespace$ methodcall , $whitespace$ resolvedmethoddeclaration $whitespace$ m1 , $whitespace$ resolvedmethoddeclaration $whitespace$ m2 ) { $newline$ $indentation$ $//·when·testing·that·one·applicable·method·is·more·specific·than·another·(§15.12.2.5),·where·the·second·method$ $newline$ $indentation$ $//·is·generic,·it·is·necessary·to·test·whether·some·instantiation·of·the·second·method's·type·parameters·can·be$ $newline$ $indentation$ $//·inferred·to·make·the·first·method·more·specific·than·the·second.$ $newline$ $indentation$ if $whitespace$ ( ! m2 . isgeneric ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·let·m1·be·the·first·method·and·m2·be·the·second·method.·where·m2·has·type·parameters·p1,·...,·pp,$ $newline$ $indentation$ $//·let·α1,·...,·αp·be·inference·variables,·and·let·θ·be·the·substitution·[p1:=α1,·...,·pp:=αp].$ $newline$ $indentation$ // $newline$ $indentation$ $//·let·e1,·...,·ek·be·the·argument·expressions·of·the·corresponding·invocation.·then:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·m1·and·m2·are·applicable·by·strict·or·loose·invocation·(§15.12.2.2,·§15.12.2.3),·then·let·s1,·...,·sk·be·the·formal·parameter·types·of·m1,·and·let·t1,·...,·tk·be·the·result·of·θ·applied·to·the·formal·parameter·types·of·m2.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·m1·and·m2·are·applicable·by·variable·arity·invocation·(§15.12.2.4),·then·let·s1,·...,·sk·be·the·first·k·variable·arity·parameter·types·of·m1,·and·let·t1,·...,·tk·be·the·result·of·θ·applied·to·the·first·k·variable·arity·parameter·types·of·m2.$ $newline$ $indentation$ // $newline$ $indentation$ $//·note·that·no·substitution·is·applied·to·s1,·...,·sk;·even·if·m1·is·generic,·the·type·parameters·of·m1·are·treated·as·type·variables,·not·inference·variables.$ $newline$ $indentation$ // $newline$ $indentation$ $//·the·process·to·determine·if·m1·is·more·specific·than·m2·is·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·first,·an·initial·bound·set,·b,·is·constructed·from·the·declared·bounds·of·p1,·...,·pp,·as·specified·in·§18.1.3.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·second,·for·all·i·(1·≤·i·≤·k),·a·set·of·constraint·formulas·or·bounds·is·generated.$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·ti·is·a·proper·type,·the·result·is·true·if·si·is·more·specific·than·ti·for·ei·(§15.12.2.5),·and·false·otherwise.·(note·that·si·is·always·a·proper·type.)$ $newline$ $indentation$ // $newline$ $indentation$ $//···otherwise,·if·ti·is·not·a·functional·interface·type,·the·constraint·formula·‹si·<:·ti›·is·generated.$ $newline$ $indentation$ // $newline$ $indentation$ $//···otherwise,·ti·is·a·parameterization·of·a·functional·interface,·i.·it·must·be·determined·whether·si·satisfies·the·following·five·conditions:$ $newline$ $indentation$ // $newline$ $indentation$ $//···1.·si·is·a·functional·interface·type.$ $newline$ $indentation$ // $newline$ $indentation$ $//···2.·si·is·not·a·superinterface·of·i,·nor·a·parameterization·of·a·superinterface·of·i.$ $newline$ $indentation$ // $newline$ $indentation$ $//···3.·si·is·not·a·subinterface·of·i,·nor·a·parameterization·of·a·subinterface·of·i.$ $newline$ $indentation$ // $newline$ $indentation$ $//···4.·if·si·is·an·intersection·type,·at·least·one·element·of·the·intersection·is·not·a·superinterface·of·i,·nor·a·parameterization·of·a·superinterface·of·i.$ $newline$ $indentation$ // $newline$ $indentation$ $//···5.·if·si·is·an·intersection·type,·no·element·of·the·intersection·is·a·subinterface·of·i,·nor·a·parameterization·of·a·subinterface·of·i.$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·all·five·conditions·are·true,·then·the·following·constraint·formulas·or·bounds·are·generated·(where·u1·...·uk·and·r1·are·the·parameter·types·and·return·type·of·the·function·type·of·the·capture·of·si,·and·v1·...·vk·and·r2·are·the·parameter·types·and·return·type·of·the·function·type·of·ti):$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·ei·is·an·explicitly·typed·lambda·expression:$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·for·all·j·(1·≤·j·≤·k),·‹uj·=·vj›.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·if·r2·is·void,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·if·r1·and·r2·are·functional·interface·types,·and·neither·interface·is·a·subinterface·of·the·other,·and·ei·has·at·least·one·result·expression,·then·these·rules·are·applied·recursively·to·r1·and·r2,·for·each·result·expression·in·ei.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·if·r1·is·a·primitive·type·and·r2·is·not,·and·ei·has·at·least·one·result·expression,·and·each·result·expression·of·ei·is·a·standalone·expression·(§15.2)·of·a·primitive·type,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·if·r2·is·a·primitive·type·and·r1·is·not,·and·ei·has·at·least·one·result·expression,·and·each·result·expression·of·ei·is·either·a·standalone·expression·of·a·reference·type·or·a·poly·expression,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·‹r1·<:·r2›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·ei·is·an·exact·method·reference:$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·for·all·j·(1·≤·j·≤·k),·‹uj·=·vj›.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·if·r2·is·void,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·if·r1·is·a·primitive·type·and·r2·is·not,·and·the·compile-time·declaration·for·ei·has·a·primitive·return·type,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise·if·r2·is·a·primitive·type·and·r1·is·not,·and·the·compile-time·declaration·for·ei·has·a·reference·return·type,·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//·····-·otherwise,·‹r1·<:·r2›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·ei·is·a·parenthesized·expression,·these·rules·are·applied·recursively·to·the·contained·expression.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·ei·is·a·conditional·expression,·these·rules·are·applied·recursively·to·each·of·the·second·and·third·operands.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·otherwise,·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·the·five·constraints·on·si·are·not·satisfied,·the·constraint·formula·‹si·<:·ti›·is·generated·instead.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·third,·if·m2·is·applicable·by·variable·arity·invocation·and·has·k+1·parameters,·then·where·sk+1·is·the·k+1'th·variable·arity·parameter·type·of·m1·and·tk+1·is·the·result·of·θ·applied·to·the·k+1'th·variable·arity·parameter·type·of·m2,·the·constraint·‹sk+1·<:·tk+1›·is·generated.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·fourth,·the·generated·bounds·and·constraint·formulas·are·reduced·and·incorporated·with·b·to·produce·a·bound·set·b'.$ $newline$ $indentation$ // $newline$ $indentation$ $//···if·b'·does·not·contain·the·bound·false,·and·resolution·of·all·the·inference·variables·in·b'·succeeds,·then·m1·is·more·specific·than·m2.$ $newline$ $indentation$ // $newline$ $indentation$ $//···otherwise,·m1·is·not·more·specific·than·m2.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ morespecificmethodinference ( methodcallexpr $whitespace$ methodcall, $whitespace$ resolvedmethoddeclaration $whitespace$ m1, $whitespace$ resolvedmethoddeclaration $whitespace$ m2 ) { $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ @formatter:off $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$//////////////////////////////////let $whitespace$ = $whitespace$ // $whitespace$ @formatter:off $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$//////////////////////////////////let $whitespace$ = $whitespace$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$//////////////////////////////////let $whitespace$ = $whitespace$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$//////////////////////////////////let $whitespace$ = $whitespace$ // $whitespace$ @formatter:on $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ m2 $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ $whitespace$//////////////////////////////////let $whitespace$ = $whitespace$ // $whitespace$ @formatter:			
formalParameterTypes	576	582	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.2369850575923919	LOW	"		private List<ResolvedType> formalParameterTypes(ResolvedMethodDeclaration methodDeclaration){
		    List<ResolvedType> types = new LinkedList<>();
		    for (int i = 0; i < methodDeclaration.getNumberOfParams(); i++) {
		        types.add(methodDeclaration.getParam(i).getType());
		    }
		    return types;
		}"	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ formalparametertypes ( resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ types $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration . getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ types . add ( methoddeclaration . getparam ( i ) . gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ types ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < resolvedtype > $whitespace$ formalparametertypes ( resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ list < resolvedtype > $whitespace$ types $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ methoddeclaration. getnumberofparams ( ) ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ types. add ( methoddeclaration. getparam ( i ). gettype ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ types ; $newline$ $indentation$ }			
functionalInterfaceParameterizationInference	348	396	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.6324297189712524	MID	"		public void functionalInterfaceParameterizationInference(LambdaExpr lambdaExpr, ResolvedInterfaceDeclaration interfaceDeclaration){
		    // Where a lambda expression with explicit parameter types P1, ..., Pn targets a functional interface
		    // type F<A1, ..., Am> with at least one wildcard type argument, then a parameterization of F may be derived
		    // as the ground target type of the lambda expression as follows.
		    int n = lambdaExpr.getParameters().size();
		    if (interfaceDeclaration.getTypeParameters().isEmpty()) {
		        throw new IllegalArgumentException(""Functional Interface without type arguments"");
		    }
		    // Let Q1, ..., Qk be the parameter types of the function type of the type F<α1, ..., αm>,
		    // where α1, ..., αm are fresh inference variables.
		    int k = interfaceDeclaration.getTypeParameters().size();
		    List<InferenceVariable> alphas = InferenceVariable.instantiate(interfaceDeclaration.getTypeParameters());
		    TypeInferenceCache.recordInferenceVariables(typeSolver, lambdaExpr, alphas);
		    // If n ≠ k, no valid parameterization exists.
		    if (n != k) {
		        throw new IllegalArgumentException(""No valida parameterization can exist has n="" + "" and k="" + k);
		    }
		    // Otherwise, a set of constraint formulas is formed with, for
		    // all i (1 ≤ i ≤ n), ‹Pi = Qi›. This constraint formula set is reduced to form the bound set B.
		    ConstraintFormulaSet constraintFormulaSet = ConstraintFormulaSet.empty();
		    for (int i = 0; i < n; i++) {
		        throw new UnsupportedOperationException();
		        //Type pi = JavaParserFacade.get(typeSolver).convertToUsage(lambdaExpr.getParameters().get(i).getType(), lambdaExpr);
		        //Type qi = JavaParserFacade.get(typeSolver).convertToUsage(interfaceDeclaration.getm.get(i).getType(), lambdaExpr);
		        //constraintFormulaSet = constraintFormulaSet.withConstraint(new TypeSameAsType(pi, qi));
		    }
		    BoundSet B = constraintFormulaSet.reduce(typeSolver);
		    // If B contains the bound false, no valid parameterization exists. Otherwise, a new parameterization of the
		    // functional interface type, F<A'1, ..., A'm>, is constructed as follows, for 1 ≤ i ≤ m:
		    //
		    // - If B contains an instantiation (§18.1.3) for αi, T, then A'i = T.
		    //
		    // - Otherwise, A'i = Ai.
		    //
		    // If F<A'1, ..., A'm> is not a well-formed type (that is, the type arguments are not within their bounds), or if F<A'1, ..., A'm> is not a subtype of F<A1, ..., Am>, no valid parameterization exists. Otherwise, the inferred parameterization is either F<A'1, ..., A'm>, if all the type arguments are types, or the non-wildcard parameterization (§9.9) of F<A'1, ..., A'm>, if one or more type arguments are still wildcards.
		    throw new UnsupportedOperationException();
		}"	$indentation$ public $whitespace$ void $whitespace$ functionalinterfaceparameterizationinference ( lambdaexpr $whitespace$ lambdaexpr , $whitespace$ resolvedinterfacedeclaration $whitespace$ interfacedeclaration ) { $newline$ $indentation$ $//·where·a·lambda·expression·with·explicit·parameter·types·p1,·...,·pn·targets·a·functional·interface$ $newline$ $indentation$ $//·type·f<a1,·...,·am>·with·at·least·one·wildcard·type·argument,·then·a·parameterization·of·f·may·be·derived$ $newline$ $indentation$ $//·as·the·ground·target·type·of·the·lambda·expression·as·follows.$ $newline$ $indentation$ int $whitespace$ n $whitespace$ = $whitespace$ lambdaexpr . getparameters ( ) . size ( ) ; $newline$ $indentation$ if $whitespace$ ( interfacedeclaration . gettypeparameters ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·let·q1,·...,·qk·be·the·parameter·types·of·the·function·type·of·the·type·f<α1,·...,·αm>,$ $newline$ $indentation$ $//·where·α1,·...,·αm·are·fresh·inference·variables.$ $newline$ $indentation$ int $whitespace$ k $whitespace$ = $whitespace$ interfacedeclaration . gettypeparameters ( ) . size ( ) ; $newline$ $indentation$ list < inferencevariable > $whitespace$ alphas $whitespace$ = $whitespace$ inferencevariable . instantiate ( interfacedeclaration . gettypeparameters ( ) ) ; $newline$ $indentation$ typeinferencecache . recordinferencevariables ( typesolver , $whitespace$ lambdaexpr , $whitespace$ alphas ) ; $newline$ $indentation$ $//·if·n·≠·k,·no·valid·parameterization·exists.$ $newline$ $indentation$ if $whitespace$ ( n $whitespace$ != $whitespace$ k ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ k ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise,·a·set·of·constraint·formulas·is·formed·with,·for$ $newline$ $indentation$ $//·all·i·(1·≤·i·≤·n),·‹pi·=·qi›.·this·constraint·formula·set·is·reduced·to·form·the·bound·set·b.$ $newline$ $indentation$ constraintformulaset $whitespace$ constraintformulaset $whitespace$ = $whitespace$ constraintformulaset . empty ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ $number$ ; $whitespace$ i $whitespace$ < $whitespace$ n ; $whitespace$ i ++ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ $//type·pi·=·javaparserfacade.get(typesolver).converttousage(lambdaexpr.getparameters().get(i).gettype(),·lambdaexpr);$ $newline$ $indentation$ $//type·qi·=·javaparserfacade.get(typesolver).converttousage(interfacedeclaration.getm.get(i).gettype(),·lambdaexpr);$ $newline$ $indentation$ $//constraintformulaset·=·constraintformulaset.withconstraint(new·typesameastype(pi,·qi));$ $newline$ $indentation$ } $newline$ $indentation$ boundset $whitespace$ b $whitespace$ = $whitespace$ constraintformulaset . reduce ( typesolver ) ; $newline$ $indentation$ $//·if·b·contains·the·bound·false,·no·valid·parameterization·exists.·otherwise,·a·new·parameterization·of·the$ $newline$ $indentation$ $//·functional·interface·type,·f<a'1,·...,·a'm>,·is·constructed·as·follows,·for·1·≤·i·≤·m:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·b·contains·an·instantiation·(§18.1.3)·for·αi,·t,·then·a'i·=·t.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·a'i·=·ai.$ $newline$ $indentation$ // $newline$ $indentation$ $//·if·f<a'1,·...,·a'm>·is·not·a·well-formed·type·(that·is,·the·type·arguments·are·not·within·their·bounds),·or·if·f<a'1,·...,·a'm>·is·not·a·subtype·of·f<a1,·...,·am>,·no·valid·parameterization·exists.·otherwise,·the·inferred·parameterization·is·either·f<a'1,·...,·a'm>,·if·all·the·type·arguments·are·types,·or·the·non-wildcard·parameterization·(§9.9)·of·f<a'1,·...,·a'm>,·if·one·or·more·type·arguments·are·still·wildcards.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ functionalinterfaceparameterizationinference ( lambdaexpr $whitespace$ lambdaexpr, $whitespace$ resolvedinterfacedeclaration $whitespace$ interfacedeclaration ) { $newline$ $indentation$ $indentation$ $string$ $whitespace$ + $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$ if $whitespace$ ( interfacedeclaration. gettypeparameters ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$ if $whitespace$ ( interfacedeclaration. gettypeparameters ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$ if $whitespace$ ( interfacedeclaration. gettypeparameters ( ). isempty ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ _ $whitespace$ = $whitespace$ lambdaexpr. getparameters ( ). size ( ) ; $newline$ $indentation$			
invocationApplicabilityInference	165	194	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInference.java	0.7204157710075378	MID	"		public boolean invocationApplicabilityInference(MethodCallExpr methodCallExpr, ResolvedMethodDeclaration methodDeclaration){
		    if (!methodCallExpr.getNameAsString().equals(methodDeclaration.getName())) {
		        throw new IllegalArgumentException();
		    }
		    Optional<InstantiationSet> partial = instantiationInference(methodCallExpr, methodDeclaration);
		    if (!partial.isPresent()) {
		        return false;
		    }
		    int nActualParams = methodCallExpr.getArguments().size();
		    int nFormalParams = methodDeclaration.getNumberOfParams();
		    if (nActualParams != nFormalParams) {
		        if (methodDeclaration.hasVariadicParameter()) {
		            if (nActualParams < (nFormalParams - 1)) {
		                return false;
		            }
		        } else {
		            return false;
		        }
		    }
		    //MethodUsage methodUsage = instantiationSetToMethodUsage(methodDeclaration, partial.get());
		    //        for (int i=0;i<nActualParams;i++) {
		    //            int formalIndex = i >= nFormalParams ? nFormalParams - 1 : i;
		    //            Type formalType = methodDeclaration.getParam(formalIndex).getType();
		    //            Type actualType = JavaParserFacade.get(typeSolver).getType(methodCallExpr.getArgument(i));
		    //            //if (!formalType.isAssignableBy(actualType)) {
		    //            //    return false;
		    //            //}
		    //        }
		    return true;
		}"	$indentation$ public $whitespace$ boolean $whitespace$ invocationapplicabilityinference ( methodcallexpr $whitespace$ methodcallexpr , $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ if $whitespace$ ( ! methodcallexpr . getnameasstring ( ) . equals ( methoddeclaration . getname ( ) ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalargumentexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ optional < instantiationset > $whitespace$ partial $whitespace$ = $whitespace$ instantiationinference ( methodcallexpr , $whitespace$ methoddeclaration ) ; $newline$ $indentation$ if $whitespace$ ( ! partial . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ nactualparams $whitespace$ = $whitespace$ methodcallexpr . getarguments ( ) . size ( ) ; $newline$ $indentation$ int $whitespace$ nformalparams $whitespace$ = $whitespace$ methoddeclaration . getnumberofparams ( ) ; $newline$ $indentation$ if $whitespace$ ( nactualparams $whitespace$ != $whitespace$ nformalparams ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( methoddeclaration . hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nactualparams $whitespace$ < $whitespace$ ( nformalparams $whitespace$ - $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ $//methodusage·methodusage·=·instantiationsettomethodusage(methoddeclaration,·partial.get());$ $newline$ $indentation$ $//········for·(int·i=0;i<nactualparams;i++)·{$ $newline$ $indentation$ $//············int·formalindex·=·i·>=·nformalparams·?·nformalparams·-·1·:·i;$ $newline$ $indentation$ $//············type·formaltype·=·methoddeclaration.getparam(formalindex).gettype();$ $newline$ $indentation$ $//············type·actualtype·=·javaparserfacade.get(typesolver).gettype(methodcallexpr.getargument(i));$ $newline$ $indentation$ $//············//if·(!formaltype.isassignableby(actualtype))·{$ $newline$ $indentation$ $//············//····return·false;$ $newline$ $indentation$ $//············//}$ $newline$ $indentation$ $//········}$ $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ }	$indentation$ public $whitespace$ boolean $whitespace$ invocationapplicabilityinference ( methodcallexpr $whitespace$ methodcallexpr, $whitespace$ resolvedmethoddeclaration $whitespace$ methoddeclaration ) { $newline$ $indentation$ string $whitespace$ numasstring $whitespace$ = $whitespace$ methodcallexpr. getnameasstring ( ) ; $newline$ $indentation$ if $whitespace$ (! methodcallexpr. getnameasstring ( ). equals ( methoddeclaration. getname ( ) ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ optional < instantiationset > $whitespace$ partial $whitespace$ = $whitespace$ instantiationinference ( methodcallexpr, $whitespace$ methoddeclaration ) ; $newline$ $indentation$ if $whitespace$ (! partial. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ int $whitespace$ nactualparams $whitespace$ = $whitespace$ methodcallexpr. getarguments ( ). size ( ) ; $newline$ $indentation$ int $whitespace$ nformalparams $whitespace$ = $whitespace$ methoddeclaration. getnumberofparams ( ) ; $newline$ $indentation$ if $whitespace$ ( nactualparams $whitespace$!= $whitespace$ nformalparams ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( methoddeclaration. hasvariadicparameter ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( nactualparams $whitespace$ < $whitespace$ ( nformalparams $whitespace$ - $whitespace$ $number$ ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$			
recordInferenceVariables	61	66	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java	0.1206015571951866	LOW	"		public static void recordInferenceVariables(TypeSolver typeSolver, LambdaExpr lambdaExpr, List<InferenceVariable> _inferenceVariables){
		    if (!inferenceVariables.containsKey(typeSolver)) {
		        inferenceVariables.put(typeSolver, new IdentityHashMap<>());
		    }
		    inferenceVariables.get(typeSolver).put(lambdaExpr, _inferenceVariables);
		}"	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ recordinferencevariables ( typesolver $whitespace$ typesolver , $whitespace$ lambdaexpr $whitespace$ lambdaexpr , $whitespace$ list < inferencevariable > $whitespace$ _inferencevariables ) { $newline$ $indentation$ if $whitespace$ ( ! inferencevariables . containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ inferencevariables . put ( typesolver , $whitespace$ new $whitespace$ identityhashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ inferencevariables . get ( typesolver ) . put ( lambdaexpr , $whitespace$ _inferencevariables ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ recordinferencevariables ( typesolver $whitespace$ typesolver, $whitespace$ lambdaexpr $whitespace$ lambdaexpr, $whitespace$ list < inferencevariable > $whitespace$ _inferencevariables ) { $newline$ $indentation$ if $whitespace$ (! inferencevariables. containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ inferencevariables. put ( typesolver, $whitespace$ new $whitespace$ identityhashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ inferencevariables. get ( typesolver ). put ( lambdaexpr, $whitespace$ _inferencevariables ) ; $newline$ $indentation$ }			
addRecord	38	46	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java	0.136798694729805	LOW	"		public static void addRecord(TypeSolver typeSolver, LambdaExpr lambdaExpr, String paramName, ResolvedType type){
		    if (!typeForLambdaParameters.containsKey(typeSolver)) {
		        typeForLambdaParameters.put(typeSolver, new IdentityHashMap<>());
		    }
		    if (!typeForLambdaParameters.get(typeSolver).containsKey(lambdaExpr)) {
		        typeForLambdaParameters.get(typeSolver).put(lambdaExpr, new HashMap<>());
		    }
		    typeForLambdaParameters.get(typeSolver).get(lambdaExpr).put(paramName, type);
		}"	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ addrecord ( typesolver $whitespace$ typesolver , $whitespace$ lambdaexpr $whitespace$ lambdaexpr , $whitespace$ string $whitespace$ paramname , $whitespace$ resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ ( ! typeforlambdaparameters . containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ typeforlambdaparameters . put ( typesolver , $whitespace$ new $whitespace$ identityhashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! typeforlambdaparameters . get ( typesolver ) . containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ typeforlambdaparameters . get ( typesolver ) . put ( lambdaexpr , $whitespace$ new $whitespace$ hashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ typeforlambdaparameters . get ( typesolver ) . get ( lambdaexpr ) . put ( paramname , $whitespace$ type ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ void $whitespace$ addrecord ( typesolver $whitespace$ typesolver, $whitespace$ lambdaexpr $whitespace$ lambdaexpr, $whitespace$ string $whitespace$ paramname, $whitespace$ resolvedtype $whitespace$ type ) { $newline$ $indentation$ if $whitespace$ (! typeforlambdaparameters. containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ typeforlambdaparameters. put ( typesolver, $whitespace$ new $whitespace$ identityhashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! typeforlambdaparameters. get ( typesolver ). containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ typeforlambdaparameters. get ( typesolver ). put ( lambdaexpr, $whitespace$ new $whitespace$ hashmap < > ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ typeforlambdaparameters. get ( typesolver ). get ( lambdaexpr ). put ( paramname, $whitespace$ type ) ; $newline$ $indentation$ }			
retrieve	48	59	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java	0.2369334846735	LOW	"		public static Optional<ResolvedType> retrieve(TypeSolver typeSolver, LambdaExpr lambdaExpr, String paramName){
		    if (!typeForLambdaParameters.containsKey(typeSolver)) {
		        return Optional.empty();
		    }
		    if (!typeForLambdaParameters.get(typeSolver).containsKey(lambdaExpr)) {
		        return Optional.empty();
		    }
		    if (!typeForLambdaParameters.get(typeSolver).get(lambdaExpr).containsKey(paramName)) {
		        return Optional.empty();
		    }
		    return Optional.of(typeForLambdaParameters.get(typeSolver).get(lambdaExpr).get(paramName));
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < resolvedtype > $whitespace$ retrieve ( typesolver $whitespace$ typesolver , $whitespace$ lambdaexpr $whitespace$ lambdaexpr , $whitespace$ string $whitespace$ paramname ) { $newline$ $indentation$ if $whitespace$ ( ! typeforlambdaparameters . containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! typeforlambdaparameters . get ( typesolver ) . containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! typeforlambdaparameters . get ( typesolver ) . get ( lambdaexpr ) . containskey ( paramname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( typeforlambdaparameters . get ( typesolver ) . get ( lambdaexpr ) . get ( paramname ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < resolvedtype > $whitespace$ retrieve ( typesolver $whitespace$ typesolver, $whitespace$ lambdaexpr $whitespace$ lambdaexpr, $whitespace$ string $whitespace$ paramname ) { $newline$ $indentation$ if $whitespace$ (! typeforlambdaparameters. containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! typeforlambdaparameters. get ( typesolver ). containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! typeforlambdaparameters. get ( typesolver ). get ( lambdaexpr ). containskey ( paramname ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( typeforlambdaparameters. get ( typesolver ). get ( lambdaexpr ). get ( paramname ) ) ; $newline$ $indentation$ }			
retrieveInferenceVariables	68	76	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/TypeInferenceCache.java	0.2412062287330627	LOW	"		public static Optional<List<InferenceVariable>> retrieveInferenceVariables(TypeSolver typeSolver, LambdaExpr lambdaExpr){
		    if (!inferenceVariables.containsKey(typeSolver)) {
		        return Optional.empty();
		    }
		    if (!inferenceVariables.get(typeSolver).containsKey(lambdaExpr)) {
		        return Optional.empty();
		    }
		    return Optional.of(inferenceVariables.get(typeSolver).get(lambdaExpr));
		}"	$indentation$ public $whitespace$ static $whitespace$ optional < list < inferencevariable >> $whitespace$ retrieveinferencevariables ( typesolver $whitespace$ typesolver , $whitespace$ lambdaexpr $whitespace$ lambdaexpr ) { $newline$ $indentation$ if $whitespace$ ( ! inferencevariables . containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ! inferencevariables . get ( typesolver ) . containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . of ( inferencevariables . get ( typesolver ) . get ( lambdaexpr ) ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ optional < list < inferencevariable >> $whitespace$ retrieveinferencevariables ( typesolver $whitespace$ typesolver, $whitespace$ lambdaexpr $whitespace$ lambdaexpr ) { $newline$ $indentation$ if $whitespace$ (! inferencevariables. containskey ( typesolver ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! inferencevariables. get ( typesolver ). containskey ( lambdaexpr ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. of ( inferencevariables. get ( typesolver ). get ( lambdaexpr ) ) ; $newline$ $indentation$ }			
equals	65	74	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/CapturesBound.java	0.6403904557228088	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    CapturesBound that = (CapturesBound) o;
		    if (!inferenceVariables.equals(that.inferenceVariables))
		        return false;
		    return typesOrWildcards.equals(that.typesOrWildcards);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ capturesbound $whitespace$ that $whitespace$ = $whitespace$ ( capturesbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! inferencevariables . equals ( that . inferencevariables ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ typesorwildcards . equals ( that . typesorwildcards ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ capturesbound $whitespace$ that $whitespace$ = $whitespace$ ( capturesbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! inferencevariables. equals ( that. inferencevariables ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ typesorwildcards. equals ( that. typesorwildcards ) ; $newline$ $indentation$ }			
isAnInstantiation	97	106	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java	0.6020457148551941	MID	"		@Override
		public Optional<Instantiation> isAnInstantiation(){
		    if (s.isInferenceVariable() && isProperType(t)) {
		        return Optional.of(new Instantiation((InferenceVariable) s, t));
		    }
		    if (isProperType(s) && t.isInferenceVariable()) {
		        return Optional.of(new Instantiation((InferenceVariable) t, s));
		    }
		    return Optional.empty();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < instantiation > $whitespace$ isaninstantiation ( ) { $newline$ $indentation$ if $whitespace$ ( s . isinferencevariable ( ) $whitespace$ && $whitespace$ ispropertype ( t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ instantiation ( ( inferencevariable ) $whitespace$ s , $whitespace$ t ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ispropertype ( s ) $whitespace$ && $whitespace$ t . isinferencevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ instantiation ( ( inferencevariable ) $whitespace$ t , $whitespace$ s ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < instantiation > $whitespace$ isaninstantiation ( ) { $newline$ $indentation$ if $whitespace$ ( s. isinferencevariable ( ) $whitespace$ && $whitespace$ ispropertype ( t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ instantiation ( ( inferencevariable ) $whitespace$ s, $whitespace$ t ) ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( ispropertype ( s ) $whitespace$ && $whitespace$ t. isinferencevariable ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ instantiation ( ( inferencevariable ) $whitespace$ t, $whitespace$ s ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
hashCode	69	74	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = s.hashCode();
		    result = 31 * result + t.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	61	67	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SameAsBound.java	0.9294410943984984	HIGH	"		@Override
		public String toString(){
		    return ""SameAsBound{"" + ""s="" + s + "", t="" + t + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
isProperUpperBound	92	98	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java	0.6051073670387268	MID	"		@Override
		public Optional<ProperUpperBound> isProperUpperBound(){
		    if (s.isInferenceVariable() && isProperType(t)) {
		        return Optional.of(new ProperUpperBound((InferenceVariable) s, t));
		    }
		    return Optional.empty();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < properupperbound > $whitespace$ isproperupperbound ( ) { $newline$ $indentation$ if $whitespace$ ( s . isinferencevariable ( ) $whitespace$ && $whitespace$ ispropertype ( t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional . of ( new $whitespace$ properupperbound ( ( inferencevariable ) $whitespace$ s , $whitespace$ t ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ optional < properupperbound > $whitespace$ isproperupperbound ( ) { $newline$ $indentation$ if $whitespace$ ( s. isinferencevariable ( ) $whitespace$ && $whitespace$ ispropertype ( t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ optional. of ( new $whitespace$ properupperbound ( ( inferencevariable ) $whitespace$ s, $whitespace$ t ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ }			
equals	50	59	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java	0.7358553409576416	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    SubtypeOfBound that = (SubtypeOfBound) o;
		    if (!s.equals(that.s))
		        return false;
		    return t.equals(that.t);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ subtypeofbound $whitespace$ that $whitespace$ = $whitespace$ ( subtypeofbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! s . equals ( that . s ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ subtypeofbound $whitespace$ that $whitespace$ = $whitespace$ ( subtypeofbound ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! s. equals ( that. s ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
hashCode	69	74	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = s.hashCode();
		    result = 31 * result + t.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	61	67	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/SubtypeOfBound.java	0.9289677739143372	HIGH	"		@Override
		public String toString(){
		    return ""SubtypeOfBound{"" + ""s="" + s + "", t="" + t + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
equals	46	54	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/ThrowsBound.java	0.691494345664978	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ThrowsBound that = (ThrowsBound) o;
		    return inferenceVariable.equals(that.inferenceVariable);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ throwsbound $whitespace$ that $whitespace$ = $whitespace$ ( throwsbound ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ inferencevariable . equals ( that . inferencevariable ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ throwsbound $whitespace$ that $whitespace$ = $whitespace$ ( throwsbound ) $whitespace$ o ; $newline$ $indentation$ return $whitespace$ inferencevariable. equals ( that. inferencevariable ) ; $newline$ $indentation$ }			
toString	56	61	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/bounds/ThrowsBound.java	0.8658134341239929	HIGH	"		@Override
		public String toString(){
		    return ""ThrowsBound{"" + ""inferenceVariable="" + inferenceVariable + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ inferencevariable $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ inferencevariable $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
getAllReturnExpressions	292	297	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java	0.0430631265044212	LOW	"		private List<Expression> getAllReturnExpressions(BlockStmt blockStmt){
		    return blockStmt.findAll(ReturnStmt.class).stream().filter(r -> r.getExpression().isPresent()).map(r -> r.getExpression().get()).collect(toList());
		}"	$indentation$ private $whitespace$ list < expression > $whitespace$ getallreturnexpressions ( blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ return $whitespace$ blockstmt . findall ( returnstmt . class ) . stream ( ) . filter ( r $whitespace$ - > $whitespace$ r . getexpression ( ) . ispresent ( ) ) . map ( r $whitespace$ - > $whitespace$ r . getexpression ( ) . get ( ) ) . collect ( tolist ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ list < expression > $whitespace$ getallreturnexpressions ( blockstmt $whitespace$ blockstmt ) { $newline$ $indentation$ return $whitespace$ blockstmt. findall ( returnstmt. class ). stream ( ) $newline$ $indentation$. filter ( r $whitespace$ - > $whitespace$ r. getexpression ( ). ispresent ( ) ) $newline$ $indentation$. map ( r $whitespace$ - > $whitespace$ r. getexpression ( ). get ( ) ) $newline$ $indentation$. collect ( tolist ( ) ) ; $newline$ $indentation$ }			
replaceTypeVariablesWithInferenceVariables	342	351	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java	0.1297843903303146	LOW	"		private MethodType replaceTypeVariablesWithInferenceVariables(MethodType methodType){
		    // Find all type variable
		    Map<ResolvedTypeVariable, InferenceVariable> correspondences = new HashMap<>();
		    List<ResolvedType> newFormalArgumentTypes = new LinkedList<>();
		    for (ResolvedType formalArg : methodType.getFormalArgumentTypes()) {
		        newFormalArgumentTypes.add(replaceTypeVariablesWithInferenceVariables(formalArg, correspondences));
		    }
		    ResolvedType newReturnType = replaceTypeVariablesWithInferenceVariables(methodType.getReturnType(), correspondences);
		    return new MethodType(methodType.getTypeParameters(), newFormalArgumentTypes, newReturnType, methodType.getExceptionTypes());
		}"	$indentation$ private $whitespace$ methodtype $whitespace$ replacetypevariableswithinferencevariables ( methodtype $whitespace$ methodtype ) { $newline$ $indentation$ $//·find·all·type·variable$ $newline$ $indentation$ map < resolvedtypevariable , $whitespace$ inferencevariable > $whitespace$ correspondences $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ newformalargumenttypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ formalarg $whitespace$ : $whitespace$ methodtype . getformalargumenttypes ( ) ) $whitespace$ { $newline$ $indentation$ newformalargumenttypes . add ( replacetypevariableswithinferencevariables ( formalarg , $whitespace$ correspondences ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ newreturntype $whitespace$ = $whitespace$ replacetypevariableswithinferencevariables ( methodtype . getreturntype ( ) , $whitespace$ correspondences ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodtype ( methodtype . gettypeparameters ( ) , $whitespace$ newformalargumenttypes , $whitespace$ newreturntype , $whitespace$ methodtype . getexceptiontypes ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ methodtype $whitespace$ replacetypevariableswithinferencevariables ( methodtype $whitespace$ methodtype ) { $newline$ $indentation$ $////llscopescopefind $whitespace$ method $newline$ $indentation$ map < resolvedtypevariable, $whitespace$ inferencevariable > $whitespace$ correspondences $whitespace$ = $whitespace$ new $whitespace$ hashmap < > ( ) ; $newline$ $indentation$ list < resolvedtype > $whitespace$ newformalargumenttypes $whitespace$ = $whitespace$ new $whitespace$ linkedlist < > ( ) ; $newline$ $indentation$ for $whitespace$ ( resolvedtype $whitespace$ formalarg $whitespace$ : $whitespace$ methodtype. getformalargumenttypes ( ) ) $whitespace$ { $newline$ $indentation$ newformalargumenttypes. add ( replacetypevariableswithinferencevariables ( formalarg, $whitespace$ correspondences ) ) ; $newline$ $indentation$ } $newline$ $indentation$ resolvedtype $whitespace$ newreturntype $whitespace$ = $whitespace$ replacetypevariableswithinferencevariables ( methodtype. getreturntype ( ), $whitespace$ correspondences ) ; $newline$ $indentation$ return $whitespace$ new $whitespace$ methodtype ( methodtype. gettypeparameters ( ), $whitespace$ newformalargumenttypes, $whitespace$ newreturntype, $whitespace$ methodtype. getexceptiontypes ( ) ) ; $newline$ $indentation$ }			
equals	313	323	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java	0.637958288192749	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    ExpressionCompatibleWithType that = (ExpressionCompatibleWithType) o;
		    if (!typeSolver.equals(that.typeSolver))
		        return false;
		    if (!expression.equals(that.expression))
		        return false;
		    return T.equals(that.T);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ expressioncompatiblewithtype $whitespace$ that $whitespace$ = $whitespace$ ( expressioncompatiblewithtype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! typesolver . equals ( that . typesolver ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ if $whitespace$ ( ! expression . equals ( that . expression ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ expressioncompatiblewithtype $whitespace$ that $whitespace$ = $whitespace$ ( expressioncompatiblewithtype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! typesolver. equals ( that. typesolver ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ (! expression. equals ( that. expression ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
isValueCompatibleBlock	299	311	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/ExpressionCompatibleWithType.java	0.6865195631980896	MID	"		private boolean isValueCompatibleBlock(Statement statement){
		    // A block lambda body is value-compatible if it cannot complete normally (§14.21) and every return statement
		    // in the block has the form return Expression;.
		    if (statement.isBlockStmt()) {
		        if (!ControlFlowLogic.getInstance().canCompleteNormally(statement)) {
		            return true;
		        }
		        List<ReturnStmt> returnStmts = statement.findAll(ReturnStmt.class);
		        return returnStmts.stream().allMatch(r -> r.getExpression().isPresent());
		    }
		    return false;
		}"	$indentation$ private $whitespace$ boolean $whitespace$ isvaluecompatibleblock ( statement $whitespace$ statement ) { $newline$ $indentation$ $//·a·block·lambda·body·is·value-compatible·if·it·cannot·complete·normally·(§14.21)·and·every·return·statement$ $newline$ $indentation$ $//·in·the·block·has·the·form·return·expression;.$ $newline$ $indentation$ if $whitespace$ ( statement . isblockstmt ( ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( ! controlflowlogic . getinstance ( ) . cancompletenormally ( statement ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ list < returnstmt > $whitespace$ returnstmts $whitespace$ = $whitespace$ statement . findall ( returnstmt . class ) ; $newline$ $indentation$ return $whitespace$ returnstmts . stream ( ) . allmatch ( r $whitespace$ - > $whitespace$ r . getexpression ( ) . ispresent ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }	$indentation$ private $whitespace$ boolean $whitespace$ isvaluecompatibleblock ( statement $whitespace$ statement ) { $newline$ $indentation$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ if $whitespace$ ( statement. isblockstmt ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ collisiondetector. getinstance ( ). cancompletenormally ( statement ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ }			
equals	63	72	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java	0.6257871985435486	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    LambdaThrowsCompatibleWithType that = (LambdaThrowsCompatibleWithType) o;
		    if (!lambdaExpression.equals(that.lambdaExpression))
		        return false;
		    return T.equals(that.T);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ lambdathrowscompatiblewithtype $whitespace$ that $whitespace$ = $whitespace$ ( lambdathrowscompatiblewithtype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! lambdaexpression . equals ( that . lambdaexpression ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ boolean $whitespace$ ismultipleofequals $whitespace$ = $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ boolean $whitespace$ ismultipleoffive $whitespace$ = $whitespace$! lambdaexpression. equals ( that. lambdaexpression ) ; $newline$ $indentation$ if $whitespace$ ( ismultipleofequals ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( ismultipleoffive ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
hashCode	74	79	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java	0.8334941267967224	HIGH	"		@Override
		public int hashCode(){
		    int result = lambdaExpression.hashCode();
		    result = 31 * result + T.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ lambdaexpression . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ lambdaexpression. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	81	87	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java	0.8472117185592651	HIGH	"		@Override
		public String toString(){
		    return ""LambdaThrowsCompatibleWithType{"" + ""lambdaExpression="" + lambdaExpression + "", T="" + T + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ lambdaexpression $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ lambdaexpression $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
reduce	39	61	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/LambdaThrowsCompatibleWithType.java	0.9014711976051332	HIGH	"		@Override
		public ReductionResult reduce(BoundSet currentBoundSet){
		    // A constraint formula of the form ‹LambdaExpression →throws T› is reduced as follows:
		    //
		    // - If T is not a functional interface type (§9.8), the constraint reduces to false.
		    //
		    // - Otherwise, let the target function type for the lambda expression be determined as specified in §15.27.3. If no valid function type can be found, the constraint reduces to false.
		    //
		    // - Otherwise, if the lambda expression is implicitly typed, and one or more of the function type's parameter types is not a proper type, the constraint reduces to false.
		    //
		    //   This condition never arises in practice, due to the substitution applied to the target type in §18.5.2.
		    //
		    // - Otherwise, if the function type's return type is neither void nor a proper type, the constraint reduces to false.
		    //
		    //   This condition never arises in practice, due to the substitution applied to the target type in §18.5.2.
		    //
		    // - Otherwise, let E1, ..., En be the types in the function type's throws clause that are not proper types. If the lambda expression is implicitly typed, let its parameter types be the function type's parameter types. If the lambda body is a poly expression or a block containing a poly result expression, let the targeted return type be the function type's return type. Let X1, ..., Xm be the checked exception types that the lambda body can throw (§11.2). Then there are two cases:
		    //
		    //   - If n = 0 (the function type's throws clause consists only of proper types), then if there exists some i (1 ≤ i ≤ m) such that Xi is not a subtype of any proper type in the throws clause, the constraint reduces to false; otherwise, the constraint reduces to true.
		    //
		    //   - If n > 0, the constraint reduces to a set of subtyping constraints: for all i (1 ≤ i ≤ m), if Xi is not a subtype of any proper type in the throws clause, then the constraints include, for all j (1 ≤ j ≤ n), ‹Xi <: Ej›. In addition, for all j (1 ≤ j ≤ n), the constraint reduces to the bound throws Ej.
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ $//·a·constraint·formula·of·the·form·‹lambdaexpression·→throws·t›·is·reduced·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·t·is·not·a·functional·interface·type·(§9.8),·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·let·the·target·function·type·for·the·lambda·expression·be·determined·as·specified·in·§15.27.3.·if·no·valid·function·type·can·be·found,·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·if·the·lambda·expression·is·implicitly·typed,·and·one·or·more·of·the·function·type's·parameter·types·is·not·a·proper·type,·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//···this·condition·never·arises·in·practice,·due·to·the·substitution·applied·to·the·target·type·in·§18.5.2.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·if·the·function·type's·return·type·is·neither·void·nor·a·proper·type,·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//···this·condition·never·arises·in·practice,·due·to·the·substitution·applied·to·the·target·type·in·§18.5.2.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·let·e1,·...,·en·be·the·types·in·the·function·type's·throws·clause·that·are·not·proper·types.·if·the·lambda·expression·is·implicitly·typed,·let·its·parameter·types·be·the·function·type's·parameter·types.·if·the·lambda·body·is·a·poly·expression·or·a·block·containing·a·poly·result·expression,·let·the·targeted·return·type·be·the·function·type's·return·type.·let·x1,·...,·xm·be·the·checked·exception·types·that·the·lambda·body·can·throw·(§11.2).·then·there·are·two·cases:$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·n·=·0·(the·function·type's·throws·clause·consists·only·of·proper·types),·then·if·there·exists·some·i·(1·≤·i·≤·m)·such·that·xi·is·not·a·subtype·of·any·proper·type·in·the·throws·clause,·the·constraint·reduces·to·false;·otherwise,·the·constraint·reduces·to·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·n·>·0,·the·constraint·reduces·to·a·set·of·subtyping·constraints:·for·all·i·(1·≤·i·≤·m),·if·xi·is·not·a·subtype·of·any·proper·type·in·the·throws·clause,·then·the·constraints·include,·for·all·j·(1·≤·j·≤·n),·‹xi·<:·ej›.·in·addition,·for·all·j·(1·≤·j·≤·n),·the·constraint·reduces·to·the·bound·throws·ej.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ // $newline$ $indentation$ $whitespace$////space$$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$////space$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ // $newline$ $indentation$ $whitespace$// $whitespace$$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace			
hashCode	69	74	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java	0.8372548818588257	HIGH	"		@Override
		public int hashCode(){
		    int result = methodReference.hashCode();
		    result = 31 * result + T.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ methodreference . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ methodreference. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	76	82	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java	0.8484845757484436	HIGH	"		@Override
		public String toString(){
		    return ""MethodReferenceThrowsCompatibleWithType{"" + ""methodReference="" + methodReference + "", T="" + T + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ methodreference $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ methodreference $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
reduce	39	56	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/MethodReferenceThrowsCompatibleWithType.java	0.906748116016388	HIGH	"		@Override
		public ReductionResult reduce(BoundSet currentBoundSet){
		    // A constraint formula of the form ‹MethodReference →throws T› is reduced as follows:
		    //
		    // - If T is not a functional interface type, or if T is a functional interface type but does not have a function type (§9.9), the constraint reduces to false.
		    //
		    // - Otherwise, let the target function type for the method reference expression be the function type of T. If the method reference is inexact (§15.13.1) and one or more of the function type's parameter types is not a proper type, the constraint reduces to false.
		    //
		    // - Otherwise, if the method reference is inexact and the function type's result is neither void nor a proper type, the constraint reduces to false.
		    //
		    // - Otherwise, let E1, ..., En be the types in the function type's throws clause that are not proper types. Let X1, ..., Xm be the checked exceptions in the throws clause of the invocation type of the method reference's compile-time declaration (§15.13.2) (as derived from the function type's parameter types and return type). Then there are two cases:
		    //
		    //   - If n = 0 (the function type's throws clause consists only of proper types), then if there exists some i (1 ≤ i ≤ m) such that Xi is not a subtype of any proper type in the throws clause, the constraint reduces to false; otherwise, the constraint reduces to true.
		    //
		    //   - If n > 0, the constraint reduces to a set of subtyping constraints: for all i (1 ≤ i ≤ m), if Xi is not a subtype of any proper type in the throws clause, then the constraints include, for all j (1 ≤ j ≤ n), ‹Xi <: Ej›. In addition, for all j (1 ≤ j ≤ n), the constraint reduces to the bound throws Ej.
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ $//·a·constraint·formula·of·the·form·‹methodreference·→throws·t›·is·reduced·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·t·is·not·a·functional·interface·type,·or·if·t·is·a·functional·interface·type·but·does·not·have·a·function·type·(§9.9),·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·let·the·target·function·type·for·the·method·reference·expression·be·the·function·type·of·t.·if·the·method·reference·is·inexact·(§15.13.1)·and·one·or·more·of·the·function·type's·parameter·types·is·not·a·proper·type,·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·if·the·method·reference·is·inexact·and·the·function·type's·result·is·neither·void·nor·a·proper·type,·the·constraint·reduces·to·false.$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·otherwise,·let·e1,·...,·en·be·the·types·in·the·function·type's·throws·clause·that·are·not·proper·types.·let·x1,·...,·xm·be·the·checked·exceptions·in·the·throws·clause·of·the·invocation·type·of·the·method·reference's·compile-time·declaration·(§15.13.2)·(as·derived·from·the·function·type's·parameter·types·and·return·type).·then·there·are·two·cases:$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·n·=·0·(the·function·type's·throws·clause·consists·only·of·proper·types),·then·if·there·exists·some·i·(1·≤·i·≤·m)·such·that·xi·is·not·a·subtype·of·any·proper·type·in·the·throws·clause,·the·constraint·reduces·to·false;·otherwise,·the·constraint·reduces·to·true.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·n·>·0,·the·constraint·reduces·to·a·set·of·subtyping·constraints:·for·all·i·(1·≤·i·≤·m),·if·xi·is·not·a·subtype·of·any·proper·type·in·the·throws·clause,·then·the·constraints·include,·for·all·j·(1·≤·j·≤·n),·‹xi·<:·ej›.·in·addition,·for·all·j·(1·≤·j·≤·n),·the·constraint·reduces·to·the·bound·throws·ej.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ this $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ // $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$			
reduce	50	115	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java	0.2820013165473938	LOW	"		@Override
		public ReductionResult reduce(BoundSet currentBoundSet){
		    // A constraint formula of the form ‹S → T› is reduced as follows:
		    //
		    // 1. If S and T are proper types, the constraint reduces to true if S is compatible in a loose invocation context with T (§5.3), and false otherwise.
		    if (isProperType(s) && isProperType(t)) {
		        if (isCompatibleInALooseInvocationContext(s, t)) {
		            return ReductionResult.trueResult();
		        }
		        return ReductionResult.falseResult();
		    }
		    // 2. Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion (§5.1.7) to S. Then the constraint reduces to ‹S' → T›.
		    if (s.isPrimitive()) {
		        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();
		        ResolvedType sFirst = new ReferenceTypeImpl(typeSolver.solveType(s.asPrimitive().getBoxTypeQName()));
		        return ReductionResult.oneConstraint(new TypeCompatibleWithType(typeSolver, sFirst, t));
		    }
		    // 3. Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion (§5.1.7) to T. Then the constraint reduces to ‹S = T'›.
		    if (t.isPrimitive()) {
		        ReflectionTypeSolver typeSolver = new ReflectionTypeSolver();
		        ResolvedType tFirst = new ReferenceTypeImpl(typeSolver.solveType(t.asPrimitive().getBoxTypeQName()));
		        return ReductionResult.oneConstraint(new TypeSameAsType(s, tFirst));
		    }
		    // The fourth and fifth cases are implicit uses of unchecked conversion (§5.1.9). These, along with any use of
		    // unchecked conversion in the first case, may result in compile-time unchecked warnings, and may influence a
		    // method's invocation type (§15.12.2.6).
		    // 4. Otherwise, if T is a parameterized type of the form G<T1, ..., Tn>, and there exists no type of the
		    //    form G<...> that is a supertype of S, but the raw type G is a supertype of S, then the constraint reduces
		    //    to true.
		    if (t.isReferenceType() && t.asReferenceType().getTypeDeclaration().isPresent() && !t.asReferenceType().getTypeDeclaration().get().getTypeParameters().isEmpty()) {
		        // FIXME I really cannot understand what the specification means...
		        // there exists a type of the form G<...> that is a supertype of S?
		        boolean condition1 = t.isAssignableBy(s);
		        // the raw type G is a supertype of S
		        ResolvedType G = t.asReferenceType().toRawType();
		        boolean condition2 = G.isAssignableBy(s);
		        if (!condition1 && condition2) {
		            return ReductionResult.trueResult();
		        }
		        //throw new UnsupportedOperationException();
		    }
		    // 5. Otherwise, if T is an array type of the form G<T1, ..., Tn>[]k, and there exists no type of the form
		    //    G<...>[]k that is a supertype of S, but the raw type G[]k is a supertype of S, then the constraint
		    //    reduces to true. (The notation []k indicates an array type of k dimensions.)
		    if (t.isArray()) {
		        throw new UnsupportedOperationException();
		    }
		    // 6. Otherwise, the constraint reduces to ‹S <: T›
		    return ReductionResult.empty().withConstraint(new TypeSubtypeOfType(typeSolver, s, t));
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ $//·a·constraint·formula·of·the·form·‹s·→·t›·is·reduced·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·1.·if·s·and·t·are·proper·types,·the·constraint·reduces·to·true·if·s·is·compatible·in·a·loose·invocation·context·with·t·(§5.3),·and·false·otherwise.$ $newline$ $indentation$ if $whitespace$ ( ispropertype ( s ) $whitespace$ && $whitespace$ ispropertype ( t ) ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( iscompatibleinalooseinvocationcontext ( s , $whitespace$ t ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reductionresult . trueresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ reductionresult . falseresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·2.·otherwise,·if·s·is·a·primitive·type,·let·s'·be·the·result·of·applying·boxing·conversion·(§5.1.7)·to·s.·then·the·constraint·reduces·to·‹s'·→·t›.$ $newline$ $indentation$ if $whitespace$ ( s . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ reflectiontypesolver $whitespace$ typesolver $whitespace$ = $whitespace$ new $whitespace$ reflectiontypesolver ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ sfirst $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . solvetype ( s . asprimitive ( ) . getboxtypeqname ( ) ) ) ; $newline$ $indentation$ return $whitespace$ reductionresult . oneconstraint ( new $whitespace$ typecompatiblewithtype ( typesolver , $whitespace$ sfirst , $whitespace$ t ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·3.·otherwise,·if·t·is·a·primitive·type,·let·t'·be·the·result·of·applying·boxing·conversion·(§5.1.7)·to·t.·then·the·constraint·reduces·to·‹s·=·t'›.$ $newline$ $indentation$ if $whitespace$ ( t . isprimitive ( ) ) $whitespace$ { $newline$ $indentation$ reflectiontypesolver $whitespace$ typesolver $whitespace$ = $whitespace$ new $whitespace$ reflectiontypesolver ( ) ; $newline$ $indentation$ resolvedtype $whitespace$ tfirst $whitespace$ = $whitespace$ new $whitespace$ referencetypeimpl ( typesolver . solvetype ( t . asprimitive ( ) . getboxtypeqname ( ) ) ) ; $newline$ $indentation$ return $whitespace$ reductionresult . oneconstraint ( new $whitespace$ typesameastype ( s , $whitespace$ tfirst ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·the·fourth·and·fifth·cases·are·implicit·uses·of·unchecked·conversion·(§5.1.9).·these,·along·with·any·use·of$ $newline$ $indentation$ $//·unchecked·conversion·in·the·first·case,·may·result·in·compile-time·unchecked·warnings,·and·may·influence·a$ $newline$ $indentation$ $//·method's·invocation·type·(§15.12.2.6).$ $newline$ $indentation$ $//·4.·otherwise,·if·t·is·a·parameterized·type·of·the·form·g<t1,·...,·tn>,·and·there·exists·no·type·of·the$ $newline$ $indentation$ $//····form·g<...>·that·is·a·supertype·of·s,·but·the·raw·type·g·is·a·supertype·of·s,·then·the·constraint·reduces$ $newline$ $indentation$ $//····to·true.$ $newline$ $indentation$ if $whitespace$ ( t . isreferencetype ( ) $whitespace$ && $whitespace$ t . asreferencetype ( ) . gettypedeclaration ( ) . ispresent ( ) $whitespace$ && $whitespace$ ! t . asreferencetype ( ) . gettypedeclaration ( ) . get ( ) . gettypeparameters ( ) . isempty ( ) ) $whitespace$ { $newline$ $indentation$ $//·fixme·i·really·cannot·understand·what·the·specification·means...$ $newline$ $indentation$ $//·there·exists·a·type·of·the·form·g<...>·that·is·a·supertype·of·s?$ $newline$ $indentation$ boolean $whitespace$ condition1 $whitespace$ = $whitespace$ t . isassignableby ( s ) ; $newline$ $indentation$ $//·the·raw·type·g·is·a·supertype·of·s$ $newline$ $indentation$ resolvedtype $whitespace$ g $whitespace$ = $whitespace$ t . asreferencetype ( ) . torawtype ( ) ; $newline$ $indentation$ boolean $whitespace$ condition2 $whitespace$ = $whitespace$ g . isassignableby ( s ) ; $newline$ $indentation$ if $whitespace$ ( ! condition1 $whitespace$ && $whitespace$ condition2 ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reductionresult . trueresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//throw·new·unsupportedoperationexception();$ $newline$ $indentation$ } $newline$ $indentation$ $//·5.·otherwise,·if·t·is·an·array·type·of·the·form·g<t1,·...,·tn>[]k,·and·there·exists·no·type·of·the·form$ $newline$ $indentation$ $//····g<...>[]k·that·is·a·supertype·of·s,·but·the·raw·type·g[]k·is·a·supertype·of·s,·then·the·constraint$ $newline$ $indentation$ $//····reduces·to·true.·(the·notation·[]k·indicates·an·array·type·of·k·dimensions.)$ $newline$ $indentation$ if $whitespace$ ( t . isarray ( ) ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·6.·otherwise,·the·constraint·reduces·to·‹s·<:·t›$ $newline$ $indentation$ return $whitespace$ reductionresult . empty ( ) . withconstraint ( new $whitespace$ typesubtypeoftype ( typesolver , $whitespace$ s , $whitespace$ t ) ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ return $whitespace$ producer. findbytype ( $string$, $whitespace$ ispropertype ( s ) ) $newline$ $indentation$. map ( e $whitespace$ - > $whitespace$ a. get ( $newline$ $indentation$ $string$, $whitespace$ ispropertype ( t ) ) $newline$ $indentation$. orelse ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ return $whitespace$ producer. findbytype ( $newline$ $indentation$ final $whitespace$ type $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ * $whitespace$ $newline$ $indentation$ final $whitespace$ boolean $whitespace$ iscompatibleinalooseinvocationcontext ( s, $whitespace$ t ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reductionresult. trueresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ recurringresult. falseresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$			
equals	117	126	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java	0.6715171933174133	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    TypeCompatibleWithType that = (TypeCompatibleWithType) o;
		    if (!s.equals(that.s))
		        return false;
		    return t.equals(that.t);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ typecompatiblewithtype $whitespace$ that $whitespace$ = $whitespace$ ( typecompatiblewithtype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! s . equals ( that . s ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! s. equals ( that. s ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ isvalid ( entity $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! s. equals ( that. t ) ; $newline$ $indentation$ }			
hashCode	128	133	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = s.hashCode();
		    result = 31 * result + t.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	135	141	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeCompatibleWithType.java	0.927258849143982	HIGH	"		@Override
		public String toString(){
		    return ""TypeCompatibleWithType{"" + ""s="" + s + "", t="" + t + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
equals	91	100	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java	0.6964297294616699	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    TypeContainedByType that = (TypeContainedByType) o;
		    if (!S.equals(that.S))
		        return false;
		    return T.equals(that.T);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ typecontainedbytype $whitespace$ that $whitespace$ = $whitespace$ ( typecontainedbytype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! s . equals ( that . s ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
reduce	39	89	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java	0.7063347697257996	MID	"		@Override
		public ReductionResult reduce(BoundSet currentBoundSet){
		    // A constraint formula of the form ‹S <= T›, where S and T are type arguments (§4.5.1), is reduced as follows:
		    //
		    // - If T is a type:
		    if (isProperType(T) && !T.isWildcard()) {
		        //   - If S is a type, the constraint reduces to ‹S = T›.
		        //
		        //   - If S is a wildcard, the constraint reduces to false.
		        throw new UnsupportedOperationException();
		    }
		    // - If T is a wildcard of the form ?, the constraint reduces to true.
		    if (T.isWildcard() && !T.asWildcard().isBounded()) {
		        return ReductionResult.trueResult();
		    }
		    // - If T is a wildcard of the form ? extends T':
		    if (T.isWildcard() && T.asWildcard().isExtends()) {
		        //   - If S is a type, the constraint reduces to ‹S <: T'›.
		        //
		        //   - If S is a wildcard of the form ?, the constraint reduces to ‹Object <: T'›.
		        //
		        //   - If S is a wildcard of the form ? extends S', the constraint reduces to ‹S' <: T'›.
		        //
		        //   - If S is a wildcard of the form ? super S', the constraint reduces to ‹Object = T'›.
		        throw new UnsupportedOperationException();
		    }
		    // - If T is a wildcard of the form ? super T':
		    if (T.isWildcard() && T.asWildcard().isSuper()) {
		        //   - If S is a type, the constraint reduces to ‹T' <: S›.
		        //
		        //   - If S is a wildcard of the form ? super S', the constraint reduces to ‹T' <: S'›.
		        //
		        //   - Otherwise, the constraint reduces to false.
		        throw new UnsupportedOperationException();
		    }
		    throw new UnsupportedOperationException();
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ $//·a·constraint·formula·of·the·form·‹s·<=·t›,·where·s·and·t·are·type·arguments·(§4.5.1),·is·reduced·as·follows:$ $newline$ $indentation$ // $newline$ $indentation$ $//·-·if·t·is·a·type:$ $newline$ $indentation$ if $whitespace$ ( ispropertype ( t ) $whitespace$ && $whitespace$ ! t . iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ $//···-·if·s·is·a·type,·the·constraint·reduces·to·‹s·=·t›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·s·is·a·wildcard,·the·constraint·reduces·to·false.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·if·t·is·a·wildcard·of·the·form·?,·the·constraint·reduces·to·true.$ $newline$ $indentation$ if $whitespace$ ( t . iswildcard ( ) $whitespace$ && $whitespace$ ! t . aswildcard ( ) . isbounded ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reductionresult . trueresult ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·if·t·is·a·wildcard·of·the·form·?·extends·t':$ $newline$ $indentation$ if $whitespace$ ( t . iswildcard ( ) $whitespace$ && $whitespace$ t . aswildcard ( ) . isextends ( ) ) $whitespace$ { $newline$ $indentation$ $//···-·if·s·is·a·type,·the·constraint·reduces·to·‹s·<:·t'›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·s·is·a·wildcard·of·the·form·?,·the·constraint·reduces·to·‹object·<:·t'›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·s·is·a·wildcard·of·the·form·?·extends·s',·the·constraint·reduces·to·‹s'·<:·t'›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·s·is·a·wildcard·of·the·form·?·super·s',·the·constraint·reduces·to·‹object·=·t'›.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·-·if·t·is·a·wildcard·of·the·form·?·super·t':$ $newline$ $indentation$ if $whitespace$ ( t . iswildcard ( ) $whitespace$ && $whitespace$ t . aswildcard ( ) . issuper ( ) ) $whitespace$ { $newline$ $indentation$ $//···-·if·s·is·a·type,·the·constraint·reduces·to·‹t'·<:·s›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·if·s·is·a·wildcard·of·the·form·?·super·s',·the·constraint·reduces·to·‹t'·<:·s'›.$ $newline$ $indentation$ // $newline$ $indentation$ $//···-·otherwise,·the·constraint·reduces·to·false.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ } $newline$ $indentation$ throw $whitespace$ new $whitespace$ unsupportedoperationexception ( ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ reductionresult $whitespace$ reduce ( boundset $whitespace$ currentboundset ) { $newline$ $indentation$ if $whitespace$ ( ispropertype ( t ) $whitespace$ && $whitespace$! t. iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ $//////////////////////////////////////////////////////////////////////////////////////////////////// $newline$ $indentation$ // $newline$ $indentation$ $whitespace$// $newline$ $indentation$ if $whitespace$ ( ispropertype ( t ) $whitespace$ && $whitespace$! t. iswildcard ( ) ) $whitespace$ { $newline$ $indentation$ $whitespace$// $newline$ $indentation$ // $newline$ $indentation$ $whitespace$// $newline$ $indentation$ if $whitespace$ ( t. iswildcard ( ) $whitespace$ && $whitespace$! t. aswildcard ( ). isbounded ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ reductionresult. trueresult ( ) ; $whitespace$			
hashCode	102	107	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = S.hashCode();
		    result = 31 * result + T.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	109	115	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeContainedByType.java	0.935076892375946	HIGH	"		@Override
		public String toString(){
		    return ""TypeContainedByType{"" + ""S="" + S + "", T="" + T + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
equals	134	143	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java	0.7376380562782288	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    TypeSameAsType that = (TypeSameAsType) o;
		    if (!S.equals(that.S))
		        return false;
		    return T.equals(that.T);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ typesameastype $whitespace$ that $whitespace$ = $whitespace$ ( typesameastype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! s . equals ( that . s ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $whitespace$ { $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$!= $whitespace$ o. getclass ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ typesameastype $whitespace$ that $whitespace$ = $whitespace$ ( typesameastype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ (! s. equals ( that. s ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
hashCode	145	150	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = S.hashCode();
		    result = 31 * result + T.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	152	158	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSameAsType.java	0.9373317360877992	HIGH	"		@Override
		public String toString(){
		    return ""TypeSameAsType{"" + ""S="" + S + "", T="" + T + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
equals	133	142	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java	0.717486560344696	MID	"		@Override
		public boolean equals(Object o){
		    if (this == o)
		        return true;
		    if (o == null || getClass() != o.getClass())
		        return false;
		    TypeSubtypeOfType that = (TypeSubtypeOfType) o;
		    if (!S.equals(that.S))
		        return false;
		    return T.equals(that.T);
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ if $whitespace$ ( this $whitespace$ == $whitespace$ o ) $newline$ $indentation$ return $whitespace$ true ; $newline$ $indentation$ if $whitespace$ ( o $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ getclass ( ) $whitespace$ != $whitespace$ o . getclass ( ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ typesubtypeoftype $whitespace$ that $whitespace$ = $whitespace$ ( typesubtypeoftype ) $whitespace$ o ; $newline$ $indentation$ if $whitespace$ ( ! s . equals ( that . s ) ) $newline$ $indentation$ return $whitespace$ false ; $newline$ $indentation$ return $whitespace$ t . equals ( that . t ) ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ boolean $whitespace$ equals ( object $whitespace$ o ) { $newline$ $indentation$ return $whitespace$ this $whitespace$ == $whitespace$ o $whitespace$ || $whitespace$ o $whitespace$ instanceof $whitespace$ todo ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ boolean $whitespace$ equals ( todo $whitespace$ other ) { $newline$ $indentation$ return $whitespace$! s. equals ( that. s ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ t. equals ( that. t ) ; $newline$ $indentation$ }			
hashCode	144	149	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java	0.8733783960342407	HIGH	"		@Override
		public int hashCode(){
		    int result = S.hashCode();
		    result = 31 * result + T.hashCode();
		    return result;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s . hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t . hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ int $whitespace$ hashcode ( ) { $newline$ $indentation$ int $whitespace$ result $whitespace$ = $whitespace$ s. hashcode ( ) ; $newline$ $indentation$ result $whitespace$ = $whitespace$ $number$ $whitespace$ * $whitespace$ result $whitespace$ + $whitespace$ t. hashcode ( ) ; $newline$ $indentation$ return $whitespace$ result ; $newline$ $indentation$ }			
toString	151	157	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typeinference/constraintformulas/TypeSubtypeOfType.java	0.936554193496704	HIGH	"		@Override
		public String toString(){
		    return ""TypeSubtypeOfType{"" + ""S="" + S + "", T="" + T + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ s $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ t $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
tryToSolveType	69	111	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/ClassLoaderTypeSolver.java	0.1112654507160186	LOW	"		@Override
		public SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveType(String name){
		    if (filterName(name)) {
		        try {
		            // Some implementations could return null when the class was loaded through the bootstrap classloader
		            // see https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClassLoader--
		            if (classLoader == null) {
		                throw new RuntimeException(""The ClassLoaderTypeSolver has been probably loaded through the bootstrap class loader. This usage is not supported by the JavaSymbolSolver"");
		            }
		            Class<?> clazz = classLoader.loadClass(name);
		            return SymbolReference.solved(ReflectionFactory.typeDeclarationFor(clazz, getRoot()));
		        } catch (NoClassDefFoundError e) {
		            // We can safely ignore this one because it is triggered when there are package names which are almost the
		            // same as class name, with the exclusion of the case.
		            // For example:
		            // java.lang.NoClassDefFoundError: com/github/javaparser/printer/ConcreteSyntaxModel
		            // (wrong name: com/github/javaparser/printer/concretesyntaxmodel)
		            // note that this exception seems to be thrown only on certain platform (mac yes, linux no)
		            return SymbolReference.unsolved();
		        } catch (ClassNotFoundException e) {
		            // it could be an inner class
		            int lastDot = name.lastIndexOf('.');
		            if (lastDot == -1) {
		                return SymbolReference.unsolved();
		            }
		            String parentName = name.substring(0, lastDot);
		            String childName = name.substring(lastDot + 1);
		            SymbolReference<ResolvedReferenceTypeDeclaration> parent = tryToSolveType(parentName);
		            if (parent.isSolved()) {
		                Optional<ResolvedReferenceTypeDeclaration> innerClass = parent.getCorrespondingDeclaration().internalTypes().stream().filter(it -> it.getName().equals(childName)).findFirst();
		                return innerClass.map(SymbolReference::solved).orElseGet(() -> SymbolReference.unsolved());
		            }
		            return SymbolReference.unsolved();
		        }
		    } else {
		        return SymbolReference.unsolved();
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( filtername ( name ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $//·some·implementations·could·return·null·when·the·class·was·loaded·through·the·bootstrap·classloader$ $newline$ $indentation$ $//·see·https://docs.oracle.com/javase/8/docs/api/java/lang/class.html#getclassloader--$ $newline$ $indentation$ if $whitespace$ ( classloader $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ class < ? > $whitespace$ clazz $whitespace$ = $whitespace$ classloader . loadclass ( name ) ; $newline$ $indentation$ return $whitespace$ symbolreference . solved ( reflectionfactory . typedeclarationfor ( clazz , $whitespace$ getroot ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( noclassdeffounderror $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·we·can·safely·ignore·this·one·because·it·is·triggered·when·there·are·package·names·which·are·almost·the$ $newline$ $indentation$ $//·same·as·class·name,·with·the·exclusion·of·the·case.$ $newline$ $indentation$ $//·for·example:$ $newline$ $indentation$ $//·java.lang.noclassdeffounderror:·com/github/javaparser/printer/concretesyntaxmodel$ $newline$ $indentation$ $//·(wrong·name:·com/github/javaparser/printer/concretesyntaxmodel)$ $newline$ $indentation$ $//·note·that·this·exception·seems·to·be·thrown·only·on·certain·platform·(mac·yes,·linux·no)$ $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( classnotfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·it·could·be·an·inner·class$ $newline$ $indentation$ int $whitespace$ lastdot $whitespace$ = $whitespace$ name . lastindexof ( $string$ ) ; $newline$ $indentation$ if $whitespace$ ( lastdot $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ parentname $whitespace$ = $whitespace$ name . substring ( $number$ , $whitespace$ lastdot ) ; $newline$ $indentation$ string $whitespace$ childname $whitespace$ = $whitespace$ name . substring ( lastdot $whitespace$ + $whitespace$ $number$ ) ; $newline$ $indentation$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ parent $whitespace$ = $whitespace$ trytosolvetype ( parentname ) ; $newline$ $indentation$ if $whitespace$ ( parent . issolved ( ) ) $whitespace$ { $newline$ $indentation$ optional < resolvedreferencetypedeclaration > $whitespace$ innerclass $whitespace$ = $whitespace$ parent . getcorrespondingdeclaration ( ) . internaltypes ( ) . stream ( ) . filter ( it $whitespace$ - > $whitespace$ it . getname ( ) . equals ( childname ) ) . findfirst ( ) ; $newline$ $indentation$ return $whitespace$ innerclass . map ( symbolreference : : solved ) . orelseget ( ( ) $whitespace$ - > $whitespace$ symbolreference . unsolved ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetype ( string $whitespace$ name ) { $newline$ $indentation$ if $whitespace$ ( filtername ( name ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ $// $whitespace$ subtasksome = =implementations ( e ) ; $newline$ $indentation$ } $newline$ $indentation$ class <? > $whitespace$ clazz $whitespace$ = $whitespace$ classloader. loadclass ( name ) ; $newline$ $indentation$ return $whitespace$ symbolreference. solved ( reflectionfactory. typedeclarationfor ( clazz, $whitespace$ getroot ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( noclassdeffounderror $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $whitespace$// $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $white			
add	128	138	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/CombinedTypeSolver.java	0.7354094386100769	MID	"		public void add(TypeSolver typeSolver, boolean resetCache){
		    Objects.requireNonNull(typeSolver, ""The type solver can't be null"");
		    this.elements.add(typeSolver);
		    typeSolver.setParent(this);
		    // Check if the cache should be reset after inserting
		    if (resetCache) {
		        typeCache.removeAll();
		    }
		}"	$indentation$ public $whitespace$ void $whitespace$ add ( typesolver $whitespace$ typesolver , $whitespace$ boolean $whitespace$ resetcache ) { $newline$ $indentation$ objects . requirenonnull ( typesolver , $whitespace$ $string$ ) ; $newline$ $indentation$ this . elements . add ( typesolver ) ; $newline$ $indentation$ typesolver . setparent ( this ) ; $newline$ $indentation$ $//·check·if·the·cache·should·be·reset·after·inserting$ $newline$ $indentation$ if $whitespace$ ( resetcache ) $whitespace$ { $newline$ $indentation$ typecache . removeall ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ public $whitespace$ void $whitespace$ add ( typesolver $whitespace$ typesolver, $whitespace$ boolean $whitespace$ resetcache ) { $newline$ $indentation$ objects. requirenonnull ( typesolver, $whitespace$ $string$ ) ; $newline$ $indentation$ this. elements. add ( typesolver ) ; $newline$ $indentation$ typesolver. setparent ( this ) ; $newline$ $indentation$ $indentation$ $whitespace$ the $whitespace$ set $whitespace$ is $whitespace$ used $whitespace$ to $whitespace$ edit $whitespace$ the $whitespace$ producer $whitespace$ as $whitespace$ the $whitespace$ first $whitespace$ function $whitespace$ of $whitespace$ the $whitespace$ addimports $whitespace$ the $whitespace$ last $whitespace$ operations $newline$ $indentation$ if $whitespace$ ( resetcache ) $whitespace$ { $newline$ $indentation$ typecache. removeall ( ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
tryToSolveType	255	274	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java	0.2674480676651001	LOW	"		@Override
		public SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveType(String name){
		    String storedKey = knownClasses.get(name);
		    // If the name is not registered in the list we can safely say is not solvable here
		    if (storedKey == null) {
		        return SymbolReference.unsolved();
		    }
		    try {
		        return SymbolReference.solved(JavassistFactory.toTypeDeclaration(classPool.get(storedKey), getRoot()));
		    } catch (NotFoundException e) {
		        // The names in stored key should always be resolved.
		        // But if for some reason this happen, the user is notified.
		        throw new IllegalStateException(String.format(""Unable to get class with name %s from class pool."" + ""This was not suppose to happen, please report at https://github.com/javaparser/javaparser/issues"", storedKey));
		    }
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetype ( string $whitespace$ name ) { $newline$ $indentation$ string $whitespace$ storedkey $whitespace$ = $whitespace$ knownclasses . get ( name ) ; $newline$ $indentation$ $//·if·the·name·is·not·registered·in·the·list·we·can·safely·say·is·not·solvable·here$ $newline$ $indentation$ if $whitespace$ ( storedkey $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javassistfactory . totypedeclaration ( classpool . get ( storedkey ) , $whitespace$ getroot ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·the·names·in·stored·key·should·always·be·resolved.$ $newline$ $indentation$ $//·but·if·for·some·reason·this·happen,·the·user·is·notified.$ $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( string . format ( $string$ $whitespace$ + $whitespace$ $string$ , $whitespace$ storedkey ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetype ( string $whitespace$ name ) { $newline$ $indentation$ string $whitespace$ storedkey $whitespace$ = $whitespace$ knownclasses. get ( name ) ; $newline$ $indentation$ $////g$if $whitespace$ the $whitespace$ first $whitespace$ name $whitespace$ is $whitespace$ the $whitespace$ current $whitespace$ working $whitespace$ directory $newline$ $indentation$ if $whitespace$ ( storedkey $whitespace$ == $whitespace$ null ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. unsolved ( ) ; $newline$ $indentation$ } $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference. solved ( javassistfactory. totypedeclaration ( classpool. get ( storedkey ), $whitespace$ getroot ( ) ) ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//g$the $whitespace$ describingcontextnames $whitespace$ = $whitespace$$ describingcontextcontextcontextcontextcontext ( $newline$ $indentation$ + $whitespace$ $string$, $whitespace$ storedkey ) ) ; $newline$ $indentation$ } $newline$ $indentation$ }			
dumpToTempFile	157	172	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java	0.6700567007064819	MID	"		private File dumpToTempFile(InputStream inputStream) throws IOException{
		    File tempFile = File.createTempFile(""jar_file_from_input_stream"", "".jar"");
		    tempFile.deleteOnExit();
		    byte[] buffer = new byte[8 * 1024];
		    try (OutputStream output = new FileOutputStream(tempFile)) {
		        int bytesRead;
		        while ((bytesRead = inputStream.read(buffer)) != -1) {
		            output.write(buffer, 0, bytesRead);
		        }
		    } finally {
		        inputStream.close();
		    }
		    return tempFile;
		}"	$indentation$ private $whitespace$ file $whitespace$ dumptotempfile ( inputstream $whitespace$ inputstream ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ file $whitespace$ tempfile $whitespace$ = $whitespace$ file . createtempfile ( $string$ , $whitespace$ $string$ ) ; $newline$ $indentation$ tempfile . deleteonexit ( ) ; $newline$ $indentation$ byte [ ] $whitespace$ buffer $whitespace$ = $whitespace$ new $whitespace$ byte [ $number$ $whitespace$ * $whitespace$ $number$ ] ; $newline$ $indentation$ try $whitespace$ ( outputstream $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ fileoutputstream ( tempfile ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ bytesread ; $newline$ $indentation$ while $whitespace$ ( ( bytesread $whitespace$ = $whitespace$ inputstream . read ( buffer ) ) $whitespace$ != $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ output . write ( buffer , $whitespace$ $number$ , $whitespace$ bytesread ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ finally $whitespace$ { $newline$ $indentation$ inputstream . close ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ tempfile ; $newline$ $indentation$ }	$indentation$ private $whitespace$ file $whitespace$ dumptotempfile ( inputstream $whitespace$ inputstream ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ file $whitespace$ tempfile $whitespace$ = $whitespace$ file. createtempfile ( $string$, $whitespace$ $string$ ) ; $newline$ $indentation$ tempfile. deleteonexit ( ) ; $newline$ $indentation$ byte [ ] $whitespace$ buffer $whitespace$ = $whitespace$ new $whitespace$ byte [ $number$ $whitespace$ * $whitespace$ $number$ ] ; $newline$ $indentation$ try $whitespace$ ( outputstream $whitespace$ output $whitespace$ = $whitespace$ new $whitespace$ fileoutputstream ( tempfile ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ bytesread ; $newline$ $indentation$ while $whitespace$ ( ( bytesread $whitespace$ = $whitespace$ inputstream. read ( buffer ) ) $whitespace$!= $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ output. write ( buffer, $whitespace$ $number$, $whitespace$ bytesread ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ finally $whitespace$ { $newline$ $indentation$ inputstream. close ( ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ tempfile ; $newline$ $indentation$ }			
registerKnownClassesFor	204	227	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java	0.7175576686859131	MID	"		private void registerKnownClassesFor(String pathToJar) throws IOException{
		    try (JarFile jarFile = new JarFile(pathToJar)) {
		        Enumeration<JarEntry> jarEntries = jarFile.entries();
		        while (jarEntries.hasMoreElements()) {
		            JarEntry entry = jarEntries.nextElement();
		            // Check if the entry is a .class file
		            if (!entry.isDirectory() && entry.getName().endsWith(CLASS_EXTENSION)) {
		                String qualifiedName = convertEntryPathToClassName(entry.getName());
		                String classPoolName = convertEntryPathToClassPoolName(entry.getName());
		                // If the qualified name is the same as the class pool name we don't need to duplicate store two
		                // different String instances. Let's reuse the same.
		                if (qualifiedName.equals(classPoolName)) {
		                    knownClasses.put(qualifiedName, qualifiedName);
		                } else {
		                    knownClasses.put(qualifiedName, classPoolName);
		                }
		            }
		        }
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ registerknownclassesfor ( string $whitespace$ pathtojar ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ try $whitespace$ ( jarfile $whitespace$ jarfile $whitespace$ = $whitespace$ new $whitespace$ jarfile ( pathtojar ) ) $whitespace$ { $newline$ $indentation$ enumeration < jarentry > $whitespace$ jarentries $whitespace$ = $whitespace$ jarfile . entries ( ) ; $newline$ $indentation$ while $whitespace$ ( jarentries . hasmoreelements ( ) ) $whitespace$ { $newline$ $indentation$ jarentry $whitespace$ entry $whitespace$ = $whitespace$ jarentries . nextelement ( ) ; $newline$ $indentation$ $//·check·if·the·entry·is·a·.class·file$ $newline$ $indentation$ if $whitespace$ ( ! entry . isdirectory ( ) $whitespace$ && $whitespace$ entry . getname ( ) . endswith ( class_extension ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ qualifiedname $whitespace$ = $whitespace$ convertentrypathtoclassname ( entry . getname ( ) ) ; $newline$ $indentation$ string $whitespace$ classpoolname $whitespace$ = $whitespace$ convertentrypathtoclasspoolname ( entry . getname ( ) ) ; $newline$ $indentation$ $//·if·the·qualified·name·is·the·same·as·the·class·pool·name·we·don't·need·to·duplicate·store·two$ $newline$ $indentation$ $//·different·string·instances.·let's·reuse·the·same.$ $newline$ $indentation$ if $whitespace$ ( qualifiedname . equals ( classpoolname ) ) $whitespace$ { $newline$ $indentation$ knownclasses . put ( qualifiedname , $whitespace$ qualifiedname ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ knownclasses . put ( qualifiedname , $whitespace$ classpoolname ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ registerknownclassesfor ( string $whitespace$ pathtojar ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ /** $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ * $whitespace$ @param $whitespace$ pathtojar $whitespace$ the $whitespace$ pathtojar $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ * $whitespace$ @return $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ */ $newline$ $indentation$ private $whitespace$ void $whitespace$ registerknownclassesfor ( string $whitespace$ pathtojar ) $whitespace$ { $newline$ $indentation$ for $whitespace$ ( jarfile $whitespace$ jarfile $whitespace$ : $whitespace$ jarfile. entries ( ) ) $whitespace$ { $newline$ $indentation$ int $whitespace$ qualifiedname $whitespace$ = $whitespace$ convertentrypathtoclassname ( entry. getname ( ) ) ; $newline$ $indentation$ string $whitespace$ classpoolname $whitespace$ = $whitespace$ convertentrypathtoclasspoolname ( entry. getname ( ) ) ; $newline$ $indentation$ if $whitespace$ ( qualifiedname. equals ( classpoolname ) ) $whitespace$ { $newline$ $indentation$ knownclasses. put ( qualifiedname, $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ addexpectedworkspacebuilder ( string $whitespace$ childname ) $whitespace$ { $newline$ $indentation$ theclasses. put ( qualifiedname, $whitespace$ $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ void $whitespace$ the the佳9797's $whitespace$ hierarchy $whitespace$ the $whitespace$ sto $			
addPathToJar	181	192	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JarTypeSolver.java	0.7300190329551697	MID	"		private void addPathToJar(String pathToJar) throws IOException{
		    try {
		        classPool.appendClassPath(pathToJar);
		        registerKnownClassesFor(pathToJar);
		    } catch (NotFoundException e) {
		        // If JavaAssist throws a NotFoundException we should notify the user
		        // with a FileNotFoundException.
		        FileNotFoundException jarNotFound = new FileNotFoundException(e.getMessage());
		        jarNotFound.initCause(e);
		        throw jarNotFound;
		    }
		}"	$indentation$ private $whitespace$ void $whitespace$ addpathtojar ( string $whitespace$ pathtojar ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ classpool . appendclasspath ( pathtojar ) ; $newline$ $indentation$ registerknownclassesfor ( pathtojar ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $//·if·javaassist·throws·a·notfoundexception·we·should·notify·the·user$ $newline$ $indentation$ $//·with·a·filenotfoundexception.$ $newline$ $indentation$ filenotfoundexception $whitespace$ jarnotfound $whitespace$ = $whitespace$ new $whitespace$ filenotfoundexception ( e . getmessage ( ) ) ; $newline$ $indentation$ jarnotfound . initcause ( e ) ; $newline$ $indentation$ throw $whitespace$ jarnotfound ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ void $whitespace$ addpathtojar ( string $whitespace$ pathtojar ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ classpool. appendclasspath ( pathtojar ) ; $newline$ $indentation$ registerknownclassesfor ( pathtojar ) ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( notfoundexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ new $whitespace$ filenotfoundexception ( e. getmessage ( ) ) ; $newline$ $indentation$ filenotfound. initcause ( e ) ; $newline$ $indentation$ throw $whitespace$ jarnotfound ; $newline$ $indentation$ } $newline$ $indentation$ }			
tryToSolveTypeUncached	258	311	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java	0.0044996528886258	LOW	"		private SymbolReference<ResolvedReferenceTypeDeclaration> tryToSolveTypeUncached(String name){
		    String[] nameElements = name.split(""\\."");
		    for (int i = nameElements.length; i > 0; i--) {
		        StringBuilder filePath = new StringBuilder(srcDir.toAbsolutePath().toString());
		        for (int j = 0; j < i; j++) {
		            filePath.append(File.separator).append(nameElements[j]);
		        }
		        filePath.append("".java"");
		        StringBuilder typeName = new StringBuilder();
		        for (int j = i - 1; j < nameElements.length; j++) {
		            if (j != i - 1) {
		                typeName.append(""."");
		            }
		            typeName.append(nameElements[j]);
		        }
		        String dirToParse = null;
		        // As an optimization we first try to look in the canonical position where we expect to find the file
		        if (FileUtils.isValidPath(filePath.toString())) {
		            Path srcFile = Paths.get(filePath.toString());
		            Optional<CompilationUnit> compilationUnit = parse(srcFile);
		            if (compilationUnit.isPresent()) {
		                Optional<com.github.javaparser.ast.body.TypeDeclaration<?>> astTypeDeclaration = Navigator.findType(compilationUnit.get(), typeName.toString());
		                if (astTypeDeclaration.isPresent()) {
		                    return SymbolReference.solved(JavaParserFacade.get(this).getTypeDeclaration(astTypeDeclaration.get()));
		                }
		            }
		            dirToParse = srcFile.getParent().normalize().toString();
		        } else {
		            dirToParse = FileUtils.getParentPath(filePath.toString());
		        }
		        // If this is not possible we parse all files
		        // We try just in the same package, for classes defined in a file not named as the class itself
		        if (FileUtils.isValidPath(dirToParse)) {
		            List<CompilationUnit> compilationUnits = parseDirectory(Paths.get(dirToParse));
		            for (CompilationUnit compilationUnit : compilationUnits) {
		                Optional<com.github.javaparser.ast.body.TypeDeclaration<?>> astTypeDeclaration = Navigator.findType(compilationUnit, typeName.toString());
		                if (astTypeDeclaration.isPresent()) {
		                    return SymbolReference.solved(JavaParserFacade.get(this).getTypeDeclaration(astTypeDeclaration.get()));
		                }
		            }
		        }
		    }
		    return SymbolReference.unsolved();
		}"	$indentation$ private $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetypeuncached ( string $whitespace$ name ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ name . split ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ nameelements . length ; $whitespace$ i $whitespace$ > $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ stringbuilder $whitespace$ filepath $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( srcdir . toabsolutepath ( ) . tostring ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ i ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ filepath . append ( file . separator ) . append ( nameelements [ j ] ) ; $newline$ $indentation$ } $newline$ $indentation$ filepath . append ( $string$ ) ; $newline$ $indentation$ stringbuilder $whitespace$ typename $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ i $whitespace$ - $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ nameelements . length ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( j $whitespace$ != $whitespace$ i $whitespace$ - $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ typename . append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ typename . append ( nameelements [ j ] ) ; $newline$ $indentation$ } $newline$ $indentation$ string $whitespace$ dirtoparse $whitespace$ = $whitespace$ null ; $newline$ $indentation$ $//·as·an·optimization·we·first·try·to·look·in·the·canonical·position·where·we·expect·to·find·the·file$ $newline$ $indentation$ if $whitespace$ ( fileutils . isvalidpath ( filepath . tostring ( ) ) ) $whitespace$ { $newline$ $indentation$ path $whitespace$ srcfile $whitespace$ = $whitespace$ paths . get ( filepath . tostring ( ) ) ; $newline$ $indentation$ optional < compilationunit > $whitespace$ compilationunit $whitespace$ = $whitespace$ parse ( srcfile ) ; $newline$ $indentation$ if $whitespace$ ( compilationunit . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ optional < com . github . javaparser . ast . body . typedeclaration < ? >> $whitespace$ asttypedeclaration $whitespace$ = $whitespace$ navigator . findtype ( compilationunit . get ( ) , $whitespace$ typename . tostring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( asttypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( this ) . gettypedeclaration ( asttypedeclaration . get ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ dirtoparse $whitespace$ = $whitespace$ srcfile . getparent ( ) . normalize ( ) . tostring ( ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ { $newline$ $indentation$ dirtoparse $whitespace$ = $whitespace$ fileutils . getparentpath ( filepath . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·this·is·not·possible·we·parse·all·files$ $newline$ $indentation$ $//·we·try·just·in·the·same·package,·for·classes·defined·in·a·file·not·named·as·the·class·itself$ $newline$ $indentation$ if $whitespace$ ( fileutils . isvalidpath ( dirtoparse ) ) $whitespace$ { $newline$ $indentation$ list < compilationunit > $whitespace$ compilationunits $whitespace$ = $whitespace$ parsedirectory ( paths . get ( dirtoparse ) ) ; $newline$ $indentation$ for $whitespace$ ( compilationunit $whitespace$ compilationunit $whitespace$ : $whitespace$ compilationunits ) $whitespace$ { $newline$ $indentation$ optional < com . github . javaparser . ast . body . typedeclaration < ? >> $whitespace$ asttypedeclaration $whitespace$ = $whitespace$ navigator . findtype ( compilationunit , $whitespace$ typename . tostring ( ) ) ; $newline$ $indentation$ if $whitespace$ ( asttypedeclaration . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ symbolreference . solved ( javaparserfacade . get ( this ) . gettypedeclaration ( asttypedeclaration . get ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ symbolreference . unsolved ( ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ symbolreference < resolvedreferencetypedeclaration > $whitespace$ trytosolvetypeuncached ( string $whitespace$ name ) { $newline$ $indentation$ string [ ] $whitespace$ nameelements $whitespace$ = $whitespace$ name. split ( $string$ ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ i $whitespace$ = $whitespace$ nameelements. length ; $whitespace$ i $whitespace$ > $whitespace$ $number$ ; $whitespace$ i -- ) $whitespace$ { $newline$ $indentation$ stringbuilder $whitespace$ filepath $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( srcdir. toabsolutepath ( ). tostring ( ) ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ nameelements. length ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ filepath. append ( file. separator ). append ( nameelements [ j ] ). append ( nameelements [ j ] ) ; $newline$ $indentation$ } $newline$ $indentation$ filepath. append ( $string$ ) ; $newline$ $indentation$ stringbuilder $whitespace$ typename $whitespace$ = $whitespace$ new $whitespace$ stringbuilder ( ) ; $newline$ $indentation$ for $whitespace$ ( int $whitespace$ j $whitespace$ = $whitespace$ i $whitespace$ - $whitespace$ $number$ ; $whitespace$ j $whitespace$ < $whitespace$ nameelements. length ; $whitespace$ j ++ ) $whitespace$ { $newline$ $indentation$ if $whitespace$ ( j $whitespace$!= $whitespace$ i $whitespace$ - $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ typename. append ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ typename. append ( nameelements [ j ] ) ; $newline			
parse	177	202	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java	0.0511861033737659	LOW	"		private Optional<CompilationUnit> parse(Path srcFile){
		    try {
		        Optional<Optional<CompilationUnit>> cachedParsedFile = parsedFiles.get(srcFile.toAbsolutePath());
		        // If the value is already cached
		        if (cachedParsedFile.isPresent()) {
		            return cachedParsedFile.get();
		        }
		        // Otherwise load it
		        if (!Files.exists(srcFile) || !Files.isRegularFile(srcFile)) {
		            parsedFiles.put(srcFile.toAbsolutePath(), Optional.empty());
		            return Optional.empty();
		        }
		        // JavaParser only allow one parse at time.
		        synchronized (javaParser) {
		            Optional<CompilationUnit> compilationUnit = javaParser.parse(COMPILATION_UNIT, provider(srcFile, javaParser.getParserConfiguration().getCharacterEncoding())).getResult().map(cu -> cu.setStorage(srcFile));
		            parsedFiles.put(srcFile.toAbsolutePath(), compilationUnit);
		            return compilationUnit;
		        }
		    } catch (IOException e) {
		        throw new RuntimeException(""Issue while parsing while type solving: "" + srcFile.toAbsolutePath(), e);
		    }
		}"	$indentation$ private $whitespace$ optional < compilationunit > $whitespace$ parse ( path $whitespace$ srcfile ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ optional < optional < compilationunit >> $whitespace$ cachedparsedfile $whitespace$ = $whitespace$ parsedfiles . get ( srcfile . toabsolutepath ( ) ) ; $newline$ $indentation$ $//·if·the·value·is·already·cached$ $newline$ $indentation$ if $whitespace$ ( cachedparsedfile . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cachedparsedfile . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·otherwise·load·it$ $newline$ $indentation$ if $whitespace$ ( ! files . exists ( srcfile ) $whitespace$ || $whitespace$ ! files . isregularfile ( srcfile ) ) $whitespace$ { $newline$ $indentation$ parsedfiles . put ( srcfile . toabsolutepath ( ) , $whitespace$ optional . empty ( ) ) ; $newline$ $indentation$ return $whitespace$ optional . empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·javaparser·only·allow·one·parse·at·time.$ $newline$ $indentation$ synchronized $whitespace$ ( javaparser ) $whitespace$ { $newline$ $indentation$ optional < compilationunit > $whitespace$ compilationunit $whitespace$ = $whitespace$ javaparser . parse ( compilation_unit , $whitespace$ provider ( srcfile , $whitespace$ javaparser . getparserconfiguration ( ) . getcharacterencoding ( ) ) ) . getresult ( ) . map ( cu $whitespace$ - > $whitespace$ cu . setstorage ( srcfile ) ) ; $newline$ $indentation$ parsedfiles . put ( srcfile . toabsolutepath ( ) , $whitespace$ compilationunit ) ; $newline$ $indentation$ return $whitespace$ compilationunit ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ srcfile . toabsolutepath ( ) , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ optional < compilationunit > $whitespace$ parse ( path $whitespace$ srcfile ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ optional < optional < compilationunit >> $whitespace$ cachedparsedfile $whitespace$ = $whitespace$ parsedfiles. get ( srcfile. toabsolutepath ( ) ) ; $newline$ $indentation$ if $whitespace$ ( cachedparsedfile. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cachedparsedfile. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ effectivepath $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ } $newline$ $indentation$ $whitespace$ optional < compilationunit > $whitespace$ cachedparsedfile $whitespace$ = $whitespace$ parsedfiles. get ( srcfile. toabsolutepath ( ) ) ; $newline$ $indentation$ $whitespace$ optional < compilationunit > $whitespace$ cachedparsedfile $whitespace$ = $whitespace$ parsedfiles. get ( srcfile. toabsolutepath ( ) ) ; $newline$ $indentation$ return $whitespace$ cachedparsedfile. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ private $whitespace$ optional < compilationunit > $whitespace$ cachedparsedfile $whitespace$ = $whitespace$ parsedfiles. get ( srcfile. toabsolutepath ( ) ) ; $newline$ $indentation$ return $whitespace$ optional. empty ( ) ; $newline$ $indentation$ } $newline$ $indentation$			
parseDirectory	216	243	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java	0.2006847858428955	LOW	"		private List<CompilationUnit> parseDirectory(Path srcDirectory, boolean recursively){
		    try {
		        Optional<List<CompilationUnit>> cachedValue = parsedDirectories.get(srcDirectory.toAbsolutePath());
		        if (cachedValue.isPresent()) {
		            return cachedValue.get();
		        }
		        // If not cached, we need to load it
		        List<CompilationUnit> units = new ArrayList<>();
		        if (Files.exists(srcDirectory)) {
		            try (DirectoryStream<Path> srcDirectoryStream = Files.newDirectoryStream(srcDirectory)) {
		                srcDirectoryStream.forEach(file -> {
		                    if (file.getFileName().toString().toLowerCase().endsWith("".java"")) {
		                        parse(file).ifPresent(units::add);
		                    } else if (recursively && file.toFile().isDirectory()) {
		                        units.addAll(parseDirectoryRecursively(file));
		                    }
		                });
		            }
		        }
		        parsedDirectories.put(srcDirectory.toAbsolutePath(), units);
		        return units;
		    } catch (IOException e) {
		        throw new RuntimeException(""Unable to parse directory due to an exception. Directory:"" + srcDirectory.toAbsolutePath(), e);
		    }
		}"	$indentation$ private $whitespace$ list < compilationunit > $whitespace$ parsedirectory ( path $whitespace$ srcdirectory , $whitespace$ boolean $whitespace$ recursively ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ optional < list < compilationunit >> $whitespace$ cachedvalue $whitespace$ = $whitespace$ parseddirectories . get ( srcdirectory . toabsolutepath ( ) ) ; $newline$ $indentation$ if $whitespace$ ( cachedvalue . ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cachedvalue . get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·if·not·cached,·we·need·to·load·it$ $newline$ $indentation$ list < compilationunit > $whitespace$ units $whitespace$ = $whitespace$ new $whitespace$ arraylist < > ( ) ; $newline$ $indentation$ if $whitespace$ ( files . exists ( srcdirectory ) ) $whitespace$ { $newline$ $indentation$ try $whitespace$ ( directorystream < path > $whitespace$ srcdirectorystream $whitespace$ = $whitespace$ files . newdirectorystream ( srcdirectory ) ) $whitespace$ { $newline$ $indentation$ srcdirectorystream . foreach ( file $whitespace$ - > $whitespace$ { $newline$ $indentation$ if $whitespace$ ( file . getfilename ( ) . tostring ( ) . tolowercase ( ) . endswith ( $string$ ) ) $whitespace$ { $newline$ $indentation$ parse ( file ) . ifpresent ( units : : add ) ; $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( recursively $whitespace$ && $whitespace$ file . tofile ( ) . isdirectory ( ) ) $whitespace$ { $newline$ $indentation$ units . addall ( parsedirectoryrecursively ( file ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } ) ; $newline$ $indentation$ } $newline$ $indentation$ } $newline$ $indentation$ parseddirectories . put ( srcdirectory . toabsolutepath ( ) , $whitespace$ units ) ; $newline$ $indentation$ return $whitespace$ units ; $newline$ $indentation$ } $whitespace$ catch $whitespace$ ( ioexception $whitespace$ e ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ runtimeexception ( $string$ $whitespace$ + $whitespace$ srcdirectory . toabsolutepath ( ) , $whitespace$ e ) ; $newline$ $indentation$ } $newline$ $indentation$ }	$indentation$ private $whitespace$ list < compilationunit > $whitespace$ parsedirectory ( path $whitespace$ srcdirectory, $whitespace$ boolean $whitespace$ recursively ) { $newline$ $indentation$ try $whitespace$ { $newline$ $indentation$ optional < list < compilationunit >> $whitespace$ cachedvalue $whitespace$ = $whitespace$ parseddirectories. get ( srcdirectory. toabsolutepath ( ) ) ; $newline$ $indentation$ if $whitespace$ ( cachedvalue. ispresent ( ) ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cachedvalue. get ( ) ; $newline$ $indentation$ } $newline$ $indentation$ $///////			
BuildCache	94	100	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java	0.2352850586175918	LOW	"		private Cache<TKey, TValue> BuildCache(long cacheSizeLimit){
		    CacheBuilder<Object, Object> cacheBuilder = CacheBuilder.newBuilder().softValues();
		    if (cacheSizeLimit != CACHE_SIZE_UNSET) {
		        cacheBuilder.maximumSize(cacheSizeLimit);
		    }
		    return new GuavaCache<>(cacheBuilder.build());
		}"	$indentation$ private $whitespace$ cache < tkey , $whitespace$ tvalue > $whitespace$ buildcache ( long $whitespace$ cachesizelimit ) { $newline$ $indentation$ cachebuilder < object , $whitespace$ object > $whitespace$ cachebuilder $whitespace$ = $whitespace$ cachebuilder . newbuilder ( ) . softvalues ( ) ; $newline$ $indentation$ if $whitespace$ ( cachesizelimit $whitespace$ != $whitespace$ cache_size_unset ) $whitespace$ { $newline$ $indentation$ cachebuilder . maximumsize ( cachesizelimit ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ guavacache < > ( cachebuilder . build ( ) ) ; $newline$ $indentation$ }	$indentation$ private $whitespace$ cache < tkey, $whitespace$ tvalue > $whitespace$ buildcache ( long $whitespace$ cachesizelimit ) { $newline$ $indentation$ cachebuilder < object, $whitespace$ object > $whitespace$ cachebuilder $whitespace$ = $whitespace$ cachebuilder. newbuilder ( ). softvalues ( ) ; $newline$ $indentation$ if $whitespace$ ( cachesizelimit $whitespace$ == $whitespace$ cache_size_unset ) $whitespace$ { $newline$ $indentation$ return $whitespace$ cachebuilder. maximumsize ( cachesizelimit ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ guavacache < > ( cachebuilder. build ( ) ) ; $newline$ $indentation$ }			
toString	152	158	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/JavaParserTypeSolver.java	0.8800491094589233	HIGH	"		@Override
		public String toString(){
		    return ""JavaParserTypeSolver{"" + ""srcDir="" + srcDir + "", parent="" + parent + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ srcdir $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ parent $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ srcdir $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ parent $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
toString	42	48	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/MemoryTypeSolver.java	0.8397467136383057	HIGH	"		@Override
		public String toString(){
		    return ""MemoryTypeSolver{"" + ""parent="" + parent + "", declarationMap="" + declarationMap + '}';
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ parent $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ declarationmap $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ string $whitespace$ tostring ( ) { $newline$ $indentation$ return $whitespace$ $string$ $whitespace$ + $whitespace$ $newline$ $indentation$ $string$ $whitespace$ + $whitespace$ parent $whitespace$ + $whitespace$ $string$ $whitespace$ + $whitespace$ declarationmap $whitespace$ + $whitespace$ $string$ ; $newline$ $indentation$ }			
build	310	325	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/TypeSolverBuilder.java	0.7335289120674133	MID	"		public TypeSolver build(){
		    int typeSolversCount = typeSolvers.size();
		    // Check if at least one solver is present
		    if (typeSolversCount == 0) {
		        throw new IllegalStateException(""At least a type solver is expected."");
		    }
		    // Check if only one exists
		    if (typeSolversCount == 1) {
		        return typeSolvers.get(0);
		    }
		    // Combine all type solver
		    return new CombinedTypeSolver(typeSolvers);
		}"	$indentation$ public $whitespace$ typesolver $whitespace$ build ( ) { $newline$ $indentation$ int $whitespace$ typesolverscount $whitespace$ = $whitespace$ typesolvers . size ( ) ; $newline$ $indentation$ $//·check·if·at·least·one·solver·is·present$ $newline$ $indentation$ if $whitespace$ ( typesolverscount $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·check·if·only·one·exists$ $newline$ $indentation$ if $whitespace$ ( typesolverscount $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ return $whitespace$ typesolvers . get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $//·combine·all·type·solver$ $newline$ $indentation$ return $whitespace$ new $whitespace$ combinedtypesolver ( typesolvers ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ typesolver $whitespace$ build ( ) { $newline$ $indentation$ int $whitespace$ typesolverscount $whitespace$ = $whitespace$ typesolvers. size ( ) ; $newline$ $indentation$ $indentation$ $number$ $whitespace$ = $whitespace$ typesolverscount $whitespace$ == $whitespace$ $number$ $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ typesolverscount ; $newline$ $indentation$ if $whitespace$ ( typesolverscount $whitespace$ == $whitespace$ $number$ ) $whitespace$ { $newline$ $indentation$ throw $whitespace$ new $whitespace$ illegalstateexception ( $string$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ typesolverscount $whitespace$ == $whitespace$ $number$ $whitespace$? $whitespace$ $string$ $whitespace$ : $whitespace$ typesolvers. get ( $number$ ) ; $newline$ $indentation$ } $newline$ $indentation$ $number$ $whitespace$ = $whitespace$ $number$ ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ new $whitespace$ combinedtypesolver ( typesolvers ) ; $newline$ $indentation$ }			
with	76	81	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/resolution/typesolvers/TypeSolverBuilder.java	0.735765278339386	MID	"		public TypeSolverBuilder with(@NonNull TypeSolver typeSolver){
		    checkNotNull(typeSolver, ""The typeSolver can't be null!"");
		    typeSolvers.add(typeSolver);
		    return this;
		}"	$indentation$ public $whitespace$ typesolverbuilder $whitespace$ with ( @ nonnull $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ checknotnull ( typesolver , $whitespace$ $string$ ) ; $newline$ $indentation$ typesolvers . add ( typesolver ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }	$indentation$ public $whitespace$ typesolverbuilder $whitespace$ with ( @ nonnull $whitespace$ typesolver $whitespace$ typesolver ) { $newline$ $indentation$ checknotnull ( typesolver, $whitespace$ $string$ ) ; $newline$ $indentation$ typesolvers. add ( typesolver ) ; $newline$ $indentation$ return $whitespace$ this ; $newline$ $indentation$ }			
getParentPath	40	44	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/FileUtils.java	0.685468852519989	MID	"		public static String getParentPath(String filename){
		    Utils.assertNotNull(filename);
		    int lastIndex = filename.lastIndexOf(File.separator);
		    return filename.substring(0, lastIndex);
		}"	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ getparentpath ( string $whitespace$ filename ) { $newline$ $indentation$ utils . assertnotnull ( filename ) ; $newline$ $indentation$ int $whitespace$ lastindex $whitespace$ = $whitespace$ filename . lastindexof ( file . separator ) ; $newline$ $indentation$ return $whitespace$ filename . substring ( $number$ , $whitespace$ lastindex ) ; $newline$ $indentation$ }	$indentation$ public $whitespace$ static $whitespace$ string $whitespace$ getparentpath ( string $whitespace$ filename ) { $newline$ $indentation$ utils. assertnotnull ( filename ) ; $newline$ $indentation$ int $whitespace$ lastindex $whitespace$ = $whitespace$ filename. lastindexof ( file. separator ; $newline$ $indentation$ int $whitespace$ lastindex $whitespace$ = $whitespace$ filename. getindexof ( file. separator ; $newline$ $indentation$ return $whitespace$ filename. substring ( $number$, $whitespace$ lastindex ) ; $newline$ $indentation$ }			
preVisitDirectory	105	112	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/SymbolSolverCollectionStrategy.java	0.6185119152069092	MID	"		@Override
		public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException{
		    if (Files.isHidden(dir)) {
		        Log.info(""Skipping sub-tree %s"", () -> dir.toString());
		        return SKIP_SUBTREE;
		    }
		    return CONTINUE;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ previsitdirectory ( path $whitespace$ dir , $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( files . ishidden ( dir ) ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ dir . tostring ( ) ) ; $newline$ $indentation$ return $whitespace$ skip_subtree ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ previsitdirectory ( path $whitespace$ dir, $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( files. ishidden ( dir ) $whitespace$ || $whitespace$ ( ) $whitespace$ - > $whitespace$ dir. tostring ( ) ) ) $newline$ $indentation$ return $whitespace$ skip_subtree ; $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }			
visitFile	78	103	javaparser/javaparser-symbol-solver-core/src/main/java/com/github/javaparser/symbolsolver/utils/SymbolSolverCollectionStrategy.java	0.6291314363479614	MID	"		@Override
		public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException{
		    if (javaMatcher.matches(file)) {
		        String parent = file.getParent().toString();
		        // This is not a very elegant or powerful solution but it works and it allows to unblock users :-(
		        // We are trying to verify the current_root directory for each package.
		        // Sometime (for exemple https://github.com/apache/logging-log4j1) we can have java packages directly under a base directory
		        // and source directory under the same base package.
		        // for exemple:
		        // logging-log4j1\examples\customLevel\XLevel.java <- examples is a package (the root source directory is logging-log4j1)
		        // logging-log4j1\src\main\java\org\apache\log4j\Appender.java <- org is a package (the root source directory is logging-log4j1\src\main\java)
		        if (!parent.equals(previousSourceDirectory)) {
		            Log.info(""Trying to compute the source root from %s"", () -> file.toString());
		            previousSourceDirectory = parent;
		            currentProjectDir = getRoot(file).orElse(null);
		        }
		        if (current_root == null || (currentProjectDir != null && !currentProjectDir.equals(current_root))) {
		            current_root = currentProjectDir;
		            if (current_root != null)
		                Log.info(""New current source root is %s"", () -> current_root.toString());
		        }
		    } else if (jarMatcher.matches(file)) {
		        Log.info(""Jar file is found %s"", () -> file.toString());
		        typeSolver.add(new JarTypeSolver(file.toString()));
		    }
		    return CONTINUE;
		}"	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ visitfile ( path $whitespace$ file , $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( javamatcher . matches ( file ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ parent $whitespace$ = $whitespace$ file . getparent ( ) . tostring ( ) ; $newline$ $indentation$ $//·this·is·not·a·very·elegant·or·powerful·solution·but·it·works·and·it·allows·to·unblock·users·:-($ $newline$ $indentation$ $//·we·are·trying·to·verify·the·current_root·directory·for·each·package.$ $newline$ $indentation$ $//·sometime·(for·exemple·https://github.com/apache/logging-log4j1)·we·can·have·java·packages·directly·under·a·base·directory$ $newline$ $indentation$ $//·and·source·directory·under·the·same·base·package.$ $newline$ $indentation$ $//·for·exemple:$ $newline$ $indentation$ $//·logging-log4j1\examples\customlevel\xlevel.java·<-·examples·is·a·package·(the·root·source·directory·is·logging-log4j1)$ $newline$ $indentation$ $//·logging-log4j1\src\main\java\org\apache\log4j\appender.java·<-·org·is·a·package·(the·root·source·directory·is·logging-log4j1\src\main\java)$ $newline$ $indentation$ if $whitespace$ ( ! parent . equals ( previoussourcedirectory ) ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ file . tostring ( ) ) ; $newline$ $indentation$ previoussourcedirectory $whitespace$ = $whitespace$ parent ; $newline$ $indentation$ currentprojectdir $whitespace$ = $whitespace$ getroot ( file ) . orelse ( null ) ; $newline$ $indentation$ } $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ == $whitespace$ null $whitespace$ || $whitespace$ ( currentprojectdir $whitespace$ != $whitespace$ null $whitespace$ && $whitespace$ ! currentprojectdir . equals ( current_root ) ) ) $whitespace$ { $newline$ $indentation$ current_root $whitespace$ = $whitespace$ currentprojectdir ; $newline$ $indentation$ if $whitespace$ ( current_root $whitespace$ != $whitespace$ null ) $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ current_root . tostring ( ) ) ; $newline$ $indentation$ } $newline$ $indentation$ } $whitespace$ else $whitespace$ if $whitespace$ ( jarmatcher . matches ( file ) ) $whitespace$ { $newline$ $indentation$ log . info ( $string$ , $whitespace$ ( ) $whitespace$ - > $whitespace$ file . tostring ( ) ) ; $newline$ $indentation$ typesolver . add ( new $whitespace$ jartypesolver ( file . tostring ( ) ) ) ; $newline$ $indentation$ } $newline$ $indentation$ return $whitespace$ continue ; $newline$ $indentation$ }	$indentation$ @ override $newline$ $indentation$ public $whitespace$ filevisitresult $whitespace$ visitfile ( path $whitespace$ file, $whitespace$ basicfileattributes $whitespace$ attrs ) $whitespace$ throws $whitespace$ ioexception { $newline$ $indentation$ if $whitespace$ ( javamatcher. matches ( file ) ) $whitespace$ { $newline$ $indentation$ string $whitespace$ parent $whitespace$ = $whitespace$ file. getparent ( ). tostring ( ) ; $newline$ $indentation$ $////// $newline$ $indentation$$$ is $whitespace$ getparent $whitespace$ = $whitespace$ file. getparent ( ). tostring ( ) ; $newline$ $indentation$ $////g$ $newline$ $indentation$ // $whitespace$ load $whitespace$ the $whitespace$ custom $whitespace$ properties $whitespace$ and $whitespace$ assign $whitespace$ the $whitespace$ notes $whitespace$ to $whitespace$ be $whitespace$ set $newline$ $indentation$ // $whitespace$ at $whitespace$ the $whitespace$ end $whitespace$ of $whitespace$ the $whitespace$ characters $whitespace$ to $whitespace$ make $whitespace$ sure $whitespace$ the $whitespace$ cert $whitespace$ is $whitespace$ expired. $newline$ $indentation$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ */ $newline$ $indentation$ if $whitespace$ ( is $whitespace$ ) $whitespace$ { $newline$ $indentation$ string $whitespace$ parent $whitespace$ = $whitespace$ file. getparent ( ). tostring ( ) ; $newline$ $indentation$ $//g$ $newline$ $indentation$ // $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ $whitespace$ = $whitespace$ $whitespace$ = $whitespace$ $			
